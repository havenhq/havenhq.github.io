"use strict";(self.webpackChunk_revideo_docs=self.webpackChunk_revideo_docs||[]).push([[987],{8621:(e,n,t)=>{t.d(n,{A:()=>u});var o=t(4041),p=t(2663),r=t(7473),s=t(9082);const c={admonition:"admonition_qNG0",admonitionHeading:"admonitionHeading_l909",admonitionIcon:"admonitionIcon_UNbs",admonitionContent:"admonitionContent_oUmQ"};const a={note:{infimaClassName:"secondary",iconComponent:function(){return o.createElement("svg",{viewBox:"0 0 14 16"},o.createElement("path",{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))},label:o.createElement(s.A,{id:"theme.admonition.note",description:"The default label used for the Note admonition (:::note)"},"note")},tip:{infimaClassName:"success",iconComponent:function(){return o.createElement("svg",{viewBox:"0 0 12 16"},o.createElement("path",{fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))},label:o.createElement(s.A,{id:"theme.admonition.tip",description:"The default label used for the Tip admonition (:::tip)"},"tip")},danger:{infimaClassName:"danger",iconComponent:function(){return o.createElement("svg",{viewBox:"0 0 12 16"},o.createElement("path",{fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"}))},label:o.createElement(s.A,{id:"theme.admonition.danger",description:"The default label used for the Danger admonition (:::danger)"},"danger")},info:{infimaClassName:"info",iconComponent:function(){return o.createElement("svg",{viewBox:"0 0 14 16"},o.createElement("path",{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))},label:o.createElement(s.A,{id:"theme.admonition.info",description:"The default label used for the Info admonition (:::info)"},"info")},caution:{infimaClassName:"warning",iconComponent:function(){return o.createElement("svg",{viewBox:"0 0 16 16"},o.createElement("path",{fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))},label:o.createElement(s.A,{id:"theme.admonition.caution",description:"The default label used for the Caution admonition (:::caution)"},"caution")}},i={secondary:"note",important:"info",success:"tip",warning:"danger"};function l(e){const{mdxAdmonitionTitle:n,rest:t}=function(e){const n=o.Children.toArray(e),t=n.find((e=>o.isValidElement(e)&&"mdxAdmonitionTitle"===e.props?.mdxType)),p=o.createElement(o.Fragment,null,n.filter((e=>e!==t)));return{mdxAdmonitionTitle:t,rest:p}}(e.children);return{...e,title:e.title??n,children:t}}function u(e){const{children:n,type:t,title:s,icon:u}=l(e),m=function(e){const n=i[e]??e,t=a[n];return t||(console.warn(`No admonition config found for admonition type "${n}". Using Info as fallback.`),a.info)}(t),y=s??m.label,{iconComponent:d}=m,h=u??o.createElement(d,null);return o.createElement("div",{className:(0,p.A)(r.G.common.admonition,r.G.common.admonitionType(e.type),"alert",`alert--${m.infimaClassName}`,c.admonition)},o.createElement("div",{className:c.admonitionHeading},o.createElement("span",{className:c.admonitionIcon},h),y),o.createElement("div",{className:c.admonitionContent},n))}},4441:(e,n,t)=>{t.d(n,{A:()=>l});var o=t(9575),p=t(4041),r=t(2663),s=t(9082),c=t(2520),a=t(9631);const i={anchorWithStickyNavbar:"anchorWithStickyNavbar_fF9Z",anchorWithHideOnScrollNavbar:"anchorWithHideOnScrollNavbar_Yh18"};function l(e){let{as:n,id:t,...l}=e;const{navbar:{hideOnScroll:u}}=(0,c.p)();if("h1"===n||!t)return p.createElement(n,(0,o.A)({},l,{id:void 0}));const m=(0,s.T)({id:"theme.common.headingLinkTitle",message:"Direct link to {heading}",description:"Title for link to heading"},{heading:"string"==typeof l.children?l.children:t});return p.createElement(n,(0,o.A)({},l,{className:(0,r.A)("anchor",u?i.anchorWithHideOnScrollNavbar:i.anchorWithStickyNavbar,l.className),id:t}),l.children,p.createElement(a.A,{className:"hash-link",to:`#${t}`,"aria-label":m,title:m},"\u200b"))}},5906:(e,n,t)=>{t.d(n,{A:()=>u});var o=t(9531),p=t(53),r=t(4041),s=t(9631),c=t(9575);function a(e){let{width:n=24,height:t=24,...o}=e;return r.createElement("svg",(0,c.A)({viewBox:"0 0 24 24",width:n,height:t,"aria-hidden":!0},o),r.createElement("path",{d:"M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z",fill:"currentColor"}))}const i={container:"container_lQCo",small:"small_As57",banner:"banner_A4QS",player:"player_tELG",link:"link_BTzN",icon:"icon_wSGd"};function l(e){let{name:n}=e;const t=`https://github.com/revideo/revideo/blob/main/packages/examples/src/scenes/${n}.tsx`;return r.createElement(s.A,{to:t,className:(0,p.A)("padding--sm",i.link)},r.createElement("span",null,"View source code"),r.createElement(a,{className:i.icon}))}function u(e){let{name:n,banner:t,small:o,link:s}=e;return r.createElement("div",{className:(0,p.A)(i.container,t&&i.banner,o&&i.small)},r.createElement("revideo-player",{class:i.player,src:`/examples/${n}.js`,auto:t}),r.createElement(l,{name:s||n}))}o.A.canUseDOM&&t.e(3980).then(t.bind(t,3980))},9987:(e,n,t)=>{t.d(n,{A:()=>s});var o=t(1125),p=t(8675),r=t(4041);function s(e){let{url:n}=e;const t=(0,p.Fx)()(n);return r.createElement(o.A,{reflection:t,headless:!0})}},3310:(e,n,t)=>{t.d(n,{A:()=>nkr});var o={};t.r(o),t.d(o,{content_0_0:()=>i,content_0_10:()=>C,content_0_100:()=>Jn,content_0_1000:()=>ev,content_0_1002:()=>ov,content_0_1004:()=>sv,content_0_1006:()=>iv,content_0_1008:()=>mv,content_0_1010:()=>hv,content_0_1012:()=>Dv,content_0_1014:()=>_v,content_0_1016:()=>Cv,content_0_1018:()=>vv,content_0_102:()=>nt,content_0_1020:()=>Nv,content_0_1022:()=>Pv,content_0_1024:()=>Wv,content_0_1026:()=>Ev,content_0_1028:()=>Uv,content_0_1030:()=>qv,content_0_1032:()=>Yv,content_0_1034:()=>Kv,content_0_1036:()=>eL,content_0_1038:()=>oL,content_0_104:()=>pt,content_0_1040:()=>sL,content_0_1042:()=>iL,content_0_1044:()=>mL,content_0_1046:()=>hL,content_0_1048:()=>DL,content_0_1050:()=>_L,content_0_1052:()=>CL,content_0_1054:()=>vL,content_0_1056:()=>NL,content_0_1058:()=>PL,content_0_106:()=>ct,content_0_1060:()=>WL,content_0_1062:()=>EL,content_0_1064:()=>UL,content_0_1066:()=>qL,content_0_1068:()=>YL,content_0_1070:()=>KL,content_0_1072:()=>eb,content_0_1074:()=>ob,content_0_1076:()=>sb,content_0_1078:()=>ib,content_0_108:()=>lt,content_0_1080:()=>mb,content_0_1082:()=>hb,content_0_1084:()=>Db,content_0_1086:()=>_b,content_0_1088:()=>Cb,content_0_1090:()=>vb,content_0_1092:()=>Nb,content_0_1094:()=>Pb,content_0_1096:()=>Wb,content_0_1098:()=>Eb,content_0_110:()=>yt,content_0_1100:()=>Ub,content_0_1102:()=>qb,content_0_1104:()=>Yb,content_0_1106:()=>Kb,content_0_1108:()=>eN,content_0_1110:()=>oN,content_0_1112:()=>sN,content_0_1114:()=>iN,content_0_1116:()=>mN,content_0_1118:()=>hN,content_0_112:()=>gt,content_0_1120:()=>DN,content_0_1122:()=>_N,content_0_1124:()=>CN,content_0_1126:()=>vN,content_0_1128:()=>NN,content_0_1130:()=>PN,content_0_1132:()=>WN,content_0_1134:()=>EN,content_0_1136:()=>UN,content_0_1138:()=>qN,content_0_114:()=>Mt,content_0_1140:()=>YN,content_0_1142:()=>KN,content_0_1144:()=>ek,content_0_1146:()=>ok,content_0_1148:()=>sk,content_0_1150:()=>ik,content_0_1152:()=>mk,content_0_1154:()=>hk,content_0_1156:()=>Dk,content_0_1158:()=>_k,content_0_116:()=>wt,content_0_1160:()=>Ck,content_0_1162:()=>vk,content_0_1164:()=>Nk,content_0_1166:()=>Pk,content_0_1168:()=>Wk,content_0_1170:()=>Ek,content_0_1172:()=>Uk,content_0_1174:()=>qk,content_0_1176:()=>Yk,content_0_1178:()=>Kk,content_0_118:()=>xt,content_0_1180:()=>ez,content_0_1182:()=>oz,content_0_1184:()=>sz,content_0_1186:()=>iz,content_0_1188:()=>mz,content_0_1190:()=>hz,content_0_1192:()=>Dz,content_0_1194:()=>_z,content_0_1196:()=>Cz,content_0_1198:()=>vz,content_0_12:()=>v,content_0_120:()=>Lt,content_0_1200:()=>Nz,content_0_1202:()=>Pz,content_0_1204:()=>Wz,content_0_1206:()=>Ez,content_0_1208:()=>Uz,content_0_1210:()=>qz,content_0_1212:()=>Yz,content_0_1214:()=>Kz,content_0_1216:()=>eP,content_0_1218:()=>oP,content_0_122:()=>kt,content_0_1220:()=>sP,content_0_1222:()=>iP,content_0_1224:()=>mP,content_0_1226:()=>hP,content_0_1228:()=>DP,content_0_1230:()=>_P,content_0_1232:()=>CP,content_0_1234:()=>vP,content_0_1236:()=>NP,content_0_1238:()=>PP,content_0_124:()=>It,content_0_1240:()=>WP,content_0_1242:()=>EP,content_0_1244:()=>UP,content_0_1246:()=>qP,content_0_1248:()=>YP,content_0_1250:()=>KP,content_0_1252:()=>eI,content_0_1254:()=>oI,content_0_1256:()=>sI,content_0_1258:()=>iI,content_0_126:()=>St,content_0_1260:()=>mI,content_0_1262:()=>hI,content_0_1264:()=>DI,content_0_1266:()=>_I,content_0_1268:()=>CI,content_0_1270:()=>vI,content_0_1272:()=>NI,content_0_1274:()=>PI,content_0_1276:()=>WI,content_0_1278:()=>EI,content_0_128:()=>Gt,content_0_1280:()=>UI,content_0_1282:()=>qI,content_0_1284:()=>YI,content_0_1286:()=>KI,content_0_1288:()=>eR,content_0_1290:()=>oR,content_0_1292:()=>sR,content_0_1294:()=>iR,content_0_1296:()=>mR,content_0_1298:()=>hR,content_0_130:()=>Ft,content_0_1300:()=>DR,content_0_1302:()=>_R,content_0_1304:()=>CR,content_0_1306:()=>vR,content_0_1308:()=>NR,content_0_1310:()=>PR,content_0_1312:()=>WR,content_0_1314:()=>ER,content_0_1316:()=>UR,content_0_1318:()=>qR,content_0_132:()=>jt,content_0_1320:()=>YR,content_0_1322:()=>KR,content_0_1324:()=>eW,content_0_1326:()=>oW,content_0_1328:()=>sW,content_0_1330:()=>iW,content_0_1332:()=>mW,content_0_1334:()=>hW,content_0_1336:()=>DW,content_0_1338:()=>_W,content_0_134:()=>Qt,content_0_1340:()=>CW,content_0_1342:()=>vW,content_0_1344:()=>NW,content_0_1346:()=>PW,content_0_1348:()=>WW,content_0_1350:()=>EW,content_0_1352:()=>UW,content_0_1354:()=>qW,content_0_1356:()=>YW,content_0_1358:()=>KW,content_0_136:()=>Jt,content_0_1360:()=>eS,content_0_1362:()=>oS,content_0_1364:()=>sS,content_0_1366:()=>iS,content_0_1368:()=>mS,content_0_1370:()=>hS,content_0_1372:()=>DS,content_0_1374:()=>_S,content_0_1376:()=>CS,content_0_1378:()=>vS,content_0_138:()=>no,content_0_1380:()=>NS,content_0_1382:()=>PS,content_0_1384:()=>WS,content_0_1386:()=>ES,content_0_1388:()=>US,content_0_1390:()=>qS,content_0_1392:()=>YS,content_0_1394:()=>KS,content_0_1396:()=>eB,content_0_1398:()=>oB,content_0_14:()=>N,content_0_140:()=>po,content_0_1400:()=>sB,content_0_1402:()=>iB,content_0_1404:()=>mB,content_0_1406:()=>hB,content_0_1408:()=>DB,content_0_1410:()=>_B,content_0_1412:()=>CB,content_0_1414:()=>vB,content_0_1416:()=>NB,content_0_1418:()=>PB,content_0_142:()=>co,content_0_1420:()=>WB,content_0_1422:()=>EB,content_0_1424:()=>UB,content_0_1426:()=>qB,content_0_1428:()=>YB,content_0_1430:()=>KB,content_0_1432:()=>eE,content_0_1434:()=>oE,content_0_1436:()=>sE,content_0_1438:()=>iE,content_0_144:()=>lo,content_0_1440:()=>mE,content_0_1442:()=>hE,content_0_1444:()=>DE,content_0_1446:()=>_E,content_0_1448:()=>CE,content_0_1450:()=>vE,content_0_1452:()=>NE,content_0_1454:()=>PE,content_0_1456:()=>WE,content_0_1458:()=>EE,content_0_146:()=>yo,content_0_1460:()=>UE,content_0_1462:()=>qE,content_0_1464:()=>YE,content_0_1466:()=>KE,content_0_1468:()=>eG,content_0_1470:()=>oG,content_0_1472:()=>sG,content_0_1474:()=>iG,content_0_1476:()=>mG,content_0_1478:()=>hG,content_0_148:()=>fo,content_0_1480:()=>DG,content_0_1482:()=>_G,content_0_1484:()=>CG,content_0_1486:()=>vG,content_0_1488:()=>NG,content_0_1490:()=>PG,content_0_1492:()=>WG,content_0_1494:()=>EG,content_0_1496:()=>UG,content_0_1498:()=>qG,content_0_150:()=>Xo,content_0_1500:()=>YG,content_0_1502:()=>KG,content_0_1504:()=>eO,content_0_1506:()=>oO,content_0_1508:()=>sO,content_0_1510:()=>iO,content_0_1512:()=>mO,content_0_1514:()=>hO,content_0_1516:()=>DO,content_0_1518:()=>_O,content_0_152:()=>To,content_0_1520:()=>CO,content_0_1522:()=>vO,content_0_1524:()=>NO,content_0_1526:()=>PO,content_0_1528:()=>WO,content_0_1530:()=>EO,content_0_1532:()=>UO,content_0_1534:()=>qO,content_0_1536:()=>YO,content_0_1538:()=>KO,content_0_154:()=>Ao,content_0_1540:()=>eU,content_0_1542:()=>oU,content_0_1544:()=>sU,content_0_1546:()=>iU,content_0_1548:()=>mU,content_0_1550:()=>hU,content_0_1552:()=>DU,content_0_1554:()=>_U,content_0_1556:()=>CU,content_0_1558:()=>vU,content_0_156:()=>bo,content_0_1560:()=>NU,content_0_1562:()=>PU,content_0_1564:()=>WU,content_0_1566:()=>EU,content_0_1568:()=>UU,content_0_1570:()=>qU,content_0_1572:()=>YU,content_0_1574:()=>KU,content_0_1576:()=>eF,content_0_1578:()=>oF,content_0_158:()=>zo,content_0_1580:()=>sF,content_0_1582:()=>iF,content_0_1584:()=>mF,content_0_1586:()=>hF,content_0_1588:()=>DF,content_0_1590:()=>_F,content_0_1592:()=>CF,content_0_1594:()=>vF,content_0_1596:()=>NF,content_0_1598:()=>PF,content_0_16:()=>P,content_0_160:()=>Ro,content_0_1600:()=>WF,content_0_1602:()=>EF,content_0_1604:()=>UF,content_0_1606:()=>qF,content_0_1608:()=>YF,content_0_1610:()=>KF,content_0_1612:()=>eV,content_0_1614:()=>oV,content_0_1616:()=>sV,content_0_1618:()=>iV,content_0_162:()=>Bo,content_0_1620:()=>mV,content_0_1622:()=>hV,content_0_1624:()=>DV,content_0_1626:()=>_V,content_0_1628:()=>CV,content_0_1630:()=>vV,content_0_1632:()=>NV,content_0_1634:()=>PV,content_0_1636:()=>WV,content_0_1638:()=>EV,content_0_164:()=>Oo,content_0_1640:()=>UV,content_0_1642:()=>qV,content_0_1644:()=>YV,content_0_1646:()=>KV,content_0_1648:()=>eq,content_0_1650:()=>oq,content_0_1652:()=>sq,content_0_1654:()=>iq,content_0_1656:()=>mq,content_0_1658:()=>hq,content_0_166:()=>Vo,content_0_1660:()=>Dq,content_0_1662:()=>_q,content_0_1664:()=>Cq,content_0_1666:()=>vq,content_0_1668:()=>Nq,content_0_1670:()=>Pq,content_0_1672:()=>Wq,content_0_1674:()=>Eq,content_0_1676:()=>Uq,content_0_1678:()=>qq,content_0_168:()=>Ho,content_0_1680:()=>Yq,content_0_1682:()=>Kq,content_0_1684:()=>ej,content_0_1686:()=>oj,content_0_1688:()=>sj,content_0_1690:()=>ij,content_0_1692:()=>mj,content_0_1694:()=>hj,content_0_1696:()=>Dj,content_0_1698:()=>_j,content_0_170:()=>$o,content_0_1700:()=>Cj,content_0_1702:()=>vj,content_0_1704:()=>Nj,content_0_1706:()=>Pj,content_0_1708:()=>Wj,content_0_1710:()=>Ej,content_0_1712:()=>Uj,content_0_1714:()=>qj,content_0_1716:()=>Yj,content_0_1718:()=>Kj,content_0_172:()=>Zo,content_0_1720:()=>eH,content_0_1722:()=>oH,content_0_1724:()=>sH,content_0_1726:()=>iH,content_0_1728:()=>mH,content_0_1730:()=>hH,content_0_1732:()=>DH,content_0_1734:()=>_H,content_0_1736:()=>CH,content_0_1738:()=>vH,content_0_174:()=>tp,content_0_1740:()=>NH,content_0_1742:()=>PH,content_0_1744:()=>WH,content_0_1746:()=>EH,content_0_1748:()=>UH,content_0_1750:()=>qH,content_0_1752:()=>YH,content_0_1754:()=>KH,content_0_1756:()=>eY,content_0_1758:()=>oY,content_0_176:()=>rp,content_0_1760:()=>sY,content_0_1762:()=>iY,content_0_1764:()=>mY,content_0_1766:()=>hY,content_0_1768:()=>DY,content_0_1770:()=>_Y,content_0_1772:()=>CY,content_0_1774:()=>vY,content_0_1776:()=>NY,content_0_1778:()=>PY,content_0_178:()=>ap,content_0_1780:()=>WY,content_0_1782:()=>EY,content_0_1784:()=>UY,content_0_1786:()=>qY,content_0_1788:()=>YY,content_0_1790:()=>KY,content_0_1792:()=>eQ,content_0_1794:()=>oQ,content_0_1796:()=>sQ,content_0_1798:()=>iQ,content_0_18:()=>W,content_0_180:()=>up,content_0_1800:()=>mQ,content_0_1802:()=>hQ,content_0_1804:()=>DQ,content_0_1806:()=>_Q,content_0_1808:()=>CQ,content_0_1810:()=>vQ,content_0_1812:()=>NQ,content_0_1814:()=>PQ,content_0_1816:()=>WQ,content_0_1818:()=>EQ,content_0_182:()=>dp,content_0_1820:()=>UQ,content_0_1822:()=>qQ,content_0_1824:()=>YQ,content_0_1826:()=>KQ,content_0_1828:()=>e$,content_0_1830:()=>o$,content_0_1832:()=>s$,content_0_1834:()=>i$,content_0_1836:()=>m$,content_0_1838:()=>h$,content_0_184:()=>fp,content_0_1840:()=>D$,content_0_1842:()=>_$,content_0_1844:()=>C$,content_0_1846:()=>v$,content_0_1848:()=>N$,content_0_1850:()=>P$,content_0_1852:()=>W$,content_0_1854:()=>E$,content_0_1856:()=>U$,content_0_1858:()=>q$,content_0_186:()=>Xp,content_0_1860:()=>Y$,content_0_1862:()=>K$,content_0_1864:()=>eK,content_0_1866:()=>oK,content_0_1868:()=>sK,content_0_1870:()=>iK,content_0_1872:()=>mK,content_0_1874:()=>hK,content_0_1876:()=>DK,content_0_1878:()=>_K,content_0_188:()=>Tp,content_0_1880:()=>CK,content_0_1882:()=>vK,content_0_1884:()=>NK,content_0_1886:()=>PK,content_0_1888:()=>WK,content_0_1890:()=>EK,content_0_1892:()=>UK,content_0_1894:()=>qK,content_0_1896:()=>YK,content_0_1898:()=>KK,content_0_190:()=>Ap,content_0_1900:()=>eJ,content_0_1902:()=>oJ,content_0_1904:()=>sJ,content_0_1906:()=>iJ,content_0_1908:()=>mJ,content_0_1910:()=>hJ,content_0_1912:()=>DJ,content_0_1914:()=>_J,content_0_1916:()=>CJ,content_0_1918:()=>vJ,content_0_192:()=>bp,content_0_1920:()=>NJ,content_0_1922:()=>PJ,content_0_1924:()=>WJ,content_0_1926:()=>EJ,content_0_1928:()=>UJ,content_0_1930:()=>qJ,content_0_1932:()=>YJ,content_0_1934:()=>KJ,content_0_1936:()=>eZ,content_0_1938:()=>oZ,content_0_194:()=>zp,content_0_1940:()=>sZ,content_0_1942:()=>iZ,content_0_1944:()=>mZ,content_0_196:()=>Rp,content_0_198:()=>Bp,content_0_2:()=>m,content_0_20:()=>E,content_0_200:()=>Op,content_0_202:()=>Vp,content_0_204:()=>Hp,content_0_206:()=>$p,content_0_208:()=>Zp,content_0_210:()=>tr,content_0_212:()=>rr,content_0_214:()=>ar,content_0_216:()=>ur,content_0_218:()=>dr,content_0_22:()=>U,content_0_220:()=>fr,content_0_222:()=>Xr,content_0_224:()=>Tr,content_0_226:()=>Ar,content_0_228:()=>br,content_0_230:()=>zr,content_0_232:()=>Rr,content_0_234:()=>Br,content_0_236:()=>Or,content_0_238:()=>Vr,content_0_24:()=>q,content_0_240:()=>Hr,content_0_242:()=>$r,content_0_244:()=>Zr,content_0_246:()=>ts,content_0_248:()=>rs,content_0_250:()=>as,content_0_252:()=>us,content_0_254:()=>ds,content_0_256:()=>fs,content_0_258:()=>Xs,content_0_26:()=>Y,content_0_260:()=>Ts,content_0_262:()=>As,content_0_264:()=>bs,content_0_266:()=>zs,content_0_268:()=>Rs,content_0_270:()=>Bs,content_0_272:()=>Os,content_0_274:()=>Vs,content_0_276:()=>Hs,content_0_278:()=>$s,content_0_28:()=>K,content_0_280:()=>Zs,content_0_282:()=>tc,content_0_284:()=>rc,content_0_286:()=>ac,content_0_288:()=>uc,content_0_290:()=>dc,content_0_292:()=>fc,content_0_294:()=>Xc,content_0_296:()=>Tc,content_0_298:()=>Ac,content_0_30:()=>ee,content_0_300:()=>bc,content_0_302:()=>zc,content_0_304:()=>Rc,content_0_306:()=>Bc,content_0_308:()=>Oc,content_0_310:()=>Vc,content_0_312:()=>Hc,content_0_314:()=>$c,content_0_316:()=>Zc,content_0_318:()=>ta,content_0_32:()=>oe,content_0_320:()=>ra,content_0_322:()=>aa,content_0_324:()=>ua,content_0_326:()=>da,content_0_328:()=>fa,content_0_330:()=>Xa,content_0_332:()=>Ta,content_0_334:()=>Aa,content_0_336:()=>ba,content_0_338:()=>za,content_0_34:()=>se,content_0_340:()=>Ra,content_0_342:()=>Ba,content_0_344:()=>Oa,content_0_346:()=>Va,content_0_348:()=>Ha,content_0_350:()=>$a,content_0_352:()=>Za,content_0_354:()=>ti,content_0_356:()=>ri,content_0_358:()=>ai,content_0_36:()=>ie,content_0_360:()=>ui,content_0_362:()=>di,content_0_364:()=>fi,content_0_366:()=>Xi,content_0_368:()=>Ti,content_0_370:()=>Ai,content_0_372:()=>bi,content_0_374:()=>zi,content_0_376:()=>Ri,content_0_378:()=>Bi,content_0_38:()=>me,content_0_380:()=>Oi,content_0_382:()=>Vi,content_0_384:()=>Hi,content_0_386:()=>$i,content_0_388:()=>Zi,content_0_390:()=>tl,content_0_392:()=>rl,content_0_394:()=>al,content_0_396:()=>ul,content_0_398:()=>dl,content_0_4:()=>h,content_0_40:()=>he,content_0_400:()=>fl,content_0_402:()=>Xl,content_0_404:()=>Tl,content_0_406:()=>Al,content_0_408:()=>bl,content_0_410:()=>zl,content_0_412:()=>Rl,content_0_414:()=>Bl,content_0_416:()=>Ol,content_0_418:()=>Vl,content_0_42:()=>De,content_0_420:()=>Hl,content_0_422:()=>$l,content_0_424:()=>Zl,content_0_426:()=>tu,content_0_428:()=>ru,content_0_430:()=>au,content_0_432:()=>uu,content_0_434:()=>du,content_0_436:()=>fu,content_0_438:()=>Xu,content_0_44:()=>_e,content_0_440:()=>Tu,content_0_442:()=>Au,content_0_444:()=>bu,content_0_446:()=>zu,content_0_448:()=>Ru,content_0_450:()=>Bu,content_0_452:()=>Ou,content_0_454:()=>Vu,content_0_456:()=>Hu,content_0_458:()=>$u,content_0_46:()=>Ce,content_0_460:()=>Zu,content_0_462:()=>tm,content_0_464:()=>rm,content_0_466:()=>am,content_0_468:()=>um,content_0_470:()=>dm,content_0_472:()=>fm,content_0_474:()=>Xm,content_0_476:()=>Tm,content_0_478:()=>Am,content_0_48:()=>ve,content_0_480:()=>bm,content_0_482:()=>zm,content_0_484:()=>Rm,content_0_486:()=>Bm,content_0_488:()=>Om,content_0_490:()=>Vm,content_0_492:()=>Hm,content_0_494:()=>$m,content_0_496:()=>Zm,content_0_498:()=>ty,content_0_50:()=>Ne,content_0_500:()=>ry,content_0_502:()=>ay,content_0_504:()=>uy,content_0_506:()=>dy,content_0_508:()=>fy,content_0_510:()=>Xy,content_0_512:()=>Ty,content_0_514:()=>Ay,content_0_516:()=>by,content_0_518:()=>zy,content_0_52:()=>Pe,content_0_520:()=>Ry,content_0_522:()=>By,content_0_524:()=>Oy,content_0_526:()=>Vy,content_0_528:()=>Hy,content_0_530:()=>$y,content_0_532:()=>Zy,content_0_534:()=>td,content_0_536:()=>rd,content_0_538:()=>ad,content_0_54:()=>We,content_0_540:()=>ud,content_0_542:()=>dd,content_0_544:()=>fd,content_0_546:()=>Xd,content_0_548:()=>Td,content_0_550:()=>Ad,content_0_552:()=>bd,content_0_554:()=>zd,content_0_556:()=>Rd,content_0_558:()=>Bd,content_0_56:()=>Ee,content_0_560:()=>Od,content_0_562:()=>Vd,content_0_564:()=>Hd,content_0_566:()=>$d,content_0_568:()=>Zd,content_0_570:()=>th,content_0_572:()=>rh,content_0_574:()=>ah,content_0_576:()=>uh,content_0_578:()=>dh,content_0_58:()=>Ue,content_0_580:()=>fh,content_0_582:()=>Xh,content_0_584:()=>Th,content_0_586:()=>Ah,content_0_588:()=>bh,content_0_590:()=>zh,content_0_592:()=>Rh,content_0_594:()=>Bh,content_0_596:()=>Oh,content_0_598:()=>Vh,content_0_6:()=>D,content_0_60:()=>qe,content_0_600:()=>Hh,content_0_602:()=>$h,content_0_604:()=>Zh,content_0_606:()=>tg,content_0_608:()=>rg,content_0_610:()=>ag,content_0_612:()=>ug,content_0_614:()=>dg,content_0_616:()=>fg,content_0_618:()=>Xg,content_0_62:()=>Ye,content_0_620:()=>Tg,content_0_622:()=>Ag,content_0_624:()=>bg,content_0_626:()=>zg,content_0_628:()=>Rg,content_0_630:()=>Bg,content_0_632:()=>Og,content_0_634:()=>Vg,content_0_636:()=>Hg,content_0_638:()=>$g,content_0_64:()=>Ke,content_0_640:()=>Zg,content_0_642:()=>tf,content_0_644:()=>rf,content_0_646:()=>af,content_0_648:()=>mf,content_0_650:()=>hf,content_0_652:()=>Df,content_0_654:()=>_f,content_0_656:()=>Cf,content_0_658:()=>vf,content_0_66:()=>en,content_0_660:()=>Nf,content_0_662:()=>Pf,content_0_664:()=>Wf,content_0_666:()=>Ef,content_0_668:()=>Uf,content_0_670:()=>qf,content_0_672:()=>Yf,content_0_674:()=>Kf,content_0_676:()=>eD,content_0_678:()=>oD,content_0_68:()=>on,content_0_680:()=>sD,content_0_682:()=>iD,content_0_684:()=>mD,content_0_686:()=>hD,content_0_688:()=>DD,content_0_690:()=>_D,content_0_692:()=>CD,content_0_694:()=>vD,content_0_696:()=>ND,content_0_698:()=>PD,content_0_70:()=>sn,content_0_700:()=>WD,content_0_702:()=>ED,content_0_704:()=>UD,content_0_706:()=>qD,content_0_708:()=>YD,content_0_710:()=>KD,content_0_712:()=>eM,content_0_714:()=>oM,content_0_716:()=>sM,content_0_718:()=>iM,content_0_72:()=>ln,content_0_720:()=>mM,content_0_722:()=>hM,content_0_724:()=>DM,content_0_726:()=>_M,content_0_728:()=>CM,content_0_730:()=>vM,content_0_732:()=>NM,content_0_734:()=>PM,content_0_736:()=>WM,content_0_738:()=>EM,content_0_74:()=>yn,content_0_740:()=>UM,content_0_742:()=>qM,content_0_744:()=>YM,content_0_746:()=>KM,content_0_748:()=>eX,content_0_750:()=>oX,content_0_752:()=>sX,content_0_754:()=>iX,content_0_756:()=>mX,content_0_758:()=>hX,content_0_76:()=>gn,content_0_760:()=>DX,content_0_762:()=>_X,content_0_764:()=>CX,content_0_766:()=>vX,content_0_768:()=>NX,content_0_770:()=>PX,content_0_772:()=>WX,content_0_774:()=>EX,content_0_776:()=>UX,content_0_778:()=>qX,content_0_78:()=>Mn,content_0_780:()=>YX,content_0_782:()=>KX,content_0_784:()=>e_,content_0_786:()=>o_,content_0_788:()=>s_,content_0_790:()=>i_,content_0_792:()=>m_,content_0_794:()=>h_,content_0_796:()=>D_,content_0_798:()=>__,content_0_8:()=>_,content_0_80:()=>wn,content_0_800:()=>C_,content_0_802:()=>v_,content_0_804:()=>N_,content_0_806:()=>P_,content_0_808:()=>W_,content_0_810:()=>E_,content_0_812:()=>U_,content_0_814:()=>q_,content_0_816:()=>Y_,content_0_818:()=>K_,content_0_82:()=>xn,content_0_820:()=>ew,content_0_822:()=>ow,content_0_824:()=>sw,content_0_826:()=>iw,content_0_828:()=>mw,content_0_830:()=>hw,content_0_832:()=>Dw,content_0_834:()=>_w,content_0_836:()=>Cw,content_0_838:()=>vw,content_0_84:()=>Ln,content_0_840:()=>Nw,content_0_842:()=>Pw,content_0_844:()=>Ww,content_0_846:()=>Ew,content_0_848:()=>Uw,content_0_850:()=>qw,content_0_852:()=>Yw,content_0_854:()=>Kw,content_0_856:()=>eT,content_0_858:()=>oT,content_0_86:()=>kn,content_0_860:()=>sT,content_0_862:()=>iT,content_0_864:()=>mT,content_0_866:()=>hT,content_0_868:()=>DT,content_0_870:()=>_T,content_0_872:()=>CT,content_0_874:()=>vT,content_0_876:()=>NT,content_0_878:()=>PT,content_0_88:()=>In,content_0_880:()=>WT,content_0_882:()=>ET,content_0_884:()=>UT,content_0_886:()=>qT,content_0_888:()=>YT,content_0_890:()=>KT,content_0_892:()=>eC,content_0_894:()=>oC,content_0_896:()=>sC,content_0_898:()=>iC,content_0_90:()=>Sn,content_0_900:()=>mC,content_0_902:()=>hC,content_0_904:()=>DC,content_0_906:()=>_C,content_0_908:()=>CC,content_0_910:()=>vC,content_0_912:()=>NC,content_0_914:()=>PC,content_0_916:()=>WC,content_0_918:()=>EC,content_0_92:()=>Gn,content_0_920:()=>UC,content_0_922:()=>qC,content_0_924:()=>YC,content_0_926:()=>KC,content_0_928:()=>ex,content_0_930:()=>ox,content_0_932:()=>sx,content_0_934:()=>ix,content_0_936:()=>mx,content_0_938:()=>hx,content_0_94:()=>Fn,content_0_940:()=>Dx,content_0_942:()=>_x,content_0_944:()=>Cx,content_0_946:()=>vx,content_0_948:()=>Nx,content_0_950:()=>Px,content_0_952:()=>Wx,content_0_954:()=>Ex,content_0_956:()=>Ux,content_0_958:()=>qx,content_0_96:()=>jn,content_0_960:()=>Yx,content_0_962:()=>Kx,content_0_964:()=>eA,content_0_966:()=>oA,content_0_968:()=>sA,content_0_970:()=>iA,content_0_972:()=>mA,content_0_974:()=>hA,content_0_976:()=>DA,content_0_978:()=>_A,content_0_98:()=>Qn,content_0_980:()=>CA,content_0_982:()=>vA,content_0_984:()=>NA,content_0_986:()=>PA,content_0_988:()=>WA,content_0_990:()=>EA,content_0_992:()=>UA,content_0_994:()=>qA,content_0_996:()=>YA,content_0_998:()=>KA,content_3913_0:()=>hZ,content_3913_10:()=>NZ,content_3913_100:()=>o1,content_3913_1000:()=>ofe,content_3913_10000:()=>pup,content_3913_10002:()=>cup,content_3913_10004:()=>lup,content_3913_10006:()=>yup,content_3913_10008:()=>gup,content_3913_10010:()=>Mup,content_3913_10012:()=>wup,content_3913_10014:()=>xup,content_3913_10016:()=>Lup,content_3913_10018:()=>kup,content_3913_1002:()=>sfe,content_3913_10020:()=>Iup,content_3913_10022:()=>Sup,content_3913_10024:()=>Gup,content_3913_10026:()=>Fup,content_3913_10028:()=>jup,content_3913_10030:()=>Qup,content_3913_10032:()=>Jup,content_3913_10034:()=>nmp,content_3913_10036:()=>pmp,content_3913_10038:()=>cmp,content_3913_1004:()=>ife,content_3913_10040:()=>lmp,content_3913_10042:()=>ymp,content_3913_10044:()=>gmp,content_3913_10046:()=>Mmp,content_3913_10048:()=>wmp,content_3913_10050:()=>xmp,content_3913_10052:()=>Lmp,content_3913_10054:()=>kmp,content_3913_10056:()=>Imp,content_3913_10058:()=>Smp,content_3913_1006:()=>mfe,content_3913_10060:()=>Gmp,content_3913_10062:()=>Fmp,content_3913_10064:()=>jmp,content_3913_10066:()=>Qmp,content_3913_10068:()=>Jmp,content_3913_10070:()=>nyp,content_3913_10072:()=>pyp,content_3913_10074:()=>cyp,content_3913_10076:()=>lyp,content_3913_10078:()=>yyp,content_3913_1008:()=>hfe,content_3913_10080:()=>gyp,content_3913_10082:()=>Myp,content_3913_10084:()=>wyp,content_3913_10086:()=>xyp,content_3913_10088:()=>Lyp,content_3913_10090:()=>kyp,content_3913_10092:()=>Iyp,content_3913_10094:()=>Syp,content_3913_10096:()=>Gyp,content_3913_10098:()=>Fyp,content_3913_1010:()=>Dfe,content_3913_10100:()=>jyp,content_3913_10102:()=>Qyp,content_3913_10104:()=>Jyp,content_3913_10106:()=>ndp,content_3913_10108:()=>pdp,content_3913_10110:()=>cdp,content_3913_10112:()=>ldp,content_3913_10114:()=>ydp,content_3913_10116:()=>gdp,content_3913_10118:()=>Mdp,content_3913_1012:()=>_fe,content_3913_10120:()=>wdp,content_3913_10122:()=>xdp,content_3913_10124:()=>Ldp,content_3913_10126:()=>kdp,content_3913_10128:()=>Idp,content_3913_10130:()=>Sdp,content_3913_10132:()=>Gdp,content_3913_10134:()=>Fdp,content_3913_10136:()=>jdp,content_3913_10138:()=>Qdp,content_3913_1014:()=>Cfe,content_3913_10140:()=>Jdp,content_3913_10142:()=>nhp,content_3913_10144:()=>php,content_3913_10146:()=>chp,content_3913_10148:()=>lhp,content_3913_10150:()=>yhp,content_3913_10152:()=>ghp,content_3913_10154:()=>Mhp,content_3913_10156:()=>whp,content_3913_10158:()=>xhp,content_3913_1016:()=>vfe,content_3913_10160:()=>Lhp,content_3913_10162:()=>khp,content_3913_10164:()=>Ihp,content_3913_10166:()=>Shp,content_3913_10168:()=>Ghp,content_3913_10170:()=>Fhp,content_3913_10172:()=>jhp,content_3913_10174:()=>Qhp,content_3913_10176:()=>Jhp,content_3913_10178:()=>ngp,content_3913_1018:()=>Nfe,content_3913_10180:()=>pgp,content_3913_10182:()=>cgp,content_3913_10184:()=>lgp,content_3913_10186:()=>ygp,content_3913_10188:()=>ggp,content_3913_10190:()=>Mgp,content_3913_10192:()=>wgp,content_3913_10194:()=>xgp,content_3913_10196:()=>Lgp,content_3913_10198:()=>kgp,content_3913_102:()=>s1,content_3913_1020:()=>Pfe,content_3913_10200:()=>Igp,content_3913_10202:()=>Sgp,content_3913_10204:()=>Ggp,content_3913_10206:()=>Fgp,content_3913_10208:()=>jgp,content_3913_10210:()=>Qgp,content_3913_10212:()=>Jgp,content_3913_10214:()=>nfp,content_3913_10216:()=>pfp,content_3913_10218:()=>cfp,content_3913_1022:()=>Wfe,content_3913_10220:()=>lfp,content_3913_10222:()=>yfp,content_3913_10224:()=>gfp,content_3913_10226:()=>Mfp,content_3913_10228:()=>wfp,content_3913_10230:()=>xfp,content_3913_10232:()=>Lfp,content_3913_10234:()=>kfp,content_3913_10236:()=>Ifp,content_3913_10238:()=>Sfp,content_3913_1024:()=>Efe,content_3913_10240:()=>Gfp,content_3913_10242:()=>Ffp,content_3913_10244:()=>jfp,content_3913_10246:()=>Qfp,content_3913_10248:()=>Jfp,content_3913_10250:()=>nDp,content_3913_10252:()=>pDp,content_3913_10254:()=>cDp,content_3913_10256:()=>lDp,content_3913_10258:()=>yDp,content_3913_1026:()=>Ufe,content_3913_10260:()=>gDp,content_3913_10262:()=>MDp,content_3913_10264:()=>wDp,content_3913_10266:()=>xDp,content_3913_10268:()=>LDp,content_3913_10270:()=>kDp,content_3913_10272:()=>IDp,content_3913_10274:()=>SDp,content_3913_10276:()=>GDp,content_3913_10278:()=>FDp,content_3913_1028:()=>qfe,content_3913_10280:()=>jDp,content_3913_10282:()=>QDp,content_3913_10284:()=>JDp,content_3913_10286:()=>nMp,content_3913_10288:()=>pMp,content_3913_10290:()=>cMp,content_3913_10292:()=>lMp,content_3913_10294:()=>yMp,content_3913_10296:()=>gMp,content_3913_10298:()=>MMp,content_3913_1030:()=>Yfe,content_3913_10300:()=>wMp,content_3913_10302:()=>xMp,content_3913_10304:()=>LMp,content_3913_10306:()=>kMp,content_3913_10308:()=>IMp,content_3913_10310:()=>SMp,content_3913_10312:()=>GMp,content_3913_10314:()=>FMp,content_3913_10316:()=>jMp,content_3913_10318:()=>QMp,content_3913_1032:()=>Kfe,content_3913_10320:()=>JMp,content_3913_10322:()=>nXp,content_3913_10324:()=>pXp,content_3913_10326:()=>cXp,content_3913_10328:()=>lXp,content_3913_10330:()=>yXp,content_3913_10332:()=>gXp,content_3913_10334:()=>MXp,content_3913_10336:()=>wXp,content_3913_10338:()=>xXp,content_3913_1034:()=>eDe,content_3913_10340:()=>LXp,content_3913_10342:()=>kXp,content_3913_10344:()=>IXp,content_3913_10346:()=>SXp,content_3913_10348:()=>GXp,content_3913_10350:()=>FXp,content_3913_10352:()=>jXp,content_3913_10354:()=>QXp,content_3913_10356:()=>JXp,content_3913_10358:()=>n_p,content_3913_1036:()=>oDe,content_3913_10360:()=>p_p,content_3913_10362:()=>c_p,content_3913_10364:()=>l_p,content_3913_10366:()=>y_p,content_3913_10368:()=>g_p,content_3913_10370:()=>M_p,content_3913_10372:()=>w_p,content_3913_10374:()=>x_p,content_3913_10376:()=>L_p,content_3913_10378:()=>k_p,content_3913_1038:()=>sDe,content_3913_10380:()=>I_p,content_3913_10382:()=>S_p,content_3913_10384:()=>G_p,content_3913_10386:()=>F_p,content_3913_10388:()=>j_p,content_3913_10390:()=>Q_p,content_3913_10392:()=>J_p,content_3913_10394:()=>nwp,content_3913_10396:()=>pwp,content_3913_10398:()=>cwp,content_3913_104:()=>i1,content_3913_1040:()=>iDe,content_3913_10400:()=>lwp,content_3913_10402:()=>ywp,content_3913_10404:()=>gwp,content_3913_10406:()=>Mwp,content_3913_10408:()=>wwp,content_3913_10410:()=>xwp,content_3913_10412:()=>Lwp,content_3913_10414:()=>kwp,content_3913_10416:()=>Iwp,content_3913_10418:()=>Swp,content_3913_1042:()=>mDe,content_3913_10420:()=>Gwp,content_3913_10422:()=>Fwp,content_3913_10424:()=>jwp,content_3913_10426:()=>Qwp,content_3913_10428:()=>Jwp,content_3913_10430:()=>nTp,content_3913_10432:()=>pTp,content_3913_10434:()=>cTp,content_3913_10436:()=>lTp,content_3913_10438:()=>yTp,content_3913_1044:()=>hDe,content_3913_10440:()=>gTp,content_3913_10442:()=>MTp,content_3913_10444:()=>wTp,content_3913_10446:()=>xTp,content_3913_10448:()=>LTp,content_3913_10450:()=>kTp,content_3913_10452:()=>ITp,content_3913_10454:()=>STp,content_3913_10456:()=>GTp,content_3913_10458:()=>FTp,content_3913_1046:()=>DDe,content_3913_10460:()=>jTp,content_3913_10462:()=>QTp,content_3913_10464:()=>JTp,content_3913_10466:()=>nCp,content_3913_10468:()=>pCp,content_3913_10470:()=>cCp,content_3913_10472:()=>lCp,content_3913_10474:()=>yCp,content_3913_10476:()=>gCp,content_3913_10478:()=>MCp,content_3913_1048:()=>_De,content_3913_10480:()=>wCp,content_3913_10482:()=>xCp,content_3913_10484:()=>LCp,content_3913_10486:()=>kCp,content_3913_10488:()=>ICp,content_3913_10490:()=>SCp,content_3913_10492:()=>GCp,content_3913_10494:()=>FCp,content_3913_10496:()=>jCp,content_3913_10498:()=>QCp,content_3913_1050:()=>CDe,content_3913_10500:()=>JCp,content_3913_10502:()=>nxp,content_3913_10504:()=>pxp,content_3913_10506:()=>cxp,content_3913_10508:()=>lxp,content_3913_10510:()=>yxp,content_3913_10512:()=>gxp,content_3913_10514:()=>Mxp,content_3913_10516:()=>wxp,content_3913_10518:()=>xxp,content_3913_1052:()=>vDe,content_3913_10520:()=>Lxp,content_3913_10522:()=>kxp,content_3913_10524:()=>Ixp,content_3913_10526:()=>Sxp,content_3913_10528:()=>Gxp,content_3913_10530:()=>Fxp,content_3913_10532:()=>jxp,content_3913_10534:()=>Qxp,content_3913_10536:()=>Jxp,content_3913_10538:()=>nAp,content_3913_1054:()=>NDe,content_3913_10540:()=>pAp,content_3913_10542:()=>cAp,content_3913_10544:()=>lAp,content_3913_10546:()=>yAp,content_3913_10548:()=>gAp,content_3913_10550:()=>MAp,content_3913_10552:()=>wAp,content_3913_10554:()=>xAp,content_3913_10556:()=>LAp,content_3913_10558:()=>kAp,content_3913_1056:()=>PDe,content_3913_10560:()=>IAp,content_3913_10562:()=>SAp,content_3913_10564:()=>GAp,content_3913_10566:()=>FAp,content_3913_10568:()=>jAp,content_3913_10570:()=>QAp,content_3913_10572:()=>JAp,content_3913_10574:()=>nvp,content_3913_10576:()=>pvp,content_3913_10578:()=>cvp,content_3913_1058:()=>WDe,content_3913_10580:()=>lvp,content_3913_10582:()=>yvp,content_3913_10584:()=>gvp,content_3913_10586:()=>Mvp,content_3913_10588:()=>wvp,content_3913_10590:()=>xvp,content_3913_10592:()=>Lvp,content_3913_10594:()=>kvp,content_3913_10596:()=>Ivp,content_3913_10598:()=>Svp,content_3913_106:()=>m1,content_3913_1060:()=>EDe,content_3913_10600:()=>Gvp,content_3913_10602:()=>Fvp,content_3913_10604:()=>jvp,content_3913_10606:()=>Qvp,content_3913_10608:()=>Jvp,content_3913_10610:()=>nLp,content_3913_10612:()=>pLp,content_3913_10614:()=>cLp,content_3913_10616:()=>lLp,content_3913_10618:()=>yLp,content_3913_1062:()=>UDe,content_3913_10620:()=>gLp,content_3913_10622:()=>MLp,content_3913_10624:()=>wLp,content_3913_10626:()=>xLp,content_3913_10628:()=>LLp,content_3913_10630:()=>kLp,content_3913_10632:()=>ILp,content_3913_10634:()=>SLp,content_3913_10636:()=>GLp,content_3913_10638:()=>FLp,content_3913_1064:()=>qDe,content_3913_10640:()=>jLp,content_3913_10642:()=>QLp,content_3913_10644:()=>JLp,content_3913_10646:()=>nbp,content_3913_10648:()=>pbp,content_3913_10650:()=>cbp,content_3913_10652:()=>lbp,content_3913_10654:()=>ybp,content_3913_10656:()=>gbp,content_3913_10658:()=>Mbp,content_3913_1066:()=>YDe,content_3913_10660:()=>wbp,content_3913_10662:()=>xbp,content_3913_10664:()=>Lbp,content_3913_10666:()=>kbp,content_3913_10668:()=>Ibp,content_3913_10670:()=>Sbp,content_3913_10672:()=>Gbp,content_3913_10674:()=>Fbp,content_3913_10676:()=>jbp,content_3913_10678:()=>Qbp,content_3913_1068:()=>KDe,content_3913_10680:()=>Jbp,content_3913_10682:()=>nNp,content_3913_10684:()=>pNp,content_3913_10686:()=>cNp,content_3913_10688:()=>lNp,content_3913_10690:()=>yNp,content_3913_10692:()=>gNp,content_3913_10694:()=>MNp,content_3913_10696:()=>wNp,content_3913_10698:()=>xNp,content_3913_1070:()=>eMe,content_3913_10700:()=>LNp,content_3913_10702:()=>kNp,content_3913_10704:()=>INp,content_3913_10706:()=>SNp,content_3913_10708:()=>GNp,content_3913_10710:()=>FNp,content_3913_10712:()=>jNp,content_3913_10714:()=>QNp,content_3913_10716:()=>JNp,content_3913_10718:()=>nkp,content_3913_1072:()=>oMe,content_3913_10720:()=>pkp,content_3913_10722:()=>ckp,content_3913_10724:()=>lkp,content_3913_10726:()=>ykp,content_3913_10728:()=>gkp,content_3913_10730:()=>Mkp,content_3913_10732:()=>wkp,content_3913_10734:()=>xkp,content_3913_10736:()=>Lkp,content_3913_10738:()=>kkp,content_3913_1074:()=>sMe,content_3913_10740:()=>Ikp,content_3913_10742:()=>Skp,content_3913_10744:()=>Gkp,content_3913_10746:()=>Fkp,content_3913_10748:()=>jkp,content_3913_10750:()=>Qkp,content_3913_10752:()=>Jkp,content_3913_10754:()=>nzp,content_3913_10756:()=>pzp,content_3913_10758:()=>czp,content_3913_1076:()=>iMe,content_3913_10760:()=>lzp,content_3913_10762:()=>yzp,content_3913_10764:()=>gzp,content_3913_10766:()=>Mzp,content_3913_10768:()=>wzp,content_3913_10770:()=>xzp,content_3913_10772:()=>Lzp,content_3913_10774:()=>kzp,content_3913_10776:()=>Izp,content_3913_10778:()=>Szp,content_3913_1078:()=>mMe,content_3913_10780:()=>Gzp,content_3913_10782:()=>Fzp,content_3913_10784:()=>jzp,content_3913_10786:()=>Qzp,content_3913_10788:()=>Jzp,content_3913_10790:()=>nPp,content_3913_10792:()=>pPp,content_3913_10794:()=>cPp,content_3913_10796:()=>lPp,content_3913_10798:()=>yPp,content_3913_108:()=>h1,content_3913_1080:()=>hMe,content_3913_10800:()=>gPp,content_3913_10802:()=>MPp,content_3913_10804:()=>wPp,content_3913_10806:()=>xPp,content_3913_10808:()=>LPp,content_3913_10810:()=>kPp,content_3913_10812:()=>IPp,content_3913_10814:()=>SPp,content_3913_10816:()=>GPp,content_3913_10818:()=>FPp,content_3913_1082:()=>DMe,content_3913_10820:()=>jPp,content_3913_10822:()=>QPp,content_3913_10824:()=>JPp,content_3913_10826:()=>nIp,content_3913_10828:()=>pIp,content_3913_10830:()=>cIp,content_3913_10832:()=>lIp,content_3913_10834:()=>yIp,content_3913_10836:()=>gIp,content_3913_10838:()=>MIp,content_3913_1084:()=>_Me,content_3913_10840:()=>wIp,content_3913_10842:()=>xIp,content_3913_10844:()=>LIp,content_3913_10846:()=>kIp,content_3913_10848:()=>IIp,content_3913_10850:()=>SIp,content_3913_10852:()=>GIp,content_3913_10854:()=>FIp,content_3913_10856:()=>jIp,content_3913_10858:()=>QIp,content_3913_1086:()=>CMe,content_3913_10860:()=>JIp,content_3913_10862:()=>nRp,content_3913_10864:()=>pRp,content_3913_10866:()=>cRp,content_3913_10868:()=>lRp,content_3913_10870:()=>yRp,content_3913_10872:()=>gRp,content_3913_10874:()=>MRp,content_3913_10876:()=>wRp,content_3913_10878:()=>xRp,content_3913_1088:()=>vMe,content_3913_10880:()=>LRp,content_3913_10882:()=>kRp,content_3913_10884:()=>IRp,content_3913_10886:()=>SRp,content_3913_10888:()=>GRp,content_3913_10890:()=>FRp,content_3913_10892:()=>jRp,content_3913_10894:()=>QRp,content_3913_10896:()=>JRp,content_3913_10898:()=>nWp,content_3913_1090:()=>NMe,content_3913_10900:()=>pWp,content_3913_10902:()=>cWp,content_3913_10904:()=>lWp,content_3913_10906:()=>yWp,content_3913_10908:()=>gWp,content_3913_10910:()=>MWp,content_3913_10912:()=>wWp,content_3913_10914:()=>xWp,content_3913_10916:()=>LWp,content_3913_10918:()=>kWp,content_3913_1092:()=>PMe,content_3913_10920:()=>IWp,content_3913_10922:()=>SWp,content_3913_10924:()=>GWp,content_3913_10926:()=>FWp,content_3913_10928:()=>jWp,content_3913_10930:()=>QWp,content_3913_10932:()=>JWp,content_3913_10934:()=>nSp,content_3913_10936:()=>pSp,content_3913_10938:()=>cSp,content_3913_1094:()=>WMe,content_3913_10940:()=>lSp,content_3913_10942:()=>ySp,content_3913_10944:()=>gSp,content_3913_10946:()=>MSp,content_3913_10948:()=>wSp,content_3913_10950:()=>xSp,content_3913_10952:()=>LSp,content_3913_10954:()=>kSp,content_3913_10956:()=>ISp,content_3913_10958:()=>SSp,content_3913_1096:()=>EMe,content_3913_10960:()=>GSp,content_3913_10962:()=>FSp,content_3913_10964:()=>jSp,content_3913_10966:()=>QSp,content_3913_10968:()=>JSp,content_3913_10970:()=>nBp,content_3913_10972:()=>pBp,content_3913_10974:()=>cBp,content_3913_10976:()=>lBp,content_3913_10978:()=>yBp,content_3913_1098:()=>UMe,content_3913_10980:()=>gBp,content_3913_10982:()=>MBp,content_3913_10984:()=>wBp,content_3913_10986:()=>xBp,content_3913_10988:()=>LBp,content_3913_10990:()=>kBp,content_3913_10992:()=>IBp,content_3913_10994:()=>SBp,content_3913_10996:()=>GBp,content_3913_10998:()=>FBp,content_3913_110:()=>D1,content_3913_1100:()=>qMe,content_3913_11000:()=>jBp,content_3913_11002:()=>QBp,content_3913_11004:()=>JBp,content_3913_11006:()=>nEp,content_3913_11008:()=>pEp,content_3913_11010:()=>cEp,content_3913_11012:()=>lEp,content_3913_11014:()=>yEp,content_3913_11016:()=>gEp,content_3913_11018:()=>MEp,content_3913_1102:()=>YMe,content_3913_11020:()=>wEp,content_3913_11022:()=>xEp,content_3913_11024:()=>LEp,content_3913_11026:()=>kEp,content_3913_11028:()=>IEp,content_3913_11030:()=>SEp,content_3913_11032:()=>GEp,content_3913_11034:()=>FEp,content_3913_11036:()=>jEp,content_3913_11038:()=>QEp,content_3913_1104:()=>KMe,content_3913_11040:()=>JEp,content_3913_11042:()=>nGp,content_3913_11044:()=>pGp,content_3913_11046:()=>cGp,content_3913_11048:()=>lGp,content_3913_11050:()=>yGp,content_3913_11052:()=>gGp,content_3913_11054:()=>MGp,content_3913_11056:()=>wGp,content_3913_11058:()=>xGp,content_3913_1106:()=>eXe,content_3913_11060:()=>LGp,content_3913_11062:()=>kGp,content_3913_11064:()=>IGp,content_3913_11066:()=>SGp,content_3913_11068:()=>GGp,content_3913_11070:()=>FGp,content_3913_11072:()=>jGp,content_3913_11074:()=>QGp,content_3913_11076:()=>JGp,content_3913_11078:()=>nOp,content_3913_1108:()=>oXe,content_3913_11080:()=>pOp,content_3913_11082:()=>cOp,content_3913_11084:()=>lOp,content_3913_11086:()=>yOp,content_3913_11088:()=>gOp,content_3913_11090:()=>MOp,content_3913_11092:()=>wOp,content_3913_11094:()=>xOp,content_3913_11096:()=>LOp,content_3913_11098:()=>kOp,content_3913_1110:()=>sXe,content_3913_11100:()=>IOp,content_3913_11102:()=>SOp,content_3913_11104:()=>GOp,content_3913_11106:()=>FOp,content_3913_11108:()=>jOp,content_3913_11110:()=>QOp,content_3913_11112:()=>JOp,content_3913_11114:()=>nUp,content_3913_11116:()=>pUp,content_3913_11118:()=>cUp,content_3913_1112:()=>iXe,content_3913_11120:()=>lUp,content_3913_11122:()=>yUp,content_3913_11124:()=>gUp,content_3913_11126:()=>MUp,content_3913_11128:()=>wUp,content_3913_11130:()=>xUp,content_3913_11132:()=>LUp,content_3913_11134:()=>kUp,content_3913_11136:()=>IUp,content_3913_11138:()=>SUp,content_3913_1114:()=>mXe,content_3913_11140:()=>GUp,content_3913_11142:()=>FUp,content_3913_11144:()=>jUp,content_3913_11146:()=>QUp,content_3913_11148:()=>JUp,content_3913_11150:()=>nFp,content_3913_11152:()=>pFp,content_3913_11154:()=>cFp,content_3913_11156:()=>lFp,content_3913_11158:()=>yFp,content_3913_1116:()=>hXe,content_3913_11160:()=>gFp,content_3913_11162:()=>MFp,content_3913_11164:()=>wFp,content_3913_11166:()=>xFp,content_3913_11168:()=>LFp,content_3913_11170:()=>kFp,content_3913_11172:()=>IFp,content_3913_11174:()=>SFp,content_3913_11176:()=>GFp,content_3913_11178:()=>FFp,content_3913_1118:()=>DXe,content_3913_11180:()=>jFp,content_3913_11182:()=>QFp,content_3913_11184:()=>JFp,content_3913_11186:()=>nVp,content_3913_11188:()=>pVp,content_3913_11190:()=>cVp,content_3913_11192:()=>lVp,content_3913_11194:()=>yVp,content_3913_11196:()=>gVp,content_3913_11198:()=>MVp,content_3913_112:()=>_1,content_3913_1120:()=>_Xe,content_3913_11200:()=>wVp,content_3913_11202:()=>xVp,content_3913_11204:()=>LVp,content_3913_11206:()=>kVp,content_3913_11208:()=>IVp,content_3913_11210:()=>SVp,content_3913_11212:()=>GVp,content_3913_11214:()=>FVp,content_3913_11216:()=>jVp,content_3913_11218:()=>QVp,content_3913_1122:()=>CXe,content_3913_11220:()=>JVp,content_3913_11222:()=>nqp,content_3913_11224:()=>pqp,content_3913_11226:()=>cqp,content_3913_11228:()=>lqp,content_3913_11230:()=>yqp,content_3913_11232:()=>gqp,content_3913_11234:()=>Mqp,content_3913_11236:()=>wqp,content_3913_11238:()=>xqp,content_3913_1124:()=>vXe,content_3913_11240:()=>Lqp,content_3913_11242:()=>kqp,content_3913_11244:()=>Iqp,content_3913_11246:()=>Sqp,content_3913_11248:()=>Gqp,content_3913_11250:()=>Fqp,content_3913_11252:()=>jqp,content_3913_11254:()=>Qqp,content_3913_11256:()=>Jqp,content_3913_11258:()=>njp,content_3913_1126:()=>NXe,content_3913_11260:()=>pjp,content_3913_11262:()=>cjp,content_3913_11264:()=>ljp,content_3913_11266:()=>yjp,content_3913_11268:()=>gjp,content_3913_11270:()=>Mjp,content_3913_11272:()=>wjp,content_3913_11274:()=>xjp,content_3913_11276:()=>Ljp,content_3913_11278:()=>kjp,content_3913_1128:()=>PXe,content_3913_11280:()=>Ijp,content_3913_11282:()=>Sjp,content_3913_11284:()=>Gjp,content_3913_11286:()=>Fjp,content_3913_11288:()=>jjp,content_3913_11290:()=>Qjp,content_3913_11292:()=>Jjp,content_3913_11294:()=>nHp,content_3913_11296:()=>pHp,content_3913_11298:()=>cHp,content_3913_1130:()=>WXe,content_3913_11300:()=>lHp,content_3913_11302:()=>yHp,content_3913_11304:()=>gHp,content_3913_11306:()=>MHp,content_3913_11308:()=>wHp,content_3913_11310:()=>xHp,content_3913_11312:()=>LHp,content_3913_11314:()=>kHp,content_3913_11316:()=>IHp,content_3913_11318:()=>SHp,content_3913_1132:()=>EXe,content_3913_11320:()=>GHp,content_3913_11322:()=>FHp,content_3913_11324:()=>jHp,content_3913_11326:()=>QHp,content_3913_11328:()=>JHp,content_3913_11330:()=>nYp,content_3913_11332:()=>pYp,content_3913_11334:()=>cYp,content_3913_11336:()=>lYp,content_3913_11338:()=>yYp,content_3913_1134:()=>UXe,content_3913_11340:()=>gYp,content_3913_11342:()=>MYp,content_3913_11344:()=>wYp,content_3913_11346:()=>xYp,content_3913_11348:()=>LYp,content_3913_11350:()=>kYp,content_3913_11352:()=>IYp,content_3913_11354:()=>SYp,content_3913_11356:()=>GYp,content_3913_11358:()=>FYp,content_3913_1136:()=>qXe,content_3913_11360:()=>jYp,content_3913_11362:()=>QYp,content_3913_11364:()=>JYp,content_3913_11366:()=>nQp,content_3913_11368:()=>pQp,content_3913_11370:()=>cQp,content_3913_11372:()=>lQp,content_3913_11374:()=>yQp,content_3913_11376:()=>gQp,content_3913_11378:()=>MQp,content_3913_1138:()=>YXe,content_3913_11380:()=>wQp,content_3913_11382:()=>xQp,content_3913_11384:()=>LQp,content_3913_11386:()=>kQp,content_3913_11388:()=>IQp,content_3913_11390:()=>SQp,content_3913_11392:()=>GQp,content_3913_11394:()=>FQp,content_3913_11396:()=>jQp,content_3913_11398:()=>QQp,content_3913_114:()=>C1,content_3913_1140:()=>KXe,content_3913_11400:()=>JQp,content_3913_11402:()=>n$p,content_3913_11404:()=>p$p,content_3913_11406:()=>c$p,content_3913_11408:()=>l$p,content_3913_11410:()=>y$p,content_3913_11412:()=>g$p,content_3913_11414:()=>M$p,content_3913_11416:()=>w$p,content_3913_11418:()=>x$p,content_3913_1142:()=>e_e,content_3913_11420:()=>L$p,content_3913_11422:()=>k$p,content_3913_11424:()=>I$p,content_3913_11426:()=>S$p,content_3913_11428:()=>G$p,content_3913_11430:()=>F$p,content_3913_11432:()=>j$p,content_3913_11434:()=>Q$p,content_3913_11436:()=>J$p,content_3913_11438:()=>nKp,content_3913_1144:()=>o_e,content_3913_11440:()=>pKp,content_3913_11442:()=>cKp,content_3913_11444:()=>lKp,content_3913_11446:()=>yKp,content_3913_11448:()=>gKp,content_3913_11450:()=>MKp,content_3913_11452:()=>wKp,content_3913_11454:()=>xKp,content_3913_11456:()=>LKp,content_3913_11458:()=>kKp,content_3913_1146:()=>s_e,content_3913_11460:()=>IKp,content_3913_11462:()=>SKp,content_3913_11464:()=>GKp,content_3913_11466:()=>FKp,content_3913_11468:()=>jKp,content_3913_11470:()=>QKp,content_3913_11472:()=>JKp,content_3913_11474:()=>nJp,content_3913_11476:()=>pJp,content_3913_11478:()=>cJp,content_3913_1148:()=>i_e,content_3913_11480:()=>lJp,content_3913_11482:()=>yJp,content_3913_11484:()=>gJp,content_3913_11486:()=>MJp,content_3913_11488:()=>wJp,content_3913_11490:()=>xJp,content_3913_11492:()=>LJp,content_3913_11494:()=>kJp,content_3913_11496:()=>IJp,content_3913_11498:()=>SJp,content_3913_1150:()=>m_e,content_3913_11500:()=>GJp,content_3913_11502:()=>FJp,content_3913_11504:()=>jJp,content_3913_11506:()=>QJp,content_3913_11508:()=>JJp,content_3913_11510:()=>nZp,content_3913_11512:()=>pZp,content_3913_11514:()=>cZp,content_3913_11516:()=>lZp,content_3913_11518:()=>yZp,content_3913_1152:()=>h_e,content_3913_11520:()=>gZp,content_3913_11522:()=>MZp,content_3913_11524:()=>wZp,content_3913_11526:()=>xZp,content_3913_11528:()=>LZp,content_3913_11530:()=>kZp,content_3913_11532:()=>IZp,content_3913_11534:()=>SZp,content_3913_11536:()=>GZp,content_3913_11538:()=>FZp,content_3913_1154:()=>D_e,content_3913_11540:()=>jZp,content_3913_11542:()=>QZp,content_3913_11544:()=>JZp,content_3913_11546:()=>n0p,content_3913_11548:()=>p0p,content_3913_11550:()=>c0p,content_3913_11552:()=>l0p,content_3913_11554:()=>y0p,content_3913_11556:()=>g0p,content_3913_11558:()=>M0p,content_3913_1156:()=>__e,content_3913_11560:()=>w0p,content_3913_11562:()=>x0p,content_3913_11564:()=>L0p,content_3913_11566:()=>k0p,content_3913_11568:()=>I0p,content_3913_11570:()=>S0p,content_3913_11572:()=>G0p,content_3913_11574:()=>F0p,content_3913_11576:()=>j0p,content_3913_11578:()=>Q0p,content_3913_1158:()=>C_e,content_3913_11580:()=>J0p,content_3913_11582:()=>n3p,content_3913_11584:()=>p3p,content_3913_11586:()=>c3p,content_3913_11588:()=>l3p,content_3913_11590:()=>y3p,content_3913_11592:()=>g3p,content_3913_11594:()=>M3p,content_3913_11596:()=>w3p,content_3913_11598:()=>x3p,content_3913_116:()=>v1,content_3913_1160:()=>v_e,content_3913_11600:()=>L3p,content_3913_11602:()=>k3p,content_3913_11604:()=>I3p,content_3913_11606:()=>S3p,content_3913_11608:()=>G3p,content_3913_11610:()=>F3p,content_3913_11612:()=>j3p,content_3913_11614:()=>Q3p,content_3913_11616:()=>J3p,content_3913_11618:()=>n1p,content_3913_1162:()=>N_e,content_3913_11620:()=>p1p,content_3913_11622:()=>c1p,content_3913_11624:()=>l1p,content_3913_11626:()=>y1p,content_3913_11628:()=>g1p,content_3913_11630:()=>M1p,content_3913_11632:()=>w1p,content_3913_11634:()=>x1p,content_3913_11636:()=>L1p,content_3913_11638:()=>k1p,content_3913_1164:()=>P_e,content_3913_11640:()=>I1p,content_3913_11642:()=>S1p,content_3913_11644:()=>G1p,content_3913_11646:()=>F1p,content_3913_11648:()=>j1p,content_3913_11650:()=>Q1p,content_3913_11652:()=>J1p,content_3913_11654:()=>n9p,content_3913_11656:()=>p9p,content_3913_11658:()=>c9p,content_3913_1166:()=>W_e,content_3913_11660:()=>l9p,content_3913_11662:()=>y9p,content_3913_11664:()=>g9p,content_3913_11666:()=>M9p,content_3913_11668:()=>w9p,content_3913_11670:()=>x9p,content_3913_11672:()=>L9p,content_3913_11674:()=>k9p,content_3913_11676:()=>I9p,content_3913_11678:()=>S9p,content_3913_1168:()=>E_e,content_3913_11680:()=>G9p,content_3913_11682:()=>F9p,content_3913_11684:()=>j9p,content_3913_11686:()=>Q9p,content_3913_11688:()=>J9p,content_3913_11690:()=>n2p,content_3913_11692:()=>p2p,content_3913_11694:()=>c2p,content_3913_11696:()=>l2p,content_3913_11698:()=>y2p,content_3913_1170:()=>U_e,content_3913_11700:()=>g2p,content_3913_11702:()=>M2p,content_3913_11704:()=>w2p,content_3913_11706:()=>x2p,content_3913_11708:()=>L2p,content_3913_11710:()=>k2p,content_3913_11712:()=>I2p,content_3913_11714:()=>S2p,content_3913_11716:()=>G2p,content_3913_11718:()=>F2p,content_3913_1172:()=>q_e,content_3913_11720:()=>j2p,content_3913_11722:()=>Q2p,content_3913_11724:()=>J2p,content_3913_11726:()=>n4p,content_3913_11728:()=>p4p,content_3913_11730:()=>c4p,content_3913_11732:()=>l4p,content_3913_11734:()=>y4p,content_3913_11736:()=>g4p,content_3913_11738:()=>M4p,content_3913_1174:()=>Y_e,content_3913_11740:()=>w4p,content_3913_11742:()=>x4p,content_3913_11744:()=>L4p,content_3913_11746:()=>k4p,content_3913_11748:()=>I4p,content_3913_11750:()=>S4p,content_3913_11752:()=>G4p,content_3913_11754:()=>F4p,content_3913_11756:()=>j4p,content_3913_11758:()=>Q4p,content_3913_1176:()=>K_e,content_3913_11760:()=>J4p,content_3913_11762:()=>n6p,content_3913_11764:()=>p6p,content_3913_11766:()=>c6p,content_3913_11768:()=>l6p,content_3913_11770:()=>y6p,content_3913_11772:()=>g6p,content_3913_11774:()=>M6p,content_3913_11776:()=>w6p,content_3913_11778:()=>x6p,content_3913_1178:()=>ewe,content_3913_11780:()=>L6p,content_3913_11782:()=>k6p,content_3913_11784:()=>I6p,content_3913_11786:()=>S6p,content_3913_11788:()=>G6p,content_3913_11790:()=>F6p,content_3913_11792:()=>j6p,content_3913_11794:()=>Q6p,content_3913_11796:()=>J6p,content_3913_11798:()=>n8p,content_3913_118:()=>N1,content_3913_1180:()=>owe,content_3913_11800:()=>p8p,content_3913_11802:()=>c8p,content_3913_11804:()=>l8p,content_3913_11806:()=>y8p,content_3913_11808:()=>g8p,content_3913_11810:()=>M8p,content_3913_11812:()=>w8p,content_3913_11814:()=>x8p,content_3913_11816:()=>L8p,content_3913_11818:()=>k8p,content_3913_1182:()=>swe,content_3913_11820:()=>I8p,content_3913_11822:()=>S8p,content_3913_11824:()=>G8p,content_3913_11826:()=>F8p,content_3913_11828:()=>j8p,content_3913_11830:()=>Q8p,content_3913_11832:()=>J8p,content_3913_11834:()=>n5p,content_3913_11836:()=>p5p,content_3913_11838:()=>c5p,content_3913_1184:()=>iwe,content_3913_11840:()=>l5p,content_3913_11842:()=>y5p,content_3913_11844:()=>g5p,content_3913_11846:()=>M5p,content_3913_11848:()=>w5p,content_3913_11850:()=>x5p,content_3913_11852:()=>L5p,content_3913_11854:()=>k5p,content_3913_11856:()=>I5p,content_3913_11858:()=>S5p,content_3913_1186:()=>mwe,content_3913_11860:()=>G5p,content_3913_11862:()=>F5p,content_3913_11864:()=>j5p,content_3913_11866:()=>Q5p,content_3913_11868:()=>J5p,content_3913_11870:()=>n7p,content_3913_11872:()=>p7p,content_3913_11874:()=>c7p,content_3913_11876:()=>l7p,content_3913_11878:()=>y7p,content_3913_1188:()=>hwe,content_3913_11880:()=>g7p,content_3913_11882:()=>M7p,content_3913_11884:()=>w7p,content_3913_11886:()=>x7p,content_3913_11888:()=>L7p,content_3913_11890:()=>k7p,content_3913_11892:()=>I7p,content_3913_11894:()=>S7p,content_3913_11896:()=>G7p,content_3913_11898:()=>F7p,content_3913_1190:()=>Dwe,content_3913_11900:()=>j7p,content_3913_11902:()=>Q7p,content_3913_11904:()=>J7p,content_3913_11906:()=>ner,content_3913_11908:()=>per,content_3913_11910:()=>cer,content_3913_11912:()=>ler,content_3913_11914:()=>yer,content_3913_11916:()=>ger,content_3913_11918:()=>Mer,content_3913_1192:()=>_we,content_3913_11920:()=>wer,content_3913_11922:()=>xer,content_3913_11924:()=>Ler,content_3913_11926:()=>ker,content_3913_11928:()=>Ier,content_3913_11930:()=>Ser,content_3913_11932:()=>Ger,content_3913_11934:()=>Fer,content_3913_11936:()=>jer,content_3913_11938:()=>Qer,content_3913_1194:()=>Cwe,content_3913_11940:()=>Jer,content_3913_11942:()=>nnr,content_3913_11944:()=>pnr,content_3913_11946:()=>cnr,content_3913_11948:()=>lnr,content_3913_11950:()=>ynr,content_3913_11952:()=>gnr,content_3913_11954:()=>Mnr,content_3913_11956:()=>wnr,content_3913_11958:()=>xnr,content_3913_1196:()=>vwe,content_3913_11960:()=>Lnr,content_3913_11962:()=>knr,content_3913_11964:()=>Inr,content_3913_11966:()=>Snr,content_3913_11968:()=>Gnr,content_3913_11970:()=>Fnr,content_3913_11972:()=>jnr,content_3913_11974:()=>Qnr,content_3913_11976:()=>Jnr,content_3913_11978:()=>ntr,content_3913_1198:()=>Nwe,content_3913_11980:()=>ptr,content_3913_11982:()=>ctr,content_3913_11984:()=>ltr,content_3913_11986:()=>ytr,content_3913_11988:()=>gtr,content_3913_11990:()=>Mtr,content_3913_11992:()=>wtr,content_3913_11994:()=>xtr,content_3913_11996:()=>Ltr,content_3913_11998:()=>ktr,content_3913_12:()=>PZ,content_3913_120:()=>P1,content_3913_1200:()=>Pwe,content_3913_12000:()=>Itr,content_3913_12002:()=>Str,content_3913_12004:()=>Gtr,content_3913_12006:()=>Ftr,content_3913_12008:()=>jtr,content_3913_12010:()=>Qtr,content_3913_12012:()=>Jtr,content_3913_12014:()=>nor,content_3913_12016:()=>por,content_3913_12018:()=>cor,content_3913_1202:()=>Wwe,content_3913_12020:()=>lor,content_3913_12022:()=>yor,content_3913_12024:()=>gor,content_3913_12026:()=>Xor,content_3913_12028:()=>Tor,content_3913_12030:()=>Aor,content_3913_12032:()=>bor,content_3913_12034:()=>zor,content_3913_12036:()=>Ror,content_3913_12038:()=>Bor,content_3913_1204:()=>Ewe,content_3913_12040:()=>Oor,content_3913_12042:()=>Vor,content_3913_12044:()=>Hor,content_3913_12046:()=>$or,content_3913_12048:()=>Zor,content_3913_12050:()=>tpr,content_3913_12052:()=>rpr,content_3913_12054:()=>apr,content_3913_12056:()=>upr,content_3913_12058:()=>dpr,content_3913_1206:()=>Uwe,content_3913_12060:()=>fpr,content_3913_12062:()=>Xpr,content_3913_12064:()=>Tpr,content_3913_12066:()=>Apr,content_3913_12068:()=>bpr,content_3913_12070:()=>zpr,content_3913_12072:()=>Rpr,content_3913_12074:()=>Bpr,content_3913_12076:()=>Opr,content_3913_12078:()=>Vpr,content_3913_1208:()=>qwe,content_3913_12080:()=>Hpr,content_3913_12082:()=>$pr,content_3913_12084:()=>Zpr,content_3913_12086:()=>trr,content_3913_12088:()=>rrr,content_3913_12090:()=>arr,content_3913_12092:()=>urr,content_3913_12094:()=>drr,content_3913_12096:()=>frr,content_3913_12098:()=>Xrr,content_3913_1210:()=>Ywe,content_3913_12100:()=>Trr,content_3913_12102:()=>Arr,content_3913_12104:()=>brr,content_3913_12106:()=>zrr,content_3913_12108:()=>Rrr,content_3913_12110:()=>Brr,content_3913_12112:()=>Orr,content_3913_12114:()=>Vrr,content_3913_12116:()=>Hrr,content_3913_12118:()=>$rr,content_3913_1212:()=>Kwe,content_3913_12120:()=>Zrr,content_3913_12122:()=>tsr,content_3913_12124:()=>rsr,content_3913_12126:()=>asr,content_3913_12128:()=>usr,content_3913_12130:()=>dsr,content_3913_12132:()=>fsr,content_3913_12134:()=>Xsr,content_3913_12136:()=>Tsr,content_3913_12138:()=>Asr,content_3913_1214:()=>eTe,content_3913_12140:()=>bsr,content_3913_12142:()=>zsr,content_3913_12144:()=>Rsr,content_3913_12146:()=>Bsr,content_3913_12148:()=>Osr,content_3913_12150:()=>Vsr,content_3913_12152:()=>Hsr,content_3913_12154:()=>$sr,content_3913_12156:()=>Zsr,content_3913_12158:()=>tcr,content_3913_1216:()=>oTe,content_3913_12160:()=>rcr,content_3913_12162:()=>acr,content_3913_12164:()=>ucr,content_3913_12166:()=>dcr,content_3913_12168:()=>fcr,content_3913_12170:()=>Xcr,content_3913_12172:()=>Tcr,content_3913_12174:()=>Acr,content_3913_12176:()=>bcr,content_3913_12178:()=>zcr,content_3913_1218:()=>sTe,content_3913_12180:()=>Rcr,content_3913_12182:()=>Bcr,content_3913_12184:()=>Ocr,content_3913_12186:()=>Vcr,content_3913_12188:()=>Hcr,content_3913_12190:()=>$cr,content_3913_12192:()=>Zcr,content_3913_12194:()=>tar,content_3913_12196:()=>rar,content_3913_12198:()=>aar,content_3913_122:()=>W1,content_3913_1220:()=>iTe,content_3913_12200:()=>uar,content_3913_12202:()=>dar,content_3913_12204:()=>far,content_3913_12206:()=>Xar,content_3913_12208:()=>Tar,content_3913_12210:()=>Aar,content_3913_12212:()=>Nar,content_3913_12214:()=>Par,content_3913_12216:()=>War,content_3913_12218:()=>Ear,content_3913_1222:()=>mTe,content_3913_12220:()=>Uar,content_3913_12222:()=>qar,content_3913_12224:()=>Yar,content_3913_12226:()=>Kar,content_3913_12228:()=>eir,content_3913_12230:()=>oir,content_3913_12232:()=>sir,content_3913_12234:()=>iir,content_3913_12236:()=>mir,content_3913_12238:()=>hir,content_3913_1224:()=>hTe,content_3913_12240:()=>Dir,content_3913_12242:()=>_ir,content_3913_12244:()=>Cir,content_3913_12246:()=>vir,content_3913_12248:()=>Nir,content_3913_12250:()=>Pir,content_3913_12252:()=>Wir,content_3913_12254:()=>Eir,content_3913_12256:()=>Uir,content_3913_12258:()=>qir,content_3913_1226:()=>DTe,content_3913_12260:()=>Yir,content_3913_12262:()=>Kir,content_3913_12264:()=>elr,content_3913_12266:()=>olr,content_3913_12268:()=>slr,content_3913_12270:()=>ilr,content_3913_12272:()=>mlr,content_3913_12274:()=>hlr,content_3913_12276:()=>Dlr,content_3913_12278:()=>_lr,content_3913_1228:()=>_Te,content_3913_12280:()=>Clr,content_3913_12282:()=>vlr,content_3913_12284:()=>Nlr,content_3913_12286:()=>Plr,content_3913_12288:()=>Wlr,content_3913_12290:()=>Elr,content_3913_12292:()=>Ulr,content_3913_12294:()=>qlr,content_3913_12296:()=>Ylr,content_3913_12298:()=>Klr,content_3913_1230:()=>CTe,content_3913_12300:()=>eur,content_3913_12302:()=>our,content_3913_12304:()=>sur,content_3913_12306:()=>iur,content_3913_12308:()=>mur,content_3913_12310:()=>hur,content_3913_12312:()=>Dur,content_3913_12314:()=>_ur,content_3913_12316:()=>Cur,content_3913_12318:()=>vur,content_3913_1232:()=>vTe,content_3913_12320:()=>Nur,content_3913_12322:()=>Pur,content_3913_12324:()=>Wur,content_3913_12326:()=>Eur,content_3913_12328:()=>Uur,content_3913_12330:()=>qur,content_3913_12332:()=>Yur,content_3913_12334:()=>Kur,content_3913_12336:()=>emr,content_3913_12338:()=>omr,content_3913_1234:()=>NTe,content_3913_12340:()=>smr,content_3913_12342:()=>imr,content_3913_12344:()=>mmr,content_3913_12346:()=>hmr,content_3913_12348:()=>Dmr,content_3913_12350:()=>_mr,content_3913_12352:()=>Cmr,content_3913_12354:()=>vmr,content_3913_12356:()=>Nmr,content_3913_12358:()=>Pmr,content_3913_1236:()=>PTe,content_3913_12360:()=>Wmr,content_3913_12362:()=>Emr,content_3913_12364:()=>Umr,content_3913_12366:()=>qmr,content_3913_12368:()=>Ymr,content_3913_12370:()=>Kmr,content_3913_12372:()=>eyr,content_3913_12374:()=>oyr,content_3913_12376:()=>syr,content_3913_12378:()=>iyr,content_3913_1238:()=>WTe,content_3913_12380:()=>myr,content_3913_12382:()=>hyr,content_3913_12384:()=>Dyr,content_3913_12386:()=>_yr,content_3913_12388:()=>Cyr,content_3913_12390:()=>vyr,content_3913_12392:()=>Nyr,content_3913_12394:()=>Pyr,content_3913_12396:()=>Wyr,content_3913_12398:()=>Eyr,content_3913_124:()=>E1,content_3913_1240:()=>ETe,content_3913_12400:()=>Uyr,content_3913_12402:()=>qyr,content_3913_12404:()=>Yyr,content_3913_12406:()=>Kyr,content_3913_12408:()=>edr,content_3913_12410:()=>odr,content_3913_12412:()=>sdr,content_3913_12414:()=>idr,content_3913_12416:()=>mdr,content_3913_12418:()=>hdr,content_3913_1242:()=>UTe,content_3913_12420:()=>Ddr,content_3913_12422:()=>_dr,content_3913_12424:()=>Cdr,content_3913_12426:()=>vdr,content_3913_12428:()=>Ndr,content_3913_12430:()=>Pdr,content_3913_12432:()=>Wdr,content_3913_12434:()=>Edr,content_3913_12436:()=>Udr,content_3913_12438:()=>qdr,content_3913_1244:()=>qTe,content_3913_12440:()=>Ydr,content_3913_12442:()=>Kdr,content_3913_12444:()=>ehr,content_3913_12446:()=>ohr,content_3913_12448:()=>shr,content_3913_12450:()=>ihr,content_3913_12452:()=>mhr,content_3913_12454:()=>hhr,content_3913_12456:()=>Dhr,content_3913_12458:()=>_hr,content_3913_1246:()=>YTe,content_3913_12460:()=>Chr,content_3913_12462:()=>vhr,content_3913_12464:()=>Nhr,content_3913_12466:()=>Phr,content_3913_12468:()=>Whr,content_3913_12470:()=>Ehr,content_3913_12472:()=>Uhr,content_3913_12474:()=>qhr,content_3913_12476:()=>Yhr,content_3913_12478:()=>Khr,content_3913_1248:()=>KTe,content_3913_12480:()=>egr,content_3913_12482:()=>ogr,content_3913_12484:()=>sgr,content_3913_12486:()=>igr,content_3913_12488:()=>mgr,content_3913_12490:()=>hgr,content_3913_12492:()=>Dgr,content_3913_12494:()=>_gr,content_3913_12496:()=>Cgr,content_3913_12498:()=>vgr,content_3913_1250:()=>eCe,content_3913_12500:()=>Ngr,content_3913_12502:()=>Pgr,content_3913_12504:()=>Wgr,content_3913_12506:()=>Egr,content_3913_12508:()=>Ugr,content_3913_12510:()=>qgr,content_3913_12512:()=>Ygr,content_3913_12514:()=>Kgr,content_3913_12516:()=>efr,content_3913_12518:()=>ofr,content_3913_1252:()=>oCe,content_3913_12520:()=>sfr,content_3913_12522:()=>ifr,content_3913_12524:()=>mfr,content_3913_12526:()=>hfr,content_3913_12528:()=>Dfr,content_3913_12530:()=>_fr,content_3913_12532:()=>Cfr,content_3913_12534:()=>vfr,content_3913_12536:()=>Nfr,content_3913_12538:()=>Pfr,content_3913_1254:()=>sCe,content_3913_12540:()=>Wfr,content_3913_12542:()=>Efr,content_3913_12544:()=>Ufr,content_3913_12546:()=>qfr,content_3913_12548:()=>Yfr,content_3913_12550:()=>Kfr,content_3913_12552:()=>eDr,content_3913_12554:()=>oDr,content_3913_12556:()=>sDr,content_3913_12558:()=>iDr,content_3913_1256:()=>iCe,content_3913_12560:()=>mDr,content_3913_12562:()=>hDr,content_3913_12564:()=>DDr,content_3913_12566:()=>_Dr,content_3913_12568:()=>CDr,content_3913_12570:()=>vDr,content_3913_12572:()=>NDr,content_3913_12574:()=>PDr,content_3913_12576:()=>WDr,content_3913_12578:()=>EDr,content_3913_1258:()=>mCe,content_3913_12580:()=>UDr,content_3913_12582:()=>qDr,content_3913_12584:()=>YDr,content_3913_12586:()=>KDr,content_3913_12588:()=>eMr,content_3913_12590:()=>oMr,content_3913_12592:()=>sMr,content_3913_12594:()=>iMr,content_3913_12596:()=>mMr,content_3913_12598:()=>hMr,content_3913_126:()=>U1,content_3913_1260:()=>hCe,content_3913_12600:()=>DMr,content_3913_12602:()=>_Mr,content_3913_12604:()=>CMr,content_3913_12606:()=>vMr,content_3913_12608:()=>NMr,content_3913_12610:()=>PMr,content_3913_12612:()=>WMr,content_3913_12614:()=>EMr,content_3913_12616:()=>UMr,content_3913_12618:()=>qMr,content_3913_1262:()=>DCe,content_3913_12620:()=>YMr,content_3913_12622:()=>KMr,content_3913_12624:()=>eXr,content_3913_12626:()=>oXr,content_3913_12628:()=>sXr,content_3913_12630:()=>iXr,content_3913_12632:()=>mXr,content_3913_12634:()=>hXr,content_3913_12636:()=>DXr,content_3913_12638:()=>_Xr,content_3913_1264:()=>_Ce,content_3913_12640:()=>CXr,content_3913_12642:()=>vXr,content_3913_12644:()=>NXr,content_3913_12646:()=>PXr,content_3913_12648:()=>WXr,content_3913_12650:()=>EXr,content_3913_12652:()=>UXr,content_3913_12654:()=>qXr,content_3913_12656:()=>YXr,content_3913_12658:()=>KXr,content_3913_1266:()=>CCe,content_3913_12660:()=>e_r,content_3913_12662:()=>o_r,content_3913_12664:()=>s_r,content_3913_12666:()=>i_r,content_3913_12668:()=>m_r,content_3913_12670:()=>h_r,content_3913_12672:()=>D_r,content_3913_12674:()=>__r,content_3913_12676:()=>C_r,content_3913_12678:()=>v_r,content_3913_1268:()=>vCe,content_3913_12680:()=>N_r,content_3913_12682:()=>P_r,content_3913_12684:()=>W_r,content_3913_12686:()=>E_r,content_3913_12688:()=>U_r,content_3913_12690:()=>q_r,content_3913_12692:()=>Y_r,content_3913_12694:()=>K_r,content_3913_12696:()=>ewr,content_3913_12698:()=>owr,content_3913_1270:()=>NCe,content_3913_12700:()=>swr,content_3913_12702:()=>iwr,content_3913_12704:()=>mwr,content_3913_12706:()=>hwr,content_3913_12708:()=>Dwr,content_3913_12710:()=>_wr,content_3913_12712:()=>Cwr,content_3913_12714:()=>vwr,content_3913_12716:()=>Nwr,content_3913_12718:()=>Pwr,content_3913_1272:()=>PCe,content_3913_12720:()=>Wwr,content_3913_12722:()=>Ewr,content_3913_12724:()=>Uwr,content_3913_12726:()=>qwr,content_3913_12728:()=>Ywr,content_3913_12730:()=>Kwr,content_3913_12732:()=>eTr,content_3913_12734:()=>oTr,content_3913_12736:()=>sTr,content_3913_12738:()=>iTr,content_3913_1274:()=>WCe,content_3913_12740:()=>mTr,content_3913_12742:()=>hTr,content_3913_12744:()=>DTr,content_3913_12746:()=>_Tr,content_3913_12748:()=>CTr,content_3913_12750:()=>vTr,content_3913_12752:()=>NTr,content_3913_12754:()=>PTr,content_3913_12756:()=>WTr,content_3913_12758:()=>ETr,content_3913_1276:()=>ECe,content_3913_12760:()=>UTr,content_3913_12762:()=>qTr,content_3913_12764:()=>YTr,content_3913_12766:()=>KTr,content_3913_12768:()=>eCr,content_3913_12770:()=>oCr,content_3913_12772:()=>sCr,content_3913_12774:()=>iCr,content_3913_12776:()=>mCr,content_3913_12778:()=>hCr,content_3913_1278:()=>UCe,content_3913_12780:()=>DCr,content_3913_12782:()=>_Cr,content_3913_12784:()=>CCr,content_3913_12786:()=>vCr,content_3913_12788:()=>NCr,content_3913_12790:()=>PCr,content_3913_12792:()=>WCr,content_3913_12794:()=>ECr,content_3913_12796:()=>UCr,content_3913_12798:()=>qCr,content_3913_128:()=>q1,content_3913_1280:()=>qCe,content_3913_12800:()=>YCr,content_3913_12802:()=>KCr,content_3913_12804:()=>exr,content_3913_12806:()=>oxr,content_3913_12808:()=>sxr,content_3913_12810:()=>ixr,content_3913_12812:()=>mxr,content_3913_12814:()=>hxr,content_3913_12816:()=>Dxr,content_3913_12818:()=>_xr,content_3913_1282:()=>YCe,content_3913_12820:()=>Cxr,content_3913_12822:()=>vxr,content_3913_12824:()=>Nxr,content_3913_12826:()=>Pxr,content_3913_12828:()=>Wxr,content_3913_12830:()=>Exr,content_3913_12832:()=>Uxr,content_3913_12834:()=>qxr,content_3913_12836:()=>Yxr,content_3913_12838:()=>Kxr,content_3913_1284:()=>KCe,content_3913_12840:()=>eAr,content_3913_12842:()=>oAr,content_3913_12844:()=>sAr,content_3913_12846:()=>iAr,content_3913_12848:()=>mAr,content_3913_12850:()=>hAr,content_3913_12852:()=>DAr,content_3913_12854:()=>_Ar,content_3913_12856:()=>CAr,content_3913_12858:()=>vAr,content_3913_1286:()=>exe,content_3913_12860:()=>NAr,content_3913_12862:()=>PAr,content_3913_12864:()=>WAr,content_3913_12866:()=>EAr,content_3913_12868:()=>UAr,content_3913_12870:()=>qAr,content_3913_12872:()=>YAr,content_3913_12874:()=>KAr,content_3913_12876:()=>evr,content_3913_12878:()=>ovr,content_3913_1288:()=>oxe,content_3913_12880:()=>svr,content_3913_12882:()=>ivr,content_3913_12884:()=>mvr,content_3913_12886:()=>hvr,content_3913_12888:()=>Dvr,content_3913_12890:()=>_vr,content_3913_12892:()=>Cvr,content_3913_12894:()=>vvr,content_3913_12896:()=>Nvr,content_3913_12898:()=>Pvr,content_3913_1290:()=>sxe,content_3913_12900:()=>Wvr,content_3913_12902:()=>Evr,content_3913_12904:()=>Uvr,content_3913_12906:()=>qvr,content_3913_12908:()=>Yvr,content_3913_12910:()=>Kvr,content_3913_12912:()=>eLr,content_3913_12914:()=>oLr,content_3913_12916:()=>sLr,content_3913_12918:()=>iLr,content_3913_1292:()=>ixe,content_3913_12920:()=>mLr,content_3913_12922:()=>hLr,content_3913_12924:()=>DLr,content_3913_12926:()=>_Lr,content_3913_12928:()=>CLr,content_3913_12930:()=>vLr,content_3913_12932:()=>NLr,content_3913_12934:()=>PLr,content_3913_12936:()=>WLr,content_3913_12938:()=>ELr,content_3913_1294:()=>mxe,content_3913_12940:()=>ULr,content_3913_12942:()=>qLr,content_3913_12944:()=>YLr,content_3913_12946:()=>KLr,content_3913_12948:()=>ebr,content_3913_12950:()=>obr,content_3913_12952:()=>sbr,content_3913_12954:()=>ibr,content_3913_12956:()=>mbr,content_3913_12958:()=>hbr,content_3913_1296:()=>hxe,content_3913_12960:()=>Dbr,content_3913_12962:()=>_br,content_3913_12964:()=>Cbr,content_3913_12966:()=>vbr,content_3913_12968:()=>Nbr,content_3913_12970:()=>Pbr,content_3913_12972:()=>Wbr,content_3913_12974:()=>Ebr,content_3913_12976:()=>Ubr,content_3913_12978:()=>qbr,content_3913_1298:()=>Dxe,content_3913_12980:()=>Ybr,content_3913_12982:()=>Kbr,content_3913_12984:()=>eNr,content_3913_12986:()=>oNr,content_3913_12988:()=>sNr,content_3913_12990:()=>iNr,content_3913_12992:()=>mNr,content_3913_12994:()=>hNr,content_3913_12996:()=>DNr,content_3913_12998:()=>_Nr,content_3913_130:()=>Y1,content_3913_1300:()=>_xe,content_3913_13000:()=>CNr,content_3913_13002:()=>vNr,content_3913_13004:()=>NNr,content_3913_13006:()=>PNr,content_3913_13008:()=>WNr,content_3913_13010:()=>ENr,content_3913_13012:()=>UNr,content_3913_13014:()=>qNr,content_3913_13016:()=>YNr,content_3913_13018:()=>KNr,content_3913_1302:()=>Cxe,content_3913_13020:()=>ekr,content_3913_1304:()=>vxe,content_3913_1306:()=>Nxe,content_3913_1308:()=>Pxe,content_3913_1310:()=>Wxe,content_3913_1312:()=>Exe,content_3913_1314:()=>Uxe,content_3913_1316:()=>qxe,content_3913_1318:()=>Yxe,content_3913_132:()=>K1,content_3913_1320:()=>Kxe,content_3913_1322:()=>eAe,content_3913_1324:()=>oAe,content_3913_1326:()=>sAe,content_3913_1328:()=>iAe,content_3913_1330:()=>mAe,content_3913_1332:()=>hAe,content_3913_1334:()=>DAe,content_3913_1336:()=>_Ae,content_3913_1338:()=>CAe,content_3913_134:()=>e9,content_3913_1340:()=>vAe,content_3913_1342:()=>NAe,content_3913_1344:()=>PAe,content_3913_1346:()=>WAe,content_3913_1348:()=>EAe,content_3913_1350:()=>UAe,content_3913_1352:()=>qAe,content_3913_1354:()=>YAe,content_3913_1356:()=>KAe,content_3913_1358:()=>eve,content_3913_136:()=>o9,content_3913_1360:()=>ove,content_3913_1362:()=>sve,content_3913_1364:()=>ive,content_3913_1366:()=>mve,content_3913_1368:()=>hve,content_3913_1370:()=>Dve,content_3913_1372:()=>_ve,content_3913_1374:()=>Cve,content_3913_1376:()=>vve,content_3913_1378:()=>Nve,content_3913_138:()=>s9,content_3913_1380:()=>Pve,content_3913_1382:()=>Wve,content_3913_1384:()=>Eve,content_3913_1386:()=>Uve,content_3913_1388:()=>qve,content_3913_1390:()=>Yve,content_3913_1392:()=>Kve,content_3913_1394:()=>eLe,content_3913_1396:()=>oLe,content_3913_1398:()=>sLe,content_3913_14:()=>WZ,content_3913_140:()=>i9,content_3913_1400:()=>iLe,content_3913_1402:()=>mLe,content_3913_1404:()=>hLe,content_3913_1406:()=>DLe,content_3913_1408:()=>_Le,content_3913_1410:()=>CLe,content_3913_1412:()=>vLe,content_3913_1414:()=>NLe,content_3913_1416:()=>PLe,content_3913_1418:()=>WLe,content_3913_142:()=>m9,content_3913_1420:()=>ELe,content_3913_1422:()=>ULe,content_3913_1424:()=>qLe,content_3913_1426:()=>YLe,content_3913_1428:()=>KLe,content_3913_1430:()=>ebe,content_3913_1432:()=>obe,content_3913_1434:()=>sbe,content_3913_1436:()=>ibe,content_3913_1438:()=>mbe,content_3913_144:()=>h9,content_3913_1440:()=>hbe,content_3913_1442:()=>Dbe,content_3913_1444:()=>_be,content_3913_1446:()=>Cbe,content_3913_1448:()=>vbe,content_3913_1450:()=>Nbe,content_3913_1452:()=>Pbe,content_3913_1454:()=>Wbe,content_3913_1456:()=>Ebe,content_3913_1458:()=>Ube,content_3913_146:()=>D9,content_3913_1460:()=>qbe,content_3913_1462:()=>Ybe,content_3913_1464:()=>Kbe,content_3913_1466:()=>eNe,content_3913_1468:()=>oNe,content_3913_1470:()=>sNe,content_3913_1472:()=>iNe,content_3913_1474:()=>mNe,content_3913_1476:()=>hNe,content_3913_1478:()=>DNe,content_3913_148:()=>_9,content_3913_1480:()=>_Ne,content_3913_1482:()=>CNe,content_3913_1484:()=>vNe,content_3913_1486:()=>NNe,content_3913_1488:()=>PNe,content_3913_1490:()=>WNe,content_3913_1492:()=>ENe,content_3913_1494:()=>UNe,content_3913_1496:()=>qNe,content_3913_1498:()=>YNe,content_3913_150:()=>C9,content_3913_1500:()=>KNe,content_3913_1502:()=>eke,content_3913_1504:()=>oke,content_3913_1506:()=>ske,content_3913_1508:()=>ike,content_3913_1510:()=>mke,content_3913_1512:()=>hke,content_3913_1514:()=>Dke,content_3913_1516:()=>_ke,content_3913_1518:()=>Cke,content_3913_152:()=>v9,content_3913_1520:()=>vke,content_3913_1522:()=>Nke,content_3913_1524:()=>Pke,content_3913_1526:()=>Wke,content_3913_1528:()=>Eke,content_3913_1530:()=>Uke,content_3913_1532:()=>qke,content_3913_1534:()=>Yke,content_3913_1536:()=>Kke,content_3913_1538:()=>eze,content_3913_154:()=>N9,content_3913_1540:()=>oze,content_3913_1542:()=>sze,content_3913_1544:()=>ize,content_3913_1546:()=>mze,content_3913_1548:()=>hze,content_3913_1550:()=>Dze,content_3913_1552:()=>_ze,content_3913_1554:()=>Cze,content_3913_1556:()=>vze,content_3913_1558:()=>Nze,content_3913_156:()=>P9,content_3913_1560:()=>Pze,content_3913_1562:()=>Wze,content_3913_1564:()=>Eze,content_3913_1566:()=>Uze,content_3913_1568:()=>qze,content_3913_1570:()=>Yze,content_3913_1572:()=>Kze,content_3913_1574:()=>ePe,content_3913_1576:()=>oPe,content_3913_1578:()=>sPe,content_3913_158:()=>W9,content_3913_1580:()=>iPe,content_3913_1582:()=>mPe,content_3913_1584:()=>hPe,content_3913_1586:()=>DPe,content_3913_1588:()=>_Pe,content_3913_1590:()=>CPe,content_3913_1592:()=>vPe,content_3913_1594:()=>NPe,content_3913_1596:()=>PPe,content_3913_1598:()=>WPe,content_3913_16:()=>EZ,content_3913_160:()=>E9,content_3913_1600:()=>EPe,content_3913_1602:()=>UPe,content_3913_1604:()=>qPe,content_3913_1606:()=>YPe,content_3913_1608:()=>KPe,content_3913_1610:()=>eIe,content_3913_1612:()=>oIe,content_3913_1614:()=>sIe,content_3913_1616:()=>iIe,content_3913_1618:()=>mIe,content_3913_162:()=>U9,content_3913_1620:()=>hIe,content_3913_1622:()=>DIe,content_3913_1624:()=>_Ie,content_3913_1626:()=>CIe,content_3913_1628:()=>vIe,content_3913_1630:()=>NIe,content_3913_1632:()=>PIe,content_3913_1634:()=>WIe,content_3913_1636:()=>EIe,content_3913_1638:()=>UIe,content_3913_164:()=>q9,content_3913_1640:()=>qIe,content_3913_1642:()=>YIe,content_3913_1644:()=>KIe,content_3913_1646:()=>eRe,content_3913_1648:()=>oRe,content_3913_1650:()=>sRe,content_3913_1652:()=>iRe,content_3913_1654:()=>mRe,content_3913_1656:()=>hRe,content_3913_1658:()=>DRe,content_3913_166:()=>Y9,content_3913_1660:()=>_Re,content_3913_1662:()=>CRe,content_3913_1664:()=>vRe,content_3913_1666:()=>NRe,content_3913_1668:()=>PRe,content_3913_1670:()=>WRe,content_3913_1672:()=>ERe,content_3913_1674:()=>URe,content_3913_1676:()=>qRe,content_3913_1678:()=>YRe,content_3913_168:()=>K9,content_3913_1680:()=>KRe,content_3913_1682:()=>eWe,content_3913_1684:()=>oWe,content_3913_1686:()=>sWe,content_3913_1688:()=>iWe,content_3913_1690:()=>mWe,content_3913_1692:()=>hWe,content_3913_1694:()=>DWe,content_3913_1696:()=>_We,content_3913_1698:()=>CWe,content_3913_170:()=>e2,content_3913_1700:()=>vWe,content_3913_1702:()=>NWe,content_3913_1704:()=>PWe,content_3913_1706:()=>WWe,content_3913_1708:()=>EWe,content_3913_1710:()=>UWe,content_3913_1712:()=>qWe,content_3913_1714:()=>YWe,content_3913_1716:()=>KWe,content_3913_1718:()=>eSe,content_3913_172:()=>o2,content_3913_1720:()=>oSe,content_3913_1722:()=>sSe,content_3913_1724:()=>iSe,content_3913_1726:()=>mSe,content_3913_1728:()=>hSe,content_3913_1730:()=>DSe,content_3913_1732:()=>_Se,content_3913_1734:()=>CSe,content_3913_1736:()=>vSe,content_3913_1738:()=>NSe,content_3913_174:()=>s2,content_3913_1740:()=>PSe,content_3913_1742:()=>WSe,content_3913_1744:()=>ESe,content_3913_1746:()=>USe,content_3913_1748:()=>qSe,content_3913_1750:()=>YSe,content_3913_1752:()=>KSe,content_3913_1754:()=>eBe,content_3913_1756:()=>oBe,content_3913_1758:()=>sBe,content_3913_176:()=>i2,content_3913_1760:()=>iBe,content_3913_1762:()=>mBe,content_3913_1764:()=>hBe,content_3913_1766:()=>DBe,content_3913_1768:()=>_Be,content_3913_1770:()=>CBe,content_3913_1772:()=>vBe,content_3913_1774:()=>NBe,content_3913_1776:()=>PBe,content_3913_1778:()=>WBe,content_3913_178:()=>m2,content_3913_1780:()=>EBe,content_3913_1782:()=>UBe,content_3913_1784:()=>qBe,content_3913_1786:()=>YBe,content_3913_1788:()=>KBe,content_3913_1790:()=>eEe,content_3913_1792:()=>oEe,content_3913_1794:()=>sEe,content_3913_1796:()=>iEe,content_3913_1798:()=>mEe,content_3913_18:()=>UZ,content_3913_180:()=>h2,content_3913_1800:()=>hEe,content_3913_1802:()=>DEe,content_3913_1804:()=>_Ee,content_3913_1806:()=>CEe,content_3913_1808:()=>vEe,content_3913_1810:()=>NEe,content_3913_1812:()=>PEe,content_3913_1814:()=>WEe,content_3913_1816:()=>EEe,content_3913_1818:()=>UEe,content_3913_182:()=>D2,content_3913_1820:()=>qEe,content_3913_1822:()=>YEe,content_3913_1824:()=>KEe,content_3913_1826:()=>eGe,content_3913_1828:()=>oGe,content_3913_1830:()=>sGe,content_3913_1832:()=>iGe,content_3913_1834:()=>mGe,content_3913_1836:()=>hGe,content_3913_1838:()=>DGe,content_3913_184:()=>_2,content_3913_1840:()=>_Ge,content_3913_1842:()=>CGe,content_3913_1844:()=>vGe,content_3913_1846:()=>NGe,content_3913_1848:()=>PGe,content_3913_1850:()=>WGe,content_3913_1852:()=>EGe,content_3913_1854:()=>UGe,content_3913_1856:()=>qGe,content_3913_1858:()=>YGe,content_3913_186:()=>C2,content_3913_1860:()=>KGe,content_3913_1862:()=>eOe,content_3913_1864:()=>oOe,content_3913_1866:()=>sOe,content_3913_1868:()=>iOe,content_3913_1870:()=>mOe,content_3913_1872:()=>hOe,content_3913_1874:()=>DOe,content_3913_1876:()=>_Oe,content_3913_1878:()=>COe,content_3913_188:()=>v2,content_3913_1880:()=>vOe,content_3913_1882:()=>NOe,content_3913_1884:()=>POe,content_3913_1886:()=>WOe,content_3913_1888:()=>EOe,content_3913_1890:()=>UOe,content_3913_1892:()=>qOe,content_3913_1894:()=>YOe,content_3913_1896:()=>KOe,content_3913_1898:()=>eUe,content_3913_190:()=>N2,content_3913_1900:()=>oUe,content_3913_1902:()=>sUe,content_3913_1904:()=>iUe,content_3913_1906:()=>mUe,content_3913_1908:()=>hUe,content_3913_1910:()=>DUe,content_3913_1912:()=>_Ue,content_3913_1914:()=>CUe,content_3913_1916:()=>vUe,content_3913_1918:()=>NUe,content_3913_192:()=>P2,content_3913_1920:()=>PUe,content_3913_1922:()=>WUe,content_3913_1924:()=>EUe,content_3913_1926:()=>UUe,content_3913_1928:()=>qUe,content_3913_1930:()=>YUe,content_3913_1932:()=>KUe,content_3913_1934:()=>eFe,content_3913_1936:()=>oFe,content_3913_1938:()=>sFe,content_3913_194:()=>W2,content_3913_1940:()=>iFe,content_3913_1942:()=>mFe,content_3913_1944:()=>hFe,content_3913_1946:()=>DFe,content_3913_1948:()=>_Fe,content_3913_1950:()=>CFe,content_3913_1952:()=>vFe,content_3913_1954:()=>NFe,content_3913_1956:()=>PFe,content_3913_1958:()=>WFe,content_3913_196:()=>E2,content_3913_1960:()=>EFe,content_3913_1962:()=>UFe,content_3913_1964:()=>qFe,content_3913_1966:()=>YFe,content_3913_1968:()=>KFe,content_3913_1970:()=>eVe,content_3913_1972:()=>oVe,content_3913_1974:()=>sVe,content_3913_1976:()=>iVe,content_3913_1978:()=>mVe,content_3913_198:()=>U2,content_3913_1980:()=>hVe,content_3913_1982:()=>DVe,content_3913_1984:()=>_Ve,content_3913_1986:()=>CVe,content_3913_1988:()=>vVe,content_3913_1990:()=>NVe,content_3913_1992:()=>PVe,content_3913_1994:()=>WVe,content_3913_1996:()=>EVe,content_3913_1998:()=>UVe,content_3913_2:()=>DZ,content_3913_20:()=>qZ,content_3913_200:()=>q2,content_3913_2000:()=>qVe,content_3913_2002:()=>YVe,content_3913_2004:()=>KVe,content_3913_2006:()=>eqe,content_3913_2008:()=>oqe,content_3913_2010:()=>sqe,content_3913_2012:()=>iqe,content_3913_2014:()=>mqe,content_3913_2016:()=>hqe,content_3913_2018:()=>Dqe,content_3913_202:()=>Y2,content_3913_2020:()=>_qe,content_3913_2022:()=>Cqe,content_3913_2024:()=>vqe,content_3913_2026:()=>Nqe,content_3913_2028:()=>Pqe,content_3913_2030:()=>Wqe,content_3913_2032:()=>Eqe,content_3913_2034:()=>Uqe,content_3913_2036:()=>qqe,content_3913_2038:()=>Yqe,content_3913_204:()=>K2,content_3913_2040:()=>Kqe,content_3913_2042:()=>eje,content_3913_2044:()=>oje,content_3913_2046:()=>sje,content_3913_2048:()=>ije,content_3913_2050:()=>mje,content_3913_2052:()=>hje,content_3913_2054:()=>Dje,content_3913_2056:()=>_je,content_3913_2058:()=>Cje,content_3913_206:()=>e4,content_3913_2060:()=>vje,content_3913_2062:()=>Nje,content_3913_2064:()=>Pje,content_3913_2066:()=>Wje,content_3913_2068:()=>Eje,content_3913_2070:()=>Uje,content_3913_2072:()=>qje,content_3913_2074:()=>Yje,content_3913_2076:()=>Kje,content_3913_2078:()=>eHe,content_3913_208:()=>o4,content_3913_2080:()=>oHe,content_3913_2082:()=>sHe,content_3913_2084:()=>iHe,content_3913_2086:()=>mHe,content_3913_2088:()=>hHe,content_3913_2090:()=>DHe,content_3913_2092:()=>_He,content_3913_2094:()=>CHe,content_3913_2096:()=>vHe,content_3913_2098:()=>NHe,content_3913_210:()=>s4,content_3913_2100:()=>PHe,content_3913_2102:()=>WHe,content_3913_2104:()=>EHe,content_3913_2106:()=>UHe,content_3913_2108:()=>qHe,content_3913_2110:()=>YHe,content_3913_2112:()=>KHe,content_3913_2114:()=>eYe,content_3913_2116:()=>oYe,content_3913_2118:()=>sYe,content_3913_212:()=>i4,content_3913_2120:()=>iYe,content_3913_2122:()=>mYe,content_3913_2124:()=>hYe,content_3913_2126:()=>DYe,content_3913_2128:()=>_Ye,content_3913_2130:()=>CYe,content_3913_2132:()=>vYe,content_3913_2134:()=>NYe,content_3913_2136:()=>PYe,content_3913_2138:()=>WYe,content_3913_214:()=>m4,content_3913_2140:()=>EYe,content_3913_2142:()=>UYe,content_3913_2144:()=>qYe,content_3913_2146:()=>YYe,content_3913_2148:()=>KYe,content_3913_2150:()=>eQe,content_3913_2152:()=>oQe,content_3913_2154:()=>sQe,content_3913_2156:()=>iQe,content_3913_2158:()=>mQe,content_3913_216:()=>h4,content_3913_2160:()=>hQe,content_3913_2162:()=>DQe,content_3913_2164:()=>_Qe,content_3913_2166:()=>CQe,content_3913_2168:()=>vQe,content_3913_2170:()=>NQe,content_3913_2172:()=>PQe,content_3913_2174:()=>WQe,content_3913_2176:()=>EQe,content_3913_2178:()=>UQe,content_3913_218:()=>D4,content_3913_2180:()=>qQe,content_3913_2182:()=>YQe,content_3913_2184:()=>KQe,content_3913_2186:()=>e$e,content_3913_2188:()=>o$e,content_3913_2190:()=>s$e,content_3913_2192:()=>i$e,content_3913_2194:()=>m$e,content_3913_2196:()=>h$e,content_3913_2198:()=>D$e,content_3913_22:()=>YZ,content_3913_220:()=>_4,content_3913_2200:()=>_$e,content_3913_2202:()=>C$e,content_3913_2204:()=>v$e,content_3913_2206:()=>N$e,content_3913_2208:()=>P$e,content_3913_2210:()=>W$e,content_3913_2212:()=>E$e,content_3913_2214:()=>U$e,content_3913_2216:()=>q$e,content_3913_2218:()=>Y$e,content_3913_222:()=>C4,content_3913_2220:()=>K$e,content_3913_2222:()=>eKe,content_3913_2224:()=>oKe,content_3913_2226:()=>sKe,content_3913_2228:()=>iKe,content_3913_2230:()=>mKe,content_3913_2232:()=>hKe,content_3913_2234:()=>DKe,content_3913_2236:()=>_Ke,content_3913_2238:()=>CKe,content_3913_224:()=>v4,content_3913_2240:()=>vKe,content_3913_2242:()=>NKe,content_3913_2244:()=>PKe,content_3913_2246:()=>WKe,content_3913_2248:()=>EKe,content_3913_2250:()=>UKe,content_3913_2252:()=>qKe,content_3913_2254:()=>YKe,content_3913_2256:()=>KKe,content_3913_2258:()=>eJe,content_3913_226:()=>N4,content_3913_2260:()=>oJe,content_3913_2262:()=>sJe,content_3913_2264:()=>iJe,content_3913_2266:()=>mJe,content_3913_2268:()=>hJe,content_3913_2270:()=>DJe,content_3913_2272:()=>_Je,content_3913_2274:()=>CJe,content_3913_2276:()=>vJe,content_3913_2278:()=>NJe,content_3913_228:()=>P4,content_3913_2280:()=>PJe,content_3913_2282:()=>WJe,content_3913_2284:()=>EJe,content_3913_2286:()=>UJe,content_3913_2288:()=>qJe,content_3913_2290:()=>YJe,content_3913_2292:()=>KJe,content_3913_2294:()=>eZe,content_3913_2296:()=>oZe,content_3913_2298:()=>sZe,content_3913_230:()=>W4,content_3913_2300:()=>iZe,content_3913_2302:()=>mZe,content_3913_2304:()=>hZe,content_3913_2306:()=>DZe,content_3913_2308:()=>_Ze,content_3913_2310:()=>CZe,content_3913_2312:()=>vZe,content_3913_2314:()=>NZe,content_3913_2316:()=>PZe,content_3913_2318:()=>WZe,content_3913_232:()=>E4,content_3913_2320:()=>EZe,content_3913_2322:()=>UZe,content_3913_2324:()=>qZe,content_3913_2326:()=>YZe,content_3913_2328:()=>KZe,content_3913_2330:()=>e0e,content_3913_2332:()=>o0e,content_3913_2334:()=>s0e,content_3913_2336:()=>i0e,content_3913_2338:()=>m0e,content_3913_234:()=>U4,content_3913_2340:()=>h0e,content_3913_2342:()=>D0e,content_3913_2344:()=>_0e,content_3913_2346:()=>C0e,content_3913_2348:()=>v0e,content_3913_2350:()=>N0e,content_3913_2352:()=>P0e,content_3913_2354:()=>W0e,content_3913_2356:()=>E0e,content_3913_2358:()=>U0e,content_3913_236:()=>q4,content_3913_2360:()=>q0e,content_3913_2362:()=>Y0e,content_3913_2364:()=>K0e,content_3913_2366:()=>e3e,content_3913_2368:()=>o3e,content_3913_2370:()=>s3e,content_3913_2372:()=>i3e,content_3913_2374:()=>m3e,content_3913_2376:()=>h3e,content_3913_2378:()=>D3e,content_3913_238:()=>Y4,content_3913_2380:()=>_3e,content_3913_2382:()=>C3e,content_3913_2384:()=>v3e,content_3913_2386:()=>N3e,content_3913_2388:()=>P3e,content_3913_2390:()=>W3e,content_3913_2392:()=>E3e,content_3913_2394:()=>U3e,content_3913_2396:()=>q3e,content_3913_2398:()=>Y3e,content_3913_24:()=>KZ,content_3913_240:()=>K4,content_3913_2400:()=>K3e,content_3913_2402:()=>e1e,content_3913_2404:()=>o1e,content_3913_2406:()=>s1e,content_3913_2408:()=>i1e,content_3913_2410:()=>m1e,content_3913_2412:()=>h1e,content_3913_2414:()=>D1e,content_3913_2416:()=>_1e,content_3913_2418:()=>C1e,content_3913_242:()=>e6,content_3913_2420:()=>v1e,content_3913_2422:()=>N1e,content_3913_2424:()=>P1e,content_3913_2426:()=>W1e,content_3913_2428:()=>E1e,content_3913_2430:()=>U1e,content_3913_2432:()=>q1e,content_3913_2434:()=>Y1e,content_3913_2436:()=>K1e,content_3913_2438:()=>e9e,content_3913_244:()=>o6,content_3913_2440:()=>o9e,content_3913_2442:()=>s9e,content_3913_2444:()=>i9e,content_3913_2446:()=>m9e,content_3913_2448:()=>h9e,content_3913_2450:()=>D9e,content_3913_2452:()=>_9e,content_3913_2454:()=>C9e,content_3913_2456:()=>v9e,content_3913_2458:()=>N9e,content_3913_246:()=>s6,content_3913_2460:()=>P9e,content_3913_2462:()=>W9e,content_3913_2464:()=>E9e,content_3913_2466:()=>U9e,content_3913_2468:()=>q9e,content_3913_2470:()=>Y9e,content_3913_2472:()=>K9e,content_3913_2474:()=>e2e,content_3913_2476:()=>o2e,content_3913_2478:()=>s2e,content_3913_248:()=>i6,content_3913_2480:()=>i2e,content_3913_2482:()=>m2e,content_3913_2484:()=>h2e,content_3913_2486:()=>D2e,content_3913_2488:()=>_2e,content_3913_2490:()=>C2e,content_3913_2492:()=>v2e,content_3913_2494:()=>N2e,content_3913_2496:()=>P2e,content_3913_2498:()=>W2e,content_3913_250:()=>m6,content_3913_2500:()=>E2e,content_3913_2502:()=>U2e,content_3913_2504:()=>q2e,content_3913_2506:()=>Y2e,content_3913_2508:()=>K2e,content_3913_2510:()=>e4e,content_3913_2512:()=>o4e,content_3913_2514:()=>s4e,content_3913_2516:()=>i4e,content_3913_2518:()=>m4e,content_3913_252:()=>h6,content_3913_2520:()=>h4e,content_3913_2522:()=>D4e,content_3913_2524:()=>_4e,content_3913_2526:()=>C4e,content_3913_2528:()=>v4e,content_3913_2530:()=>N4e,content_3913_2532:()=>P4e,content_3913_2534:()=>W4e,content_3913_2536:()=>E4e,content_3913_2538:()=>U4e,content_3913_254:()=>D6,content_3913_2540:()=>q4e,content_3913_2542:()=>Y4e,content_3913_2544:()=>K4e,content_3913_2546:()=>e6e,content_3913_2548:()=>o6e,content_3913_2550:()=>s6e,content_3913_2552:()=>i6e,content_3913_2554:()=>m6e,content_3913_2556:()=>h6e,content_3913_2558:()=>D6e,content_3913_256:()=>_6,content_3913_2560:()=>_6e,content_3913_2562:()=>C6e,content_3913_2564:()=>v6e,content_3913_2566:()=>N6e,content_3913_2568:()=>P6e,content_3913_2570:()=>W6e,content_3913_2572:()=>E6e,content_3913_2574:()=>U6e,content_3913_2576:()=>q6e,content_3913_2578:()=>Y6e,content_3913_258:()=>C6,content_3913_2580:()=>K6e,content_3913_2582:()=>e8e,content_3913_2584:()=>o8e,content_3913_2586:()=>s8e,content_3913_2588:()=>i8e,content_3913_2590:()=>m8e,content_3913_2592:()=>h8e,content_3913_2594:()=>D8e,content_3913_2596:()=>_8e,content_3913_2598:()=>C8e,content_3913_26:()=>e0,content_3913_260:()=>v6,content_3913_2600:()=>v8e,content_3913_2602:()=>N8e,content_3913_2604:()=>P8e,content_3913_2606:()=>W8e,content_3913_2608:()=>E8e,content_3913_2610:()=>U8e,content_3913_2612:()=>q8e,content_3913_2614:()=>Y8e,content_3913_2616:()=>K8e,content_3913_2618:()=>e5e,content_3913_262:()=>N6,content_3913_2620:()=>o5e,content_3913_2622:()=>s5e,content_3913_2624:()=>i5e,content_3913_2626:()=>m5e,content_3913_2628:()=>h5e,content_3913_2630:()=>D5e,content_3913_2632:()=>_5e,content_3913_2634:()=>C5e,content_3913_2636:()=>v5e,content_3913_2638:()=>N5e,content_3913_264:()=>P6,content_3913_2640:()=>P5e,content_3913_2642:()=>W5e,content_3913_2644:()=>E5e,content_3913_2646:()=>U5e,content_3913_2648:()=>q5e,content_3913_2650:()=>Y5e,content_3913_2652:()=>K5e,content_3913_2654:()=>e7e,content_3913_2656:()=>o7e,content_3913_2658:()=>s7e,content_3913_266:()=>W6,content_3913_2660:()=>i7e,content_3913_2662:()=>m7e,content_3913_2664:()=>h7e,content_3913_2666:()=>D7e,content_3913_2668:()=>_7e,content_3913_2670:()=>C7e,content_3913_2672:()=>v7e,content_3913_2674:()=>N7e,content_3913_2676:()=>P7e,content_3913_2678:()=>W7e,content_3913_268:()=>E6,content_3913_2680:()=>E7e,content_3913_2682:()=>U7e,content_3913_2684:()=>q7e,content_3913_2686:()=>Y7e,content_3913_2688:()=>K7e,content_3913_2690:()=>een,content_3913_2692:()=>oen,content_3913_2694:()=>sen,content_3913_2696:()=>ien,content_3913_2698:()=>men,content_3913_270:()=>U6,content_3913_2700:()=>hen,content_3913_2702:()=>Den,content_3913_2704:()=>_en,content_3913_2706:()=>Cen,content_3913_2708:()=>ven,content_3913_2710:()=>Nen,content_3913_2712:()=>Pen,content_3913_2714:()=>Wen,content_3913_2716:()=>Een,content_3913_2718:()=>Uen,content_3913_272:()=>q6,content_3913_2720:()=>qen,content_3913_2722:()=>Yen,content_3913_2724:()=>Ken,content_3913_2726:()=>enn,content_3913_2728:()=>onn,content_3913_2730:()=>snn,content_3913_2732:()=>inn,content_3913_2734:()=>mnn,content_3913_2736:()=>hnn,content_3913_2738:()=>Dnn,content_3913_274:()=>Y6,content_3913_2740:()=>_nn,content_3913_2742:()=>Cnn,content_3913_2744:()=>vnn,content_3913_2746:()=>Nnn,content_3913_2748:()=>Pnn,content_3913_2750:()=>Wnn,content_3913_2752:()=>Enn,content_3913_2754:()=>Unn,content_3913_2756:()=>qnn,content_3913_2758:()=>Ynn,content_3913_276:()=>K6,content_3913_2760:()=>Knn,content_3913_2762:()=>etn,content_3913_2764:()=>otn,content_3913_2766:()=>stn,content_3913_2768:()=>itn,content_3913_2770:()=>mtn,content_3913_2772:()=>htn,content_3913_2774:()=>Dtn,content_3913_2776:()=>_tn,content_3913_2778:()=>Ctn,content_3913_278:()=>e8,content_3913_2780:()=>vtn,content_3913_2782:()=>Ntn,content_3913_2784:()=>Ptn,content_3913_2786:()=>Wtn,content_3913_2788:()=>Etn,content_3913_2790:()=>Utn,content_3913_2792:()=>qtn,content_3913_2794:()=>Ytn,content_3913_2796:()=>Ktn,content_3913_2798:()=>eon,content_3913_28:()=>o0,content_3913_280:()=>o8,content_3913_2800:()=>oon,content_3913_2802:()=>son,content_3913_2804:()=>ion,content_3913_2806:()=>mon,content_3913_2808:()=>hon,content_3913_2810:()=>Don,content_3913_2812:()=>_on,content_3913_2814:()=>Con,content_3913_2816:()=>von,content_3913_2818:()=>Non,content_3913_282:()=>s8,content_3913_2820:()=>Pon,content_3913_2822:()=>Won,content_3913_2824:()=>Eon,content_3913_2826:()=>Uon,content_3913_2828:()=>qon,content_3913_2830:()=>Yon,content_3913_2832:()=>Kon,content_3913_2834:()=>epn,content_3913_2836:()=>opn,content_3913_2838:()=>spn,content_3913_284:()=>i8,content_3913_2840:()=>ipn,content_3913_2842:()=>mpn,content_3913_2844:()=>hpn,content_3913_2846:()=>Dpn,content_3913_2848:()=>_pn,content_3913_2850:()=>Cpn,content_3913_2852:()=>vpn,content_3913_2854:()=>Npn,content_3913_2856:()=>Ppn,content_3913_2858:()=>Wpn,content_3913_286:()=>m8,content_3913_2860:()=>Epn,content_3913_2862:()=>Upn,content_3913_2864:()=>qpn,content_3913_2866:()=>Ypn,content_3913_2868:()=>Kpn,content_3913_2870:()=>ern,content_3913_2872:()=>orn,content_3913_2874:()=>srn,content_3913_2876:()=>irn,content_3913_2878:()=>mrn,content_3913_288:()=>h8,content_3913_2880:()=>hrn,content_3913_2882:()=>Drn,content_3913_2884:()=>_rn,content_3913_2886:()=>Crn,content_3913_2888:()=>vrn,content_3913_2890:()=>Nrn,content_3913_2892:()=>Prn,content_3913_2894:()=>Wrn,content_3913_2896:()=>Ern,content_3913_2898:()=>Urn,content_3913_290:()=>D8,content_3913_2900:()=>qrn,content_3913_2902:()=>Yrn,content_3913_2904:()=>Krn,content_3913_2906:()=>esn,content_3913_2908:()=>osn,content_3913_2910:()=>ssn,content_3913_2912:()=>isn,content_3913_2914:()=>msn,content_3913_2916:()=>hsn,content_3913_2918:()=>Dsn,content_3913_292:()=>_8,content_3913_2920:()=>_sn,content_3913_2922:()=>Csn,content_3913_2924:()=>vsn,content_3913_2926:()=>Nsn,content_3913_2928:()=>Psn,content_3913_2930:()=>Wsn,content_3913_2932:()=>Esn,content_3913_2934:()=>Usn,content_3913_2936:()=>qsn,content_3913_2938:()=>Ysn,content_3913_294:()=>C8,content_3913_2940:()=>Ksn,content_3913_2942:()=>ecn,content_3913_2944:()=>ocn,content_3913_2946:()=>scn,content_3913_2948:()=>icn,content_3913_2950:()=>mcn,content_3913_2952:()=>hcn,content_3913_2954:()=>Dcn,content_3913_2956:()=>_cn,content_3913_2958:()=>Ccn,content_3913_296:()=>v8,content_3913_2960:()=>vcn,content_3913_2962:()=>Ncn,content_3913_2964:()=>Pcn,content_3913_2966:()=>Wcn,content_3913_2968:()=>Ecn,content_3913_2970:()=>Ucn,content_3913_2972:()=>qcn,content_3913_2974:()=>Ycn,content_3913_2976:()=>Kcn,content_3913_2978:()=>ean,content_3913_298:()=>N8,content_3913_2980:()=>oan,content_3913_2982:()=>san,content_3913_2984:()=>ian,content_3913_2986:()=>man,content_3913_2988:()=>han,content_3913_2990:()=>Dan,content_3913_2992:()=>_an,content_3913_2994:()=>Can,content_3913_2996:()=>van,content_3913_2998:()=>Nan,content_3913_30:()=>s0,content_3913_300:()=>P8,content_3913_3000:()=>Pan,content_3913_3002:()=>Wan,content_3913_3004:()=>Ean,content_3913_3006:()=>Uan,content_3913_3008:()=>qan,content_3913_3010:()=>Yan,content_3913_3012:()=>Kan,content_3913_3014:()=>ein,content_3913_3016:()=>oin,content_3913_3018:()=>sin,content_3913_302:()=>W8,content_3913_3020:()=>iin,content_3913_3022:()=>min,content_3913_3024:()=>hin,content_3913_3026:()=>Din,content_3913_3028:()=>_in,content_3913_3030:()=>Cin,content_3913_3032:()=>vin,content_3913_3034:()=>Nin,content_3913_3036:()=>Pin,content_3913_3038:()=>Win,content_3913_304:()=>E8,content_3913_3040:()=>Ein,content_3913_3042:()=>Uin,content_3913_3044:()=>qin,content_3913_3046:()=>Yin,content_3913_3048:()=>Kin,content_3913_3050:()=>eln,content_3913_3052:()=>oln,content_3913_3054:()=>sln,content_3913_3056:()=>iln,content_3913_3058:()=>mln,content_3913_306:()=>U8,content_3913_3060:()=>hln,content_3913_3062:()=>Dln,content_3913_3064:()=>_ln,content_3913_3066:()=>Cln,content_3913_3068:()=>vln,content_3913_3070:()=>Nln,content_3913_3072:()=>Pln,content_3913_3074:()=>Wln,content_3913_3076:()=>Eln,content_3913_3078:()=>Uln,content_3913_308:()=>q8,content_3913_3080:()=>qln,content_3913_3082:()=>Yln,content_3913_3084:()=>Kln,content_3913_3086:()=>eun,content_3913_3088:()=>oun,content_3913_3090:()=>sun,content_3913_3092:()=>iun,content_3913_3094:()=>mun,content_3913_3096:()=>hun,content_3913_3098:()=>Dun,content_3913_310:()=>Y8,content_3913_3100:()=>_un,content_3913_3102:()=>Cun,content_3913_3104:()=>vun,content_3913_3106:()=>Nun,content_3913_3108:()=>Pun,content_3913_3110:()=>Wun,content_3913_3112:()=>Eun,content_3913_3114:()=>Uun,content_3913_3116:()=>qun,content_3913_3118:()=>Yun,content_3913_312:()=>K8,content_3913_3120:()=>Kun,content_3913_3122:()=>emn,content_3913_3124:()=>omn,content_3913_3126:()=>smn,content_3913_3128:()=>imn,content_3913_3130:()=>mmn,content_3913_3132:()=>hmn,content_3913_3134:()=>Dmn,content_3913_3136:()=>_mn,content_3913_3138:()=>Cmn,content_3913_314:()=>e5,content_3913_3140:()=>vmn,content_3913_3142:()=>Nmn,content_3913_3144:()=>Pmn,content_3913_3146:()=>Wmn,content_3913_3148:()=>Emn,content_3913_3150:()=>Umn,content_3913_3152:()=>qmn,content_3913_3154:()=>Ymn,content_3913_3156:()=>Kmn,content_3913_3158:()=>eyn,content_3913_316:()=>o5,content_3913_3160:()=>oyn,content_3913_3162:()=>syn,content_3913_3164:()=>iyn,content_3913_3166:()=>myn,content_3913_3168:()=>hyn,content_3913_3170:()=>Dyn,content_3913_3172:()=>_yn,content_3913_3174:()=>Cyn,content_3913_3176:()=>vyn,content_3913_3178:()=>Nyn,content_3913_318:()=>s5,content_3913_3180:()=>Pyn,content_3913_3182:()=>Wyn,content_3913_3184:()=>Eyn,content_3913_3186:()=>Uyn,content_3913_3188:()=>qyn,content_3913_3190:()=>Yyn,content_3913_3192:()=>Kyn,content_3913_3194:()=>edn,content_3913_3196:()=>odn,content_3913_3198:()=>sdn,content_3913_32:()=>i0,content_3913_320:()=>i5,content_3913_3200:()=>idn,content_3913_3202:()=>mdn,content_3913_3204:()=>hdn,content_3913_3206:()=>Ddn,content_3913_3208:()=>_dn,content_3913_3210:()=>Cdn,content_3913_3212:()=>vdn,content_3913_3214:()=>Ndn,content_3913_3216:()=>Pdn,content_3913_3218:()=>Wdn,content_3913_322:()=>m5,content_3913_3220:()=>Edn,content_3913_3222:()=>Udn,content_3913_3224:()=>qdn,content_3913_3226:()=>Ydn,content_3913_3228:()=>Kdn,content_3913_3230:()=>ehn,content_3913_3232:()=>ohn,content_3913_3234:()=>shn,content_3913_3236:()=>ihn,content_3913_3238:()=>mhn,content_3913_324:()=>h5,content_3913_3240:()=>hhn,content_3913_3242:()=>Dhn,content_3913_3244:()=>_hn,content_3913_3246:()=>Chn,content_3913_3248:()=>vhn,content_3913_3250:()=>Nhn,content_3913_3252:()=>Phn,content_3913_3254:()=>Whn,content_3913_3256:()=>Ehn,content_3913_3258:()=>Uhn,content_3913_326:()=>D5,content_3913_3260:()=>qhn,content_3913_3262:()=>Yhn,content_3913_3264:()=>Khn,content_3913_3266:()=>egn,content_3913_3268:()=>ogn,content_3913_3270:()=>sgn,content_3913_3272:()=>ign,content_3913_3274:()=>mgn,content_3913_3276:()=>hgn,content_3913_3278:()=>Dgn,content_3913_328:()=>_5,content_3913_3280:()=>_gn,content_3913_3282:()=>Cgn,content_3913_3284:()=>vgn,content_3913_3286:()=>Ngn,content_3913_3288:()=>Pgn,content_3913_3290:()=>Wgn,content_3913_3292:()=>Egn,content_3913_3294:()=>Ugn,content_3913_3296:()=>qgn,content_3913_3298:()=>Ygn,content_3913_330:()=>C5,content_3913_3300:()=>Kgn,content_3913_3302:()=>efn,content_3913_3304:()=>ofn,content_3913_3306:()=>sfn,content_3913_3308:()=>ifn,content_3913_3310:()=>mfn,content_3913_3312:()=>hfn,content_3913_3314:()=>Dfn,content_3913_3316:()=>_fn,content_3913_3318:()=>Cfn,content_3913_332:()=>v5,content_3913_3320:()=>vfn,content_3913_3322:()=>Nfn,content_3913_3324:()=>Pfn,content_3913_3326:()=>Wfn,content_3913_3328:()=>Efn,content_3913_3330:()=>Ufn,content_3913_3332:()=>qfn,content_3913_3334:()=>Yfn,content_3913_3336:()=>Kfn,content_3913_3338:()=>eDn,content_3913_334:()=>N5,content_3913_3340:()=>oDn,content_3913_3342:()=>sDn,content_3913_3344:()=>iDn,content_3913_3346:()=>mDn,content_3913_3348:()=>hDn,content_3913_3350:()=>DDn,content_3913_3352:()=>_Dn,content_3913_3354:()=>CDn,content_3913_3356:()=>vDn,content_3913_3358:()=>NDn,content_3913_336:()=>P5,content_3913_3360:()=>PDn,content_3913_3362:()=>WDn,content_3913_3364:()=>EDn,content_3913_3366:()=>UDn,content_3913_3368:()=>qDn,content_3913_3370:()=>YDn,content_3913_3372:()=>KDn,content_3913_3374:()=>eMn,content_3913_3376:()=>oMn,content_3913_3378:()=>sMn,content_3913_338:()=>W5,content_3913_3380:()=>iMn,content_3913_3382:()=>mMn,content_3913_3384:()=>hMn,content_3913_3386:()=>DMn,content_3913_3388:()=>_Mn,content_3913_3390:()=>CMn,content_3913_3392:()=>vMn,content_3913_3394:()=>NMn,content_3913_3396:()=>PMn,content_3913_3398:()=>WMn,content_3913_34:()=>m0,content_3913_340:()=>E5,content_3913_3400:()=>EMn,content_3913_3402:()=>UMn,content_3913_3404:()=>qMn,content_3913_3406:()=>YMn,content_3913_3408:()=>KMn,content_3913_3410:()=>eXn,content_3913_3412:()=>oXn,content_3913_3414:()=>sXn,content_3913_3416:()=>iXn,content_3913_3418:()=>mXn,content_3913_342:()=>U5,content_3913_3420:()=>hXn,content_3913_3422:()=>DXn,content_3913_3424:()=>_Xn,content_3913_3426:()=>CXn,content_3913_3428:()=>vXn,content_3913_3430:()=>NXn,content_3913_3432:()=>PXn,content_3913_3434:()=>WXn,content_3913_3436:()=>EXn,content_3913_3438:()=>UXn,content_3913_344:()=>q5,content_3913_3440:()=>qXn,content_3913_3442:()=>YXn,content_3913_3444:()=>KXn,content_3913_3446:()=>e_n,content_3913_3448:()=>o_n,content_3913_3450:()=>s_n,content_3913_3452:()=>i_n,content_3913_3454:()=>m_n,content_3913_3456:()=>h_n,content_3913_3458:()=>D_n,content_3913_346:()=>Y5,content_3913_3460:()=>__n,content_3913_3462:()=>C_n,content_3913_3464:()=>v_n,content_3913_3466:()=>N_n,content_3913_3468:()=>P_n,content_3913_3470:()=>W_n,content_3913_3472:()=>E_n,content_3913_3474:()=>U_n,content_3913_3476:()=>q_n,content_3913_3478:()=>Y_n,content_3913_348:()=>K5,content_3913_3480:()=>K_n,content_3913_3482:()=>ewn,content_3913_3484:()=>own,content_3913_3486:()=>swn,content_3913_3488:()=>iwn,content_3913_3490:()=>mwn,content_3913_3492:()=>hwn,content_3913_3494:()=>Dwn,content_3913_3496:()=>_wn,content_3913_3498:()=>Cwn,content_3913_350:()=>e7,content_3913_3500:()=>vwn,content_3913_3502:()=>Nwn,content_3913_3504:()=>Pwn,content_3913_3506:()=>Wwn,content_3913_3508:()=>Ewn,content_3913_3510:()=>Uwn,content_3913_3512:()=>qwn,content_3913_3514:()=>Ywn,content_3913_3516:()=>Kwn,content_3913_3518:()=>eTn,content_3913_352:()=>o7,content_3913_3520:()=>oTn,content_3913_3522:()=>sTn,content_3913_3524:()=>iTn,content_3913_3526:()=>mTn,content_3913_3528:()=>hTn,content_3913_3530:()=>DTn,content_3913_3532:()=>_Tn,content_3913_3534:()=>CTn,content_3913_3536:()=>vTn,content_3913_3538:()=>NTn,content_3913_354:()=>s7,content_3913_3540:()=>PTn,content_3913_3542:()=>WTn,content_3913_3544:()=>ETn,content_3913_3546:()=>UTn,content_3913_3548:()=>qTn,content_3913_3550:()=>YTn,content_3913_3552:()=>KTn,content_3913_3554:()=>eCn,content_3913_3556:()=>oCn,content_3913_3558:()=>sCn,content_3913_356:()=>i7,content_3913_3560:()=>iCn,content_3913_3562:()=>mCn,content_3913_3564:()=>hCn,content_3913_3566:()=>DCn,content_3913_3568:()=>_Cn,content_3913_3570:()=>CCn,content_3913_3572:()=>vCn,content_3913_3574:()=>NCn,content_3913_3576:()=>PCn,content_3913_3578:()=>WCn,content_3913_358:()=>m7,content_3913_3580:()=>ECn,content_3913_3582:()=>UCn,content_3913_3584:()=>qCn,content_3913_3586:()=>YCn,content_3913_3588:()=>KCn,content_3913_3590:()=>exn,content_3913_3592:()=>oxn,content_3913_3594:()=>sxn,content_3913_3596:()=>ixn,content_3913_3598:()=>mxn,content_3913_36:()=>h0,content_3913_360:()=>h7,content_3913_3600:()=>hxn,content_3913_3602:()=>Dxn,content_3913_3604:()=>_xn,content_3913_3606:()=>Cxn,content_3913_3608:()=>vxn,content_3913_3610:()=>Nxn,content_3913_3612:()=>Pxn,content_3913_3614:()=>Wxn,content_3913_3616:()=>Exn,content_3913_3618:()=>Uxn,content_3913_362:()=>D7,content_3913_3620:()=>qxn,content_3913_3622:()=>Yxn,content_3913_3624:()=>Kxn,content_3913_3626:()=>eAn,content_3913_3628:()=>oAn,content_3913_3630:()=>sAn,content_3913_3632:()=>iAn,content_3913_3634:()=>mAn,content_3913_3636:()=>hAn,content_3913_3638:()=>DAn,content_3913_364:()=>_7,content_3913_3640:()=>_An,content_3913_3642:()=>CAn,content_3913_3644:()=>vAn,content_3913_3646:()=>NAn,content_3913_3648:()=>PAn,content_3913_3650:()=>WAn,content_3913_3652:()=>EAn,content_3913_3654:()=>UAn,content_3913_3656:()=>qAn,content_3913_3658:()=>YAn,content_3913_366:()=>C7,content_3913_3660:()=>KAn,content_3913_3662:()=>evn,content_3913_3664:()=>ovn,content_3913_3666:()=>svn,content_3913_3668:()=>ivn,content_3913_3670:()=>mvn,content_3913_3672:()=>hvn,content_3913_3674:()=>Dvn,content_3913_3676:()=>_vn,content_3913_3678:()=>Cvn,content_3913_368:()=>v7,content_3913_3680:()=>vvn,content_3913_3682:()=>Nvn,content_3913_3684:()=>Pvn,content_3913_3686:()=>Wvn,content_3913_3688:()=>Evn,content_3913_3690:()=>Uvn,content_3913_3692:()=>qvn,content_3913_3694:()=>Yvn,content_3913_3696:()=>Kvn,content_3913_3698:()=>eLn,content_3913_370:()=>N7,content_3913_3700:()=>oLn,content_3913_3702:()=>sLn,content_3913_3704:()=>iLn,content_3913_3706:()=>mLn,content_3913_3708:()=>hLn,content_3913_3710:()=>DLn,content_3913_3712:()=>_Ln,content_3913_3714:()=>CLn,content_3913_3716:()=>vLn,content_3913_3718:()=>NLn,content_3913_372:()=>P7,content_3913_3720:()=>PLn,content_3913_3722:()=>WLn,content_3913_3724:()=>ELn,content_3913_3726:()=>ULn,content_3913_3728:()=>qLn,content_3913_3730:()=>YLn,content_3913_3732:()=>KLn,content_3913_3734:()=>ebn,content_3913_3736:()=>obn,content_3913_3738:()=>sbn,content_3913_374:()=>W7,content_3913_3740:()=>ibn,content_3913_3742:()=>mbn,content_3913_3744:()=>hbn,content_3913_3746:()=>Dbn,content_3913_3748:()=>_bn,content_3913_3750:()=>Cbn,content_3913_3752:()=>vbn,content_3913_3754:()=>Nbn,content_3913_3756:()=>Pbn,content_3913_3758:()=>Wbn,content_3913_376:()=>E7,content_3913_3760:()=>Ebn,content_3913_3762:()=>Ubn,content_3913_3764:()=>qbn,content_3913_3766:()=>Ybn,content_3913_3768:()=>Kbn,content_3913_3770:()=>eNn,content_3913_3772:()=>oNn,content_3913_3774:()=>sNn,content_3913_3776:()=>iNn,content_3913_3778:()=>mNn,content_3913_378:()=>U7,content_3913_3780:()=>hNn,content_3913_3782:()=>DNn,content_3913_3784:()=>_Nn,content_3913_3786:()=>CNn,content_3913_3788:()=>vNn,content_3913_3790:()=>NNn,content_3913_3792:()=>PNn,content_3913_3794:()=>WNn,content_3913_3796:()=>ENn,content_3913_3798:()=>UNn,content_3913_38:()=>D0,content_3913_380:()=>q7,content_3913_3800:()=>qNn,content_3913_3802:()=>YNn,content_3913_3804:()=>KNn,content_3913_3806:()=>ekn,content_3913_3808:()=>okn,content_3913_3810:()=>skn,content_3913_3812:()=>ikn,content_3913_3814:()=>mkn,content_3913_3816:()=>hkn,content_3913_3818:()=>Dkn,content_3913_382:()=>Y7,content_3913_3820:()=>_kn,content_3913_3822:()=>Ckn,content_3913_3824:()=>vkn,content_3913_3826:()=>Nkn,content_3913_3828:()=>Pkn,content_3913_3830:()=>Wkn,content_3913_3832:()=>Ekn,content_3913_3834:()=>Ukn,content_3913_3836:()=>qkn,content_3913_3838:()=>Ykn,content_3913_384:()=>K7,content_3913_3840:()=>Kkn,content_3913_3842:()=>ezn,content_3913_3844:()=>ozn,content_3913_3846:()=>szn,content_3913_3848:()=>izn,content_3913_3850:()=>mzn,content_3913_3852:()=>hzn,content_3913_3854:()=>Dzn,content_3913_3856:()=>_zn,content_3913_3858:()=>Czn,content_3913_386:()=>eee,content_3913_3860:()=>vzn,content_3913_3862:()=>Nzn,content_3913_3864:()=>Pzn,content_3913_3866:()=>Wzn,content_3913_3868:()=>Ezn,content_3913_3870:()=>Uzn,content_3913_3872:()=>qzn,content_3913_3874:()=>Yzn,content_3913_3876:()=>Kzn,content_3913_3878:()=>ePn,content_3913_388:()=>oee,content_3913_3880:()=>oPn,content_3913_3882:()=>sPn,content_3913_3884:()=>iPn,content_3913_3886:()=>mPn,content_3913_3888:()=>hPn,content_3913_3890:()=>DPn,content_3913_3892:()=>_Pn,content_3913_3894:()=>CPn,content_3913_3896:()=>vPn,content_3913_3898:()=>NPn,content_3913_390:()=>see,content_3913_3900:()=>PPn,content_3913_3902:()=>WPn,content_3913_3904:()=>EPn,content_3913_3906:()=>UPn,content_3913_3908:()=>qPn,content_3913_3910:()=>YPn,content_3913_3912:()=>KPn,content_3913_3914:()=>eIn,content_3913_3916:()=>oIn,content_3913_3918:()=>sIn,content_3913_392:()=>iee,content_3913_3920:()=>iIn,content_3913_3922:()=>mIn,content_3913_3924:()=>hIn,content_3913_3926:()=>DIn,content_3913_3928:()=>_In,content_3913_3930:()=>CIn,content_3913_3932:()=>vIn,content_3913_3934:()=>NIn,content_3913_3936:()=>PIn,content_3913_3938:()=>WIn,content_3913_394:()=>mee,content_3913_3940:()=>EIn,content_3913_3942:()=>UIn,content_3913_3944:()=>qIn,content_3913_3946:()=>YIn,content_3913_3948:()=>KIn,content_3913_3950:()=>eRn,content_3913_3952:()=>oRn,content_3913_3954:()=>sRn,content_3913_3956:()=>iRn,content_3913_3958:()=>mRn,content_3913_396:()=>hee,content_3913_3960:()=>hRn,content_3913_3962:()=>DRn,content_3913_3964:()=>_Rn,content_3913_3966:()=>CRn,content_3913_3968:()=>vRn,content_3913_3970:()=>NRn,content_3913_3972:()=>PRn,content_3913_3974:()=>WRn,content_3913_3976:()=>ERn,content_3913_3978:()=>URn,content_3913_398:()=>Dee,content_3913_3980:()=>qRn,content_3913_3982:()=>YRn,content_3913_3984:()=>KRn,content_3913_3986:()=>eWn,content_3913_3988:()=>oWn,content_3913_3990:()=>sWn,content_3913_3992:()=>iWn,content_3913_3994:()=>mWn,content_3913_3996:()=>hWn,content_3913_3998:()=>DWn,content_3913_4:()=>_Z,content_3913_40:()=>_0,content_3913_400:()=>_ee,content_3913_4000:()=>_Wn,content_3913_4002:()=>CWn,content_3913_4004:()=>vWn,content_3913_4006:()=>NWn,content_3913_4008:()=>PWn,content_3913_4010:()=>WWn,content_3913_4012:()=>EWn,content_3913_4014:()=>UWn,content_3913_4016:()=>qWn,content_3913_4018:()=>YWn,content_3913_402:()=>Cee,content_3913_4020:()=>KWn,content_3913_4022:()=>eSn,content_3913_4024:()=>oSn,content_3913_4026:()=>sSn,content_3913_4028:()=>iSn,content_3913_4030:()=>mSn,content_3913_4032:()=>hSn,content_3913_4034:()=>DSn,content_3913_4036:()=>_Sn,content_3913_4038:()=>CSn,content_3913_404:()=>vee,content_3913_4040:()=>vSn,content_3913_4042:()=>NSn,content_3913_4044:()=>PSn,content_3913_4046:()=>WSn,content_3913_4048:()=>ESn,content_3913_4050:()=>USn,content_3913_4052:()=>qSn,content_3913_4054:()=>YSn,content_3913_4056:()=>KSn,content_3913_4058:()=>eBn,content_3913_406:()=>Nee,content_3913_4060:()=>oBn,content_3913_4062:()=>sBn,content_3913_4064:()=>iBn,content_3913_4066:()=>mBn,content_3913_4068:()=>hBn,content_3913_4070:()=>DBn,content_3913_4072:()=>_Bn,content_3913_4074:()=>CBn,content_3913_4076:()=>vBn,content_3913_4078:()=>NBn,content_3913_408:()=>Pee,content_3913_4080:()=>PBn,content_3913_4082:()=>WBn,content_3913_4084:()=>EBn,content_3913_4086:()=>UBn,content_3913_4088:()=>qBn,content_3913_4090:()=>YBn,content_3913_4092:()=>KBn,content_3913_4094:()=>eEn,content_3913_4096:()=>oEn,content_3913_4098:()=>sEn,content_3913_410:()=>Wee,content_3913_4100:()=>iEn,content_3913_4102:()=>mEn,content_3913_4104:()=>hEn,content_3913_4106:()=>DEn,content_3913_4108:()=>_En,content_3913_4110:()=>CEn,content_3913_4112:()=>vEn,content_3913_4114:()=>NEn,content_3913_4116:()=>PEn,content_3913_4118:()=>WEn,content_3913_412:()=>Eee,content_3913_4120:()=>EEn,content_3913_4122:()=>UEn,content_3913_4124:()=>qEn,content_3913_4126:()=>YEn,content_3913_4128:()=>KEn,content_3913_4130:()=>eGn,content_3913_4132:()=>oGn,content_3913_4134:()=>sGn,content_3913_4136:()=>iGn,content_3913_4138:()=>mGn,content_3913_414:()=>Uee,content_3913_4140:()=>hGn,content_3913_4142:()=>DGn,content_3913_4144:()=>_Gn,content_3913_4146:()=>CGn,content_3913_4148:()=>vGn,content_3913_4150:()=>NGn,content_3913_4152:()=>PGn,content_3913_4154:()=>WGn,content_3913_4156:()=>EGn,content_3913_4158:()=>UGn,content_3913_416:()=>qee,content_3913_4160:()=>qGn,content_3913_4162:()=>YGn,content_3913_4164:()=>KGn,content_3913_4166:()=>eOn,content_3913_4168:()=>oOn,content_3913_4170:()=>sOn,content_3913_4172:()=>iOn,content_3913_4174:()=>mOn,content_3913_4176:()=>hOn,content_3913_4178:()=>DOn,content_3913_418:()=>Yee,content_3913_4180:()=>_On,content_3913_4182:()=>COn,content_3913_4184:()=>vOn,content_3913_4186:()=>NOn,content_3913_4188:()=>POn,content_3913_4190:()=>WOn,content_3913_4192:()=>EOn,content_3913_4194:()=>UOn,content_3913_4196:()=>qOn,content_3913_4198:()=>YOn,content_3913_42:()=>C0,content_3913_420:()=>Kee,content_3913_4200:()=>KOn,content_3913_4202:()=>eUn,content_3913_4204:()=>oUn,content_3913_4206:()=>sUn,content_3913_4208:()=>iUn,content_3913_4210:()=>mUn,content_3913_4212:()=>hUn,content_3913_4214:()=>DUn,content_3913_4216:()=>_Un,content_3913_4218:()=>CUn,content_3913_422:()=>ene,content_3913_4220:()=>vUn,content_3913_4222:()=>NUn,content_3913_4224:()=>PUn,content_3913_4226:()=>WUn,content_3913_4228:()=>EUn,content_3913_4230:()=>UUn,content_3913_4232:()=>qUn,content_3913_4234:()=>YUn,content_3913_4236:()=>KUn,content_3913_4238:()=>eFn,content_3913_424:()=>one,content_3913_4240:()=>oFn,content_3913_4242:()=>sFn,content_3913_4244:()=>iFn,content_3913_4246:()=>mFn,content_3913_4248:()=>hFn,content_3913_4250:()=>DFn,content_3913_4252:()=>_Fn,content_3913_4254:()=>CFn,content_3913_4256:()=>vFn,content_3913_4258:()=>NFn,content_3913_426:()=>sne,content_3913_4260:()=>PFn,content_3913_4262:()=>WFn,content_3913_4264:()=>EFn,content_3913_4266:()=>UFn,content_3913_4268:()=>qFn,content_3913_4270:()=>YFn,content_3913_4272:()=>KFn,content_3913_4274:()=>eVn,content_3913_4276:()=>oVn,content_3913_4278:()=>sVn,content_3913_428:()=>ine,content_3913_4280:()=>iVn,content_3913_4282:()=>mVn,content_3913_4284:()=>hVn,content_3913_4286:()=>DVn,content_3913_4288:()=>_Vn,content_3913_4290:()=>CVn,content_3913_4292:()=>vVn,content_3913_4294:()=>NVn,content_3913_4296:()=>PVn,content_3913_4298:()=>WVn,content_3913_430:()=>mne,content_3913_4300:()=>EVn,content_3913_4302:()=>UVn,content_3913_4304:()=>qVn,content_3913_4306:()=>YVn,content_3913_4308:()=>KVn,content_3913_4310:()=>eqn,content_3913_4312:()=>oqn,content_3913_4314:()=>sqn,content_3913_4316:()=>iqn,content_3913_4318:()=>mqn,content_3913_432:()=>hne,content_3913_4320:()=>hqn,content_3913_4322:()=>Dqn,content_3913_4324:()=>_qn,content_3913_4326:()=>Cqn,content_3913_4328:()=>vqn,content_3913_4330:()=>Nqn,content_3913_4332:()=>Pqn,content_3913_4334:()=>Wqn,content_3913_4336:()=>Eqn,content_3913_4338:()=>Uqn,content_3913_434:()=>Dne,content_3913_4340:()=>qqn,content_3913_4342:()=>Yqn,content_3913_4344:()=>Kqn,content_3913_4346:()=>ejn,content_3913_4348:()=>ojn,content_3913_4350:()=>sjn,content_3913_4352:()=>ijn,content_3913_4354:()=>mjn,content_3913_4356:()=>hjn,content_3913_4358:()=>Djn,content_3913_436:()=>_ne,content_3913_4360:()=>_jn,content_3913_4362:()=>Cjn,content_3913_4364:()=>vjn,content_3913_4366:()=>Njn,content_3913_4368:()=>Pjn,content_3913_4370:()=>Wjn,content_3913_4372:()=>Ejn,content_3913_4374:()=>Ujn,content_3913_4376:()=>qjn,content_3913_4378:()=>Yjn,content_3913_438:()=>Cne,content_3913_4380:()=>Kjn,content_3913_4382:()=>eHn,content_3913_4384:()=>oHn,content_3913_4386:()=>sHn,content_3913_4388:()=>iHn,content_3913_4390:()=>mHn,content_3913_4392:()=>hHn,content_3913_4394:()=>DHn,content_3913_4396:()=>_Hn,content_3913_4398:()=>CHn,content_3913_44:()=>v0,content_3913_440:()=>vne,content_3913_4400:()=>vHn,content_3913_4402:()=>NHn,content_3913_4404:()=>PHn,content_3913_4406:()=>WHn,content_3913_4408:()=>EHn,content_3913_4410:()=>UHn,content_3913_4412:()=>qHn,content_3913_4414:()=>YHn,content_3913_4416:()=>KHn,content_3913_4418:()=>eYn,content_3913_442:()=>Nne,content_3913_4420:()=>oYn,content_3913_4422:()=>sYn,content_3913_4424:()=>iYn,content_3913_4426:()=>mYn,content_3913_4428:()=>hYn,content_3913_4430:()=>DYn,content_3913_4432:()=>_Yn,content_3913_4434:()=>CYn,content_3913_4436:()=>vYn,content_3913_4438:()=>NYn,content_3913_444:()=>Pne,content_3913_4440:()=>PYn,content_3913_4442:()=>WYn,content_3913_4444:()=>EYn,content_3913_4446:()=>UYn,content_3913_4448:()=>qYn,content_3913_4450:()=>YYn,content_3913_4452:()=>KYn,content_3913_4454:()=>eQn,content_3913_4456:()=>oQn,content_3913_4458:()=>sQn,content_3913_446:()=>Wne,content_3913_4460:()=>iQn,content_3913_4462:()=>mQn,content_3913_4464:()=>hQn,content_3913_4466:()=>DQn,content_3913_4468:()=>_Qn,content_3913_4470:()=>CQn,content_3913_4472:()=>vQn,content_3913_4474:()=>NQn,content_3913_4476:()=>PQn,content_3913_4478:()=>WQn,content_3913_448:()=>Ene,content_3913_4480:()=>EQn,content_3913_4482:()=>UQn,content_3913_4484:()=>qQn,content_3913_4486:()=>YQn,content_3913_4488:()=>KQn,content_3913_4490:()=>e$n,content_3913_4492:()=>o$n,content_3913_4494:()=>s$n,content_3913_4496:()=>i$n,content_3913_4498:()=>m$n,content_3913_450:()=>Une,content_3913_4500:()=>h$n,content_3913_4502:()=>D$n,content_3913_4504:()=>_$n,content_3913_4506:()=>C$n,content_3913_4508:()=>v$n,content_3913_4510:()=>N$n,content_3913_4512:()=>P$n,content_3913_4514:()=>W$n,content_3913_4516:()=>E$n,content_3913_4518:()=>U$n,content_3913_452:()=>qne,content_3913_4520:()=>q$n,content_3913_4522:()=>Y$n,content_3913_4524:()=>K$n,content_3913_4526:()=>eKn,content_3913_4528:()=>oKn,content_3913_4530:()=>sKn,content_3913_4532:()=>iKn,content_3913_4534:()=>mKn,content_3913_4536:()=>hKn,content_3913_4538:()=>DKn,content_3913_454:()=>Yne,content_3913_4540:()=>_Kn,content_3913_4542:()=>CKn,content_3913_4544:()=>vKn,content_3913_4546:()=>NKn,content_3913_4548:()=>PKn,content_3913_4550:()=>WKn,content_3913_4552:()=>EKn,content_3913_4554:()=>UKn,content_3913_4556:()=>qKn,content_3913_4558:()=>YKn,content_3913_456:()=>Kne,content_3913_4560:()=>KKn,content_3913_4562:()=>eJn,content_3913_4564:()=>oJn,content_3913_4566:()=>sJn,content_3913_4568:()=>iJn,content_3913_4570:()=>mJn,content_3913_4572:()=>hJn,content_3913_4574:()=>DJn,content_3913_4576:()=>_Jn,content_3913_4578:()=>CJn,content_3913_458:()=>ete,content_3913_4580:()=>vJn,content_3913_4582:()=>NJn,content_3913_4584:()=>PJn,content_3913_4586:()=>WJn,content_3913_4588:()=>EJn,content_3913_4590:()=>UJn,content_3913_4592:()=>qJn,content_3913_4594:()=>YJn,content_3913_4596:()=>KJn,content_3913_4598:()=>eZn,content_3913_46:()=>N0,content_3913_460:()=>ote,content_3913_4600:()=>oZn,content_3913_4602:()=>sZn,content_3913_4604:()=>iZn,content_3913_4606:()=>mZn,content_3913_4608:()=>hZn,content_3913_4610:()=>DZn,content_3913_4612:()=>_Zn,content_3913_4614:()=>CZn,content_3913_4616:()=>vZn,content_3913_4618:()=>NZn,content_3913_462:()=>ste,content_3913_4620:()=>PZn,content_3913_4622:()=>WZn,content_3913_4624:()=>EZn,content_3913_4626:()=>UZn,content_3913_4628:()=>qZn,content_3913_4630:()=>YZn,content_3913_4632:()=>KZn,content_3913_4634:()=>e0n,content_3913_4636:()=>o0n,content_3913_4638:()=>s0n,content_3913_464:()=>ite,content_3913_4640:()=>i0n,content_3913_4642:()=>m0n,content_3913_4644:()=>h0n,content_3913_4646:()=>D0n,content_3913_4648:()=>_0n,content_3913_4650:()=>C0n,content_3913_4652:()=>v0n,content_3913_4654:()=>N0n,content_3913_4656:()=>P0n,content_3913_4658:()=>W0n,content_3913_466:()=>mte,content_3913_4660:()=>E0n,content_3913_4662:()=>U0n,content_3913_4664:()=>q0n,content_3913_4666:()=>Y0n,content_3913_4668:()=>K0n,content_3913_4670:()=>e3n,content_3913_4672:()=>o3n,content_3913_4674:()=>s3n,content_3913_4676:()=>i3n,content_3913_4678:()=>m3n,content_3913_468:()=>hte,content_3913_4680:()=>h3n,content_3913_4682:()=>D3n,content_3913_4684:()=>_3n,content_3913_4686:()=>C3n,content_3913_4688:()=>v3n,content_3913_4690:()=>N3n,content_3913_4692:()=>P3n,content_3913_4694:()=>W3n,content_3913_4696:()=>E3n,content_3913_4698:()=>U3n,content_3913_470:()=>Dte,content_3913_4700:()=>q3n,content_3913_4702:()=>Y3n,content_3913_4704:()=>K3n,content_3913_4706:()=>e1n,content_3913_4708:()=>o1n,content_3913_4710:()=>s1n,content_3913_4712:()=>i1n,content_3913_4714:()=>m1n,content_3913_4716:()=>h1n,content_3913_4718:()=>D1n,content_3913_472:()=>_te,content_3913_4720:()=>_1n,content_3913_4722:()=>C1n,content_3913_4724:()=>v1n,content_3913_4726:()=>N1n,content_3913_4728:()=>P1n,content_3913_4730:()=>W1n,content_3913_4732:()=>E1n,content_3913_4734:()=>U1n,content_3913_4736:()=>q1n,content_3913_4738:()=>Y1n,content_3913_474:()=>Cte,content_3913_4740:()=>K1n,content_3913_4742:()=>e9n,content_3913_4744:()=>o9n,content_3913_4746:()=>s9n,content_3913_4748:()=>i9n,content_3913_4750:()=>m9n,content_3913_4752:()=>h9n,content_3913_4754:()=>D9n,content_3913_4756:()=>_9n,content_3913_4758:()=>C9n,content_3913_476:()=>vte,content_3913_4760:()=>v9n,content_3913_4762:()=>N9n,content_3913_4764:()=>P9n,content_3913_4766:()=>W9n,content_3913_4768:()=>E9n,content_3913_4770:()=>U9n,content_3913_4772:()=>q9n,content_3913_4774:()=>Y9n,content_3913_4776:()=>K9n,content_3913_4778:()=>e2n,content_3913_478:()=>Nte,content_3913_4780:()=>o2n,content_3913_4782:()=>s2n,content_3913_4784:()=>i2n,content_3913_4786:()=>m2n,content_3913_4788:()=>h2n,content_3913_4790:()=>D2n,content_3913_4792:()=>_2n,content_3913_4794:()=>C2n,content_3913_4796:()=>v2n,content_3913_4798:()=>N2n,content_3913_48:()=>P0,content_3913_480:()=>Pte,content_3913_4800:()=>P2n,content_3913_4802:()=>W2n,content_3913_4804:()=>E2n,content_3913_4806:()=>U2n,content_3913_4808:()=>q2n,content_3913_4810:()=>Y2n,content_3913_4812:()=>K2n,content_3913_4814:()=>e4n,content_3913_4816:()=>o4n,content_3913_4818:()=>s4n,content_3913_482:()=>Wte,content_3913_4820:()=>i4n,content_3913_4822:()=>m4n,content_3913_4824:()=>h4n,content_3913_4826:()=>D4n,content_3913_4828:()=>_4n,content_3913_4830:()=>C4n,content_3913_4832:()=>v4n,content_3913_4834:()=>N4n,content_3913_4836:()=>P4n,content_3913_4838:()=>W4n,content_3913_484:()=>Ete,content_3913_4840:()=>E4n,content_3913_4842:()=>U4n,content_3913_4844:()=>q4n,content_3913_4846:()=>Y4n,content_3913_4848:()=>K4n,content_3913_4850:()=>e6n,content_3913_4852:()=>o6n,content_3913_4854:()=>s6n,content_3913_4856:()=>i6n,content_3913_4858:()=>m6n,content_3913_486:()=>Ute,content_3913_4860:()=>h6n,content_3913_4862:()=>D6n,content_3913_4864:()=>_6n,content_3913_4866:()=>C6n,content_3913_4868:()=>v6n,content_3913_4870:()=>N6n,content_3913_4872:()=>P6n,content_3913_4874:()=>W6n,content_3913_4876:()=>E6n,content_3913_4878:()=>U6n,content_3913_488:()=>qte,content_3913_4880:()=>q6n,content_3913_4882:()=>Y6n,content_3913_4884:()=>K6n,content_3913_4886:()=>e8n,content_3913_4888:()=>o8n,content_3913_4890:()=>s8n,content_3913_4892:()=>i8n,content_3913_4894:()=>m8n,content_3913_4896:()=>h8n,content_3913_4898:()=>D8n,content_3913_490:()=>Yte,content_3913_4900:()=>_8n,content_3913_4902:()=>C8n,content_3913_4904:()=>v8n,content_3913_4906:()=>N8n,content_3913_4908:()=>P8n,content_3913_4910:()=>W8n,content_3913_4912:()=>E8n,content_3913_4914:()=>U8n,content_3913_4916:()=>q8n,content_3913_4918:()=>Y8n,content_3913_492:()=>Kte,content_3913_4920:()=>K8n,content_3913_4922:()=>e5n,content_3913_4924:()=>o5n,content_3913_4926:()=>s5n,content_3913_4928:()=>i5n,content_3913_4930:()=>m5n,content_3913_4932:()=>h5n,content_3913_4934:()=>D5n,content_3913_4936:()=>_5n,content_3913_4938:()=>C5n,content_3913_494:()=>eoe,content_3913_4940:()=>v5n,content_3913_4942:()=>N5n,content_3913_4944:()=>P5n,content_3913_4946:()=>W5n,content_3913_4948:()=>E5n,content_3913_4950:()=>U5n,content_3913_4952:()=>q5n,content_3913_4954:()=>Y5n,content_3913_4956:()=>K5n,content_3913_4958:()=>e7n,content_3913_496:()=>ooe,content_3913_4960:()=>o7n,content_3913_4962:()=>s7n,content_3913_4964:()=>i7n,content_3913_4966:()=>m7n,content_3913_4968:()=>h7n,content_3913_4970:()=>D7n,content_3913_4972:()=>_7n,content_3913_4974:()=>C7n,content_3913_4976:()=>v7n,content_3913_4978:()=>N7n,content_3913_498:()=>soe,content_3913_4980:()=>P7n,content_3913_4982:()=>W7n,content_3913_4984:()=>E7n,content_3913_4986:()=>U7n,content_3913_4988:()=>q7n,content_3913_4990:()=>Y7n,content_3913_4992:()=>K7n,content_3913_4994:()=>eet,content_3913_4996:()=>oet,content_3913_4998:()=>set,content_3913_50:()=>W0,content_3913_500:()=>ioe,content_3913_5000:()=>iet,content_3913_5002:()=>yet,content_3913_5004:()=>get,content_3913_5006:()=>Met,content_3913_5008:()=>wet,content_3913_5010:()=>xet,content_3913_5012:()=>Let,content_3913_5014:()=>ket,content_3913_5016:()=>Iet,content_3913_5018:()=>Set,content_3913_502:()=>moe,content_3913_5020:()=>Get,content_3913_5022:()=>Fet,content_3913_5024:()=>jet,content_3913_5026:()=>Qet,content_3913_5028:()=>Jet,content_3913_5030:()=>nnt,content_3913_5032:()=>pnt,content_3913_5034:()=>cnt,content_3913_5036:()=>lnt,content_3913_5038:()=>ynt,content_3913_504:()=>hoe,content_3913_5040:()=>gnt,content_3913_5042:()=>Mnt,content_3913_5044:()=>wnt,content_3913_5046:()=>xnt,content_3913_5048:()=>Lnt,content_3913_5050:()=>knt,content_3913_5052:()=>Int,content_3913_5054:()=>Snt,content_3913_5056:()=>Gnt,content_3913_5058:()=>Fnt,content_3913_506:()=>Doe,content_3913_5060:()=>jnt,content_3913_5062:()=>Qnt,content_3913_5064:()=>Jnt,content_3913_5066:()=>ntt,content_3913_5068:()=>ptt,content_3913_5070:()=>ctt,content_3913_5072:()=>ltt,content_3913_5074:()=>ytt,content_3913_5076:()=>gtt,content_3913_5078:()=>Mtt,content_3913_508:()=>_oe,content_3913_5080:()=>wtt,content_3913_5082:()=>xtt,content_3913_5084:()=>Ltt,content_3913_5086:()=>ktt,content_3913_5088:()=>Itt,content_3913_5090:()=>Stt,content_3913_5092:()=>Gtt,content_3913_5094:()=>Ftt,content_3913_5096:()=>jtt,content_3913_5098:()=>Qtt,content_3913_510:()=>Coe,content_3913_5100:()=>Jtt,content_3913_5102:()=>not,content_3913_5104:()=>pot,content_3913_5106:()=>cot,content_3913_5108:()=>lot,content_3913_5110:()=>yot,content_3913_5112:()=>got,content_3913_5114:()=>Mot,content_3913_5116:()=>wot,content_3913_5118:()=>xot,content_3913_512:()=>voe,content_3913_5120:()=>Lot,content_3913_5122:()=>kot,content_3913_5124:()=>Iot,content_3913_5126:()=>Sot,content_3913_5128:()=>Got,content_3913_5130:()=>Fot,content_3913_5132:()=>jot,content_3913_5134:()=>Qot,content_3913_5136:()=>Jot,content_3913_5138:()=>npt,content_3913_514:()=>Noe,content_3913_5140:()=>ppt,content_3913_5142:()=>cpt,content_3913_5144:()=>lpt,content_3913_5146:()=>ypt,content_3913_5148:()=>gpt,content_3913_5150:()=>Mpt,content_3913_5152:()=>wpt,content_3913_5154:()=>xpt,content_3913_5156:()=>Lpt,content_3913_5158:()=>kpt,content_3913_516:()=>Poe,content_3913_5160:()=>Ipt,content_3913_5162:()=>Spt,content_3913_5164:()=>Gpt,content_3913_5166:()=>Fpt,content_3913_5168:()=>jpt,content_3913_5170:()=>Qpt,content_3913_5172:()=>Jpt,content_3913_5174:()=>nrt,content_3913_5176:()=>prt,content_3913_5178:()=>crt,content_3913_518:()=>Woe,content_3913_5180:()=>lrt,content_3913_5182:()=>yrt,content_3913_5184:()=>grt,content_3913_5186:()=>Mrt,content_3913_5188:()=>wrt,content_3913_5190:()=>xrt,content_3913_5192:()=>Lrt,content_3913_5194:()=>krt,content_3913_5196:()=>Irt,content_3913_5198:()=>Srt,content_3913_52:()=>E0,content_3913_520:()=>Eoe,content_3913_5200:()=>Grt,content_3913_5202:()=>Frt,content_3913_5204:()=>jrt,content_3913_5206:()=>Qrt,content_3913_5208:()=>Jrt,content_3913_5210:()=>nst,content_3913_5212:()=>pst,content_3913_5214:()=>cst,content_3913_5216:()=>lst,content_3913_5218:()=>yst,content_3913_522:()=>Uoe,content_3913_5220:()=>gst,content_3913_5222:()=>Mst,content_3913_5224:()=>wst,content_3913_5226:()=>xst,content_3913_5228:()=>Lst,content_3913_5230:()=>kst,content_3913_5232:()=>Ist,content_3913_5234:()=>Sst,content_3913_5236:()=>Gst,content_3913_5238:()=>Fst,content_3913_524:()=>qoe,content_3913_5240:()=>jst,content_3913_5242:()=>Qst,content_3913_5244:()=>Jst,content_3913_5246:()=>nct,content_3913_5248:()=>pct,content_3913_5250:()=>cct,content_3913_5252:()=>lct,content_3913_5254:()=>yct,content_3913_5256:()=>gct,content_3913_5258:()=>Mct,content_3913_526:()=>Yoe,content_3913_5260:()=>wct,content_3913_5262:()=>xct,content_3913_5264:()=>Lct,content_3913_5266:()=>kct,content_3913_5268:()=>Ict,content_3913_5270:()=>Sct,content_3913_5272:()=>Gct,content_3913_5274:()=>Fct,content_3913_5276:()=>jct,content_3913_5278:()=>Qct,content_3913_528:()=>Koe,content_3913_5280:()=>Jct,content_3913_5282:()=>nat,content_3913_5284:()=>pat,content_3913_5286:()=>cat,content_3913_5288:()=>lat,content_3913_5290:()=>yat,content_3913_5292:()=>gat,content_3913_5294:()=>Mat,content_3913_5296:()=>wat,content_3913_5298:()=>xat,content_3913_530:()=>epe,content_3913_5300:()=>Lat,content_3913_5302:()=>kat,content_3913_5304:()=>Iat,content_3913_5306:()=>Sat,content_3913_5308:()=>Gat,content_3913_5310:()=>Fat,content_3913_5312:()=>jat,content_3913_5314:()=>Qat,content_3913_5316:()=>Jat,content_3913_5318:()=>nit,content_3913_532:()=>ope,content_3913_5320:()=>pit,content_3913_5322:()=>cit,content_3913_5324:()=>lit,content_3913_5326:()=>yit,content_3913_5328:()=>git,content_3913_5330:()=>Mit,content_3913_5332:()=>wit,content_3913_5334:()=>xit,content_3913_5336:()=>Lit,content_3913_5338:()=>kit,content_3913_534:()=>spe,content_3913_5340:()=>Iit,content_3913_5342:()=>Sit,content_3913_5344:()=>Git,content_3913_5346:()=>Fit,content_3913_5348:()=>jit,content_3913_5350:()=>Qit,content_3913_5352:()=>Jit,content_3913_5354:()=>nlt,content_3913_5356:()=>plt,content_3913_5358:()=>clt,content_3913_536:()=>ipe,content_3913_5360:()=>llt,content_3913_5362:()=>ylt,content_3913_5364:()=>glt,content_3913_5366:()=>Mlt,content_3913_5368:()=>wlt,content_3913_5370:()=>xlt,content_3913_5372:()=>Llt,content_3913_5374:()=>klt,content_3913_5376:()=>Ilt,content_3913_5378:()=>Slt,content_3913_538:()=>mpe,content_3913_5380:()=>Glt,content_3913_5382:()=>Flt,content_3913_5384:()=>jlt,content_3913_5386:()=>Qlt,content_3913_5388:()=>Jlt,content_3913_5390:()=>nut,content_3913_5392:()=>put,content_3913_5394:()=>cut,content_3913_5396:()=>lut,content_3913_5398:()=>yut,content_3913_54:()=>U0,content_3913_540:()=>hpe,content_3913_5400:()=>gut,content_3913_5402:()=>Mut,content_3913_5404:()=>wut,content_3913_5406:()=>xut,content_3913_5408:()=>Lut,content_3913_5410:()=>kut,content_3913_5412:()=>Iut,content_3913_5414:()=>Sut,content_3913_5416:()=>Gut,content_3913_5418:()=>Fut,content_3913_542:()=>Dpe,content_3913_5420:()=>jut,content_3913_5422:()=>Qut,content_3913_5424:()=>Jut,content_3913_5426:()=>nmt,content_3913_5428:()=>pmt,content_3913_5430:()=>cmt,content_3913_5432:()=>lmt,content_3913_5434:()=>ymt,content_3913_5436:()=>gmt,content_3913_5438:()=>Mmt,content_3913_544:()=>_pe,content_3913_5440:()=>wmt,content_3913_5442:()=>xmt,content_3913_5444:()=>Lmt,content_3913_5446:()=>kmt,content_3913_5448:()=>Imt,content_3913_5450:()=>Smt,content_3913_5452:()=>Gmt,content_3913_5454:()=>Fmt,content_3913_5456:()=>jmt,content_3913_5458:()=>Qmt,content_3913_546:()=>Cpe,content_3913_5460:()=>Jmt,content_3913_5462:()=>nyt,content_3913_5464:()=>pyt,content_3913_5466:()=>cyt,content_3913_5468:()=>lyt,content_3913_5470:()=>yyt,content_3913_5472:()=>gyt,content_3913_5474:()=>Myt,content_3913_5476:()=>wyt,content_3913_5478:()=>xyt,content_3913_548:()=>vpe,content_3913_5480:()=>Lyt,content_3913_5482:()=>kyt,content_3913_5484:()=>Iyt,content_3913_5486:()=>Syt,content_3913_5488:()=>Gyt,content_3913_5490:()=>Fyt,content_3913_5492:()=>jyt,content_3913_5494:()=>Qyt,content_3913_5496:()=>Jyt,content_3913_5498:()=>ndt,content_3913_550:()=>Npe,content_3913_5500:()=>pdt,content_3913_5502:()=>cdt,content_3913_5504:()=>ldt,content_3913_5506:()=>ydt,content_3913_5508:()=>gdt,content_3913_5510:()=>Mdt,content_3913_5512:()=>wdt,content_3913_5514:()=>xdt,content_3913_5516:()=>Ldt,content_3913_5518:()=>kdt,content_3913_552:()=>Ppe,content_3913_5520:()=>Idt,content_3913_5522:()=>Sdt,content_3913_5524:()=>Gdt,content_3913_5526:()=>Fdt,content_3913_5528:()=>jdt,content_3913_5530:()=>Qdt,content_3913_5532:()=>Jdt,content_3913_5534:()=>nht,content_3913_5536:()=>pht,content_3913_5538:()=>cht,content_3913_554:()=>Wpe,content_3913_5540:()=>lht,content_3913_5542:()=>yht,content_3913_5544:()=>ght,content_3913_5546:()=>Mht,content_3913_5548:()=>wht,content_3913_5550:()=>xht,content_3913_5552:()=>Lht,content_3913_5554:()=>kht,content_3913_5556:()=>Iht,content_3913_5558:()=>Sht,content_3913_556:()=>Epe,content_3913_5560:()=>Ght,content_3913_5562:()=>Fht,content_3913_5564:()=>jht,content_3913_5566:()=>Qht,content_3913_5568:()=>Jht,content_3913_5570:()=>ngt,content_3913_5572:()=>pgt,content_3913_5574:()=>cgt,content_3913_5576:()=>lgt,content_3913_5578:()=>ygt,content_3913_558:()=>Upe,content_3913_5580:()=>ggt,content_3913_5582:()=>Mgt,content_3913_5584:()=>wgt,content_3913_5586:()=>xgt,content_3913_5588:()=>Lgt,content_3913_5590:()=>kgt,content_3913_5592:()=>Igt,content_3913_5594:()=>Sgt,content_3913_5596:()=>Ggt,content_3913_5598:()=>Fgt,content_3913_56:()=>q0,content_3913_560:()=>qpe,content_3913_5600:()=>jgt,content_3913_5602:()=>Qgt,content_3913_5604:()=>Jgt,content_3913_5606:()=>nft,content_3913_5608:()=>pft,content_3913_5610:()=>cft,content_3913_5612:()=>lft,content_3913_5614:()=>yft,content_3913_5616:()=>gft,content_3913_5618:()=>Mft,content_3913_562:()=>Ype,content_3913_5620:()=>wft,content_3913_5622:()=>xft,content_3913_5624:()=>Lft,content_3913_5626:()=>kft,content_3913_5628:()=>Ift,content_3913_5630:()=>Sft,content_3913_5632:()=>Gft,content_3913_5634:()=>Fft,content_3913_5636:()=>jft,content_3913_5638:()=>Qft,content_3913_564:()=>Kpe,content_3913_5640:()=>Jft,content_3913_5642:()=>nDt,content_3913_5644:()=>pDt,content_3913_5646:()=>cDt,content_3913_5648:()=>lDt,content_3913_5650:()=>yDt,content_3913_5652:()=>gDt,content_3913_5654:()=>MDt,content_3913_5656:()=>wDt,content_3913_5658:()=>xDt,content_3913_566:()=>ere,content_3913_5660:()=>LDt,content_3913_5662:()=>kDt,content_3913_5664:()=>IDt,content_3913_5666:()=>SDt,content_3913_5668:()=>GDt,content_3913_5670:()=>FDt,content_3913_5672:()=>jDt,content_3913_5674:()=>QDt,content_3913_5676:()=>JDt,content_3913_5678:()=>nMt,content_3913_568:()=>ore,content_3913_5680:()=>pMt,content_3913_5682:()=>cMt,content_3913_5684:()=>lMt,content_3913_5686:()=>yMt,content_3913_5688:()=>gMt,content_3913_5690:()=>MMt,content_3913_5692:()=>wMt,content_3913_5694:()=>xMt,content_3913_5696:()=>LMt,content_3913_5698:()=>kMt,content_3913_570:()=>sre,content_3913_5700:()=>IMt,content_3913_5702:()=>SMt,content_3913_5704:()=>GMt,content_3913_5706:()=>FMt,content_3913_5708:()=>jMt,content_3913_5710:()=>QMt,content_3913_5712:()=>JMt,content_3913_5714:()=>nXt,content_3913_5716:()=>pXt,content_3913_5718:()=>cXt,content_3913_572:()=>ire,content_3913_5720:()=>lXt,content_3913_5722:()=>yXt,content_3913_5724:()=>gXt,content_3913_5726:()=>MXt,content_3913_5728:()=>wXt,content_3913_5730:()=>xXt,content_3913_5732:()=>LXt,content_3913_5734:()=>kXt,content_3913_5736:()=>IXt,content_3913_5738:()=>SXt,content_3913_574:()=>mre,content_3913_5740:()=>GXt,content_3913_5742:()=>FXt,content_3913_5744:()=>jXt,content_3913_5746:()=>QXt,content_3913_5748:()=>JXt,content_3913_5750:()=>n_t,content_3913_5752:()=>p_t,content_3913_5754:()=>c_t,content_3913_5756:()=>l_t,content_3913_5758:()=>y_t,content_3913_576:()=>hre,content_3913_5760:()=>g_t,content_3913_5762:()=>M_t,content_3913_5764:()=>w_t,content_3913_5766:()=>x_t,content_3913_5768:()=>L_t,content_3913_5770:()=>k_t,content_3913_5772:()=>I_t,content_3913_5774:()=>S_t,content_3913_5776:()=>G_t,content_3913_5778:()=>F_t,content_3913_578:()=>Dre,content_3913_5780:()=>j_t,content_3913_5782:()=>Q_t,content_3913_5784:()=>J_t,content_3913_5786:()=>nwt,content_3913_5788:()=>pwt,content_3913_5790:()=>cwt,content_3913_5792:()=>lwt,content_3913_5794:()=>ywt,content_3913_5796:()=>gwt,content_3913_5798:()=>Mwt,content_3913_58:()=>Y0,content_3913_580:()=>_re,content_3913_5800:()=>wwt,content_3913_5802:()=>xwt,content_3913_5804:()=>Lwt,content_3913_5806:()=>kwt,content_3913_5808:()=>Iwt,content_3913_5810:()=>Swt,content_3913_5812:()=>Gwt,content_3913_5814:()=>Fwt,content_3913_5816:()=>jwt,content_3913_5818:()=>Qwt,content_3913_582:()=>Cre,content_3913_5820:()=>Jwt,content_3913_5822:()=>nTt,content_3913_5824:()=>pTt,content_3913_5826:()=>cTt,content_3913_5828:()=>lTt,content_3913_5830:()=>yTt,content_3913_5832:()=>gTt,content_3913_5834:()=>MTt,content_3913_5836:()=>wTt,content_3913_5838:()=>xTt,content_3913_584:()=>vre,content_3913_5840:()=>LTt,content_3913_5842:()=>kTt,content_3913_5844:()=>ITt,content_3913_5846:()=>STt,content_3913_5848:()=>GTt,content_3913_5850:()=>FTt,content_3913_5852:()=>jTt,content_3913_5854:()=>QTt,content_3913_5856:()=>JTt,content_3913_5858:()=>nCt,content_3913_586:()=>Nre,content_3913_5860:()=>pCt,content_3913_5862:()=>cCt,content_3913_5864:()=>lCt,content_3913_5866:()=>yCt,content_3913_5868:()=>gCt,content_3913_5870:()=>MCt,content_3913_5872:()=>wCt,content_3913_5874:()=>xCt,content_3913_5876:()=>LCt,content_3913_5878:()=>kCt,content_3913_588:()=>Pre,content_3913_5880:()=>ICt,content_3913_5882:()=>SCt,content_3913_5884:()=>GCt,content_3913_5886:()=>FCt,content_3913_5888:()=>jCt,content_3913_5890:()=>QCt,content_3913_5892:()=>JCt,content_3913_5894:()=>nxt,content_3913_5896:()=>pxt,content_3913_5898:()=>cxt,content_3913_590:()=>Wre,content_3913_5900:()=>lxt,content_3913_5902:()=>yxt,content_3913_5904:()=>gxt,content_3913_5906:()=>Mxt,content_3913_5908:()=>wxt,content_3913_5910:()=>xxt,content_3913_5912:()=>Lxt,content_3913_5914:()=>kxt,content_3913_5916:()=>Ixt,content_3913_5918:()=>Sxt,content_3913_592:()=>Ere,content_3913_5920:()=>Gxt,content_3913_5922:()=>Fxt,content_3913_5924:()=>jxt,content_3913_5926:()=>Qxt,content_3913_5928:()=>Jxt,content_3913_5930:()=>nAt,content_3913_5932:()=>pAt,content_3913_5934:()=>cAt,content_3913_5936:()=>lAt,content_3913_5938:()=>yAt,content_3913_594:()=>Ure,content_3913_5940:()=>gAt,content_3913_5942:()=>MAt,content_3913_5944:()=>wAt,content_3913_5946:()=>xAt,content_3913_5948:()=>LAt,content_3913_5950:()=>kAt,content_3913_5952:()=>IAt,content_3913_5954:()=>SAt,content_3913_5956:()=>GAt,content_3913_5958:()=>FAt,content_3913_596:()=>qre,content_3913_5960:()=>jAt,content_3913_5962:()=>QAt,content_3913_5964:()=>JAt,content_3913_5966:()=>nvt,content_3913_5968:()=>pvt,content_3913_5970:()=>cvt,content_3913_5972:()=>lvt,content_3913_5974:()=>yvt,content_3913_5976:()=>gvt,content_3913_5978:()=>Mvt,content_3913_598:()=>Yre,content_3913_5980:()=>wvt,content_3913_5982:()=>xvt,content_3913_5984:()=>Lvt,content_3913_5986:()=>kvt,content_3913_5988:()=>Ivt,content_3913_5990:()=>Svt,content_3913_5992:()=>Gvt,content_3913_5994:()=>Fvt,content_3913_5996:()=>jvt,content_3913_5998:()=>Qvt,content_3913_6:()=>CZ,content_3913_60:()=>K0,content_3913_600:()=>Kre,content_3913_6000:()=>Jvt,content_3913_6002:()=>nLt,content_3913_6004:()=>pLt,content_3913_6006:()=>cLt,content_3913_6008:()=>lLt,content_3913_6010:()=>yLt,content_3913_6012:()=>gLt,content_3913_6014:()=>MLt,content_3913_6016:()=>wLt,content_3913_6018:()=>xLt,content_3913_602:()=>ese,content_3913_6020:()=>LLt,content_3913_6022:()=>kLt,content_3913_6024:()=>ILt,content_3913_6026:()=>SLt,content_3913_6028:()=>GLt,content_3913_6030:()=>FLt,content_3913_6032:()=>jLt,content_3913_6034:()=>QLt,content_3913_6036:()=>JLt,content_3913_6038:()=>nbt,content_3913_604:()=>ose,content_3913_6040:()=>pbt,content_3913_6042:()=>cbt,content_3913_6044:()=>lbt,content_3913_6046:()=>ybt,content_3913_6048:()=>gbt,content_3913_6050:()=>Mbt,content_3913_6052:()=>wbt,content_3913_6054:()=>xbt,content_3913_6056:()=>Lbt,content_3913_6058:()=>kbt,content_3913_606:()=>sse,content_3913_6060:()=>Ibt,content_3913_6062:()=>Sbt,content_3913_6064:()=>Gbt,content_3913_6066:()=>Fbt,content_3913_6068:()=>jbt,content_3913_6070:()=>Qbt,content_3913_6072:()=>Jbt,content_3913_6074:()=>nNt,content_3913_6076:()=>pNt,content_3913_6078:()=>cNt,content_3913_608:()=>ise,content_3913_6080:()=>lNt,content_3913_6082:()=>yNt,content_3913_6084:()=>gNt,content_3913_6086:()=>MNt,content_3913_6088:()=>wNt,content_3913_6090:()=>xNt,content_3913_6092:()=>LNt,content_3913_6094:()=>kNt,content_3913_6096:()=>INt,content_3913_6098:()=>SNt,content_3913_610:()=>mse,content_3913_6100:()=>GNt,content_3913_6102:()=>FNt,content_3913_6104:()=>jNt,content_3913_6106:()=>QNt,content_3913_6108:()=>JNt,content_3913_6110:()=>nkt,content_3913_6112:()=>pkt,content_3913_6114:()=>ckt,content_3913_6116:()=>lkt,content_3913_6118:()=>ykt,content_3913_612:()=>hse,content_3913_6120:()=>gkt,content_3913_6122:()=>Mkt,content_3913_6124:()=>wkt,content_3913_6126:()=>xkt,content_3913_6128:()=>Lkt,content_3913_6130:()=>kkt,content_3913_6132:()=>Ikt,content_3913_6134:()=>Skt,content_3913_6136:()=>Gkt,content_3913_6138:()=>Fkt,content_3913_614:()=>Dse,content_3913_6140:()=>jkt,content_3913_6142:()=>Qkt,content_3913_6144:()=>Jkt,content_3913_6146:()=>nzt,content_3913_6148:()=>pzt,content_3913_6150:()=>czt,content_3913_6152:()=>lzt,content_3913_6154:()=>yzt,content_3913_6156:()=>gzt,content_3913_6158:()=>Mzt,content_3913_616:()=>_se,content_3913_6160:()=>wzt,content_3913_6162:()=>xzt,content_3913_6164:()=>Lzt,content_3913_6166:()=>kzt,content_3913_6168:()=>Izt,content_3913_6170:()=>Szt,content_3913_6172:()=>Gzt,content_3913_6174:()=>Fzt,content_3913_6176:()=>jzt,content_3913_6178:()=>Qzt,content_3913_618:()=>Cse,content_3913_6180:()=>Jzt,content_3913_6182:()=>nPt,content_3913_6184:()=>pPt,content_3913_6186:()=>cPt,content_3913_6188:()=>lPt,content_3913_6190:()=>yPt,content_3913_6192:()=>gPt,content_3913_6194:()=>MPt,content_3913_6196:()=>wPt,content_3913_6198:()=>xPt,content_3913_62:()=>e3,content_3913_620:()=>vse,content_3913_6200:()=>LPt,content_3913_6202:()=>kPt,content_3913_6204:()=>IPt,content_3913_6206:()=>SPt,content_3913_6208:()=>GPt,content_3913_6210:()=>FPt,content_3913_6212:()=>jPt,content_3913_6214:()=>QPt,content_3913_6216:()=>JPt,content_3913_6218:()=>nIt,content_3913_622:()=>Nse,content_3913_6220:()=>pIt,content_3913_6222:()=>cIt,content_3913_6224:()=>lIt,content_3913_6226:()=>yIt,content_3913_6228:()=>gIt,content_3913_6230:()=>MIt,content_3913_6232:()=>wIt,content_3913_6234:()=>xIt,content_3913_6236:()=>LIt,content_3913_6238:()=>kIt,content_3913_624:()=>Pse,content_3913_6240:()=>IIt,content_3913_6242:()=>SIt,content_3913_6244:()=>GIt,content_3913_6246:()=>FIt,content_3913_6248:()=>jIt,content_3913_6250:()=>QIt,content_3913_6252:()=>JIt,content_3913_6254:()=>nRt,content_3913_6256:()=>pRt,content_3913_6258:()=>cRt,content_3913_626:()=>Wse,content_3913_6260:()=>lRt,content_3913_6262:()=>yRt,content_3913_6264:()=>gRt,content_3913_6266:()=>MRt,content_3913_6268:()=>wRt,content_3913_6270:()=>xRt,content_3913_6272:()=>LRt,content_3913_6274:()=>kRt,content_3913_6276:()=>IRt,content_3913_6278:()=>SRt,content_3913_628:()=>Ese,content_3913_6280:()=>GRt,content_3913_6282:()=>FRt,content_3913_6284:()=>jRt,content_3913_6286:()=>QRt,content_3913_6288:()=>JRt,content_3913_6290:()=>nWt,content_3913_6292:()=>pWt,content_3913_6294:()=>cWt,content_3913_6296:()=>lWt,content_3913_6298:()=>yWt,content_3913_630:()=>Use,content_3913_6300:()=>gWt,content_3913_6302:()=>MWt,content_3913_6304:()=>wWt,content_3913_6306:()=>xWt,content_3913_6308:()=>LWt,content_3913_6310:()=>kWt,content_3913_6312:()=>IWt,content_3913_6314:()=>SWt,content_3913_6316:()=>GWt,content_3913_6318:()=>FWt,content_3913_632:()=>qse,content_3913_6320:()=>jWt,content_3913_6322:()=>QWt,content_3913_6324:()=>JWt,content_3913_6326:()=>nSt,content_3913_6328:()=>pSt,content_3913_6330:()=>cSt,content_3913_6332:()=>lSt,content_3913_6334:()=>ySt,content_3913_6336:()=>gSt,content_3913_6338:()=>MSt,content_3913_634:()=>Yse,content_3913_6340:()=>wSt,content_3913_6342:()=>xSt,content_3913_6344:()=>LSt,content_3913_6346:()=>kSt,content_3913_6348:()=>ISt,content_3913_6350:()=>SSt,content_3913_6352:()=>GSt,content_3913_6354:()=>FSt,content_3913_6356:()=>jSt,content_3913_6358:()=>QSt,content_3913_636:()=>Kse,content_3913_6360:()=>JSt,content_3913_6362:()=>nBt,content_3913_6364:()=>pBt,content_3913_6366:()=>cBt,content_3913_6368:()=>lBt,content_3913_6370:()=>yBt,content_3913_6372:()=>gBt,content_3913_6374:()=>MBt,content_3913_6376:()=>wBt,content_3913_6378:()=>xBt,content_3913_638:()=>ece,content_3913_6380:()=>LBt,content_3913_6382:()=>kBt,content_3913_6384:()=>IBt,content_3913_6386:()=>SBt,content_3913_6388:()=>GBt,content_3913_6390:()=>FBt,content_3913_6392:()=>jBt,content_3913_6394:()=>QBt,content_3913_6396:()=>JBt,content_3913_6398:()=>nEt,content_3913_64:()=>o3,content_3913_640:()=>oce,content_3913_6400:()=>pEt,content_3913_6402:()=>cEt,content_3913_6404:()=>lEt,content_3913_6406:()=>yEt,content_3913_6408:()=>gEt,content_3913_6410:()=>MEt,content_3913_6412:()=>wEt,content_3913_6414:()=>xEt,content_3913_6416:()=>LEt,content_3913_6418:()=>kEt,content_3913_642:()=>sce,content_3913_6420:()=>IEt,content_3913_6422:()=>SEt,content_3913_6424:()=>GEt,content_3913_6426:()=>FEt,content_3913_6428:()=>jEt,content_3913_6430:()=>QEt,content_3913_6432:()=>JEt,content_3913_6434:()=>nGt,content_3913_6436:()=>pGt,content_3913_6438:()=>cGt,content_3913_644:()=>ice,content_3913_6440:()=>lGt,content_3913_6442:()=>yGt,content_3913_6444:()=>gGt,content_3913_6446:()=>MGt,content_3913_6448:()=>wGt,content_3913_6450:()=>xGt,content_3913_6452:()=>LGt,content_3913_6454:()=>kGt,content_3913_6456:()=>IGt,content_3913_6458:()=>SGt,content_3913_646:()=>mce,content_3913_6460:()=>GGt,content_3913_6462:()=>FGt,content_3913_6464:()=>jGt,content_3913_6466:()=>QGt,content_3913_6468:()=>JGt,content_3913_6470:()=>nOt,content_3913_6472:()=>pOt,content_3913_6474:()=>cOt,content_3913_6476:()=>lOt,content_3913_6478:()=>yOt,content_3913_648:()=>hce,content_3913_6480:()=>gOt,content_3913_6482:()=>MOt,content_3913_6484:()=>wOt,content_3913_6486:()=>xOt,content_3913_6488:()=>LOt,content_3913_6490:()=>kOt,content_3913_6492:()=>IOt,content_3913_6494:()=>SOt,content_3913_6496:()=>GOt,content_3913_6498:()=>FOt,content_3913_650:()=>Dce,content_3913_6500:()=>jOt,content_3913_6502:()=>QOt,content_3913_6504:()=>JOt,content_3913_6506:()=>nUt,content_3913_6508:()=>pUt,content_3913_6510:()=>cUt,content_3913_6512:()=>lUt,content_3913_6514:()=>yUt,content_3913_6516:()=>gUt,content_3913_6518:()=>MUt,content_3913_652:()=>_ce,content_3913_6520:()=>wUt,content_3913_6522:()=>xUt,content_3913_6524:()=>LUt,content_3913_6526:()=>kUt,content_3913_6528:()=>IUt,content_3913_6530:()=>SUt,content_3913_6532:()=>GUt,content_3913_6534:()=>FUt,content_3913_6536:()=>jUt,content_3913_6538:()=>QUt,content_3913_654:()=>Cce,content_3913_6540:()=>JUt,content_3913_6542:()=>nFt,content_3913_6544:()=>pFt,content_3913_6546:()=>cFt,content_3913_6548:()=>lFt,content_3913_6550:()=>yFt,content_3913_6552:()=>gFt,content_3913_6554:()=>MFt,content_3913_6556:()=>wFt,content_3913_6558:()=>xFt,content_3913_656:()=>vce,content_3913_6560:()=>LFt,content_3913_6562:()=>kFt,content_3913_6564:()=>IFt,content_3913_6566:()=>SFt,content_3913_6568:()=>GFt,content_3913_6570:()=>FFt,content_3913_6572:()=>jFt,content_3913_6574:()=>QFt,content_3913_6576:()=>JFt,content_3913_6578:()=>nVt,content_3913_658:()=>Nce,content_3913_6580:()=>pVt,content_3913_6582:()=>cVt,content_3913_6584:()=>lVt,content_3913_6586:()=>yVt,content_3913_6588:()=>gVt,content_3913_6590:()=>MVt,content_3913_6592:()=>wVt,content_3913_6594:()=>xVt,content_3913_6596:()=>LVt,content_3913_6598:()=>kVt,content_3913_66:()=>s3,content_3913_660:()=>Pce,content_3913_6600:()=>IVt,content_3913_6602:()=>SVt,content_3913_6604:()=>GVt,content_3913_6606:()=>FVt,content_3913_6608:()=>jVt,content_3913_6610:()=>QVt,content_3913_6612:()=>JVt,content_3913_6614:()=>nqt,content_3913_6616:()=>pqt,content_3913_6618:()=>cqt,content_3913_662:()=>Wce,content_3913_6620:()=>lqt,content_3913_6622:()=>yqt,content_3913_6624:()=>gqt,content_3913_6626:()=>Mqt,content_3913_6628:()=>wqt,content_3913_6630:()=>xqt,content_3913_6632:()=>Lqt,content_3913_6634:()=>kqt,content_3913_6636:()=>Iqt,content_3913_6638:()=>Sqt,content_3913_664:()=>Ece,content_3913_6640:()=>Gqt,content_3913_6642:()=>Fqt,content_3913_6644:()=>jqt,content_3913_6646:()=>Qqt,content_3913_6648:()=>Jqt,content_3913_6650:()=>njt,content_3913_6652:()=>pjt,content_3913_6654:()=>cjt,content_3913_6656:()=>ljt,content_3913_6658:()=>yjt,content_3913_666:()=>Uce,content_3913_6660:()=>gjt,content_3913_6662:()=>Mjt,content_3913_6664:()=>wjt,content_3913_6666:()=>xjt,content_3913_6668:()=>Ljt,content_3913_6670:()=>kjt,content_3913_6672:()=>Ijt,content_3913_6674:()=>Sjt,content_3913_6676:()=>Gjt,content_3913_6678:()=>Fjt,content_3913_668:()=>qce,content_3913_6680:()=>jjt,content_3913_6682:()=>Qjt,content_3913_6684:()=>Jjt,content_3913_6686:()=>nHt,content_3913_6688:()=>pHt,content_3913_6690:()=>cHt,content_3913_6692:()=>lHt,content_3913_6694:()=>yHt,content_3913_6696:()=>gHt,content_3913_6698:()=>MHt,content_3913_670:()=>Yce,content_3913_6700:()=>wHt,content_3913_6702:()=>xHt,content_3913_6704:()=>LHt,content_3913_6706:()=>kHt,content_3913_6708:()=>IHt,content_3913_6710:()=>SHt,content_3913_6712:()=>GHt,content_3913_6714:()=>FHt,content_3913_6716:()=>jHt,content_3913_6718:()=>QHt,content_3913_672:()=>Kce,content_3913_6720:()=>JHt,content_3913_6722:()=>nYt,content_3913_6724:()=>pYt,content_3913_6726:()=>cYt,content_3913_6728:()=>lYt,content_3913_6730:()=>yYt,content_3913_6732:()=>gYt,content_3913_6734:()=>MYt,content_3913_6736:()=>wYt,content_3913_6738:()=>xYt,content_3913_674:()=>eae,content_3913_6740:()=>LYt,content_3913_6742:()=>kYt,content_3913_6744:()=>IYt,content_3913_6746:()=>SYt,content_3913_6748:()=>GYt,content_3913_6750:()=>FYt,content_3913_6752:()=>jYt,content_3913_6754:()=>QYt,content_3913_6756:()=>JYt,content_3913_6758:()=>nQt,content_3913_676:()=>oae,content_3913_6760:()=>pQt,content_3913_6762:()=>cQt,content_3913_6764:()=>lQt,content_3913_6766:()=>yQt,content_3913_6768:()=>gQt,content_3913_6770:()=>MQt,content_3913_6772:()=>wQt,content_3913_6774:()=>xQt,content_3913_6776:()=>LQt,content_3913_6778:()=>kQt,content_3913_678:()=>sae,content_3913_6780:()=>IQt,content_3913_6782:()=>SQt,content_3913_6784:()=>GQt,content_3913_6786:()=>FQt,content_3913_6788:()=>jQt,content_3913_6790:()=>QQt,content_3913_6792:()=>JQt,content_3913_6794:()=>n$t,content_3913_6796:()=>p$t,content_3913_6798:()=>c$t,content_3913_68:()=>i3,content_3913_680:()=>iae,content_3913_6800:()=>l$t,content_3913_6802:()=>y$t,content_3913_6804:()=>g$t,content_3913_6806:()=>M$t,content_3913_6808:()=>w$t,content_3913_6810:()=>x$t,content_3913_6812:()=>L$t,content_3913_6814:()=>k$t,content_3913_6816:()=>I$t,content_3913_6818:()=>S$t,content_3913_682:()=>mae,content_3913_6820:()=>G$t,content_3913_6822:()=>F$t,content_3913_6824:()=>j$t,content_3913_6826:()=>Q$t,content_3913_6828:()=>J$t,content_3913_6830:()=>nKt,content_3913_6832:()=>pKt,content_3913_6834:()=>cKt,content_3913_6836:()=>lKt,content_3913_6838:()=>yKt,content_3913_684:()=>hae,content_3913_6840:()=>gKt,content_3913_6842:()=>MKt,content_3913_6844:()=>wKt,content_3913_6846:()=>xKt,content_3913_6848:()=>LKt,content_3913_6850:()=>kKt,content_3913_6852:()=>IKt,content_3913_6854:()=>SKt,content_3913_6856:()=>GKt,content_3913_6858:()=>FKt,content_3913_686:()=>Dae,content_3913_6860:()=>jKt,content_3913_6862:()=>QKt,content_3913_6864:()=>JKt,content_3913_6866:()=>nJt,content_3913_6868:()=>pJt,content_3913_6870:()=>cJt,content_3913_6872:()=>lJt,content_3913_6874:()=>yJt,content_3913_6876:()=>gJt,content_3913_6878:()=>MJt,content_3913_688:()=>_ae,content_3913_6880:()=>wJt,content_3913_6882:()=>xJt,content_3913_6884:()=>LJt,content_3913_6886:()=>kJt,content_3913_6888:()=>IJt,content_3913_6890:()=>SJt,content_3913_6892:()=>GJt,content_3913_6894:()=>FJt,content_3913_6896:()=>jJt,content_3913_6898:()=>QJt,content_3913_690:()=>Cae,content_3913_6900:()=>JJt,content_3913_6902:()=>nZt,content_3913_6904:()=>pZt,content_3913_6906:()=>cZt,content_3913_6908:()=>lZt,content_3913_6910:()=>yZt,content_3913_6912:()=>gZt,content_3913_6914:()=>MZt,content_3913_6916:()=>wZt,content_3913_6918:()=>xZt,content_3913_692:()=>vae,content_3913_6920:()=>LZt,content_3913_6922:()=>kZt,content_3913_6924:()=>IZt,content_3913_6926:()=>SZt,content_3913_6928:()=>GZt,content_3913_6930:()=>FZt,content_3913_6932:()=>jZt,content_3913_6934:()=>QZt,content_3913_6936:()=>JZt,content_3913_6938:()=>n0t,content_3913_694:()=>Nae,content_3913_6940:()=>p0t,content_3913_6942:()=>c0t,content_3913_6944:()=>l0t,content_3913_6946:()=>y0t,content_3913_6948:()=>g0t,content_3913_6950:()=>M0t,content_3913_6952:()=>w0t,content_3913_6954:()=>x0t,content_3913_6956:()=>L0t,content_3913_6958:()=>k0t,content_3913_696:()=>Pae,content_3913_6960:()=>I0t,content_3913_6962:()=>S0t,content_3913_6964:()=>G0t,content_3913_6966:()=>F0t,content_3913_6968:()=>j0t,content_3913_6970:()=>Q0t,content_3913_6972:()=>J0t,content_3913_6974:()=>n3t,content_3913_6976:()=>p3t,content_3913_6978:()=>c3t,content_3913_698:()=>Wae,content_3913_6980:()=>l3t,content_3913_6982:()=>y3t,content_3913_6984:()=>g3t,content_3913_6986:()=>M3t,content_3913_6988:()=>w3t,content_3913_6990:()=>x3t,content_3913_6992:()=>L3t,content_3913_6994:()=>k3t,content_3913_6996:()=>I3t,content_3913_6998:()=>S3t,content_3913_70:()=>m3,content_3913_700:()=>Eae,content_3913_7000:()=>G3t,content_3913_7002:()=>F3t,content_3913_7004:()=>j3t,content_3913_7006:()=>Q3t,content_3913_7008:()=>J3t,content_3913_7010:()=>n1t,content_3913_7012:()=>p1t,content_3913_7014:()=>c1t,content_3913_7016:()=>l1t,content_3913_7018:()=>y1t,content_3913_702:()=>Uae,content_3913_7020:()=>g1t,content_3913_7022:()=>M1t,content_3913_7024:()=>w1t,content_3913_7026:()=>x1t,content_3913_7028:()=>L1t,content_3913_7030:()=>k1t,content_3913_7032:()=>I1t,content_3913_7034:()=>S1t,content_3913_7036:()=>G1t,content_3913_7038:()=>F1t,content_3913_704:()=>qae,content_3913_7040:()=>j1t,content_3913_7042:()=>Q1t,content_3913_7044:()=>J1t,content_3913_7046:()=>n9t,content_3913_7048:()=>p9t,content_3913_7050:()=>c9t,content_3913_7052:()=>l9t,content_3913_7054:()=>y9t,content_3913_7056:()=>g9t,content_3913_7058:()=>M9t,content_3913_706:()=>Yae,content_3913_7060:()=>w9t,content_3913_7062:()=>x9t,content_3913_7064:()=>L9t,content_3913_7066:()=>k9t,content_3913_7068:()=>I9t,content_3913_7070:()=>S9t,content_3913_7072:()=>G9t,content_3913_7074:()=>F9t,content_3913_7076:()=>j9t,content_3913_7078:()=>Q9t,content_3913_708:()=>Kae,content_3913_7080:()=>J9t,content_3913_7082:()=>n2t,content_3913_7084:()=>p2t,content_3913_7086:()=>c2t,content_3913_7088:()=>l2t,content_3913_7090:()=>y2t,content_3913_7092:()=>g2t,content_3913_7094:()=>M2t,content_3913_7096:()=>w2t,content_3913_7098:()=>x2t,content_3913_710:()=>eie,content_3913_7100:()=>L2t,content_3913_7102:()=>k2t,content_3913_7104:()=>I2t,content_3913_7106:()=>S2t,content_3913_7108:()=>G2t,content_3913_7110:()=>F2t,content_3913_7112:()=>j2t,content_3913_7114:()=>Q2t,content_3913_7116:()=>J2t,content_3913_7118:()=>n4t,content_3913_712:()=>oie,content_3913_7120:()=>p4t,content_3913_7122:()=>c4t,content_3913_7124:()=>l4t,content_3913_7126:()=>y4t,content_3913_7128:()=>g4t,content_3913_7130:()=>M4t,content_3913_7132:()=>w4t,content_3913_7134:()=>x4t,content_3913_7136:()=>L4t,content_3913_7138:()=>k4t,content_3913_714:()=>sie,content_3913_7140:()=>I4t,content_3913_7142:()=>S4t,content_3913_7144:()=>G4t,content_3913_7146:()=>F4t,content_3913_7148:()=>j4t,content_3913_7150:()=>Q4t,content_3913_7152:()=>J4t,content_3913_7154:()=>n6t,content_3913_7156:()=>p6t,content_3913_7158:()=>c6t,content_3913_716:()=>iie,content_3913_7160:()=>l6t,content_3913_7162:()=>y6t,content_3913_7164:()=>g6t,content_3913_7166:()=>M6t,content_3913_7168:()=>w6t,content_3913_7170:()=>x6t,content_3913_7172:()=>L6t,content_3913_7174:()=>k6t,content_3913_7176:()=>I6t,content_3913_7178:()=>S6t,content_3913_718:()=>mie,content_3913_7180:()=>G6t,content_3913_7182:()=>F6t,content_3913_7184:()=>j6t,content_3913_7186:()=>Q6t,content_3913_7188:()=>J6t,content_3913_7190:()=>n8t,content_3913_7192:()=>p8t,content_3913_7194:()=>c8t,content_3913_7196:()=>l8t,content_3913_7198:()=>y8t,content_3913_72:()=>h3,content_3913_720:()=>hie,content_3913_7200:()=>g8t,content_3913_7202:()=>M8t,content_3913_7204:()=>w8t,content_3913_7206:()=>x8t,content_3913_7208:()=>L8t,content_3913_7210:()=>k8t,content_3913_7212:()=>I8t,content_3913_7214:()=>S8t,content_3913_7216:()=>G8t,content_3913_7218:()=>F8t,content_3913_722:()=>Die,content_3913_7220:()=>j8t,content_3913_7222:()=>Q8t,content_3913_7224:()=>J8t,content_3913_7226:()=>n5t,content_3913_7228:()=>p5t,content_3913_7230:()=>c5t,content_3913_7232:()=>l5t,content_3913_7234:()=>y5t,content_3913_7236:()=>g5t,content_3913_7238:()=>M5t,content_3913_724:()=>_ie,content_3913_7240:()=>w5t,content_3913_7242:()=>x5t,content_3913_7244:()=>L5t,content_3913_7246:()=>k5t,content_3913_7248:()=>I5t,content_3913_7250:()=>S5t,content_3913_7252:()=>G5t,content_3913_7254:()=>F5t,content_3913_7256:()=>j5t,content_3913_7258:()=>Q5t,content_3913_726:()=>Cie,content_3913_7260:()=>J5t,content_3913_7262:()=>n7t,content_3913_7264:()=>p7t,content_3913_7266:()=>c7t,content_3913_7268:()=>l7t,content_3913_7270:()=>y7t,content_3913_7272:()=>g7t,content_3913_7274:()=>M7t,content_3913_7276:()=>w7t,content_3913_7278:()=>x7t,content_3913_728:()=>vie,content_3913_7280:()=>L7t,content_3913_7282:()=>k7t,content_3913_7284:()=>I7t,content_3913_7286:()=>S7t,content_3913_7288:()=>G7t,content_3913_7290:()=>F7t,content_3913_7292:()=>j7t,content_3913_7294:()=>Q7t,content_3913_7296:()=>J7t,content_3913_7298:()=>neo,content_3913_730:()=>Nie,content_3913_7300:()=>peo,content_3913_7302:()=>ceo,content_3913_7304:()=>leo,content_3913_7306:()=>yeo,content_3913_7308:()=>geo,content_3913_7310:()=>Meo,content_3913_7312:()=>weo,content_3913_7314:()=>xeo,content_3913_7316:()=>Leo,content_3913_7318:()=>keo,content_3913_732:()=>Pie,content_3913_7320:()=>Ieo,content_3913_7322:()=>Seo,content_3913_7324:()=>Geo,content_3913_7326:()=>Feo,content_3913_7328:()=>jeo,content_3913_7330:()=>Qeo,content_3913_7332:()=>Jeo,content_3913_7334:()=>nno,content_3913_7336:()=>pno,content_3913_7338:()=>cno,content_3913_734:()=>Wie,content_3913_7340:()=>lno,content_3913_7342:()=>yno,content_3913_7344:()=>gno,content_3913_7346:()=>Mno,content_3913_7348:()=>wno,content_3913_7350:()=>xno,content_3913_7352:()=>Lno,content_3913_7354:()=>kno,content_3913_7356:()=>Ino,content_3913_7358:()=>Sno,content_3913_736:()=>Eie,content_3913_7360:()=>Gno,content_3913_7362:()=>Fno,content_3913_7364:()=>jno,content_3913_7366:()=>Qno,content_3913_7368:()=>Jno,content_3913_7370:()=>nto,content_3913_7372:()=>pto,content_3913_7374:()=>cto,content_3913_7376:()=>lto,content_3913_7378:()=>yto,content_3913_738:()=>Uie,content_3913_7380:()=>gto,content_3913_7382:()=>Mto,content_3913_7384:()=>wto,content_3913_7386:()=>xto,content_3913_7388:()=>Lto,content_3913_7390:()=>kto,content_3913_7392:()=>Ito,content_3913_7394:()=>Sto,content_3913_7396:()=>Gto,content_3913_7398:()=>Fto,content_3913_74:()=>D3,content_3913_740:()=>qie,content_3913_7400:()=>jto,content_3913_7402:()=>Qto,content_3913_7404:()=>Jto,content_3913_7406:()=>noo,content_3913_7408:()=>poo,content_3913_7410:()=>coo,content_3913_7412:()=>loo,content_3913_7414:()=>yoo,content_3913_7416:()=>goo,content_3913_7418:()=>Moo,content_3913_742:()=>Yie,content_3913_7420:()=>woo,content_3913_7422:()=>xoo,content_3913_7424:()=>Loo,content_3913_7426:()=>koo,content_3913_7428:()=>Ioo,content_3913_7430:()=>Soo,content_3913_7432:()=>Goo,content_3913_7434:()=>Foo,content_3913_7436:()=>joo,content_3913_7438:()=>Qoo,content_3913_744:()=>Kie,content_3913_7440:()=>Joo,content_3913_7442:()=>npo,content_3913_7444:()=>ppo,content_3913_7446:()=>cpo,content_3913_7448:()=>lpo,content_3913_7450:()=>ypo,content_3913_7452:()=>gpo,content_3913_7454:()=>Mpo,content_3913_7456:()=>wpo,content_3913_7458:()=>xpo,content_3913_746:()=>ele,content_3913_7460:()=>Lpo,content_3913_7462:()=>kpo,content_3913_7464:()=>Ipo,content_3913_7466:()=>Spo,content_3913_7468:()=>Gpo,content_3913_7470:()=>Fpo,content_3913_7472:()=>jpo,content_3913_7474:()=>Qpo,content_3913_7476:()=>Jpo,content_3913_7478:()=>nro,content_3913_748:()=>ole,content_3913_7480:()=>pro,content_3913_7482:()=>cro,content_3913_7484:()=>lro,content_3913_7486:()=>yro,content_3913_7488:()=>gro,content_3913_7490:()=>Mro,content_3913_7492:()=>wro,content_3913_7494:()=>xro,content_3913_7496:()=>Lro,content_3913_7498:()=>kro,content_3913_750:()=>sle,content_3913_7500:()=>Iro,content_3913_7502:()=>Sro,content_3913_7504:()=>Gro,content_3913_7506:()=>Fro,content_3913_7508:()=>jro,content_3913_7510:()=>Qro,content_3913_7512:()=>Jro,content_3913_7514:()=>nso,content_3913_7516:()=>pso,content_3913_7518:()=>cso,content_3913_752:()=>ile,content_3913_7520:()=>lso,content_3913_7522:()=>yso,content_3913_7524:()=>gso,content_3913_7526:()=>Mso,content_3913_7528:()=>wso,content_3913_7530:()=>xso,content_3913_7532:()=>Lso,content_3913_7534:()=>kso,content_3913_7536:()=>Iso,content_3913_7538:()=>Sso,content_3913_754:()=>mle,content_3913_7540:()=>Gso,content_3913_7542:()=>Fso,content_3913_7544:()=>jso,content_3913_7546:()=>Qso,content_3913_7548:()=>Jso,content_3913_7550:()=>nco,content_3913_7552:()=>pco,content_3913_7554:()=>cco,content_3913_7556:()=>lco,content_3913_7558:()=>yco,content_3913_756:()=>hle,content_3913_7560:()=>gco,content_3913_7562:()=>Mco,content_3913_7564:()=>wco,content_3913_7566:()=>xco,content_3913_7568:()=>Lco,content_3913_7570:()=>kco,content_3913_7572:()=>Ico,content_3913_7574:()=>Sco,content_3913_7576:()=>Gco,content_3913_7578:()=>Fco,content_3913_758:()=>Dle,content_3913_7580:()=>jco,content_3913_7582:()=>Qco,content_3913_7584:()=>Jco,content_3913_7586:()=>nao,content_3913_7588:()=>pao,content_3913_7590:()=>cao,content_3913_7592:()=>lao,content_3913_7594:()=>yao,content_3913_7596:()=>gao,content_3913_7598:()=>Mao,content_3913_76:()=>_3,content_3913_760:()=>_le,content_3913_7600:()=>wao,content_3913_7602:()=>xao,content_3913_7604:()=>Lao,content_3913_7606:()=>kao,content_3913_7608:()=>Iao,content_3913_7610:()=>Sao,content_3913_7612:()=>Gao,content_3913_7614:()=>Fao,content_3913_7616:()=>jao,content_3913_7618:()=>Qao,content_3913_762:()=>Cle,content_3913_7620:()=>Jao,content_3913_7622:()=>nio,content_3913_7624:()=>pio,content_3913_7626:()=>cio,content_3913_7628:()=>lio,content_3913_7630:()=>yio,content_3913_7632:()=>gio,content_3913_7634:()=>Mio,content_3913_7636:()=>wio,content_3913_7638:()=>xio,content_3913_764:()=>vle,content_3913_7640:()=>Lio,content_3913_7642:()=>kio,content_3913_7644:()=>Iio,content_3913_7646:()=>Sio,content_3913_7648:()=>Gio,content_3913_7650:()=>Fio,content_3913_7652:()=>jio,content_3913_7654:()=>Qio,content_3913_7656:()=>Jio,content_3913_7658:()=>nlo,content_3913_766:()=>Nle,content_3913_7660:()=>plo,content_3913_7662:()=>clo,content_3913_7664:()=>llo,content_3913_7666:()=>ylo,content_3913_7668:()=>glo,content_3913_7670:()=>Mlo,content_3913_7672:()=>wlo,content_3913_7674:()=>xlo,content_3913_7676:()=>Llo,content_3913_7678:()=>klo,content_3913_768:()=>Ple,content_3913_7680:()=>Ilo,content_3913_7682:()=>Slo,content_3913_7684:()=>Glo,content_3913_7686:()=>Flo,content_3913_7688:()=>jlo,content_3913_7690:()=>Qlo,content_3913_7692:()=>Jlo,content_3913_7694:()=>nuo,content_3913_7696:()=>puo,content_3913_7698:()=>cuo,content_3913_770:()=>Wle,content_3913_7700:()=>luo,content_3913_7702:()=>yuo,content_3913_7704:()=>guo,content_3913_7706:()=>Muo,content_3913_7708:()=>wuo,content_3913_7710:()=>xuo,content_3913_7712:()=>Luo,content_3913_7714:()=>kuo,content_3913_7716:()=>Iuo,content_3913_7718:()=>Suo,content_3913_772:()=>Ele,content_3913_7720:()=>Guo,content_3913_7722:()=>Fuo,content_3913_7724:()=>juo,content_3913_7726:()=>Quo,content_3913_7728:()=>Juo,content_3913_7730:()=>nmo,content_3913_7732:()=>pmo,content_3913_7734:()=>cmo,content_3913_7736:()=>lmo,content_3913_7738:()=>ymo,content_3913_774:()=>Ule,content_3913_7740:()=>gmo,content_3913_7742:()=>Mmo,content_3913_7744:()=>wmo,content_3913_7746:()=>xmo,content_3913_7748:()=>Lmo,content_3913_7750:()=>kmo,content_3913_7752:()=>Imo,content_3913_7754:()=>Smo,content_3913_7756:()=>Gmo,content_3913_7758:()=>Fmo,content_3913_776:()=>qle,content_3913_7760:()=>jmo,content_3913_7762:()=>Qmo,content_3913_7764:()=>Jmo,content_3913_7766:()=>nyo,content_3913_7768:()=>pyo,content_3913_7770:()=>cyo,content_3913_7772:()=>lyo,content_3913_7774:()=>yyo,content_3913_7776:()=>gyo,content_3913_7778:()=>Myo,content_3913_778:()=>Yle,content_3913_7780:()=>wyo,content_3913_7782:()=>xyo,content_3913_7784:()=>Lyo,content_3913_7786:()=>kyo,content_3913_7788:()=>Iyo,content_3913_7790:()=>Syo,content_3913_7792:()=>Gyo,content_3913_7794:()=>Fyo,content_3913_7796:()=>jyo,content_3913_7798:()=>Qyo,content_3913_78:()=>C3,content_3913_780:()=>Kle,content_3913_7800:()=>Jyo,content_3913_7802:()=>ndo,content_3913_7804:()=>pdo,content_3913_7806:()=>cdo,content_3913_7808:()=>ldo,content_3913_7810:()=>ydo,content_3913_7812:()=>gdo,content_3913_7814:()=>Mdo,content_3913_7816:()=>wdo,content_3913_7818:()=>xdo,content_3913_782:()=>eue,content_3913_7820:()=>Ldo,content_3913_7822:()=>kdo,content_3913_7824:()=>Ido,content_3913_7826:()=>Sdo,content_3913_7828:()=>Gdo,content_3913_7830:()=>Fdo,content_3913_7832:()=>jdo,content_3913_7834:()=>Qdo,content_3913_7836:()=>Jdo,content_3913_7838:()=>nho,content_3913_784:()=>oue,content_3913_7840:()=>pho,content_3913_7842:()=>cho,content_3913_7844:()=>lho,content_3913_7846:()=>yho,content_3913_7848:()=>gho,content_3913_7850:()=>Mho,content_3913_7852:()=>who,content_3913_7854:()=>xho,content_3913_7856:()=>Lho,content_3913_7858:()=>kho,content_3913_786:()=>sue,content_3913_7860:()=>Iho,content_3913_7862:()=>Sho,content_3913_7864:()=>Gho,content_3913_7866:()=>Fho,content_3913_7868:()=>jho,content_3913_7870:()=>Qho,content_3913_7872:()=>Jho,content_3913_7874:()=>ngo,content_3913_7876:()=>pgo,content_3913_7878:()=>cgo,content_3913_788:()=>iue,content_3913_7880:()=>lgo,content_3913_7882:()=>ygo,content_3913_7884:()=>ggo,content_3913_7886:()=>Mgo,content_3913_7888:()=>wgo,content_3913_7890:()=>xgo,content_3913_7892:()=>Lgo,content_3913_7894:()=>kgo,content_3913_7896:()=>Igo,content_3913_7898:()=>Sgo,content_3913_790:()=>mue,content_3913_7900:()=>Ggo,content_3913_7902:()=>Fgo,content_3913_7904:()=>jgo,content_3913_7906:()=>Qgo,content_3913_7908:()=>Jgo,content_3913_7910:()=>nfo,content_3913_7912:()=>pfo,content_3913_7914:()=>cfo,content_3913_7916:()=>lfo,content_3913_7918:()=>yfo,content_3913_792:()=>hue,content_3913_7920:()=>gfo,content_3913_7922:()=>Mfo,content_3913_7924:()=>wfo,content_3913_7926:()=>xfo,content_3913_7928:()=>Lfo,content_3913_7930:()=>kfo,content_3913_7932:()=>Ifo,content_3913_7934:()=>Sfo,content_3913_7936:()=>Gfo,content_3913_7938:()=>Ffo,content_3913_794:()=>Due,content_3913_7940:()=>jfo,content_3913_7942:()=>Qfo,content_3913_7944:()=>Jfo,content_3913_7946:()=>nDo,content_3913_7948:()=>pDo,content_3913_7950:()=>cDo,content_3913_7952:()=>lDo,content_3913_7954:()=>yDo,content_3913_7956:()=>gDo,content_3913_7958:()=>MDo,content_3913_796:()=>_ue,content_3913_7960:()=>wDo,content_3913_7962:()=>xDo,content_3913_7964:()=>LDo,content_3913_7966:()=>kDo,content_3913_7968:()=>IDo,content_3913_7970:()=>SDo,content_3913_7972:()=>GDo,content_3913_7974:()=>FDo,content_3913_7976:()=>jDo,content_3913_7978:()=>QDo,content_3913_798:()=>Cue,content_3913_7980:()=>JDo,content_3913_7982:()=>nMo,content_3913_7984:()=>pMo,content_3913_7986:()=>cMo,content_3913_7988:()=>lMo,content_3913_7990:()=>yMo,content_3913_7992:()=>gMo,content_3913_7994:()=>MMo,content_3913_7996:()=>wMo,content_3913_7998:()=>xMo,content_3913_8:()=>vZ,content_3913_80:()=>v3,content_3913_800:()=>vue,content_3913_8000:()=>LMo,content_3913_8002:()=>kMo,content_3913_8004:()=>IMo,content_3913_8006:()=>SMo,content_3913_8008:()=>GMo,content_3913_8010:()=>FMo,content_3913_8012:()=>jMo,content_3913_8014:()=>QMo,content_3913_8016:()=>JMo,content_3913_8018:()=>nXo,content_3913_802:()=>Nue,content_3913_8020:()=>pXo,content_3913_8022:()=>cXo,content_3913_8024:()=>lXo,content_3913_8026:()=>yXo,content_3913_8028:()=>gXo,content_3913_8030:()=>MXo,content_3913_8032:()=>wXo,content_3913_8034:()=>xXo,content_3913_8036:()=>LXo,content_3913_8038:()=>kXo,content_3913_804:()=>Pue,content_3913_8040:()=>IXo,content_3913_8042:()=>SXo,content_3913_8044:()=>GXo,content_3913_8046:()=>FXo,content_3913_8048:()=>jXo,content_3913_8050:()=>QXo,content_3913_8052:()=>JXo,content_3913_8054:()=>n_o,content_3913_8056:()=>p_o,content_3913_8058:()=>c_o,content_3913_806:()=>Wue,content_3913_8060:()=>l_o,content_3913_8062:()=>y_o,content_3913_8064:()=>g_o,content_3913_8066:()=>M_o,content_3913_8068:()=>w_o,content_3913_8070:()=>x_o,content_3913_8072:()=>L_o,content_3913_8074:()=>k_o,content_3913_8076:()=>I_o,content_3913_8078:()=>S_o,content_3913_808:()=>Eue,content_3913_8080:()=>G_o,content_3913_8082:()=>F_o,content_3913_8084:()=>j_o,content_3913_8086:()=>Q_o,content_3913_8088:()=>J_o,content_3913_8090:()=>nwo,content_3913_8092:()=>pwo,content_3913_8094:()=>cwo,content_3913_8096:()=>lwo,content_3913_8098:()=>ywo,content_3913_810:()=>Uue,content_3913_8100:()=>gwo,content_3913_8102:()=>Mwo,content_3913_8104:()=>wwo,content_3913_8106:()=>xwo,content_3913_8108:()=>Lwo,content_3913_8110:()=>kwo,content_3913_8112:()=>Iwo,content_3913_8114:()=>Swo,content_3913_8116:()=>Gwo,content_3913_8118:()=>Fwo,content_3913_812:()=>que,content_3913_8120:()=>jwo,content_3913_8122:()=>Qwo,content_3913_8124:()=>Jwo,content_3913_8126:()=>nTo,content_3913_8128:()=>pTo,content_3913_8130:()=>cTo,content_3913_8132:()=>lTo,content_3913_8134:()=>yTo,content_3913_8136:()=>gTo,content_3913_8138:()=>MTo,content_3913_814:()=>Yue,content_3913_8140:()=>wTo,content_3913_8142:()=>xTo,content_3913_8144:()=>LTo,content_3913_8146:()=>kTo,content_3913_8148:()=>ITo,content_3913_8150:()=>STo,content_3913_8152:()=>GTo,content_3913_8154:()=>FTo,content_3913_8156:()=>jTo,content_3913_8158:()=>QTo,content_3913_816:()=>Kue,content_3913_8160:()=>JTo,content_3913_8162:()=>nCo,content_3913_8164:()=>pCo,content_3913_8166:()=>cCo,content_3913_8168:()=>lCo,content_3913_8170:()=>yCo,content_3913_8172:()=>gCo,content_3913_8174:()=>MCo,content_3913_8176:()=>wCo,content_3913_8178:()=>xCo,content_3913_818:()=>eme,content_3913_8180:()=>LCo,content_3913_8182:()=>kCo,content_3913_8184:()=>ICo,content_3913_8186:()=>SCo,content_3913_8188:()=>GCo,content_3913_8190:()=>FCo,content_3913_8192:()=>jCo,content_3913_8194:()=>QCo,content_3913_8196:()=>JCo,content_3913_8198:()=>nxo,content_3913_82:()=>N3,content_3913_820:()=>ome,content_3913_8200:()=>pxo,content_3913_8202:()=>cxo,content_3913_8204:()=>lxo,content_3913_8206:()=>yxo,content_3913_8208:()=>gxo,content_3913_8210:()=>Mxo,content_3913_8212:()=>wxo,content_3913_8214:()=>xxo,content_3913_8216:()=>Lxo,content_3913_8218:()=>kxo,content_3913_822:()=>sme,content_3913_8220:()=>Ixo,content_3913_8222:()=>Sxo,content_3913_8224:()=>Gxo,content_3913_8226:()=>Fxo,content_3913_8228:()=>jxo,content_3913_8230:()=>Qxo,content_3913_8232:()=>Jxo,content_3913_8234:()=>nAo,content_3913_8236:()=>pAo,content_3913_8238:()=>cAo,content_3913_824:()=>ime,content_3913_8240:()=>lAo,content_3913_8242:()=>yAo,content_3913_8244:()=>gAo,content_3913_8246:()=>MAo,content_3913_8248:()=>wAo,content_3913_8250:()=>xAo,content_3913_8252:()=>LAo,content_3913_8254:()=>kAo,content_3913_8256:()=>IAo,content_3913_8258:()=>SAo,content_3913_826:()=>mme,content_3913_8260:()=>GAo,content_3913_8262:()=>FAo,content_3913_8264:()=>jAo,content_3913_8266:()=>QAo,content_3913_8268:()=>JAo,content_3913_8270:()=>nvo,content_3913_8272:()=>pvo,content_3913_8274:()=>cvo,content_3913_8276:()=>lvo,content_3913_8278:()=>yvo,content_3913_828:()=>hme,content_3913_8280:()=>gvo,content_3913_8282:()=>Mvo,content_3913_8284:()=>wvo,content_3913_8286:()=>xvo,content_3913_8288:()=>Lvo,content_3913_8290:()=>kvo,content_3913_8292:()=>Ivo,content_3913_8294:()=>Svo,content_3913_8296:()=>Gvo,content_3913_8298:()=>Fvo,content_3913_830:()=>Dme,content_3913_8300:()=>jvo,content_3913_8302:()=>Qvo,content_3913_8304:()=>Jvo,content_3913_8306:()=>nLo,content_3913_8308:()=>pLo,content_3913_8310:()=>cLo,content_3913_8312:()=>lLo,content_3913_8314:()=>yLo,content_3913_8316:()=>gLo,content_3913_8318:()=>MLo,content_3913_832:()=>_me,content_3913_8320:()=>wLo,content_3913_8322:()=>xLo,content_3913_8324:()=>LLo,content_3913_8326:()=>kLo,content_3913_8328:()=>ILo,content_3913_8330:()=>SLo,content_3913_8332:()=>GLo,content_3913_8334:()=>FLo,content_3913_8336:()=>jLo,content_3913_8338:()=>QLo,content_3913_834:()=>Cme,content_3913_8340:()=>JLo,content_3913_8342:()=>nbo,content_3913_8344:()=>pbo,content_3913_8346:()=>cbo,content_3913_8348:()=>lbo,content_3913_8350:()=>ybo,content_3913_8352:()=>gbo,content_3913_8354:()=>Mbo,content_3913_8356:()=>wbo,content_3913_8358:()=>xbo,content_3913_836:()=>vme,content_3913_8360:()=>Lbo,content_3913_8362:()=>kbo,content_3913_8364:()=>Ibo,content_3913_8366:()=>Sbo,content_3913_8368:()=>Gbo,content_3913_8370:()=>Fbo,content_3913_8372:()=>jbo,content_3913_8374:()=>Qbo,content_3913_8376:()=>Jbo,content_3913_8378:()=>nNo,content_3913_838:()=>Nme,content_3913_8380:()=>pNo,content_3913_8382:()=>cNo,content_3913_8384:()=>lNo,content_3913_8386:()=>yNo,content_3913_8388:()=>gNo,content_3913_8390:()=>MNo,content_3913_8392:()=>wNo,content_3913_8394:()=>xNo,content_3913_8396:()=>LNo,content_3913_8398:()=>kNo,content_3913_84:()=>P3,content_3913_840:()=>Pme,content_3913_8400:()=>INo,content_3913_8402:()=>SNo,content_3913_8404:()=>GNo,content_3913_8406:()=>FNo,content_3913_8408:()=>jNo,content_3913_8410:()=>QNo,content_3913_8412:()=>JNo,content_3913_8414:()=>nko,content_3913_8416:()=>pko,content_3913_8418:()=>cko,content_3913_842:()=>Wme,content_3913_8420:()=>lko,content_3913_8422:()=>yko,content_3913_8424:()=>gko,content_3913_8426:()=>Mko,content_3913_8428:()=>wko,content_3913_8430:()=>xko,content_3913_8432:()=>Lko,content_3913_8434:()=>kko,content_3913_8436:()=>Iko,content_3913_8438:()=>Sko,content_3913_844:()=>Eme,content_3913_8440:()=>Gko,content_3913_8442:()=>Fko,content_3913_8444:()=>jko,content_3913_8446:()=>Qko,content_3913_8448:()=>Jko,content_3913_8450:()=>nzo,content_3913_8452:()=>pzo,content_3913_8454:()=>czo,content_3913_8456:()=>lzo,content_3913_8458:()=>yzo,content_3913_846:()=>Ume,content_3913_8460:()=>gzo,content_3913_8462:()=>Mzo,content_3913_8464:()=>wzo,content_3913_8466:()=>xzo,content_3913_8468:()=>Lzo,content_3913_8470:()=>kzo,content_3913_8472:()=>Izo,content_3913_8474:()=>Szo,content_3913_8476:()=>Gzo,content_3913_8478:()=>Fzo,content_3913_848:()=>qme,content_3913_8480:()=>jzo,content_3913_8482:()=>Qzo,content_3913_8484:()=>Jzo,content_3913_8486:()=>nPo,content_3913_8488:()=>pPo,content_3913_8490:()=>cPo,content_3913_8492:()=>lPo,content_3913_8494:()=>yPo,content_3913_8496:()=>gPo,content_3913_8498:()=>MPo,content_3913_850:()=>Yme,content_3913_8500:()=>wPo,content_3913_8502:()=>xPo,content_3913_8504:()=>LPo,content_3913_8506:()=>kPo,content_3913_8508:()=>IPo,content_3913_8510:()=>SPo,content_3913_8512:()=>GPo,content_3913_8514:()=>FPo,content_3913_8516:()=>jPo,content_3913_8518:()=>QPo,content_3913_852:()=>Kme,content_3913_8520:()=>JPo,content_3913_8522:()=>nIo,content_3913_8524:()=>pIo,content_3913_8526:()=>cIo,content_3913_8528:()=>lIo,content_3913_8530:()=>yIo,content_3913_8532:()=>gIo,content_3913_8534:()=>MIo,content_3913_8536:()=>wIo,content_3913_8538:()=>xIo,content_3913_854:()=>eye,content_3913_8540:()=>LIo,content_3913_8542:()=>kIo,content_3913_8544:()=>IIo,content_3913_8546:()=>SIo,content_3913_8548:()=>GIo,content_3913_8550:()=>FIo,content_3913_8552:()=>jIo,content_3913_8554:()=>QIo,content_3913_8556:()=>JIo,content_3913_8558:()=>nRo,content_3913_856:()=>oye,content_3913_8560:()=>pRo,content_3913_8562:()=>cRo,content_3913_8564:()=>lRo,content_3913_8566:()=>yRo,content_3913_8568:()=>gRo,content_3913_8570:()=>MRo,content_3913_8572:()=>wRo,content_3913_8574:()=>xRo,content_3913_8576:()=>LRo,content_3913_8578:()=>kRo,content_3913_858:()=>sye,content_3913_8580:()=>IRo,content_3913_8582:()=>SRo,content_3913_8584:()=>GRo,content_3913_8586:()=>FRo,content_3913_8588:()=>jRo,content_3913_8590:()=>QRo,content_3913_8592:()=>JRo,content_3913_8594:()=>nWo,content_3913_8596:()=>pWo,content_3913_8598:()=>cWo,content_3913_86:()=>W3,content_3913_860:()=>iye,content_3913_8600:()=>lWo,content_3913_8602:()=>yWo,content_3913_8604:()=>gWo,content_3913_8606:()=>MWo,content_3913_8608:()=>wWo,content_3913_8610:()=>xWo,content_3913_8612:()=>LWo,content_3913_8614:()=>kWo,content_3913_8616:()=>IWo,content_3913_8618:()=>SWo,content_3913_862:()=>mye,content_3913_8620:()=>GWo,content_3913_8622:()=>FWo,content_3913_8624:()=>jWo,content_3913_8626:()=>QWo,content_3913_8628:()=>JWo,content_3913_8630:()=>nSo,content_3913_8632:()=>pSo,content_3913_8634:()=>cSo,content_3913_8636:()=>lSo,content_3913_8638:()=>ySo,content_3913_864:()=>hye,content_3913_8640:()=>gSo,content_3913_8642:()=>MSo,content_3913_8644:()=>wSo,content_3913_8646:()=>xSo,content_3913_8648:()=>LSo,content_3913_8650:()=>kSo,content_3913_8652:()=>ISo,content_3913_8654:()=>SSo,content_3913_8656:()=>GSo,content_3913_8658:()=>FSo,content_3913_866:()=>Dye,content_3913_8660:()=>jSo,content_3913_8662:()=>QSo,content_3913_8664:()=>JSo,content_3913_8666:()=>nBo,content_3913_8668:()=>pBo,content_3913_8670:()=>cBo,content_3913_8672:()=>lBo,content_3913_8674:()=>yBo,content_3913_8676:()=>gBo,content_3913_8678:()=>MBo,content_3913_868:()=>_ye,content_3913_8680:()=>wBo,content_3913_8682:()=>xBo,content_3913_8684:()=>LBo,content_3913_8686:()=>kBo,content_3913_8688:()=>IBo,content_3913_8690:()=>SBo,content_3913_8692:()=>GBo,content_3913_8694:()=>FBo,content_3913_8696:()=>jBo,content_3913_8698:()=>QBo,content_3913_870:()=>Cye,content_3913_8700:()=>JBo,content_3913_8702:()=>nEo,content_3913_8704:()=>pEo,content_3913_8706:()=>cEo,content_3913_8708:()=>lEo,content_3913_8710:()=>yEo,content_3913_8712:()=>gEo,content_3913_8714:()=>MEo,content_3913_8716:()=>wEo,content_3913_8718:()=>xEo,content_3913_872:()=>vye,content_3913_8720:()=>LEo,content_3913_8722:()=>kEo,content_3913_8724:()=>IEo,content_3913_8726:()=>SEo,content_3913_8728:()=>GEo,content_3913_8730:()=>FEo,content_3913_8732:()=>jEo,content_3913_8734:()=>QEo,content_3913_8736:()=>JEo,content_3913_8738:()=>nGo,content_3913_874:()=>Nye,content_3913_8740:()=>pGo,content_3913_8742:()=>cGo,content_3913_8744:()=>lGo,content_3913_8746:()=>yGo,content_3913_8748:()=>gGo,content_3913_8750:()=>MGo,content_3913_8752:()=>wGo,content_3913_8754:()=>xGo,content_3913_8756:()=>LGo,content_3913_8758:()=>kGo,content_3913_876:()=>Pye,content_3913_8760:()=>IGo,content_3913_8762:()=>SGo,content_3913_8764:()=>GGo,content_3913_8766:()=>FGo,content_3913_8768:()=>jGo,content_3913_8770:()=>QGo,content_3913_8772:()=>JGo,content_3913_8774:()=>nOo,content_3913_8776:()=>pOo,content_3913_8778:()=>cOo,content_3913_878:()=>Wye,content_3913_8780:()=>lOo,content_3913_8782:()=>yOo,content_3913_8784:()=>gOo,content_3913_8786:()=>MOo,content_3913_8788:()=>wOo,content_3913_8790:()=>xOo,content_3913_8792:()=>LOo,content_3913_8794:()=>kOo,content_3913_8796:()=>IOo,content_3913_8798:()=>SOo,content_3913_88:()=>E3,content_3913_880:()=>Eye,content_3913_8800:()=>GOo,content_3913_8802:()=>FOo,content_3913_8804:()=>jOo,content_3913_8806:()=>QOo,content_3913_8808:()=>JOo,content_3913_8810:()=>nUo,content_3913_8812:()=>pUo,content_3913_8814:()=>cUo,content_3913_8816:()=>lUo,content_3913_8818:()=>yUo,content_3913_882:()=>Uye,content_3913_8820:()=>gUo,content_3913_8822:()=>MUo,content_3913_8824:()=>wUo,content_3913_8826:()=>xUo,content_3913_8828:()=>LUo,content_3913_8830:()=>kUo,content_3913_8832:()=>IUo,content_3913_8834:()=>SUo,content_3913_8836:()=>GUo,content_3913_8838:()=>FUo,content_3913_884:()=>qye,content_3913_8840:()=>jUo,content_3913_8842:()=>QUo,content_3913_8844:()=>JUo,content_3913_8846:()=>nFo,content_3913_8848:()=>pFo,content_3913_8850:()=>cFo,content_3913_8852:()=>lFo,content_3913_8854:()=>yFo,content_3913_8856:()=>gFo,content_3913_8858:()=>MFo,content_3913_886:()=>Yye,content_3913_8860:()=>wFo,content_3913_8862:()=>xFo,content_3913_8864:()=>LFo,content_3913_8866:()=>kFo,content_3913_8868:()=>IFo,content_3913_8870:()=>SFo,content_3913_8872:()=>GFo,content_3913_8874:()=>FFo,content_3913_8876:()=>jFo,content_3913_8878:()=>QFo,content_3913_888:()=>Kye,content_3913_8880:()=>JFo,content_3913_8882:()=>nVo,content_3913_8884:()=>pVo,content_3913_8886:()=>cVo,content_3913_8888:()=>lVo,content_3913_8890:()=>yVo,content_3913_8892:()=>gVo,content_3913_8894:()=>MVo,content_3913_8896:()=>wVo,content_3913_8898:()=>xVo,content_3913_890:()=>ede,content_3913_8900:()=>LVo,content_3913_8902:()=>kVo,content_3913_8904:()=>IVo,content_3913_8906:()=>SVo,content_3913_8908:()=>GVo,content_3913_8910:()=>FVo,content_3913_8912:()=>jVo,content_3913_8914:()=>QVo,content_3913_8916:()=>JVo,content_3913_8918:()=>nqo,content_3913_892:()=>ode,content_3913_8920:()=>pqo,content_3913_8922:()=>cqo,content_3913_8924:()=>lqo,content_3913_8926:()=>yqo,content_3913_8928:()=>gqo,content_3913_8930:()=>Mqo,content_3913_8932:()=>wqo,content_3913_8934:()=>xqo,content_3913_8936:()=>Lqo,content_3913_8938:()=>kqo,content_3913_894:()=>sde,content_3913_8940:()=>Iqo,content_3913_8942:()=>Sqo,content_3913_8944:()=>Gqo,content_3913_8946:()=>Fqo,content_3913_8948:()=>jqo,content_3913_8950:()=>Qqo,content_3913_8952:()=>Jqo,content_3913_8954:()=>njo,content_3913_8956:()=>pjo,content_3913_8958:()=>cjo,content_3913_896:()=>ide,content_3913_8960:()=>ljo,content_3913_8962:()=>yjo,content_3913_8964:()=>gjo,content_3913_8966:()=>Mjo,content_3913_8968:()=>wjo,content_3913_8970:()=>xjo,content_3913_8972:()=>Ljo,content_3913_8974:()=>kjo,content_3913_8976:()=>Ijo,content_3913_8978:()=>Sjo,content_3913_898:()=>mde,content_3913_8980:()=>Gjo,content_3913_8982:()=>Fjo,content_3913_8984:()=>jjo,content_3913_8986:()=>Qjo,content_3913_8988:()=>Jjo,content_3913_8990:()=>nHo,content_3913_8992:()=>pHo,content_3913_8994:()=>cHo,content_3913_8996:()=>lHo,content_3913_8998:()=>yHo,content_3913_90:()=>U3,content_3913_900:()=>hde,content_3913_9000:()=>gHo,content_3913_9002:()=>MHo,content_3913_9004:()=>wHo,content_3913_9006:()=>xHo,content_3913_9008:()=>LHo,content_3913_9010:()=>kHo,content_3913_9012:()=>IHo,content_3913_9014:()=>SHo,content_3913_9016:()=>GHo,content_3913_9018:()=>FHo,content_3913_902:()=>Dde,content_3913_9020:()=>jHo,content_3913_9022:()=>QHo,content_3913_9024:()=>JHo,content_3913_9026:()=>nYo,content_3913_9028:()=>pYo,content_3913_9030:()=>cYo,content_3913_9032:()=>lYo,content_3913_9034:()=>yYo,content_3913_9036:()=>gYo,content_3913_9038:()=>MYo,content_3913_904:()=>_de,content_3913_9040:()=>wYo,content_3913_9042:()=>xYo,content_3913_9044:()=>LYo,content_3913_9046:()=>kYo,content_3913_9048:()=>IYo,content_3913_9050:()=>SYo,content_3913_9052:()=>GYo,content_3913_9054:()=>FYo,content_3913_9056:()=>jYo,content_3913_9058:()=>QYo,content_3913_906:()=>Cde,content_3913_9060:()=>JYo,content_3913_9062:()=>nQo,content_3913_9064:()=>pQo,content_3913_9066:()=>cQo,content_3913_9068:()=>lQo,content_3913_9070:()=>yQo,content_3913_9072:()=>gQo,content_3913_9074:()=>MQo,content_3913_9076:()=>wQo,content_3913_9078:()=>xQo,content_3913_908:()=>vde,content_3913_9080:()=>LQo,content_3913_9082:()=>kQo,content_3913_9084:()=>IQo,content_3913_9086:()=>SQo,content_3913_9088:()=>GQo,content_3913_9090:()=>FQo,content_3913_9092:()=>jQo,content_3913_9094:()=>QQo,content_3913_9096:()=>JQo,content_3913_9098:()=>n$o,content_3913_910:()=>Nde,content_3913_9100:()=>p$o,content_3913_9102:()=>c$o,content_3913_9104:()=>l$o,content_3913_9106:()=>y$o,content_3913_9108:()=>g$o,content_3913_9110:()=>M$o,content_3913_9112:()=>w$o,content_3913_9114:()=>x$o,content_3913_9116:()=>L$o,content_3913_9118:()=>k$o,content_3913_912:()=>Pde,content_3913_9120:()=>I$o,content_3913_9122:()=>S$o,content_3913_9124:()=>G$o,content_3913_9126:()=>F$o,content_3913_9128:()=>j$o,content_3913_9130:()=>Q$o,content_3913_9132:()=>J$o,content_3913_9134:()=>nKo,content_3913_9136:()=>pKo,content_3913_9138:()=>cKo,content_3913_914:()=>Wde,content_3913_9140:()=>lKo,content_3913_9142:()=>yKo,content_3913_9144:()=>gKo,content_3913_9146:()=>MKo,content_3913_9148:()=>wKo,content_3913_9150:()=>xKo,content_3913_9152:()=>LKo,content_3913_9154:()=>kKo,content_3913_9156:()=>IKo,content_3913_9158:()=>SKo,content_3913_916:()=>Ede,content_3913_9160:()=>GKo,content_3913_9162:()=>FKo,content_3913_9164:()=>jKo,content_3913_9166:()=>QKo,content_3913_9168:()=>JKo,content_3913_9170:()=>nJo,content_3913_9172:()=>pJo,content_3913_9174:()=>cJo,content_3913_9176:()=>lJo,content_3913_9178:()=>yJo,content_3913_918:()=>Ude,content_3913_9180:()=>gJo,content_3913_9182:()=>MJo,content_3913_9184:()=>wJo,content_3913_9186:()=>xJo,content_3913_9188:()=>LJo,content_3913_9190:()=>kJo,content_3913_9192:()=>IJo,content_3913_9194:()=>SJo,content_3913_9196:()=>GJo,content_3913_9198:()=>FJo,content_3913_92:()=>q3,content_3913_920:()=>qde,content_3913_9200:()=>jJo,content_3913_9202:()=>QJo,content_3913_9204:()=>JJo,content_3913_9206:()=>nZo,content_3913_9208:()=>pZo,content_3913_9210:()=>cZo,content_3913_9212:()=>lZo,content_3913_9214:()=>yZo,content_3913_9216:()=>gZo,content_3913_9218:()=>MZo,content_3913_922:()=>Yde,content_3913_9220:()=>wZo,content_3913_9222:()=>xZo,content_3913_9224:()=>LZo,content_3913_9226:()=>kZo,content_3913_9228:()=>IZo,content_3913_9230:()=>SZo,content_3913_9232:()=>GZo,content_3913_9234:()=>FZo,content_3913_9236:()=>jZo,content_3913_9238:()=>QZo,content_3913_924:()=>Kde,content_3913_9240:()=>JZo,content_3913_9242:()=>n0o,content_3913_9244:()=>p0o,content_3913_9246:()=>c0o,content_3913_9248:()=>l0o,content_3913_9250:()=>y0o,content_3913_9252:()=>g0o,content_3913_9254:()=>M0o,content_3913_9256:()=>w0o,content_3913_9258:()=>x0o,content_3913_926:()=>ehe,content_3913_9260:()=>L0o,content_3913_9262:()=>k0o,content_3913_9264:()=>I0o,content_3913_9266:()=>S0o,content_3913_9268:()=>G0o,content_3913_9270:()=>F0o,content_3913_9272:()=>j0o,content_3913_9274:()=>Q0o,content_3913_9276:()=>J0o,content_3913_9278:()=>n3o,content_3913_928:()=>ohe,content_3913_9280:()=>p3o,content_3913_9282:()=>c3o,content_3913_9284:()=>l3o,content_3913_9286:()=>y3o,content_3913_9288:()=>g3o,content_3913_9290:()=>M3o,content_3913_9292:()=>w3o,content_3913_9294:()=>x3o,content_3913_9296:()=>L3o,content_3913_9298:()=>k3o,content_3913_930:()=>she,content_3913_9300:()=>I3o,content_3913_9302:()=>S3o,content_3913_9304:()=>G3o,content_3913_9306:()=>F3o,content_3913_9308:()=>j3o,content_3913_9310:()=>Q3o,content_3913_9312:()=>J3o,content_3913_9314:()=>n1o,content_3913_9316:()=>p1o,content_3913_9318:()=>c1o,content_3913_932:()=>ihe,content_3913_9320:()=>l1o,content_3913_9322:()=>y1o,content_3913_9324:()=>g1o,content_3913_9326:()=>M1o,content_3913_9328:()=>w1o,content_3913_9330:()=>x1o,content_3913_9332:()=>L1o,content_3913_9334:()=>k1o,content_3913_9336:()=>I1o,content_3913_9338:()=>S1o,content_3913_934:()=>mhe,content_3913_9340:()=>G1o,content_3913_9342:()=>F1o,content_3913_9344:()=>j1o,content_3913_9346:()=>Q1o,content_3913_9348:()=>J1o,content_3913_9350:()=>n9o,content_3913_9352:()=>p9o,content_3913_9354:()=>c9o,content_3913_9356:()=>l9o,content_3913_9358:()=>y9o,content_3913_936:()=>hhe,content_3913_9360:()=>g9o,content_3913_9362:()=>M9o,content_3913_9364:()=>w9o,content_3913_9366:()=>x9o,content_3913_9368:()=>L9o,content_3913_9370:()=>k9o,content_3913_9372:()=>I9o,content_3913_9374:()=>S9o,content_3913_9376:()=>G9o,content_3913_9378:()=>F9o,content_3913_938:()=>Dhe,content_3913_9380:()=>j9o,content_3913_9382:()=>Q9o,content_3913_9384:()=>J9o,content_3913_9386:()=>n2o,content_3913_9388:()=>p2o,content_3913_9390:()=>c2o,content_3913_9392:()=>l2o,content_3913_9394:()=>y2o,content_3913_9396:()=>g2o,content_3913_9398:()=>M2o,content_3913_94:()=>Y3,content_3913_940:()=>_he,content_3913_9400:()=>w2o,content_3913_9402:()=>x2o,content_3913_9404:()=>L2o,content_3913_9406:()=>k2o,content_3913_9408:()=>I2o,content_3913_9410:()=>S2o,content_3913_9412:()=>G2o,content_3913_9414:()=>F2o,content_3913_9416:()=>j2o,content_3913_9418:()=>Q2o,content_3913_942:()=>Che,content_3913_9420:()=>J2o,content_3913_9422:()=>n4o,content_3913_9424:()=>p4o,content_3913_9426:()=>c4o,content_3913_9428:()=>l4o,content_3913_9430:()=>y4o,content_3913_9432:()=>g4o,content_3913_9434:()=>M4o,content_3913_9436:()=>w4o,content_3913_9438:()=>x4o,content_3913_944:()=>vhe,content_3913_9440:()=>L4o,content_3913_9442:()=>k4o,content_3913_9444:()=>I4o,content_3913_9446:()=>S4o,content_3913_9448:()=>G4o,content_3913_9450:()=>F4o,content_3913_9452:()=>j4o,content_3913_9454:()=>Q4o,content_3913_9456:()=>J4o,content_3913_9458:()=>n6o,content_3913_946:()=>Nhe,content_3913_9460:()=>p6o,content_3913_9462:()=>c6o,content_3913_9464:()=>l6o,content_3913_9466:()=>y6o,content_3913_9468:()=>g6o,content_3913_9470:()=>M6o,content_3913_9472:()=>w6o,content_3913_9474:()=>x6o,content_3913_9476:()=>L6o,content_3913_9478:()=>k6o,content_3913_948:()=>Phe,content_3913_9480:()=>I6o,content_3913_9482:()=>S6o,content_3913_9484:()=>G6o,content_3913_9486:()=>F6o,content_3913_9488:()=>j6o,content_3913_9490:()=>Q6o,content_3913_9492:()=>J6o,content_3913_9494:()=>n8o,content_3913_9496:()=>p8o,content_3913_9498:()=>c8o,content_3913_950:()=>Whe,content_3913_9500:()=>l8o,content_3913_9502:()=>y8o,content_3913_9504:()=>g8o,content_3913_9506:()=>M8o,content_3913_9508:()=>w8o,content_3913_9510:()=>x8o,content_3913_9512:()=>L8o,content_3913_9514:()=>k8o,content_3913_9516:()=>I8o,content_3913_9518:()=>S8o,content_3913_952:()=>Ehe,content_3913_9520:()=>G8o,content_3913_9522:()=>F8o,content_3913_9524:()=>j8o,content_3913_9526:()=>Q8o,content_3913_9528:()=>J8o,content_3913_9530:()=>n5o,content_3913_9532:()=>p5o,content_3913_9534:()=>c5o,content_3913_9536:()=>l5o,content_3913_9538:()=>y5o,content_3913_954:()=>Uhe,content_3913_9540:()=>g5o,content_3913_9542:()=>M5o,content_3913_9544:()=>w5o,content_3913_9546:()=>x5o,content_3913_9548:()=>L5o,content_3913_9550:()=>k5o,content_3913_9552:()=>I5o,content_3913_9554:()=>S5o,content_3913_9556:()=>G5o,content_3913_9558:()=>F5o,content_3913_956:()=>qhe,content_3913_9560:()=>j5o,content_3913_9562:()=>Q5o,content_3913_9564:()=>J5o,content_3913_9566:()=>n7o,content_3913_9568:()=>p7o,content_3913_9570:()=>c7o,content_3913_9572:()=>l7o,content_3913_9574:()=>y7o,content_3913_9576:()=>g7o,content_3913_9578:()=>M7o,content_3913_958:()=>Yhe,content_3913_9580:()=>w7o,content_3913_9582:()=>x7o,content_3913_9584:()=>L7o,content_3913_9586:()=>k7o,content_3913_9588:()=>I7o,content_3913_9590:()=>S7o,content_3913_9592:()=>G7o,content_3913_9594:()=>F7o,content_3913_9596:()=>j7o,content_3913_9598:()=>Q7o,content_3913_96:()=>K3,content_3913_960:()=>Khe,content_3913_9600:()=>J7o,content_3913_9602:()=>nep,content_3913_9604:()=>pep,content_3913_9606:()=>cep,content_3913_9608:()=>lep,content_3913_9610:()=>yep,content_3913_9612:()=>gep,content_3913_9614:()=>Mep,content_3913_9616:()=>wep,content_3913_9618:()=>xep,content_3913_962:()=>ege,content_3913_9620:()=>Lep,content_3913_9622:()=>kep,content_3913_9624:()=>Iep,content_3913_9626:()=>Sep,content_3913_9628:()=>Gep,content_3913_9630:()=>Fep,content_3913_9632:()=>jep,content_3913_9634:()=>Qep,content_3913_9636:()=>Jep,content_3913_9638:()=>nnp,content_3913_964:()=>oge,content_3913_9640:()=>pnp,content_3913_9642:()=>cnp,content_3913_9644:()=>lnp,content_3913_9646:()=>ynp,content_3913_9648:()=>gnp,content_3913_9650:()=>Mnp,content_3913_9652:()=>wnp,content_3913_9654:()=>xnp,content_3913_9656:()=>Lnp,content_3913_9658:()=>knp,content_3913_966:()=>sge,content_3913_9660:()=>Inp,content_3913_9662:()=>Snp,content_3913_9664:()=>Gnp,content_3913_9666:()=>Fnp,content_3913_9668:()=>jnp,content_3913_9670:()=>Qnp,content_3913_9672:()=>Jnp,content_3913_9674:()=>ntp,content_3913_9676:()=>ptp,content_3913_9678:()=>ctp,content_3913_968:()=>ige,content_3913_9680:()=>ltp,content_3913_9682:()=>ytp,content_3913_9684:()=>gtp,content_3913_9686:()=>Mtp,content_3913_9688:()=>wtp,content_3913_9690:()=>xtp,content_3913_9692:()=>Ltp,content_3913_9694:()=>ktp,content_3913_9696:()=>Itp,content_3913_9698:()=>Stp,content_3913_970:()=>mge,content_3913_9700:()=>Gtp,content_3913_9702:()=>Ftp,content_3913_9704:()=>jtp,content_3913_9706:()=>Qtp,content_3913_9708:()=>Jtp,content_3913_9710:()=>nop,content_3913_9712:()=>pop,content_3913_9714:()=>cop,content_3913_9716:()=>lop,content_3913_9718:()=>yop,content_3913_972:()=>hge,content_3913_9720:()=>gop,content_3913_9722:()=>Mop,content_3913_9724:()=>wop,content_3913_9726:()=>xop,content_3913_9728:()=>Lop,content_3913_9730:()=>kop,content_3913_9732:()=>Iop,content_3913_9734:()=>Sop,content_3913_9736:()=>Gop,content_3913_9738:()=>Fop,content_3913_974:()=>Dge,content_3913_9740:()=>jop,content_3913_9742:()=>Qop,content_3913_9744:()=>Jop,content_3913_9746:()=>npp,content_3913_9748:()=>ppp,content_3913_9750:()=>cpp,content_3913_9752:()=>lpp,content_3913_9754:()=>ypp,content_3913_9756:()=>gpp,content_3913_9758:()=>Mpp,content_3913_976:()=>_ge,content_3913_9760:()=>wpp,content_3913_9762:()=>xpp,content_3913_9764:()=>Lpp,content_3913_9766:()=>kpp,content_3913_9768:()=>Ipp,content_3913_9770:()=>Spp,content_3913_9772:()=>Gpp,content_3913_9774:()=>Fpp,content_3913_9776:()=>jpp,content_3913_9778:()=>Qpp,content_3913_978:()=>Cge,content_3913_9780:()=>Jpp,content_3913_9782:()=>nrp,content_3913_9784:()=>prp,content_3913_9786:()=>crp,content_3913_9788:()=>lrp,content_3913_9790:()=>yrp,content_3913_9792:()=>grp,content_3913_9794:()=>Mrp,content_3913_9796:()=>wrp,content_3913_9798:()=>xrp,content_3913_98:()=>e1,content_3913_980:()=>vge,content_3913_9800:()=>Lrp,content_3913_9802:()=>krp,content_3913_9804:()=>Irp,content_3913_9806:()=>Srp,content_3913_9808:()=>Grp,content_3913_9810:()=>Frp,content_3913_9812:()=>jrp,content_3913_9814:()=>Qrp,content_3913_9816:()=>Jrp,content_3913_9818:()=>nsp,content_3913_982:()=>Nge,content_3913_9820:()=>psp,content_3913_9822:()=>csp,content_3913_9824:()=>lsp,content_3913_9826:()=>ysp,content_3913_9828:()=>gsp,content_3913_9830:()=>Msp,content_3913_9832:()=>wsp,content_3913_9834:()=>xsp,content_3913_9836:()=>Lsp,content_3913_9838:()=>ksp,content_3913_984:()=>Pge,content_3913_9840:()=>Isp,content_3913_9842:()=>Ssp,content_3913_9844:()=>Gsp,content_3913_9846:()=>Fsp,content_3913_9848:()=>jsp,content_3913_9850:()=>Qsp,content_3913_9852:()=>Jsp,content_3913_9854:()=>ncp,content_3913_9856:()=>pcp,content_3913_9858:()=>ccp,content_3913_986:()=>Wge,content_3913_9860:()=>lcp,content_3913_9862:()=>ycp,content_3913_9864:()=>gcp,content_3913_9866:()=>Mcp,content_3913_9868:()=>wcp,content_3913_9870:()=>xcp,content_3913_9872:()=>Lcp,content_3913_9874:()=>kcp,content_3913_9876:()=>Icp,content_3913_9878:()=>Scp,content_3913_988:()=>Ege,content_3913_9880:()=>Gcp,content_3913_9882:()=>Fcp,content_3913_9884:()=>jcp,content_3913_9886:()=>Qcp,content_3913_9888:()=>Jcp,content_3913_9890:()=>nap,content_3913_9892:()=>pap,content_3913_9894:()=>cap,content_3913_9896:()=>lap,content_3913_9898:()=>yap,content_3913_990:()=>Uge,content_3913_9900:()=>gap,content_3913_9902:()=>Map,content_3913_9904:()=>wap,content_3913_9906:()=>xap,content_3913_9908:()=>Lap,content_3913_9910:()=>kap,content_3913_9912:()=>Iap,content_3913_9914:()=>Sap,content_3913_9916:()=>Gap,content_3913_9918:()=>Fap,content_3913_992:()=>qge,content_3913_9920:()=>jap,content_3913_9922:()=>Qap,content_3913_9924:()=>Jap,content_3913_9926:()=>nip,content_3913_9928:()=>pip,content_3913_9930:()=>cip,content_3913_9932:()=>lip,content_3913_9934:()=>yip,content_3913_9936:()=>gip,content_3913_9938:()=>Mip,content_3913_994:()=>Yge,content_3913_9940:()=>wip,content_3913_9942:()=>xip,content_3913_9944:()=>Lip,content_3913_9946:()=>kip,content_3913_9948:()=>Iip,content_3913_9950:()=>Sip,content_3913_9952:()=>Gip,content_3913_9954:()=>Fip,content_3913_9956:()=>jip,content_3913_9958:()=>Qip,content_3913_996:()=>Kge,content_3913_9960:()=>Jip,content_3913_9962:()=>nlp,content_3913_9964:()=>plp,content_3913_9966:()=>clp,content_3913_9968:()=>llp,content_3913_9970:()=>ylp,content_3913_9972:()=>glp,content_3913_9974:()=>Mlp,content_3913_9976:()=>wlp,content_3913_9978:()=>xlp,content_3913_998:()=>efe,content_3913_9980:()=>Llp,content_3913_9982:()=>klp,content_3913_9984:()=>Ilp,content_3913_9986:()=>Slp,content_3913_9988:()=>Glp,content_3913_9990:()=>Flp,content_3913_9992:()=>jlp,content_3913_9994:()=>Qlp,content_3913_9996:()=>Jlp,content_3913_9998:()=>nup});var p=t(9575),r=t(4041),s=t(2247);const c={toc:[]},a="wrapper";function i(e){let{components:n,...t}=e;return(0,s.yg)(a,(0,p.A)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Main Motion Canvas classes."))}i.isMDXComponent=!0;const l={toc:[]},u="wrapper";function m(e){let{components:n,...t}=e;return(0,s.yg)(u,(0,p.A)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when a new message is logged."))}m.isMDXComponent=!0;const y={toc:[]},d="wrapper";function h(e){let{components:n,...t}=e;return(0,s.yg)(d,(0,p.A)({},y,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A read-only representation of the playback."))}h.isMDXComponent=!0;const g={toc:[]},f="wrapper";function D(e){let{components:n,...t}=e;return(0,s.yg)(f,(0,p.A)({},g,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The time passed since the last frame in seconds."))}D.isMDXComponent=!0;const M={toc:[]},X="wrapper";function _(e){let{components:n,...t}=e;return(0,s.yg)(X,(0,p.A)({},M,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert frames to seconds using the current framerate."))}_.isMDXComponent=!0;const w={toc:[]},T="wrapper";function C(e){let{components:n,...t}=e;return(0,s.yg)(T,(0,p.A)({},w,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frames to convert."))}C.isMDXComponent=!0;const x={toc:[]},A="wrapper";function v(e){let{components:n,...t}=e;return(0,s.yg)(A,(0,p.A)({},x,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert seconds to frames using the current framerate."))}v.isMDXComponent=!0;const L={toc:[]},b="wrapper";function N(e){let{components:n,...t}=e;return(0,s.yg)(b,(0,p.A)({},L,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The seconds to convert."))}N.isMDXComponent=!0;const k={toc:[]},z="wrapper";function P(e){let{components:n,...t}=e;return(0,s.yg)(z,(0,p.A)({},k,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This class builds on top of the ",(0,s.yg)("inlineCode",{parentName:"p"},"PlaybackManager")," to provide a simple\ninterface similar to other media players. It plays through the animation\nusing a real-time update loop and optionally synchronises it with audio."))}P.isMDXComponent=!0;const I={toc:[]},R="wrapper";function W(e){let{components:n,...t}=e;return(0,s.yg)(R,(0,p.A)({},I,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The player logic used by the editor and embeddable player."))}W.isMDXComponent=!0;const S={toc:[]},B="wrapper";function E(e){let{components:n,...t}=e;return(0,s.yg)(B,(0,p.A)({},S,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Can be used to provide visual feedback."))}E.isMDXComponent=!0;const G={toc:[]},O="wrapper";function U(e){let{components:n,...t}=e;return(0,s.yg)(O,(0,p.A)({},G,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered right after recalculation finishes."))}U.isMDXComponent=!0;const F={toc:[]},V="wrapper";function q(e){let{components:n,...t}=e;return(0,s.yg)(V,(0,p.A)({},F,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Player does not perform any rendering on its own. For the animation to be\nvisible, another class must subscribe to this event and perform the\nrendering itself. ",(0,s.yg)("a",{parentName:"p",href:"/api/core/app/Stage"},(0,s.yg)("inlineCode",{parentName:"a"},"Stage"))," can be used to display the animation."))}q.isMDXComponent=!0;const j={toc:[]},H="wrapper";function Y(e){let{components:n,...t}=e;return(0,s.yg)(H,(0,p.A)({},j,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered during each iteration of the update loop when the frame is ready\nto be rendered."))}Y.isMDXComponent=!0;const Q={toc:[]},$="wrapper";function K(e){let{components:n,...t}=e;return(0,s.yg)($,(0,p.A)({},Q,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A player needs to be active in order for the update loop to run. Each\nplayer is active by default."))}K.isMDXComponent=!0;const J={toc:[]},Z="wrapper";function ee(e){let{components:n,...t}=e;return(0,s.yg)(Z,(0,p.A)({},J,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Activate the player."))}ee.isMDXComponent=!0;const ne={toc:[]},te="wrapper";function oe(e){let{components:n,...t}=e;return(0,s.yg)(te,(0,p.A)({},ne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Deactivating the player prevents its update loop from running. This should\nbe done before disposing the player, to prevent it from running in the\nbackground."),(0,s.yg)("p",null,"Just pausing the player does not stop the loop."))}oe.isMDXComponent=!0;const pe={toc:[]},re="wrapper";function se(e){let{components:n,...t}=e;return(0,s.yg)(re,(0,p.A)({},pe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Deactivate the player."))}se.isMDXComponent=!0;const ce={toc:[]},ae="wrapper";function ie(e){let{components:n,...t}=e;return(0,s.yg)(ae,(0,p.A)({},ce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the given frame is inside the animation range."))}ie.isMDXComponent=!0;const le={toc:[]},ue="wrapper";function me(e){let{components:n,...t}=e;return(0,s.yg)(ue,(0,p.A)({},le,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame to check."))}me.isMDXComponent=!0;const ye={toc:[]},de="wrapper";function he(e){let{components:n,...t}=e;return(0,s.yg)(de,(0,p.A)({},ye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the given frame is inside the user-defined range."))}he.isMDXComponent=!0;const ge={toc:[]},fe="wrapper";function De(e){let{components:n,...t}=e;return(0,s.yg)(fe,(0,p.A)({},ge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame to check."))}De.isMDXComponent=!0;const Me={toc:[]},Xe="wrapper";function _e(e){let{components:n,...t}=e;return(0,s.yg)(Xe,(0,p.A)({},Me,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the root of all assets that use relative paths."),(0,s.yg)("p",null,"e.g. /video.mp4 becomes ",(0,s.yg)("a",{parentName:"p",href:"https://example.com/video.mp4"},"https://example.com/video.mp4")))}_e.isMDXComponent=!0;const we={toc:[]},Te="wrapper";function Ce(e){let{components:n,...t}=e;return(0,s.yg)(Te,(0,p.A)({},we,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The root URL. Including the trailing slash."))}Ce.isMDXComponent=!0;const xe={toc:[]},Ae="wrapper";function ve(e){let{components:n,...t}=e;return(0,s.yg)(Ae,(0,p.A)({},xe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Abort the ongoing presentation process."))}ve.isMDXComponent=!0;const Le={toc:[]},be="wrapper";function Ne(e){let{components:n,...t}=e;return(0,s.yg)(be,(0,p.A)({},Le,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Present the animation."))}Ne.isMDXComponent=!0;const ke={toc:[]},ze="wrapper";function Pe(e){let{components:n,...t}=e;return(0,s.yg)(ze,(0,p.A)({},ke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The presentation settings."))}Pe.isMDXComponent=!0;const Ie={toc:[]},Re="wrapper";function We(e){let{components:n,...t}=e;return(0,s.yg)(Re,(0,p.A)({},Ie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Resume the presentation if waiting for the next slide."))}We.isMDXComponent=!0;const Se={toc:[]},Be="wrapper";function Ee(e){let{components:n,...t}=e;return(0,s.yg)(Be,(0,p.A)({},Se,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}Ee.isMDXComponent=!0;const Ge={toc:[]},Oe="wrapper";function Ue(e){let{components:n,...t}=e;return(0,s.yg)(Oe,(0,p.A)({},Ge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}Ue.isMDXComponent=!0;const Fe={toc:[]},Ve="wrapper";function qe(e){let{components:n,...t}=e;return(0,s.yg)(Ve,(0,p.A)({},Fe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}qe.isMDXComponent=!0;const je={toc:[]},He="wrapper";function Ye(e){let{components:n,...t}=e;return(0,s.yg)(He,(0,p.A)({},je,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}Ye.isMDXComponent=!0;const Qe={toc:[]},$e="wrapper";function Ke(e){let{components:n,...t}=e;return(0,s.yg)($e,(0,p.A)({},Qe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the nested fields change."))}Ke.isMDXComponent=!0;const Je={toc:[]},Ze="wrapper";function en(e){let{components:n,...t}=e;return(0,s.yg)(Ze,(0,p.A)({},Je,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}en.isMDXComponent=!0;const nn={toc:[]},tn="wrapper";function on(e){let{components:n,...t}=e;return(0,s.yg)(tn,(0,p.A)({},nn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}on.isMDXComponent=!0;const pn={toc:[]},rn="wrapper";function sn(e){let{components:n,...t}=e;return(0,s.yg)(rn,(0,p.A)({},pn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}sn.isMDXComponent=!0;const cn={toc:[]},an="wrapper";function ln(e){let{components:n,...t}=e;return(0,s.yg)(an,(0,p.A)({},cn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}ln.isMDXComponent=!0;const un={toc:[]},mn="wrapper";function yn(e){let{components:n,...t}=e;return(0,s.yg)(mn,(0,p.A)({},un,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}yn.isMDXComponent=!0;const dn={toc:[]},hn="wrapper";function gn(e){let{components:n,...t}=e;return(0,s.yg)(hn,(0,p.A)({},dn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}gn.isMDXComponent=!0;const fn={toc:[]},Dn="wrapper";function Mn(e){let{components:n,...t}=e;return(0,s.yg)(Dn,(0,p.A)({},fn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}Mn.isMDXComponent=!0;const Xn={toc:[]},_n="wrapper";function wn(e){let{components:n,...t}=e;return(0,s.yg)(_n,(0,p.A)({},Xn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}wn.isMDXComponent=!0;const Tn={toc:[]},Cn="wrapper";function xn(e){let{components:n,...t}=e;return(0,s.yg)(Cn,(0,p.A)({},Tn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}xn.isMDXComponent=!0;const An={toc:[]},vn="wrapper";function Ln(e){let{components:n,...t}=e;return(0,s.yg)(vn,(0,p.A)({},An,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This class uses the ",(0,s.yg)("inlineCode",{parentName:"p"},"PlaybackManager")," to render animations. In contrast to a\nplayer, a renderer does not use an update loop. It plays through the\nanimation as fast as it can, occasionally pausing to keep the UI responsive."),(0,s.yg)("p",null,"The actual exporting is outsourced to an Exporter."))}Ln.isMDXComponent=!0;const bn={toc:[]},Nn="wrapper";function kn(e){let{components:n,...t}=e;return(0,s.yg)(Nn,(0,p.A)({},bn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The rendering logic used by the editor to export animations."))}kn.isMDXComponent=!0;const zn={toc:[]},Pn="wrapper";function In(e){let{components:n,...t}=e;return(0,s.yg)(Pn,(0,p.A)({},zn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Abort the ongoing render process."))}In.isMDXComponent=!0;const Rn={toc:[]},Wn="wrapper";function Sn(e){let{components:n,...t}=e;return(0,s.yg)(Wn,(0,p.A)({},Rn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Returns number of frames that a project will have."))}Sn.isMDXComponent=!0;const Bn={toc:[]},En="wrapper";function Gn(e){let{components:n,...t}=e;return(0,s.yg)(En,(0,p.A)({},Bn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render the animation using the provided settings."))}Gn.isMDXComponent=!0;const On={toc:[]},Un="wrapper";function Fn(e){let{components:n,...t}=e;return(0,s.yg)(Un,(0,p.A)({},On,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The rendering settings."))}Fn.isMDXComponent=!0;const Vn={toc:[]},qn="wrapper";function jn(e){let{components:n,...t}=e;return(0,s.yg)(qn,(0,p.A)({},Vn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method always uses the default ",(0,s.yg)("inlineCode",{parentName:"p"},"ImageExporter"),"."))}jn.isMDXComponent=!0;const Hn={toc:[]},Yn="wrapper";function Qn(e){let{components:n,...t}=e;return(0,s.yg)(Yn,(0,p.A)({},Hn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Export an individual frame."))}Qn.isMDXComponent=!0;const $n={toc:[]},Kn="wrapper";function Jn(e){let{components:n,...t}=e;return(0,s.yg)(Kn,(0,p.A)({},$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The rendering settings."))}Jn.isMDXComponent=!0;const Zn={toc:[]},et="wrapper";function nt(e){let{components:n,...t}=e;return(0,s.yg)(et,(0,p.A)({},Zn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timestamp to export."))}nt.isMDXComponent=!0;const tt={toc:[]},ot="wrapper";function pt(e){let{components:n,...t}=e;return(0,s.yg)(ot,(0,p.A)({},tt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Dispose the WebGL context to free up resources."))}pt.isMDXComponent=!0;const rt={toc:[]},st="wrapper";function ct(e){let{components:n,...t}=e;return(0,s.yg)(st,(0,p.A)({},rt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Manages canvases on which an animation can be displayed."))}ct.isMDXComponent=!0;const at={toc:[]},it="wrapper";function lt(e){let{components:n,...t}=e;return(0,s.yg)(it,(0,p.A)({},at,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When displayed in the editor, the log entry will have the following format:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre"},"                             inspect node \u2510\n  \u250c expand more          duration \u2510       \u2502\n  \u25bc                               \u25bc       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 \u25b6 message                       300 ms (+) \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 remarks                                    \u2502\n\u2502 object                                     \u2502\n\u2502 stacktrace                                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")))}lt.isMDXComponent=!0;const ut={toc:[]},mt="wrapper";function yt(e){let{components:n,...t}=e;return(0,s.yg)(mt,(0,p.A)({},ut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents an individual log entry."))}yt.isMDXComponent=!0;const dt={toc:[]},ht="wrapper";function gt(e){let{components:n,...t}=e;return(0,s.yg)(ht,(0,p.A)({},dt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Can be used to display any duration related to the log.\nThe value is always visible next to the message."))}gt.isMDXComponent=!0;const ft={toc:[]},Dt="wrapper";function Mt(e){let{components:n,...t}=e;return(0,s.yg)(Dt,(0,p.A)({},ft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional duration in milliseconds."))}Mt.isMDXComponent=!0;const Xt={toc:[]},_t="wrapper";function wt(e){let{components:n,...t}=e;return(0,s.yg)(_t,(0,p.A)({},Xt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This will be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Inspectable"},(0,s.yg)("inlineCode",{parentName:"a"},"Inspectable")),' interface to\ndisplay additional information about the inspected object.\nWhen specified, the log will have an "inspect" button that will open the\n"Properties" tab and select the inspected object.'))}wt.isMDXComponent=!0;const Tt={toc:[]},Ct="wrapper";function xt(e){let{components:n,...t}=e;return(0,s.yg)(Ct,(0,p.A)({},Tt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional key used to inspect a related object."))}xt.isMDXComponent=!0;const At={toc:[]},vt="wrapper";function Lt(e){let{components:n,...t}=e;return(0,s.yg)(vt,(0,p.A)({},At,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The log level."))}Lt.isMDXComponent=!0;const bt={toc:[]},Nt="wrapper";function kt(e){let{components:n,...t}=e;return(0,s.yg)(Nt,(0,p.A)({},bt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Always visible."))}kt.isMDXComponent=!0;const zt={toc:[]},Pt="wrapper";function It(e){let{components:n,...t}=e;return(0,s.yg)(Pt,(0,p.A)({},zt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The main message of the log."))}It.isMDXComponent=!0;const Rt={toc:[]},Wt="wrapper";function St(e){let{components:n,...t}=e;return(0,s.yg)(Wt,(0,p.A)({},Rt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Visible only when the log is expanded."))}St.isMDXComponent=!0;const Bt={toc:[]},Et="wrapper";function Gt(e){let{components:n,...t}=e;return(0,s.yg)(Et,(0,p.A)({},Bt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An object that will be serialized as JSON and displayed under the message."))}Gt.isMDXComponent=!0;const Ot={toc:[]},Ut="wrapper";function Ft(e){let{components:n,...t}=e;return(0,s.yg)(Ut,(0,p.A)({},Ot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Visible only when the log is expanded."))}Ft.isMDXComponent=!0;const Vt={toc:[]},qt="wrapper";function jt(e){let{components:n,...t}=e;return(0,s.yg)(qt,(0,p.A)({},Vt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Additional information about the log."))}jt.isMDXComponent=!0;const Ht={toc:[]},Yt="wrapper";function Qt(e){let{components:n,...t}=e;return(0,s.yg)(Yt,(0,p.A)({},Ht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Visible only when the log is expanded.\nThe current stack trace can be obtained using ",(0,s.yg)("inlineCode",{parentName:"p"},"new Error().stack"),".\nBoth Chromium and Firefox stack traces are supported."))}Qt.isMDXComponent=!0;const $t={toc:[]},Kt="wrapper";function Jt(e){let{components:n,...t}=e;return(0,s.yg)(Kt,(0,p.A)({},$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The stack trace of the log."))}Jt.isMDXComponent=!0;const Zt={toc:[]},eo="wrapper";function no(e){let{components:n,...t}=e;return(0,s.yg)(eo,(0,p.A)({},Zt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("a",{parentName:"p",href:"https://motioncanvas.io/docs/media#audio"},"https://motioncanvas.io/docs/media#audio")))}no.isMDXComponent=!0;const to={toc:[]},oo="wrapper";function po(e){let{components:n,...t}=e;return(0,s.yg)(oo,(0,p.A)({},to,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An url for the audio track to play alongside the animation."))}po.isMDXComponent=!0;const ro={toc:[]},so="wrapper";function co(e){let{components:n,...t}=e;return(0,s.yg)(so,(0,p.A)({},ro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Configure the offset in the Video Settings tab of th editor."))}co.isMDXComponent=!0;const ao={toc:[]},io="wrapper";function lo(e){let{components:n,...t}=e;return(0,s.yg)(io,(0,p.A)({},ao,t,{components:n,mdxType:"MDXLayout"}))}lo.isMDXComponent=!0;const uo={toc:[]},mo="wrapper";function yo(e){let{components:n,...t}=e;return(0,s.yg)(mo,(0,p.A)({},uo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("a",{parentName:"p",href:"https://motioncanvas.io/docs/experimental"},"https://motioncanvas.io/docs/experimental")))}yo.isMDXComponent=!0;const ho={toc:[]},go="wrapper";function fo(e){let{components:n,...t}=e;return(0,s.yg)(go,(0,p.A)({},ho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enable experimental features."))}fo.isMDXComponent=!0;const Do={toc:[]},Mo="wrapper";function Xo(e){let{components:n,...t}=e;return(0,s.yg)(Mo,(0,p.A)({},Do,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A custom logger instance to use."))}Xo.isMDXComponent=!0;const _o={toc:[]},wo="wrapper";function To(e){let{components:n,...t}=e;return(0,s.yg)(wo,(0,p.A)({},_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of the project."))}To.isMDXComponent=!0;const Co={toc:[]},xo="wrapper";function Ao(e){let{components:n,...t}=e;return(0,s.yg)(xo,(0,p.A)({},Co,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When a string is provided, the plugin will be imported dynamically using\nthe string as the module specifier. This is the preferred way to include\neditor plugins because it makes sure that the plugin's source code gets\nexcluded from the production build."))}Ao.isMDXComponent=!0;const vo={toc:[]},Lo="wrapper";function bo(e){let{components:n,...t}=e;return(0,s.yg)(Lo,(0,p.A)({},vo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of plugins to include in the project."))}bo.isMDXComponent=!0;const No={toc:[]},ko="wrapper";function zo(e){let{components:n,...t}=e;return(0,s.yg)(ko,(0,p.A)({},No,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A full scene description can be obtained by loading a scene module with a\n",(0,s.yg)("inlineCode",{parentName:"p"},"?scene")," query parameter."))}zo.isMDXComponent=!0;const Po={toc:[]},Io="wrapper";function Ro(e){let{components:n,...t}=e;return(0,s.yg)(Io,(0,p.A)({},Po,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"import exampleScene from './example?scene';\n\nexport default makeProject({\n  scenes: [exampleScene],\n});\n")))}Ro.isMDXComponent=!0;const Wo={toc:[]},So="wrapper";function Bo(e){let{components:n,...t}=e;return(0,s.yg)(So,(0,p.A)({},Wo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of scene descriptions that make up the project."))}Bo.isMDXComponent=!0;const Eo={toc:[]},Go="wrapper";function Oo(e){let{components:n,...t}=e;return(0,s.yg)(Go,(0,p.A)({},Eo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("a",{parentName:"p",href:"https://motioncanvas.io/docs/project-variables"},"https://motioncanvas.io/docs/project-variables")))}Oo.isMDXComponent=!0;const Uo={toc:[]},Fo="wrapper";function Vo(e){let{components:n,...t}=e;return(0,s.yg)(Fo,(0,p.A)({},Uo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Default values for project variables."))}Vo.isMDXComponent=!0;const qo={toc:[]},jo="wrapper";function Ho(e){let{components:n,...t}=e;return(0,s.yg)(jo,(0,p.A)({},qo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A runtime representation of the settings metadata."))}Ho.isMDXComponent=!0;const Yo={toc:[]},Qo="wrapper";function $o(e){let{components:n,...t}=e;return(0,s.yg)(Qo,(0,p.A)({},Yo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a runtime representation of the settings metadata."))}$o.isMDXComponent=!0;const Ko={toc:[]},Jo="wrapper";function Zo(e){let{components:n,...t}=e;return(0,s.yg)(Jo,(0,p.A)({},Ko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Property decorators."))}Zo.isMDXComponent=!0;const ep={toc:[]},np="wrapper";function tp(e){let{components:n,...t}=e;return(0,s.yg)(np,(0,p.A)({},ep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A property marked as lazy will not be initialized until it's requested for\nthe first time. Lazy properties are read-only."),(0,s.yg)("p",null,"Must be used for any static properties that require the DOM API to be\ninitialized."))}tp.isMDXComponent=!0;const op={toc:[]},pp="wrapper";function rp(e){let{components:n,...t}=e;return(0,s.yg)(pp,(0,p.A)({},op,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a lazy decorator."))}rp.isMDXComponent=!0;const sp={toc:[]},cp="wrapper";function ap(e){let{components:n,...t}=e;return(0,s.yg)(cp,(0,p.A)({},sp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns the value of this property."))}ap.isMDXComponent=!0;const ip={toc:[]},lp="wrapper";function up(e){let{components:n,...t}=e;return(0,s.yg)(lp,(0,p.A)({},ip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscriptions and triggering of events."))}up.isMDXComponent=!0;const mp={toc:[]},yp="wrapper";function dp(e){let{components:n,...t}=e;return(0,s.yg)(yp,(0,p.A)({},mp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,s.yg)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}dp.isMDXComponent=!0;const hp={toc:[]},gp="wrapper";function fp(e){let{components:n,...t}=e;return(0,s.yg)(gp,(0,p.A)({},hp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}fp.isMDXComponent=!0;const Dp={toc:[]},Mp="wrapper";function Xp(e){let{components:n,...t}=e;return(0,s.yg)(Mp,(0,p.A)({},Dp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Dispatches an asynchronous ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.yg)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}Xp.isMDXComponent=!0;const _p={toc:[]},wp="wrapper";function Tp(e){let{components:n,...t}=e;return(0,s.yg)(wp,(0,p.A)({},_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe all subscribers from the event."))}Tp.isMDXComponent=!0;const Cp={toc:[]},xp="wrapper";function Ap(e){let{components:n,...t}=e;return(0,s.yg)(xp,(0,p.A)({},Cp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A callback function that cancels the subscription."))}Ap.isMDXComponent=!0;const vp={toc:[]},Lp="wrapper";function bp(e){let{components:n,...t}=e;return(0,s.yg)(Lp,(0,p.A)({},vp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."))}bp.isMDXComponent=!0;const Np={toc:[]},kp="wrapper";function zp(e){let{components:n,...t}=e;return(0,s.yg)(kp,(0,p.A)({},Np,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to invoke when the event occurs."))}zp.isMDXComponent=!0;const Pp={toc:[]},Ip="wrapper";function Rp(e){let{components:n,...t}=e;return(0,s.yg)(Ip,(0,p.A)({},Pp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe from the event."))}Rp.isMDXComponent=!0;const Wp={toc:[]},Sp="wrapper";function Bp(e){let{components:n,...t}=e;return(0,s.yg)(Sp,(0,p.A)({},Wp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to unsubscribe."))}Bp.isMDXComponent=!0;const Ep={toc:[]},Gp="wrapper";function Op(e){let{components:n,...t}=e;return(0,s.yg)(Gp,(0,p.A)({},Ep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the argument passed to subscribers."))}Op.isMDXComponent=!0;const Up={toc:[]},Fp="wrapper";function Vp(e){let{components:n,...t}=e;return(0,s.yg)(Fp,(0,p.A)({},Up,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}Vp.isMDXComponent=!0;const qp={toc:[]},jp="wrapper";function Hp(e){let{components:n,...t}=e;return(0,s.yg)(jp,(0,p.A)({},qp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Dispatches a ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.yg)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}Hp.isMDXComponent=!0;const Yp={toc:[]},Qp="wrapper";function $p(e){let{components:n,...t}=e;return(0,s.yg)(Qp,(0,p.A)({},Yp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe all subscribers from the event."))}$p.isMDXComponent=!0;const Kp={toc:[]},Jp="wrapper";function Zp(e){let{components:n,...t}=e;return(0,s.yg)(Jp,(0,p.A)({},Kp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A callback function that cancels the subscription."))}Zp.isMDXComponent=!0;const er={toc:[]},nr="wrapper";function tr(e){let{components:n,...t}=e;return(0,s.yg)(nr,(0,p.A)({},er,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."))}tr.isMDXComponent=!0;const or={toc:[]},pr="wrapper";function rr(e){let{components:n,...t}=e;return(0,s.yg)(pr,(0,p.A)({},or,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to invoke when the event occurs."))}rr.isMDXComponent=!0;const sr={toc:[]},cr="wrapper";function ar(e){let{components:n,...t}=e;return(0,s.yg)(cr,(0,p.A)({},sr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe from the event."))}ar.isMDXComponent=!0;const ir={toc:[]},lr="wrapper";function ur(e){let{components:n,...t}=e;return(0,s.yg)(lr,(0,p.A)({},ir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to unsubscribe."))}ur.isMDXComponent=!0;const mr={toc:[]},yr="wrapper";function dr(e){let{components:n,...t}=e;return(0,s.yg)(yr,(0,p.A)({},mr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the value argument to subscribers."))}dr.isMDXComponent=!0;const hr={toc:[]},gr="wrapper";function fr(e){let{components:n,...t}=e;return(0,s.yg)(gr,(0,p.A)({},hr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A base for dispatching ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,s.yg)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}fr.isMDXComponent=!0;const Dr={toc:[]},Mr="wrapper";function Xr(e){let{components:n,...t}=e;return(0,s.yg)(Mr,(0,p.A)({},Dr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe all subscribers from the event."))}Xr.isMDXComponent=!0;const _r={toc:[]},wr="wrapper";function Tr(e){let{components:n,...t}=e;return(0,s.yg)(wr,(0,p.A)({},_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A callback function that cancels the subscription."))}Tr.isMDXComponent=!0;const Cr={toc:[]},xr="wrapper";function Ar(e){let{components:n,...t}=e;return(0,s.yg)(xr,(0,p.A)({},Cr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."))}Ar.isMDXComponent=!0;const vr={toc:[]},Lr="wrapper";function br(e){let{components:n,...t}=e;return(0,s.yg)(Lr,(0,p.A)({},vr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to invoke when the event occurs."))}br.isMDXComponent=!0;const Nr={toc:[]},kr="wrapper";function zr(e){let{components:n,...t}=e;return(0,s.yg)(kr,(0,p.A)({},Nr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe from the event."))}zr.isMDXComponent=!0;const Pr={toc:[]},Ir="wrapper";function Rr(e){let{components:n,...t}=e;return(0,s.yg)(Ir,(0,p.A)({},Pr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to unsubscribe."))}Rr.isMDXComponent=!0;const Wr={toc:[]},Sr="wrapper";function Br(e){let{components:n,...t}=e;return(0,s.yg)(Sr,(0,p.A)({},Wr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the argument passed to subscribers."))}Br.isMDXComponent=!0;const Er={toc:[]},Gr="wrapper";function Or(e){let{components:n,...t}=e;return(0,s.yg)(Gr,(0,p.A)({},Er,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the callback function."))}Or.isMDXComponent=!0;const Ur={toc:[]},Fr="wrapper";function Vr(e){let{components:n,...t}=e;return(0,s.yg)(Fr,(0,p.A)({},Ur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,s.yg)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,s.yg)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}Vr.isMDXComponent=!0;const qr={toc:[]},jr="wrapper";function Hr(e){let{components:n,...t}=e;return(0,s.yg)(jr,(0,p.A)({},qr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}Hr.isMDXComponent=!0;const Yr={toc:[]},Qr="wrapper";function $r(e){let{components:n,...t}=e;return(0,s.yg)(Qr,(0,p.A)({},Yr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Dispatches a ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,s.yg)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}$r.isMDXComponent=!0;const Kr={toc:[]},Jr="wrapper";function Zr(e){let{components:n,...t}=e;return(0,s.yg)(Jr,(0,p.A)({},Kr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe all subscribers from the event."))}Zr.isMDXComponent=!0;const es={toc:[]},ns="wrapper";function ts(e){let{components:n,...t}=e;return(0,s.yg)(ns,(0,p.A)({},es,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Are subscribers being notified?"))}ts.isMDXComponent=!0;const os={toc:[]},ps="wrapper";function rs(e){let{components:n,...t}=e;return(0,s.yg)(ps,(0,p.A)({},os,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Notify all current and future subscribers."))}rs.isMDXComponent=!0;const ss={toc:[]},cs="wrapper";function as(e){let{components:n,...t}=e;return(0,s.yg)(cs,(0,p.A)({},ss,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Stop notifying future subscribers."))}as.isMDXComponent=!0;const is={toc:[]},ls="wrapper";function us(e){let{components:n,...t}=e;return(0,s.yg)(ls,(0,p.A)({},is,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A callback function that cancels the subscription."))}us.isMDXComponent=!0;const ms={toc:[]},ys="wrapper";function ds(e){let{components:n,...t}=e;return(0,s.yg)(ys,(0,p.A)({},ms,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."))}ds.isMDXComponent=!0;const hs={toc:[]},gs="wrapper";function fs(e){let{components:n,...t}=e;return(0,s.yg)(gs,(0,p.A)({},hs,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to invoke when the event occurs."))}fs.isMDXComponent=!0;const Ds={toc:[]},Ms="wrapper";function Xs(e){let{components:n,...t}=e;return(0,s.yg)(Ms,(0,p.A)({},Ds,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe from the event."))}Xs.isMDXComponent=!0;const _s={toc:[]},ws="wrapper";function Ts(e){let{components:n,...t}=e;return(0,s.yg)(ws,(0,p.A)({},_s,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to unsubscribe."))}Ts.isMDXComponent=!0;const Cs={toc:[]},xs="wrapper";function As(e){let{components:n,...t}=e;return(0,s.yg)(xs,(0,p.A)({},Cs,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}As.isMDXComponent=!0;const vs={toc:[]},Ls="wrapper";function bs(e){let{components:n,...t}=e;return(0,s.yg)(Ls,(0,p.A)({},vs,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provides safe access to the public interface of ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,s.yg)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}bs.isMDXComponent=!0;const Ns={toc:[]},ks="wrapper";function zs(e){let{components:n,...t}=e;return(0,s.yg)(ks,(0,p.A)({},Ns,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A callback function that cancels the subscription."))}zs.isMDXComponent=!0;const Ps={toc:[]},Is="wrapper";function Rs(e){let{components:n,...t}=e;return(0,s.yg)(Is,(0,p.A)({},Ps,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."))}Rs.isMDXComponent=!0;const Ws={toc:[]},Ss="wrapper";function Bs(e){let{components:n,...t}=e;return(0,s.yg)(Ss,(0,p.A)({},Ws,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to invoke when the event occurs."))}Bs.isMDXComponent=!0;const Es={toc:[]},Gs="wrapper";function Os(e){let{components:n,...t}=e;return(0,s.yg)(Gs,(0,p.A)({},Es,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe from the event."))}Os.isMDXComponent=!0;const Us={toc:[]},Fs="wrapper";function Vs(e){let{components:n,...t}=e;return(0,s.yg)(Fs,(0,p.A)({},Us,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to unsubscribe."))}Vs.isMDXComponent=!0;const qs={toc:[]},js="wrapper";function Hs(e){let{components:n,...t}=e;return(0,s.yg)(js,(0,p.A)({},qs,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the argument passed to subscribers."))}Hs.isMDXComponent=!0;const Ys={toc:[]},Qs="wrapper";function $s(e){let{components:n,...t}=e;return(0,s.yg)(Qs,(0,p.A)({},Ys,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the callback function."))}$s.isMDXComponent=!0;const Ks={toc:[]},Js="wrapper";function Zs(e){let{components:n,...t}=e;return(0,s.yg)(Js,(0,p.A)({},Ks,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Zs.isMDXComponent=!0;const ec={toc:[]},nc="wrapper";function tc(e){let{components:n,...t}=e;return(0,s.yg)(nc,(0,p.A)({},ec,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provides safe access to the public interface of ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,s.yg)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}tc.isMDXComponent=!0;const oc={toc:[]},pc="wrapper";function rc(e){let{components:n,...t}=e;return(0,s.yg)(pc,(0,p.A)({},oc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the most recent value of this dispatcher."))}rc.isMDXComponent=!0;const sc={toc:[]},cc="wrapper";function ac(e){let{components:n,...t}=e;return(0,s.yg)(cc,(0,p.A)({},sc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Callback function that cancels the subscription."))}ac.isMDXComponent=!0;const ic={toc:[]},lc="wrapper";function uc(e){let{components:n,...t}=e;return(0,s.yg)(lc,(0,p.A)({},ic,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."),(0,s.yg)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}uc.isMDXComponent=!0;const mc={toc:[]},yc="wrapper";function dc(e){let{components:n,...t}=e;return(0,s.yg)(yc,(0,p.A)({},mc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to invoke when the event occurs."))}dc.isMDXComponent=!0;const hc={toc:[]},gc="wrapper";function fc(e){let{components:n,...t}=e;return(0,s.yg)(gc,(0,p.A)({},hc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}fc.isMDXComponent=!0;const Dc={toc:[]},Mc="wrapper";function Xc(e){let{components:n,...t}=e;return(0,s.yg)(Mc,(0,p.A)({},Dc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Callback function that cancels the subscription."))}Xc.isMDXComponent=!0;const _c={toc:[]},wc="wrapper";function Tc(e){let{components:n,...t}=e;return(0,s.yg)(wc,(0,p.A)({},_c,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."),(0,s.yg)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Tc.isMDXComponent=!0;const Cc={toc:[]},xc="wrapper";function Ac(e){let{components:n,...t}=e;return(0,s.yg)(xc,(0,p.A)({},Cc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe from the event."))}Ac.isMDXComponent=!0;const vc={toc:[]},Lc="wrapper";function bc(e){let{components:n,...t}=e;return(0,s.yg)(Lc,(0,p.A)({},vc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to unsubscribe."))}bc.isMDXComponent=!0;const Nc={toc:[]},kc="wrapper";function zc(e){let{components:n,...t}=e;return(0,s.yg)(kc,(0,p.A)({},Nc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the value passed to subscribers."))}zc.isMDXComponent=!0;const Pc={toc:[]},Ic="wrapper";function Rc(e){let{components:n,...t}=e;return(0,s.yg)(Ic,(0,p.A)({},Pc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}Rc.isMDXComponent=!0;const Wc={toc:[]},Sc="wrapper";function Bc(e){let{components:n,...t}=e;return(0,s.yg)(Sc,(0,p.A)({},Wc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}Bc.isMDXComponent=!0;const Ec={toc:[]},Gc="wrapper";function Oc(e){let{components:n,...t}=e;return(0,s.yg)(Gc,(0,p.A)({},Ec,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Dispatches a ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,s.yg)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}Oc.isMDXComponent=!0;const Uc={toc:[]},Fc="wrapper";function Vc(e){let{components:n,...t}=e;return(0,s.yg)(Fc,(0,p.A)({},Uc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value."))}Vc.isMDXComponent=!0;const qc={toc:[]},jc="wrapper";function Hc(e){let{components:n,...t}=e;return(0,s.yg)(jc,(0,p.A)({},qc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the most recent value of this dispatcher."))}Hc.isMDXComponent=!0;const Yc={toc:[]},Qc="wrapper";function $c(e){let{components:n,...t}=e;return(0,s.yg)(Qc,(0,p.A)({},Yc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Setting the value will immediately notify all subscribers."))}$c.isMDXComponent=!0;const Kc={toc:[]},Jc="wrapper";function Zc(e){let{components:n,...t}=e;return(0,s.yg)(Jc,(0,p.A)({},Kc,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value of this dispatcher."))}Zc.isMDXComponent=!0;const ea={toc:[]},na="wrapper";function ta(e){let{components:n,...t}=e;return(0,s.yg)(na,(0,p.A)({},ea,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}ta.isMDXComponent=!0;const oa={toc:[]},pa="wrapper";function ra(e){let{components:n,...t}=e;return(0,s.yg)(pa,(0,p.A)({},oa,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe all subscribers from the event."))}ra.isMDXComponent=!0;const sa={toc:[]},ca="wrapper";function aa(e){let{components:n,...t}=e;return(0,s.yg)(ca,(0,p.A)({},sa,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Callback function that cancels the subscription."))}aa.isMDXComponent=!0;const ia={toc:[]},la="wrapper";function ua(e){let{components:n,...t}=e;return(0,s.yg)(la,(0,p.A)({},ia,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subscribe to the event."),(0,s.yg)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}ua.isMDXComponent=!0;const ma={toc:[]},ya="wrapper";function da(e){let{components:n,...t}=e;return(0,s.yg)(ya,(0,p.A)({},ma,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to invoke when the event occurs."))}da.isMDXComponent=!0;const ha={toc:[]},ga="wrapper";function fa(e){let{components:n,...t}=e;return(0,s.yg)(ga,(0,p.A)({},ha,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}fa.isMDXComponent=!0;const Da={toc:[]},Ma="wrapper";function Xa(e){let{components:n,...t}=e;return(0,s.yg)(Ma,(0,p.A)({},Da,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unsubscribe from the event."))}Xa.isMDXComponent=!0;const _a={toc:[]},wa="wrapper";function Ta(e){let{components:n,...t}=e;return(0,s.yg)(wa,(0,p.A)({},_a,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The handler to unsubscribe."))}Ta.isMDXComponent=!0;const Ca={toc:[]},xa="wrapper";function Aa(e){let{components:n,...t}=e;return(0,s.yg)(xa,(0,p.A)({},Ca,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the value passed to subscribers."))}Aa.isMDXComponent=!0;const va={toc:[]},La="wrapper";function ba(e){let{components:n,...t}=e;return(0,s.yg)(La,(0,p.A)({},va,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ba.isMDXComponent=!0;const Na={toc:[]},ka="wrapper";function za(e){let{components:n,...t}=e;return(0,s.yg)(ka,(0,p.A)({},Na,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provides safe access to the public interface of ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,s.yg)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}za.isMDXComponent=!0;const Pa={toc:[]},Ia="wrapper";function Ra(e){let{components:n,...t}=e;return(0,s.yg)(Ia,(0,p.A)({},Pa,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the argument passed to subscribers."))}Ra.isMDXComponent=!0;const Wa={toc:[]},Sa="wrapper";function Ba(e){let{components:n,...t}=e;return(0,s.yg)(Sa,(0,p.A)({},Wa,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Ba.isMDXComponent=!0;const Ea={toc:[]},Ga="wrapper";function Oa(e){let{components:n,...t}=e;return(0,s.yg)(Ga,(0,p.A)({},Ea,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provides safe access to the public interface of ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,s.yg)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}Oa.isMDXComponent=!0;const Ua={toc:[]},Fa="wrapper";function Va(e){let{components:n,...t}=e;return(0,s.yg)(Fa,(0,p.A)({},Ua,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the argument passed to subscribers."))}Va.isMDXComponent=!0;const qa={toc:[]},ja="wrapper";function Ha(e){let{components:n,...t}=e;return(0,s.yg)(ja,(0,p.A)({},qa,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Ha.isMDXComponent=!0;const Ya={toc:[]},Qa="wrapper";function $a(e){let{components:n,...t}=e;return(0,s.yg)(Qa,(0,p.A)({},Ya,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provides safe access to the public interface of ",(0,s.yg)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,s.yg)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}$a.isMDXComponent=!0;const Ka={toc:[]},Ja="wrapper";function Za(e){let{components:n,...t}=e;return(0,s.yg)(Ja,(0,p.A)({},Ka,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Most of the export logic is handled on the server. This class communicates\nwith the FFmpegBridge through a WebSocket connection which lets it invoke\nmethods on the FFmpegExporterServer class."),(0,s.yg)("p",null,"For example, calling the following method:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"async this.invoke('process', 7);\n")),(0,s.yg)("p",null,"Will invoke the ",(0,s.yg)("inlineCode",{parentName:"p"},"process")," method on the FFmpegExporterServer class with ",(0,s.yg)("inlineCode",{parentName:"p"},"7"),"\nas the argument. The result of the method will be returned as a Promise."),(0,s.yg)("p",null,"Before any methods can be invoked, the FFmpegExporterServer class must be\ninitialized by invoking ",(0,s.yg)("inlineCode",{parentName:"p"},"start"),"."))}Za.isMDXComponent=!0;const ei={toc:[]},ni="wrapper";function ti(e){let{components:n,...t}=e;return(0,s.yg)(ni,(0,p.A)({},ei,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"FFmpeg video exporter."))}ti.isMDXComponent=!0;const oi={toc:[]},pi="wrapper";function ri(e){let{components:n,...t}=e;return(0,s.yg)(pi,(0,p.A)({},oi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Take in media assets per frame and generate audio track for the video."))}ri.isMDXComponent=!0;const si={toc:[]},ci="wrapper";function ai(e){let{components:n,...t}=e;return(0,s.yg)(ci,(0,p.A)({},si,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Called each time after a frame is rendered."))}ai.isMDXComponent=!0;const ii={toc:[]},li="wrapper";function ui(e){let{components:n,...t}=e;return(0,s.yg)(li,(0,p.A)({},ii,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Export a frame."))}ui.isMDXComponent=!0;const mi={toc:[]},yi="wrapper";function di(e){let{components:n,...t}=e;return(0,s.yg)(yi,(0,p.A)({},mi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A canvas containing the rendered frame."))}di.isMDXComponent=!0;const hi={toc:[]},gi="wrapper";function fi(e){let{components:n,...t}=e;return(0,s.yg)(gi,(0,p.A)({},hi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Guaranteed to be called after the rendering has finished - no matter the\nresult. Performs clean-up."))}fi.isMDXComponent=!0;const Di={toc:[]},Mi="wrapper";function Xi(e){let{components:n,...t}=e;return(0,s.yg)(Mi,(0,p.A)({},Di,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Finish the rendering process."))}Xi.isMDXComponent=!0;const _i={toc:[]},wi="wrapper";function Ti(e){let{components:n,...t}=e;return(0,s.yg)(wi,(0,p.A)({},_i,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"after processing the image stream and generating an audio file, merge the video and audio stream as the final video"))}Ti.isMDXComponent=!0;const Ci={toc:[]},xi="wrapper";function Ai(e){let{components:n,...t}=e;return(0,s.yg)(xi,(0,p.A)({},Ci,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Called after the rendering has been set up, right before the first frame\nis rendered. Once ",(0,s.yg)("inlineCode",{parentName:"p"},"start()")," is called, it is guaranteed that the ",(0,s.yg)("inlineCode",{parentName:"p"},"stop()"),"\nmethod will be called as well. Can be used to initialize any resources that\nrequire a clean-up."))}Ai.isMDXComponent=!0;const vi={toc:[]},Li="wrapper";function bi(e){let{components:n,...t}=e;return(0,s.yg)(Li,(0,p.A)({},vi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Begin the rendering process."))}bi.isMDXComponent=!0;const Ni={toc:[]},ki="wrapper";function zi(e){let{components:n,...t}=e;return(0,s.yg)(ki,(0,p.A)({},Ni,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Called after rendering the visual elements has finished and audio so that audio track can be merged."))}zi.isMDXComponent=!0;const Pi={toc:[]},Ii="wrapper";function Ri(e){let{components:n,...t}=e;return(0,s.yg)(Ii,(0,p.A)({},Pi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Finish the rendering process."))}Ri.isMDXComponent=!0;const Wi={toc:[]},Si="wrapper";function Bi(e){let{components:n,...t}=e;return(0,s.yg)(Si,(0,p.A)({},Wi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The result of the rendering."))}Bi.isMDXComponent=!0;const Ei={toc:[]},Gi="wrapper";function Oi(e){let{components:n,...t}=e;return(0,s.yg)(Gi,(0,p.A)({},Ei,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The main interface for implementing custom exporters."))}Oi.isMDXComponent=!0;const Ui={toc:[]},Fi="wrapper";function Vi(e){let{components:n,...t}=e;return(0,s.yg)(Fi,(0,p.A)({},Ui,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Take in media assets per frame and generate audio track for the video."))}Vi.isMDXComponent=!0;const qi={toc:[]},ji="wrapper";function Hi(e){let{components:n,...t}=e;return(0,s.yg)(ji,(0,p.A)({},qi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Called each time after a frame is rendered."))}Hi.isMDXComponent=!0;const Yi={toc:[]},Qi="wrapper";function $i(e){let{components:n,...t}=e;return(0,s.yg)(Qi,(0,p.A)({},Yi,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Export a frame."))}$i.isMDXComponent=!0;const Ki={toc:[]},Ji="wrapper";function Zi(e){let{components:n,...t}=e;return(0,s.yg)(Ji,(0,p.A)({},Ki,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A canvas containing the rendered frame."))}Zi.isMDXComponent=!0;const el={toc:[]},nl="wrapper";function tl(e){let{components:n,...t}=e;return(0,s.yg)(nl,(0,p.A)({},el,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"after processing the image stream and generating an audio file, merge the video and audio stream as the final video"))}tl.isMDXComponent=!0;const ol={toc:[]},pl="wrapper";function rl(e){let{components:n,...t}=e;return(0,s.yg)(pl,(0,p.A)({},ol,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Called after the rendering has been set up, right before the first frame\nis rendered. Once ",(0,s.yg)("inlineCode",{parentName:"p"},"start()")," is called, it is guaranteed that the ",(0,s.yg)("inlineCode",{parentName:"p"},"stop()"),"\nmethod will be called as well. Can be used to initialize any resources that\nrequire a clean-up."))}rl.isMDXComponent=!0;const sl={toc:[]},cl="wrapper";function al(e){let{components:n,...t}=e;return(0,s.yg)(cl,(0,p.A)({},sl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Begin the rendering process."))}al.isMDXComponent=!0;const il={toc:[]},ll="wrapper";function ul(e){let{components:n,...t}=e;return(0,s.yg)(ll,(0,p.A)({},il,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Called after rendering the visual elements has finished and audio so that audio track can be merged."))}ul.isMDXComponent=!0;const ml={toc:[]},yl="wrapper";function dl(e){let{components:n,...t}=e;return(0,s.yg)(yl,(0,p.A)({},ml,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Finish the rendering process."))}dl.isMDXComponent=!0;const hl={toc:[]},gl="wrapper";function fl(e){let{components:n,...t}=e;return(0,s.yg)(gl,(0,p.A)({},hl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The main interface for implementing custom exporters."))}fl.isMDXComponent=!0;const Dl={toc:[]},Ml="wrapper";function Xl(e){let{components:n,...t}=e;return(0,s.yg)(Ml,(0,p.A)({},Dl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Called at the beginning of the rendering process, before anything else has\nbeen set up. The returned value can be used to override the rendering\nsettings provided by the user."))}Xl.isMDXComponent=!0;const _l={toc:[]},wl="wrapper";function Tl(e){let{components:n,...t}=e;return(0,s.yg)(wl,(0,p.A)({},_l,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the rendering configuration."))}Tl.isMDXComponent=!0;const Cl={toc:[]},xl="wrapper";function Al(e){let{components:n,...t}=e;return(0,s.yg)(xl,(0,p.A)({},Cl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Take in media assets per frame and generate audio track for the video."))}Al.isMDXComponent=!0;const vl={toc:[]},Ll="wrapper";function bl(e){let{components:n,...t}=e;return(0,s.yg)(Ll,(0,p.A)({},vl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Called each time after a frame is rendered."))}bl.isMDXComponent=!0;const Nl={toc:[]},kl="wrapper";function zl(e){let{components:n,...t}=e;return(0,s.yg)(kl,(0,p.A)({},Nl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Export a frame."))}zl.isMDXComponent=!0;const Pl={toc:[]},Il="wrapper";function Rl(e){let{components:n,...t}=e;return(0,s.yg)(Il,(0,p.A)({},Pl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A canvas containing the rendered frame."))}Rl.isMDXComponent=!0;const Wl={toc:[]},Sl="wrapper";function Bl(e){let{components:n,...t}=e;return(0,s.yg)(Sl,(0,p.A)({},Wl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame number."))}Bl.isMDXComponent=!0;const El={toc:[]},Gl="wrapper";function Ol(e){let{components:n,...t}=e;return(0,s.yg)(Gl,(0,p.A)({},El,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame number within the scene."))}Ol.isMDXComponent=!0;const Ul={toc:[]},Fl="wrapper";function Vl(e){let{components:n,...t}=e;return(0,s.yg)(Fl,(0,p.A)({},Ul,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of the scene with which the frame is associated."))}Vl.isMDXComponent=!0;const ql={toc:[]},jl="wrapper";function Hl(e){let{components:n,...t}=e;return(0,s.yg)(jl,(0,p.A)({},ql,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An abort signal triggered if the user aborts the rendering."))}Hl.isMDXComponent=!0;const Yl={toc:[]},Ql="wrapper";function $l(e){let{components:n,...t}=e;return(0,s.yg)(Ql,(0,p.A)({},Yl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Guaranteed to be called after the rendering has finished - no matter the\nresult. Performs clean-up."))}$l.isMDXComponent=!0;const Kl={toc:[]},Jl="wrapper";function Zl(e){let{components:n,...t}=e;return(0,s.yg)(Jl,(0,p.A)({},Kl,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Finish the rendering process."))}Zl.isMDXComponent=!0;const eu={toc:[]},nu="wrapper";function tu(e){let{components:n,...t}=e;return(0,s.yg)(nu,(0,p.A)({},eu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"after processing the image stream and generating an audio file, merge the video and audio stream as the final video"))}tu.isMDXComponent=!0;const ou={toc:[]},pu="wrapper";function ru(e){let{components:n,...t}=e;return(0,s.yg)(pu,(0,p.A)({},ou,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Called after the rendering has been set up, right before the first frame\nis rendered. Once ",(0,s.yg)("inlineCode",{parentName:"p"},"start()")," is called, it is guaranteed that the ",(0,s.yg)("inlineCode",{parentName:"p"},"stop()"),"\nmethod will be called as well. Can be used to initialize any resources that\nrequire a clean-up."))}ru.isMDXComponent=!0;const su={toc:[]},cu="wrapper";function au(e){let{components:n,...t}=e;return(0,s.yg)(cu,(0,p.A)({},su,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Begin the rendering process."))}au.isMDXComponent=!0;const iu={toc:[]},lu="wrapper";function uu(e){let{components:n,...t}=e;return(0,s.yg)(lu,(0,p.A)({},iu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Called after rendering the visual elements has finished and audio so that audio track can be merged."))}uu.isMDXComponent=!0;const mu={toc:[]},yu="wrapper";function du(e){let{components:n,...t}=e;return(0,s.yg)(yu,(0,p.A)({},mu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Finish the rendering process."))}du.isMDXComponent=!0;const hu={toc:[]},gu="wrapper";function fu(e){let{components:n,...t}=e;return(0,s.yg)(gu,(0,p.A)({},hu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The result of the rendering."))}fu.isMDXComponent=!0;const Du={toc:[]},Mu="wrapper";function Xu(e){let{components:n,...t}=e;return(0,s.yg)(Mu,(0,p.A)({},Du,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The static interface for exporters."))}Xu.isMDXComponent=!0;const _u={toc:[]},wu="wrapper";function Tu(e){let{components:n,...t}=e;return(0,s.yg)(wu,(0,p.A)({},_u,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This name will be displayed in the editor."))}Tu.isMDXComponent=!0;const Cu={toc:[]},xu="wrapper";function Au(e){let{components:n,...t}=e;return(0,s.yg)(xu,(0,p.A)({},Cu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this exporter."))}Au.isMDXComponent=!0;const vu={toc:[]},Lu="wrapper";function bu(e){let{components:n,...t}=e;return(0,s.yg)(Lu,(0,p.A)({},vu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This identifier will be used to store the settings of this exporter.\nIt's recommended to prepend it with the name of the package to avoid\ncollisions."))}bu.isMDXComponent=!0;const Nu={toc:[]},ku="wrapper";function zu(e){let{components:n,...t}=e;return(0,s.yg)(ku,(0,p.A)({},Nu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The unique identifier of this exporter."))}zu.isMDXComponent=!0;const Pu={toc:[]},Iu="wrapper";function Ru(e){let{components:n,...t}=e;return(0,s.yg)(Iu,(0,p.A)({},Pu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A new exporter is created whenever the user starts a new rendering process."))}Ru.isMDXComponent=!0;const Wu={toc:[]},Su="wrapper";function Bu(e){let{components:n,...t}=e;return(0,s.yg)(Su,(0,p.A)({},Wu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this exporter."))}Bu.isMDXComponent=!0;const Eu={toc:[]},Gu="wrapper";function Ou(e){let{components:n,...t}=e;return(0,s.yg)(Gu,(0,p.A)({},Eu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The current project."))}Ou.isMDXComponent=!0;const Uu={toc:[]},Fu="wrapper";function Vu(e){let{components:n,...t}=e;return(0,s.yg)(Fu,(0,p.A)({},Uu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The rendering settings."))}Vu.isMDXComponent=!0;const qu={toc:[]},ju="wrapper";function Hu(e){let{components:n,...t}=e;return(0,s.yg)(ju,(0,p.A)({},qu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a meta field representing the options of this exporter."))}Hu.isMDXComponent=!0;const Yu={toc:[]},Qu="wrapper";function $u(e){let{components:n,...t}=e;return(0,s.yg)(Qu,(0,p.A)({},Yu,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Utilities for controlling the flow and timing of an animation."))}$u.isMDXComponent=!0;const Ku={toc:[]},Ju="wrapper";function Zu(e){let{components:n,...t}=e;return(0,s.yg)(Ju,(0,p.A)({},Ku,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A callback called by ",(0,s.yg)("a",{parentName:"p",href:"/api/core/flow/EveryTimer"},(0,s.yg)("inlineCode",{parentName:"a"},"EveryTimer"))," every N seconds."))}Zu.isMDXComponent=!0;const em={toc:[]},nm="wrapper";function tm(e){let{components:n,...t}=e;return(0,s.yg)(nm,(0,p.A)({},em,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The amount of times the timer has ticked."))}tm.isMDXComponent=!0;const om={toc:[]},pm="wrapper";function rm(e){let{components:n,...t}=e;return(0,s.yg)(pm,(0,p.A)({},om,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The generator responsible for running this timer."))}rm.isMDXComponent=!0;const sm={toc:[]},cm="wrapper";function am(e){let{components:n,...t}=e;return(0,s.yg)(cm,(0,p.A)({},sm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait until the timer ticks."))}am.isMDXComponent=!0;const im={toc:[]},lm="wrapper";function um(e){let{components:n,...t}=e;return(0,s.yg)(lm,(0,p.A)({},im,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A callback called by ",(0,s.yg)("a",{parentName:"p",href:"/api/core/flow#loop"},(0,s.yg)("inlineCode",{parentName:"a"},"loop"))," during each iteration."))}um.isMDXComponent=!0;const mm={toc:[]},ym="wrapper";function dm(e){let{components:n,...t}=e;return(0,s.yg)(ym,(0,p.A)({},mm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The current iteration index."))}dm.isMDXComponent=!0;const hm={toc:[]},gm="wrapper";function fm(e){let{components:n,...t}=e;return(0,s.yg)(gm,(0,p.A)({},hm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}fm.isMDXComponent=!0;const Dm={toc:[]},Mm="wrapper";function Xm(e){let{components:n,...t}=e;return(0,s.yg)(Mm,(0,p.A)({},Dm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}Xm.isMDXComponent=!0;const _m={toc:[]},wm="wrapper";function Tm(e){let{components:n,...t}=e;return(0,s.yg)(wm,(0,p.A)({},_m,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of tasks to run."))}Tm.isMDXComponent=!0;const Cm={toc:[]},xm="wrapper";function Am(e){let{components:n,...t}=e;return(0,s.yg)(xm,(0,p.A)({},Cm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}Am.isMDXComponent=!0;const vm={toc:[]},Lm="wrapper";function bm(e){let{components:n,...t}=e;return(0,s.yg)(Lm,(0,p.A)({},vm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}bm.isMDXComponent=!0;const Nm={toc:[]},km="wrapper";function zm(e){let{components:n,...t}=e;return(0,s.yg)(km,(0,p.A)({},Nm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of tasks to run."))}zm.isMDXComponent=!0;const Pm={toc:[]},Im="wrapper";function Rm(e){let{components:n,...t}=e;return(0,s.yg)(Im,(0,p.A)({},Pm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,s.yg)("p",null,"Note that the same animation can be written as:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,s.yg)("p",null,"The reason ",(0,s.yg)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.radius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}Rm.isMDXComponent=!0;const Wm={toc:[]},Sm="wrapper";function Bm(e){let{components:n,...t}=e;return(0,s.yg)(Sm,(0,p.A)({},Wm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run tasks one after another."))}Bm.isMDXComponent=!0;const Em={toc:[]},Gm="wrapper";function Om(e){let{components:n,...t}=e;return(0,s.yg)(Gm,(0,p.A)({},Em,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of tasks to run."))}Om.isMDXComponent=!0;const Um={toc:[]},Fm="wrapper";function Vm(e){let{components:n,...t}=e;return(0,s.yg)(Fm,(0,p.A)({},Um,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,s.yg)("p",null,"Note that the same animation can be written as:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,s.yg)("p",null,"The reason ",(0,s.yg)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}Vm.isMDXComponent=!0;const qm={toc:[]},jm="wrapper";function Hm(e){let{components:n,...t}=e;return(0,s.yg)(jm,(0,p.A)({},qm,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run the given generator or callback after a specific amount of time."))}Hm.isMDXComponent=!0;const Ym={toc:[]},Qm="wrapper";function $m(e){let{components:n,...t}=e;return(0,s.yg)(Qm,(0,p.A)({},Ym,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The delay in seconds"))}$m.isMDXComponent=!0;const Km={toc:[]},Jm="wrapper";function Zm(e){let{components:n,...t}=e;return(0,s.yg)(Jm,(0,p.A)({},Km,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The task or callback to run after the delay."))}Zm.isMDXComponent=!0;const ey={toc:[]},ny="wrapper";function ty(e){let{components:n,...t}=e;return(0,s.yg)(ny,(0,p.A)({},ey,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}ty.isMDXComponent=!0;const oy={toc:[]},py="wrapper";function ry(e){let{components:n,...t}=e;return(0,s.yg)(py,(0,p.A)({},oy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Call the given callback every N seconds."))}ry.isMDXComponent=!0;const sy={toc:[]},cy="wrapper";function ay(e){let{components:n,...t}=e;return(0,s.yg)(cy,(0,p.A)({},sy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The interval between subsequent calls."))}ay.isMDXComponent=!0;const iy={toc:[]},ly="wrapper";function uy(e){let{components:n,...t}=e;return(0,s.yg)(ly,(0,p.A)({},iy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The callback to be called."))}uy.isMDXComponent=!0;const my={toc:[]},yy="wrapper";function dy(e){let{components:n,...t}=e;return(0,s.yg)(yy,(0,p.A)({},my,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Each iteration waits until the previous one is completed.\nBecause this loop never finishes it cannot be used in the main thread.\nInstead, use ",(0,s.yg)("inlineCode",{parentName:"p"},"yield")," or ",(0,s.yg)("a",{parentName:"p",href:"/api/core/threading#spawn"},(0,s.yg)("inlineCode",{parentName:"a"},"spawn"))," to run the loop concurrently."))}dy.isMDXComponent=!0;const hy={toc:[]},gy="wrapper";function fy(e){let{components:n,...t}=e;return(0,s.yg)(gy,(0,p.A)({},hy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rotate the ",(0,s.yg)("inlineCode",{parentName:"p"},"rect")," indefinitely:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield loop(\n  () => rect.rotation(0).rotation(360, 2, linear),\n);\n")))}fy.isMDXComponent=!0;const Dy={toc:[]},My="wrapper";function Xy(e){let{components:n,...t}=e;return(0,s.yg)(My,(0,p.A)({},Dy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run the given generator in a loop."))}Xy.isMDXComponent=!0;const _y={toc:[]},wy="wrapper";function Ty(e){let{components:n,...t}=e;return(0,s.yg)(wy,(0,p.A)({},_y,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}Ty.isMDXComponent=!0;const Cy={toc:[]},xy="wrapper";function Ay(e){let{components:n,...t}=e;return(0,s.yg)(xy,(0,p.A)({},Cy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Each iteration waits until the previous one is completed."))}Ay.isMDXComponent=!0;const vy={toc:[]},Ly="wrapper";function by(e){let{components:n,...t}=e;return(0,s.yg)(Ly,(0,p.A)({},vy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n);\n")))}by.isMDXComponent=!0;const Ny={toc:[]},ky="wrapper";function zy(e){let{components:n,...t}=e;return(0,s.yg)(ky,(0,p.A)({},Ny,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run the given generator N times."))}zy.isMDXComponent=!0;const Py={toc:[]},Iy="wrapper";function Ry(e){let{components:n,...t}=e;return(0,s.yg)(Iy,(0,p.A)({},Py,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The number of iterations."))}Ry.isMDXComponent=!0;const Wy={toc:[]},Sy="wrapper";function By(e){let{components:n,...t}=e;return(0,s.yg)(Sy,(0,p.A)({},Wy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}By.isMDXComponent=!0;const Ey={toc:[]},Gy="wrapper";function Oy(e){let{components:n,...t}=e;return(0,s.yg)(Gy,(0,p.A)({},Ey,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}Oy.isMDXComponent=!0;const Uy={toc:[]},Fy="wrapper";function Vy(e){let{components:n,...t}=e;return(0,s.yg)(Fy,(0,p.A)({},Uy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* loopFor(\n  3,\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}Vy.isMDXComponent=!0;const qy={toc:[]},jy="wrapper";function Hy(e){let{components:n,...t}=e;return(0,s.yg)(jy,(0,p.A)({},qy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run a generator in a loop for the given amount of time."))}Hy.isMDXComponent=!0;const Yy={toc:[]},Qy="wrapper";function $y(e){let{components:n,...t}=e;return(0,s.yg)(Qy,(0,p.A)({},Yy,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration in seconds."))}$y.isMDXComponent=!0;const Ky={toc:[]},Jy="wrapper";function Zy(e){let{components:n,...t}=e;return(0,s.yg)(Jy,(0,p.A)({},Ky,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}Zy.isMDXComponent=!0;const ed={toc:[]},nd="wrapper";function td(e){let{components:n,...t}=e;return(0,s.yg)(nd,(0,p.A)({},ed,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}td.isMDXComponent=!0;const od={toc:[]},pd="wrapper";function rd(e){let{components:n,...t}=e;return(0,s.yg)(pd,(0,p.A)({},od,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* loopUntil(\n  'Stop Looping',\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}rd.isMDXComponent=!0;const sd={toc:[]},cd="wrapper";function ad(e){let{components:n,...t}=e;return(0,s.yg)(cd,(0,p.A)({},sd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run a generator in a loop until the given time event."))}ad.isMDXComponent=!0;const id={toc:[]},ld="wrapper";function ud(e){let{components:n,...t}=e;return(0,s.yg)(ld,(0,p.A)({},id,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The event."))}ud.isMDXComponent=!0;const md={toc:[]},yd="wrapper";function dd(e){let{components:n,...t}=e;return(0,s.yg)(yd,(0,p.A)({},md,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}dd.isMDXComponent=!0;const hd={toc:[]},gd="wrapper";function fd(e){let{components:n,...t}=e;return(0,s.yg)(gd,(0,p.A)({},hd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Do nothing."))}fd.isMDXComponent=!0;const Dd={toc:[]},Md="wrapper";function Xd(e){let{components:n,...t}=e;return(0,s.yg)(Md,(0,p.A)({},Dd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If you want to immediately run the generator in its own thread, you can use\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/threading#spawn"},(0,s.yg)("inlineCode",{parentName:"a"},"spawn"))," instead. This function is useful when you want to\npass the created task to other flow functions."))}Xd.isMDXComponent=!0;const _d={toc:[]},wd="wrapper";function Td(e){let{components:n,...t}=e;return(0,s.yg)(wd,(0,p.A)({},_d,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  run(function* () {\n    // do things\n  }),\n  rect.opacity(1, 1),\n);\n")))}Td.isMDXComponent=!0;const Cd={toc:[]},xd="wrapper";function Ad(e){let{components:n,...t}=e;return(0,s.yg)(xd,(0,p.A)({},Cd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Turn the given generator function into a task."))}Ad.isMDXComponent=!0;const vd={toc:[]},Ld="wrapper";function bd(e){let{components:n,...t}=e;return(0,s.yg)(Ld,(0,p.A)({},vd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A generator function or a factory that creates the generator."))}bd.isMDXComponent=!0;const Nd={toc:[]},kd="wrapper";function zd(e){let{components:n,...t}=e;return(0,s.yg)(kd,(0,p.A)({},Nd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If you want to immediately run the generator in its own thread, you can use\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/threading#spawn"},(0,s.yg)("inlineCode",{parentName:"a"},"spawn"))," instead. This function is useful when you want to\npass the created task to other flow functions."))}zd.isMDXComponent=!0;const Pd={toc:[]},Id="wrapper";function Rd(e){let{components:n,...t}=e;return(0,s.yg)(Id,(0,p.A)({},Pd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  run(function* () {\n    // do things\n  }),\n  rect.opacity(1, 1),\n);\n")))}Rd.isMDXComponent=!0;const Wd={toc:[]},Sd="wrapper";function Bd(e){let{components:n,...t}=e;return(0,s.yg)(Sd,(0,p.A)({},Wd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Turn the given generator function into a task."))}Bd.isMDXComponent=!0;const Ed={toc:[]},Gd="wrapper";function Od(e){let{components:n,...t}=e;return(0,s.yg)(Gd,(0,p.A)({},Ed,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional name used when displaying this generator in the UI."))}Od.isMDXComponent=!0;const Ud={toc:[]},Fd="wrapper";function Vd(e){let{components:n,...t}=e;return(0,s.yg)(Fd,(0,p.A)({},Ud,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A generator function or a factory that creates the generator."))}Vd.isMDXComponent=!0;const qd={toc:[]},jd="wrapper";function Hd(e){let{components:n,...t}=e;return(0,s.yg)(jd,(0,p.A)({},qd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}Hd.isMDXComponent=!0;const Yd={toc:[]},Qd="wrapper";function $d(e){let{components:n,...t}=e;return(0,s.yg)(Qd,(0,p.A)({},Yd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}$d.isMDXComponent=!0;const Kd={toc:[]},Jd="wrapper";function Zd(e){let{components:n,...t}=e;return(0,s.yg)(Jd,(0,p.A)({},Kd,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Start all tasks one after another with a constant delay between."))}Zd.isMDXComponent=!0;const eh={toc:[]},nh="wrapper";function th(e){let{components:n,...t}=e;return(0,s.yg)(nh,(0,p.A)({},eh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The delay between each of the tasks."))}th.isMDXComponent=!0;const oh={toc:[]},ph="wrapper";function rh(e){let{components:n,...t}=e;return(0,s.yg)(ph,(0,p.A)({},oh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of tasks to be run in a sequence."))}rh.isMDXComponent=!0;const sh={toc:[]},ch="wrapper";function ah(e){let{components:n,...t}=e;return(0,s.yg)(ch,(0,p.A)({},sh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}ah.isMDXComponent=!0;const ih={toc:[]},lh="wrapper";function uh(e){let{components:n,...t}=e;return(0,s.yg)(lh,(0,p.A)({},ih,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for the given amount of time."))}uh.isMDXComponent=!0;const mh={toc:[]},yh="wrapper";function dh(e){let{components:n,...t}=e;return(0,s.yg)(yh,(0,p.A)({},mh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The relative time in seconds."))}dh.isMDXComponent=!0;const hh={toc:[]},gh="wrapper";function fh(e){let{components:n,...t}=e;return(0,s.yg)(gh,(0,p.A)({},hh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional task to be run after the function completes."))}fh.isMDXComponent=!0;const Dh={toc:[]},Mh="wrapper";function Xh(e){let{components:n,...t}=e;return(0,s.yg)(Mh,(0,p.A)({},Dh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}Xh.isMDXComponent=!0;const _h={toc:[]},wh="wrapper";function Th(e){let{components:n,...t}=e;return(0,s.yg)(wh,(0,p.A)({},_h,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}Th.isMDXComponent=!0;const Ch={toc:[]},xh="wrapper";function Ah(e){let{components:n,...t}=e;return(0,s.yg)(xh,(0,p.A)({},Ch,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait until the given time event."))}Ah.isMDXComponent=!0;const vh={toc:[]},Lh="wrapper";function bh(e){let{components:n,...t}=e;return(0,s.yg)(Lh,(0,p.A)({},vh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of the time event."))}bh.isMDXComponent=!0;const Nh={toc:[]},kh="wrapper";function zh(e){let{components:n,...t}=e;return(0,s.yg)(kh,(0,p.A)({},Nh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional task to be run after the function completes."))}zh.isMDXComponent=!0;const Ph={toc:[]},Ih="wrapper";function Rh(e){let{components:n,...t}=e;return(0,s.yg)(Ih,(0,p.A)({},Ph,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Multi-media management."))}Rh.isMDXComponent=!0;const Wh={toc:[]},Sh="wrapper";function Bh(e){let{components:n,...t}=e;return(0,s.yg)(Sh,(0,p.A)({},Wh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}Bh.isMDXComponent=!0;const Eh={toc:[]},Gh="wrapper";function Oh(e){let{components:n,...t}=e;return(0,s.yg)(Gh,(0,p.A)({},Eh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Pause/resume the audio."))}Oh.isMDXComponent=!0;const Uh={toc:[]},Fh="wrapper";function Vh(e){let{components:n,...t}=e;return(0,s.yg)(Fh,(0,p.A)({},Uh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the audio should be paused or resumed."))}Vh.isMDXComponent=!0;const qh={toc:[]},jh="wrapper";function Hh(e){let{components:n,...t}=e;return(0,s.yg)(jh,(0,p.A)({},qh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The absolute biggest value from the peaks array."))}Hh.isMDXComponent=!0;const Yh={toc:[]},Qh="wrapper";function $h(e){let{components:n,...t}=e;return(0,s.yg)(Qh,(0,p.A)({},Yh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The amount of samples taken."))}$h.isMDXComponent=!0;const Kh={toc:[]},Jh="wrapper";function Zh(e){let{components:n,...t}=e;return(0,s.yg)(Jh,(0,p.A)({},Kh,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}Zh.isMDXComponent=!0;const eg={toc:[]},ng="wrapper";function tg(e){let{components:n,...t}=e;return(0,s.yg)(ng,(0,p.A)({},eg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Samples per seconds."))}tg.isMDXComponent=!0;const og={toc:[]},pg="wrapper";function rg(e){let{components:n,...t}=e;return(0,s.yg)(pg,(0,p.A)({},og,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The runtime representation of meta files."))}rg.isMDXComponent=!0;const sg={toc:[]},cg="wrapper";function ag(e){let{components:n,...t}=e;return(0,s.yg)(cg,(0,p.A)({},sg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a boolean value stored in a meta file."))}ag.isMDXComponent=!0;const ig={toc:[]},lg="wrapper";function ug(e){let{components:n,...t}=e;return(0,s.yg)(lg,(0,p.A)({},ig,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}ug.isMDXComponent=!0;const mg={toc:[]},yg="wrapper";function dg(e){let{components:n,...t}=e;return(0,s.yg)(yg,(0,p.A)({},mg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}dg.isMDXComponent=!0;const hg={toc:[]},gg="wrapper";function fg(e){let{components:n,...t}=e;return(0,s.yg)(gg,(0,p.A)({},hg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}fg.isMDXComponent=!0;const Dg={toc:[]},Mg="wrapper";function Xg(e){let{components:n,...t}=e;return(0,s.yg)(Mg,(0,p.A)({},Dg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}Xg.isMDXComponent=!0;const _g={toc:[]},wg="wrapper";function Tg(e){let{components:n,...t}=e;return(0,s.yg)(wg,(0,p.A)({},_g,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}Tg.isMDXComponent=!0;const Cg={toc:[]},xg="wrapper";function Ag(e){let{components:n,...t}=e;return(0,s.yg)(xg,(0,p.A)({},Cg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}Ag.isMDXComponent=!0;const vg={toc:[]},Lg="wrapper";function bg(e){let{components:n,...t}=e;return(0,s.yg)(Lg,(0,p.A)({},vg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}bg.isMDXComponent=!0;const Ng={toc:[]},kg="wrapper";function zg(e){let{components:n,...t}=e;return(0,s.yg)(kg,(0,p.A)({},Ng,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}zg.isMDXComponent=!0;const Pg={toc:[]},Ig="wrapper";function Rg(e){let{components:n,...t}=e;return(0,s.yg)(Ig,(0,p.A)({},Pg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}Rg.isMDXComponent=!0;const Wg={toc:[]},Sg="wrapper";function Bg(e){let{components:n,...t}=e;return(0,s.yg)(Sg,(0,p.A)({},Wg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}Bg.isMDXComponent=!0;const Eg={toc:[]},Gg="wrapper";function Og(e){let{components:n,...t}=e;return(0,s.yg)(Gg,(0,p.A)({},Eg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}Og.isMDXComponent=!0;const Ug={toc:[]},Fg="wrapper";function Vg(e){let{components:n,...t}=e;return(0,s.yg)(Fg,(0,p.A)({},Ug,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}Vg.isMDXComponent=!0;const qg={toc:[]},jg="wrapper";function Hg(e){let{components:n,...t}=e;return(0,s.yg)(jg,(0,p.A)({},qg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}Hg.isMDXComponent=!0;const Yg={toc:[]},Qg="wrapper";function $g(e){let{components:n,...t}=e;return(0,s.yg)(Qg,(0,p.A)({},Yg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}$g.isMDXComponent=!0;const Kg={toc:[]},Jg="wrapper";function Zg(e){let{components:n,...t}=e;return(0,s.yg)(Jg,(0,p.A)({},Kg,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}Zg.isMDXComponent=!0;const ef={toc:[]},nf="wrapper";function tf(e){let{components:n,...t}=e;return(0,s.yg)(nf,(0,p.A)({},ef,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}tf.isMDXComponent=!0;const of={toc:[]},pf="wrapper";function rf(e){let{components:n,...t}=e;return(0,s.yg)(pf,(0,p.A)({},of,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}rf.isMDXComponent=!0;const sf={toc:[]},cf="wrapper";function af(e){let{components:n,...t}=e;return(0,s.yg)(cf,(0,p.A)({},sf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}af.isMDXComponent=!0;const lf={toc:[]},uf="wrapper";function mf(e){let{components:n,...t}=e;return(0,s.yg)(uf,(0,p.A)({},lf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}mf.isMDXComponent=!0;const yf={toc:[]},df="wrapper";function hf(e){let{components:n,...t}=e;return(0,s.yg)(df,(0,p.A)({},yf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}hf.isMDXComponent=!0;const gf={toc:[]},ff="wrapper";function Df(e){let{components:n,...t}=e;return(0,s.yg)(ff,(0,p.A)({},gf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a color stored in a meta file."))}Df.isMDXComponent=!0;const Mf={toc:[]},Xf="wrapper";function _f(e){let{components:n,...t}=e;return(0,s.yg)(Xf,(0,p.A)({},Mf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}_f.isMDXComponent=!0;const wf={toc:[]},Tf="wrapper";function Cf(e){let{components:n,...t}=e;return(0,s.yg)(Tf,(0,p.A)({},wf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}Cf.isMDXComponent=!0;const xf={toc:[]},Af="wrapper";function vf(e){let{components:n,...t}=e;return(0,s.yg)(Af,(0,p.A)({},xf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}vf.isMDXComponent=!0;const Lf={toc:[]},bf="wrapper";function Nf(e){let{components:n,...t}=e;return(0,s.yg)(bf,(0,p.A)({},Lf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}Nf.isMDXComponent=!0;const kf={toc:[]},zf="wrapper";function Pf(e){let{components:n,...t}=e;return(0,s.yg)(zf,(0,p.A)({},kf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}Pf.isMDXComponent=!0;const If={toc:[]},Rf="wrapper";function Wf(e){let{components:n,...t}=e;return(0,s.yg)(Rf,(0,p.A)({},If,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}Wf.isMDXComponent=!0;const Sf={toc:[]},Bf="wrapper";function Ef(e){let{components:n,...t}=e;return(0,s.yg)(Bf,(0,p.A)({},Sf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}Ef.isMDXComponent=!0;const Gf={toc:[]},Of="wrapper";function Uf(e){let{components:n,...t}=e;return(0,s.yg)(Of,(0,p.A)({},Gf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}Uf.isMDXComponent=!0;const Ff={toc:[]},Vf="wrapper";function qf(e){let{components:n,...t}=e;return(0,s.yg)(Vf,(0,p.A)({},Ff,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}qf.isMDXComponent=!0;const jf={toc:[]},Hf="wrapper";function Yf(e){let{components:n,...t}=e;return(0,s.yg)(Hf,(0,p.A)({},jf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}Yf.isMDXComponent=!0;const Qf={toc:[]},$f="wrapper";function Kf(e){let{components:n,...t}=e;return(0,s.yg)($f,(0,p.A)({},Qf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}Kf.isMDXComponent=!0;const Jf={toc:[]},Zf="wrapper";function eD(e){let{components:n,...t}=e;return(0,s.yg)(Zf,(0,p.A)({},Jf,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}eD.isMDXComponent=!0;const nD={toc:[]},tD="wrapper";function oD(e){let{components:n,...t}=e;return(0,s.yg)(tD,(0,p.A)({},nD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}oD.isMDXComponent=!0;const pD={toc:[]},rD="wrapper";function sD(e){let{components:n,...t}=e;return(0,s.yg)(rD,(0,p.A)({},pD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}sD.isMDXComponent=!0;const cD={toc:[]},aD="wrapper";function iD(e){let{components:n,...t}=e;return(0,s.yg)(aD,(0,p.A)({},cD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}iD.isMDXComponent=!0;const lD={toc:[]},uD="wrapper";function mD(e){let{components:n,...t}=e;return(0,s.yg)(uD,(0,p.A)({},lD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}mD.isMDXComponent=!0;const yD={toc:[]},dD="wrapper";function hD(e){let{components:n,...t}=e;return(0,s.yg)(dD,(0,p.A)({},yD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}hD.isMDXComponent=!0;const gD={toc:[]},fD="wrapper";function DD(e){let{components:n,...t}=e;return(0,s.yg)(fD,(0,p.A)({},gD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}DD.isMDXComponent=!0;const MD={toc:[]},XD="wrapper";function _D(e){let{components:n,...t}=e;return(0,s.yg)(XD,(0,p.A)({},MD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}_D.isMDXComponent=!0;const wD={toc:[]},TD="wrapper";function CD(e){let{components:n,...t}=e;return(0,s.yg)(TD,(0,p.A)({},wD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}CD.isMDXComponent=!0;const xD={toc:[]},AD="wrapper";function vD(e){let{components:n,...t}=e;return(0,s.yg)(AD,(0,p.A)({},xD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents an enum value stored in a meta file."))}vD.isMDXComponent=!0;const LD={toc:[]},bD="wrapper";function ND(e){let{components:n,...t}=e;return(0,s.yg)(bD,(0,p.A)({},LD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}ND.isMDXComponent=!0;const kD={toc:[]},zD="wrapper";function PD(e){let{components:n,...t}=e;return(0,s.yg)(zD,(0,p.A)({},kD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}PD.isMDXComponent=!0;const ID={toc:[]},RD="wrapper";function WD(e){let{components:n,...t}=e;return(0,s.yg)(RD,(0,p.A)({},ID,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}WD.isMDXComponent=!0;const SD={toc:[]},BD="wrapper";function ED(e){let{components:n,...t}=e;return(0,s.yg)(BD,(0,p.A)({},SD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}ED.isMDXComponent=!0;const GD={toc:[]},OD="wrapper";function UD(e){let{components:n,...t}=e;return(0,s.yg)(OD,(0,p.A)({},GD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}UD.isMDXComponent=!0;const FD={toc:[]},VD="wrapper";function qD(e){let{components:n,...t}=e;return(0,s.yg)(VD,(0,p.A)({},FD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}qD.isMDXComponent=!0;const jD={toc:[]},HD="wrapper";function YD(e){let{components:n,...t}=e;return(0,s.yg)(HD,(0,p.A)({},jD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}YD.isMDXComponent=!0;const QD={toc:[]},$D="wrapper";function KD(e){let{components:n,...t}=e;return(0,s.yg)($D,(0,p.A)({},QD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}KD.isMDXComponent=!0;const JD={toc:[]},ZD="wrapper";function eM(e){let{components:n,...t}=e;return(0,s.yg)(ZD,(0,p.A)({},JD,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}eM.isMDXComponent=!0;const nM={toc:[]},tM="wrapper";function oM(e){let{components:n,...t}=e;return(0,s.yg)(tM,(0,p.A)({},nM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}oM.isMDXComponent=!0;const pM={toc:[]},rM="wrapper";function sM(e){let{components:n,...t}=e;return(0,s.yg)(rM,(0,p.A)({},pM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}sM.isMDXComponent=!0;const cM={toc:[]},aM="wrapper";function iM(e){let{components:n,...t}=e;return(0,s.yg)(aM,(0,p.A)({},cM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}iM.isMDXComponent=!0;const lM={toc:[]},uM="wrapper";function mM(e){let{components:n,...t}=e;return(0,s.yg)(uM,(0,p.A)({},lM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}mM.isMDXComponent=!0;const yM={toc:[]},dM="wrapper";function hM(e){let{components:n,...t}=e;return(0,s.yg)(dM,(0,p.A)({},yM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}hM.isMDXComponent=!0;const gM={toc:[]},fM="wrapper";function DM(e){let{components:n,...t}=e;return(0,s.yg)(fM,(0,p.A)({},gM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}DM.isMDXComponent=!0;const MM={toc:[]},XM="wrapper";function _M(e){let{components:n,...t}=e;return(0,s.yg)(XM,(0,p.A)({},MM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}_M.isMDXComponent=!0;const wM={toc:[]},TM="wrapper";function CM(e){let{components:n,...t}=e;return(0,s.yg)(TM,(0,p.A)({},wM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}CM.isMDXComponent=!0;const xM={toc:[]},AM="wrapper";function vM(e){let{components:n,...t}=e;return(0,s.yg)(AM,(0,p.A)({},xM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}vM.isMDXComponent=!0;const LM={toc:[]},bM="wrapper";function NM(e){let{components:n,...t}=e;return(0,s.yg)(bM,(0,p.A)({},LM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the exporter configuration."))}NM.isMDXComponent=!0;const kM={toc:[]},zM="wrapper";function PM(e){let{components:n,...t}=e;return(0,s.yg)(zM,(0,p.A)({},kM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}PM.isMDXComponent=!0;const IM={toc:[]},RM="wrapper";function WM(e){let{components:n,...t}=e;return(0,s.yg)(RM,(0,p.A)({},IM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}WM.isMDXComponent=!0;const SM={toc:[]},BM="wrapper";function EM(e){let{components:n,...t}=e;return(0,s.yg)(BM,(0,p.A)({},SM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}EM.isMDXComponent=!0;const GM={toc:[]},OM="wrapper";function UM(e){let{components:n,...t}=e;return(0,s.yg)(OM,(0,p.A)({},GM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}UM.isMDXComponent=!0;const FM={toc:[]},VM="wrapper";function qM(e){let{components:n,...t}=e;return(0,s.yg)(VM,(0,p.A)({},FM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}qM.isMDXComponent=!0;const jM={toc:[]},HM="wrapper";function YM(e){let{components:n,...t}=e;return(0,s.yg)(HM,(0,p.A)({},jM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the nested fields change."))}YM.isMDXComponent=!0;const QM={toc:[]},$M="wrapper";function KM(e){let{components:n,...t}=e;return(0,s.yg)($M,(0,p.A)({},QM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}KM.isMDXComponent=!0;const JM={toc:[]},ZM="wrapper";function eX(e){let{components:n,...t}=e;return(0,s.yg)(ZM,(0,p.A)({},JM,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}eX.isMDXComponent=!0;const nX={toc:[]},tX="wrapper";function oX(e){let{components:n,...t}=e;return(0,s.yg)(tX,(0,p.A)({},nX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}oX.isMDXComponent=!0;const pX={toc:[]},rX="wrapper";function sX(e){let{components:n,...t}=e;return(0,s.yg)(rX,(0,p.A)({},pX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}sX.isMDXComponent=!0;const cX={toc:[]},aX="wrapper";function iX(e){let{components:n,...t}=e;return(0,s.yg)(aX,(0,p.A)({},cX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}iX.isMDXComponent=!0;const lX={toc:[]},uX="wrapper";function mX(e){let{components:n,...t}=e;return(0,s.yg)(uX,(0,p.A)({},lX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}mX.isMDXComponent=!0;const yX={toc:[]},dX="wrapper";function hX(e){let{components:n,...t}=e;return(0,s.yg)(dX,(0,p.A)({},yX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}hX.isMDXComponent=!0;const gX={toc:[]},fX="wrapper";function DX(e){let{components:n,...t}=e;return(0,s.yg)(fX,(0,p.A)({},gX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}DX.isMDXComponent=!0;const MX={toc:[]},XX="wrapper";function _X(e){let{components:n,...t}=e;return(0,s.yg)(XX,(0,p.A)({},MX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}_X.isMDXComponent=!0;const wX={toc:[]},TX="wrapper";function CX(e){let{components:n,...t}=e;return(0,s.yg)(TX,(0,p.A)({},wX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}CX.isMDXComponent=!0;const xX={toc:[]},AX="wrapper";function vX(e){let{components:n,...t}=e;return(0,s.yg)(AX,(0,p.A)({},xX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}vX.isMDXComponent=!0;const LX={toc:[]},bX="wrapper";function NX(e){let{components:n,...t}=e;return(0,s.yg)(bX,(0,p.A)({},LX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}NX.isMDXComponent=!0;const kX={toc:[]},zX="wrapper";function PX(e){let{components:n,...t}=e;return(0,s.yg)(zX,(0,p.A)({},kX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}PX.isMDXComponent=!0;const IX={toc:[]},RX="wrapper";function WX(e){let{components:n,...t}=e;return(0,s.yg)(RX,(0,p.A)({},IX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents an entry in the meta file."))}WX.isMDXComponent=!0;const SX={toc:[]},BX="wrapper";function EX(e){let{components:n,...t}=e;return(0,s.yg)(BX,(0,p.A)({},SX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}EX.isMDXComponent=!0;const GX={toc:[]},OX="wrapper";function UX(e){let{components:n,...t}=e;return(0,s.yg)(OX,(0,p.A)({},GX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}UX.isMDXComponent=!0;const FX={toc:[]},VX="wrapper";function qX(e){let{components:n,...t}=e;return(0,s.yg)(VX,(0,p.A)({},FX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}qX.isMDXComponent=!0;const jX={toc:[]},HX="wrapper";function YX(e){let{components:n,...t}=e;return(0,s.yg)(HX,(0,p.A)({},jX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}YX.isMDXComponent=!0;const QX={toc:[]},$X="wrapper";function KX(e){let{components:n,...t}=e;return(0,s.yg)($X,(0,p.A)({},QX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}KX.isMDXComponent=!0;const JX={toc:[]},ZX="wrapper";function e_(e){let{components:n,...t}=e;return(0,s.yg)(ZX,(0,p.A)({},JX,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}e_.isMDXComponent=!0;const n_={toc:[]},t_="wrapper";function o_(e){let{components:n,...t}=e;return(0,s.yg)(t_,(0,p.A)({},n_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}o_.isMDXComponent=!0;const p_={toc:[]},r_="wrapper";function s_(e){let{components:n,...t}=e;return(0,s.yg)(r_,(0,p.A)({},p_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}s_.isMDXComponent=!0;const c_={toc:[]},a_="wrapper";function i_(e){let{components:n,...t}=e;return(0,s.yg)(a_,(0,p.A)({},c_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}i_.isMDXComponent=!0;const l_={toc:[]},u_="wrapper";function m_(e){let{components:n,...t}=e;return(0,s.yg)(u_,(0,p.A)({},l_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}m_.isMDXComponent=!0;const y_={toc:[]},d_="wrapper";function h_(e){let{components:n,...t}=e;return(0,s.yg)(d_,(0,p.A)({},y_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}h_.isMDXComponent=!0;const g_={toc:[]},f_="wrapper";function D_(e){let{components:n,...t}=e;return(0,s.yg)(f_,(0,p.A)({},g_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}D_.isMDXComponent=!0;const M_={toc:[]},X_="wrapper";function __(e){let{components:n,...t}=e;return(0,s.yg)(X_,(0,p.A)({},M_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}__.isMDXComponent=!0;const w_={toc:[]},T_="wrapper";function C_(e){let{components:n,...t}=e;return(0,s.yg)(T_,(0,p.A)({},w_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}C_.isMDXComponent=!0;const x_={toc:[]},A_="wrapper";function v_(e){let{components:n,...t}=e;return(0,s.yg)(A_,(0,p.A)({},x_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}v_.isMDXComponent=!0;const L_={toc:[]},b_="wrapper";function N_(e){let{components:n,...t}=e;return(0,s.yg)(b_,(0,p.A)({},L_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}N_.isMDXComponent=!0;const k_={toc:[]},z_="wrapper";function P_(e){let{components:n,...t}=e;return(0,s.yg)(z_,(0,p.A)({},k_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}P_.isMDXComponent=!0;const I_={toc:[]},R_="wrapper";function W_(e){let{components:n,...t}=e;return(0,s.yg)(R_,(0,p.A)({},I_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}W_.isMDXComponent=!0;const S_={toc:[]},B_="wrapper";function E_(e){let{components:n,...t}=e;return(0,s.yg)(B_,(0,p.A)({},S_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}E_.isMDXComponent=!0;const G_={toc:[]},O_="wrapper";function U_(e){let{components:n,...t}=e;return(0,s.yg)(O_,(0,p.A)({},G_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}U_.isMDXComponent=!0;const F_={toc:[]},V_="wrapper";function q_(e){let{components:n,...t}=e;return(0,s.yg)(V_,(0,p.A)({},F_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type used to store this field in the meta\nfile."))}q_.isMDXComponent=!0;const j_={toc:[]},H_="wrapper";function Y_(e){let{components:n,...t}=e;return(0,s.yg)(H_,(0,p.A)({},j_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The runtime type of this field."))}Y_.isMDXComponent=!0;const Q_={toc:[]},$_="wrapper";function K_(e){let{components:n,...t}=e;return(0,s.yg)($_,(0,p.A)({},Q_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a number stored in a meta file."))}K_.isMDXComponent=!0;const J_={toc:[]},Z_="wrapper";function ew(e){let{components:n,...t}=e;return(0,s.yg)(Z_,(0,p.A)({},J_,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}ew.isMDXComponent=!0;const nw={toc:[]},tw="wrapper";function ow(e){let{components:n,...t}=e;return(0,s.yg)(tw,(0,p.A)({},nw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}ow.isMDXComponent=!0;const pw={toc:[]},rw="wrapper";function sw(e){let{components:n,...t}=e;return(0,s.yg)(rw,(0,p.A)({},pw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}sw.isMDXComponent=!0;const cw={toc:[]},aw="wrapper";function iw(e){let{components:n,...t}=e;return(0,s.yg)(aw,(0,p.A)({},cw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}iw.isMDXComponent=!0;const lw={toc:[]},uw="wrapper";function mw(e){let{components:n,...t}=e;return(0,s.yg)(uw,(0,p.A)({},lw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}mw.isMDXComponent=!0;const yw={toc:[]},dw="wrapper";function hw(e){let{components:n,...t}=e;return(0,s.yg)(dw,(0,p.A)({},yw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}hw.isMDXComponent=!0;const gw={toc:[]},fw="wrapper";function Dw(e){let{components:n,...t}=e;return(0,s.yg)(fw,(0,p.A)({},gw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}Dw.isMDXComponent=!0;const Mw={toc:[]},Xw="wrapper";function _w(e){let{components:n,...t}=e;return(0,s.yg)(Xw,(0,p.A)({},Mw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}_w.isMDXComponent=!0;const ww={toc:[]},Tw="wrapper";function Cw(e){let{components:n,...t}=e;return(0,s.yg)(Tw,(0,p.A)({},ww,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}Cw.isMDXComponent=!0;const xw={toc:[]},Aw="wrapper";function vw(e){let{components:n,...t}=e;return(0,s.yg)(Aw,(0,p.A)({},xw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}vw.isMDXComponent=!0;const Lw={toc:[]},bw="wrapper";function Nw(e){let{components:n,...t}=e;return(0,s.yg)(bw,(0,p.A)({},Lw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}Nw.isMDXComponent=!0;const kw={toc:[]},zw="wrapper";function Pw(e){let{components:n,...t}=e;return(0,s.yg)(zw,(0,p.A)({},kw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}Pw.isMDXComponent=!0;const Iw={toc:[]},Rw="wrapper";function Ww(e){let{components:n,...t}=e;return(0,s.yg)(Rw,(0,p.A)({},Iw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}Ww.isMDXComponent=!0;const Sw={toc:[]},Bw="wrapper";function Ew(e){let{components:n,...t}=e;return(0,s.yg)(Bw,(0,p.A)({},Sw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}Ew.isMDXComponent=!0;const Gw={toc:[]},Ow="wrapper";function Uw(e){let{components:n,...t}=e;return(0,s.yg)(Ow,(0,p.A)({},Gw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}Uw.isMDXComponent=!0;const Fw={toc:[]},Vw="wrapper";function qw(e){let{components:n,...t}=e;return(0,s.yg)(Vw,(0,p.A)({},Fw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}qw.isMDXComponent=!0;const jw={toc:[]},Hw="wrapper";function Yw(e){let{components:n,...t}=e;return(0,s.yg)(Hw,(0,p.A)({},jw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}Yw.isMDXComponent=!0;const Qw={toc:[]},$w="wrapper";function Kw(e){let{components:n,...t}=e;return(0,s.yg)($w,(0,p.A)({},Qw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}Kw.isMDXComponent=!0;const Jw={toc:[]},Zw="wrapper";function eT(e){let{components:n,...t}=e;return(0,s.yg)(Zw,(0,p.A)({},Jw,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}eT.isMDXComponent=!0;const nT={toc:[]},tT="wrapper";function oT(e){let{components:n,...t}=e;return(0,s.yg)(tT,(0,p.A)({},nT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}oT.isMDXComponent=!0;const pT={toc:[]},rT="wrapper";function sT(e){let{components:n,...t}=e;return(0,s.yg)(rT,(0,p.A)({},pT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Range is an array with two elements denoting the beginning and end of a\nrange, respectively."))}sT.isMDXComponent=!0;const cT={toc:[]},aT="wrapper";function iT(e){let{components:n,...t}=e;return(0,s.yg)(aT,(0,p.A)({},cT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a range stored in a meta file."))}iT.isMDXComponent=!0;const lT={toc:[]},uT="wrapper";function mT(e){let{components:n,...t}=e;return(0,s.yg)(uT,(0,p.A)({},lT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}mT.isMDXComponent=!0;const yT={toc:[]},dT="wrapper";function hT(e){let{components:n,...t}=e;return(0,s.yg)(dT,(0,p.A)({},yT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}hT.isMDXComponent=!0;const gT={toc:[]},fT="wrapper";function DT(e){let{components:n,...t}=e;return(0,s.yg)(fT,(0,p.A)({},gT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}DT.isMDXComponent=!0;const MT={toc:[]},XT="wrapper";function _T(e){let{components:n,...t}=e;return(0,s.yg)(XT,(0,p.A)({},MT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}_T.isMDXComponent=!0;const wT={toc:[]},TT="wrapper";function CT(e){let{components:n,...t}=e;return(0,s.yg)(TT,(0,p.A)({},wT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}CT.isMDXComponent=!0;const xT={toc:[]},AT="wrapper";function vT(e){let{components:n,...t}=e;return(0,s.yg)(AT,(0,p.A)({},xT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}vT.isMDXComponent=!0;const LT={toc:[]},bT="wrapper";function NT(e){let{components:n,...t}=e;return(0,s.yg)(bT,(0,p.A)({},LT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}NT.isMDXComponent=!0;const kT={toc:[]},zT="wrapper";function PT(e){let{components:n,...t}=e;return(0,s.yg)(zT,(0,p.A)({},kT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}PT.isMDXComponent=!0;const IT={toc:[]},RT="wrapper";function WT(e){let{components:n,...t}=e;return(0,s.yg)(RT,(0,p.A)({},IT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}WT.isMDXComponent=!0;const ST={toc:[]},BT="wrapper";function ET(e){let{components:n,...t}=e;return(0,s.yg)(BT,(0,p.A)({},ST,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}ET.isMDXComponent=!0;const GT={toc:[]},OT="wrapper";function UT(e){let{components:n,...t}=e;return(0,s.yg)(OT,(0,p.A)({},GT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}UT.isMDXComponent=!0;const FT={toc:[]},VT="wrapper";function qT(e){let{components:n,...t}=e;return(0,s.yg)(VT,(0,p.A)({},FT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}qT.isMDXComponent=!0;const jT={toc:[]},HT="wrapper";function YT(e){let{components:n,...t}=e;return(0,s.yg)(HT,(0,p.A)({},jT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}YT.isMDXComponent=!0;const QT={toc:[]},$T="wrapper";function KT(e){let{components:n,...t}=e;return(0,s.yg)($T,(0,p.A)({},QT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}KT.isMDXComponent=!0;const JT={toc:[]},ZT="wrapper";function eC(e){let{components:n,...t}=e;return(0,s.yg)(ZT,(0,p.A)({},JT,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}eC.isMDXComponent=!0;const nC={toc:[]},tC="wrapper";function oC(e){let{components:n,...t}=e;return(0,s.yg)(tC,(0,p.A)({},nC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}oC.isMDXComponent=!0;const pC={toc:[]},rC="wrapper";function sC(e){let{components:n,...t}=e;return(0,s.yg)(rC,(0,p.A)({},pC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}sC.isMDXComponent=!0;const cC={toc:[]},aC="wrapper";function iC(e){let{components:n,...t}=e;return(0,s.yg)(aC,(0,p.A)({},cC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}iC.isMDXComponent=!0;const lC={toc:[]},uC="wrapper";function mC(e){let{components:n,...t}=e;return(0,s.yg)(uC,(0,p.A)({},lC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}mC.isMDXComponent=!0;const yC={toc:[]},dC="wrapper";function hC(e){let{components:n,...t}=e;return(0,s.yg)(dC,(0,p.A)({},yC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}hC.isMDXComponent=!0;const gC={toc:[]},fC="wrapper";function DC(e){let{components:n,...t}=e;return(0,s.yg)(fC,(0,p.A)({},gC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This helper method applies additional validation to the range, preventing\nit from overflowing the timeline."))}DC.isMDXComponent=!0;const MC={toc:[]},XC="wrapper";function _C(e){let{components:n,...t}=e;return(0,s.yg)(XC,(0,p.A)({},MC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert the given range from frames to seconds and update this field."))}_C.isMDXComponent=!0;const wC={toc:[]},TC="wrapper";function CC(e){let{components:n,...t}=e;return(0,s.yg)(TC,(0,p.A)({},wC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The beginning of the range."))}CC.isMDXComponent=!0;const xC={toc:[]},AC="wrapper";function vC(e){let{components:n,...t}=e;return(0,s.yg)(AC,(0,p.A)({},xC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end of the range."))}vC.isMDXComponent=!0;const LC={toc:[]},bC="wrapper";function NC(e){let{components:n,...t}=e;return(0,s.yg)(bC,(0,p.A)({},LC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The current duration in frames."))}NC.isMDXComponent=!0;const kC={toc:[]},zC="wrapper";function PC(e){let{components:n,...t}=e;return(0,s.yg)(zC,(0,p.A)({},kC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The current framerate."))}PC.isMDXComponent=!0;const IC={toc:[]},RC="wrapper";function WC(e){let{components:n,...t}=e;return(0,s.yg)(RC,(0,p.A)({},IC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a string stored in a meta file."))}WC.isMDXComponent=!0;const SC={toc:[]},BC="wrapper";function EC(e){let{components:n,...t}=e;return(0,s.yg)(BC,(0,p.A)({},SC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}EC.isMDXComponent=!0;const GC={toc:[]},OC="wrapper";function UC(e){let{components:n,...t}=e;return(0,s.yg)(OC,(0,p.A)({},GC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}UC.isMDXComponent=!0;const FC={toc:[]},VC="wrapper";function qC(e){let{components:n,...t}=e;return(0,s.yg)(VC,(0,p.A)({},FC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}qC.isMDXComponent=!0;const jC={toc:[]},HC="wrapper";function YC(e){let{components:n,...t}=e;return(0,s.yg)(HC,(0,p.A)({},jC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}YC.isMDXComponent=!0;const QC={toc:[]},$C="wrapper";function KC(e){let{components:n,...t}=e;return(0,s.yg)($C,(0,p.A)({},QC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}KC.isMDXComponent=!0;const JC={toc:[]},ZC="wrapper";function ex(e){let{components:n,...t}=e;return(0,s.yg)(ZC,(0,p.A)({},JC,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}ex.isMDXComponent=!0;const nx={toc:[]},tx="wrapper";function ox(e){let{components:n,...t}=e;return(0,s.yg)(tx,(0,p.A)({},nx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}ox.isMDXComponent=!0;const px={toc:[]},rx="wrapper";function sx(e){let{components:n,...t}=e;return(0,s.yg)(rx,(0,p.A)({},px,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}sx.isMDXComponent=!0;const cx={toc:[]},ax="wrapper";function ix(e){let{components:n,...t}=e;return(0,s.yg)(ax,(0,p.A)({},cx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}ix.isMDXComponent=!0;const lx={toc:[]},ux="wrapper";function mx(e){let{components:n,...t}=e;return(0,s.yg)(ux,(0,p.A)({},lx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}mx.isMDXComponent=!0;const yx={toc:[]},dx="wrapper";function hx(e){let{components:n,...t}=e;return(0,s.yg)(dx,(0,p.A)({},yx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}hx.isMDXComponent=!0;const gx={toc:[]},fx="wrapper";function Dx(e){let{components:n,...t}=e;return(0,s.yg)(fx,(0,p.A)({},gx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}Dx.isMDXComponent=!0;const Mx={toc:[]},Xx="wrapper";function _x(e){let{components:n,...t}=e;return(0,s.yg)(Xx,(0,p.A)({},Mx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}_x.isMDXComponent=!0;const wx={toc:[]},Tx="wrapper";function Cx(e){let{components:n,...t}=e;return(0,s.yg)(Tx,(0,p.A)({},wx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}Cx.isMDXComponent=!0;const xx={toc:[]},Ax="wrapper";function vx(e){let{components:n,...t}=e;return(0,s.yg)(Ax,(0,p.A)({},xx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}vx.isMDXComponent=!0;const Lx={toc:[]},bx="wrapper";function Nx(e){let{components:n,...t}=e;return(0,s.yg)(bx,(0,p.A)({},Lx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}Nx.isMDXComponent=!0;const kx={toc:[]},zx="wrapper";function Px(e){let{components:n,...t}=e;return(0,s.yg)(zx,(0,p.A)({},kx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}Px.isMDXComponent=!0;const Ix={toc:[]},Rx="wrapper";function Wx(e){let{components:n,...t}=e;return(0,s.yg)(Rx,(0,p.A)({},Ix,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}Wx.isMDXComponent=!0;const Sx={toc:[]},Bx="wrapper";function Ex(e){let{components:n,...t}=e;return(0,s.yg)(Bx,(0,p.A)({},Sx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}Ex.isMDXComponent=!0;const Gx={toc:[]},Ox="wrapper";function Ux(e){let{components:n,...t}=e;return(0,s.yg)(Ox,(0,p.A)({},Gx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}Ux.isMDXComponent=!0;const Fx={toc:[]},Vx="wrapper";function qx(e){let{components:n,...t}=e;return(0,s.yg)(Vx,(0,p.A)({},Fx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a two-dimensional vector stored in a meta file."))}qx.isMDXComponent=!0;const jx={toc:[]},Hx="wrapper";function Yx(e){let{components:n,...t}=e;return(0,s.yg)(Hx,(0,p.A)({},jx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}Yx.isMDXComponent=!0;const Qx={toc:[]},$x="wrapper";function Kx(e){let{components:n,...t}=e;return(0,s.yg)($x,(0,p.A)({},Qx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}Kx.isMDXComponent=!0;const Jx={toc:[]},Zx="wrapper";function eA(e){let{components:n,...t}=e;return(0,s.yg)(Zx,(0,p.A)({},Jx,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of this field."))}eA.isMDXComponent=!0;const nA={toc:[]},tA="wrapper";function oA(e){let{components:n,...t}=e;return(0,s.yg)(tA,(0,p.A)({},nA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of this field displayed in the editor."))}oA.isMDXComponent=!0;const pA={toc:[]},rA="wrapper";function sA(e){let{components:n,...t}=e;return(0,s.yg)(rA,(0,p.A)({},pA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of this field used by the editor to display the correct input."))}sA.isMDXComponent=!0;const cA={toc:[]},aA="wrapper";function iA(e){let{components:n,...t}=e;return(0,s.yg)(aA,(0,p.A)({},cA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the data of this field changes."))}iA.isMDXComponent=!0;const lA={toc:[]},uA="wrapper";function mA(e){let{components:n,...t}=e;return(0,s.yg)(uA,(0,p.A)({},lA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the field becomes disabled or enabled."))}mA.isMDXComponent=!0;const yA={toc:[]},dA="wrapper";function hA(e){let{components:n,...t}=e;return(0,s.yg)(dA,(0,p.A)({},yA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a clone of this field."))}hA.isMDXComponent=!0;const gA={toc:[]},fA="wrapper";function DA(e){let{components:n,...t}=e;return(0,s.yg)(fA,(0,p.A)({},gA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the description of this field."))}DA.isMDXComponent=!0;const MA={toc:[]},XA="wrapper";function _A(e){let{components:n,...t}=e;return(0,s.yg)(XA,(0,p.A)({},MA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The description."))}_A.isMDXComponent=!0;const wA={toc:[]},TA="wrapper";function CA(e){let{components:n,...t}=e;return(0,s.yg)(TA,(0,p.A)({},wA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Disable or enable the field in the editor."))}CA.isMDXComponent=!0;const xA={toc:[]},AA="wrapper";function vA(e){let{components:n,...t}=e;return(0,s.yg)(AA,(0,p.A)({},xA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the field should be disabled."))}vA.isMDXComponent=!0;const LA={toc:[]},bA="wrapper";function NA(e){let{components:n,...t}=e;return(0,s.yg)(bA,(0,p.A)({},LA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current value."))}NA.isMDXComponent=!0;const kA={toc:[]},zA="wrapper";function PA(e){let{components:n,...t}=e;return(0,s.yg)(zA,(0,p.A)({},kA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a serialized value into a runtime type."))}PA.isMDXComponent=!0;const IA={toc:[]},RA="wrapper";function WA(e){let{components:n,...t}=e;return(0,s.yg)(RA,(0,p.A)({},IA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The serialized value."))}WA.isMDXComponent=!0;const SA={toc:[]},BA="wrapper";function EA(e){let{components:n,...t}=e;return(0,s.yg)(BA,(0,p.A)({},SA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Serialize the value of this field."))}EA.isMDXComponent=!0;const GA={toc:[]},OA="wrapper";function UA(e){let{components:n,...t}=e;return(0,s.yg)(OA,(0,p.A)({},GA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the current value."))}UA.isMDXComponent=!0;const FA={toc:[]},VA="wrapper";function qA(e){let{components:n,...t}=e;return(0,s.yg)(VA,(0,p.A)({},FA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new value."))}qA.isMDXComponent=!0;const jA={toc:[]},HA="wrapper";function YA(e){let{components:n,...t}=e;return(0,s.yg)(HA,(0,p.A)({},jA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add or remove spacing at the beginning of this field."))}YA.isMDXComponent=!0;const QA={toc:[]},$A="wrapper";function KA(e){let{components:n,...t}=e;return(0,s.yg)($A,(0,p.A)({},QA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to include the spacing."))}KA.isMDXComponent=!0;const JA={toc:[]},ZA="wrapper";function ev(e){let{components:n,...t}=e;return(0,s.yg)(ZA,(0,p.A)({},JA,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents an object with nested meta-fields."))}ev.isMDXComponent=!0;const nv={toc:[]},tv="wrapper";function ov(e){let{components:n,...t}=e;return(0,s.yg)(tv,(0,p.A)({},nv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents an object with nested meta-fields."))}ov.isMDXComponent=!0;const pv={toc:[]},rv="wrapper";function sv(e){let{components:n,...t}=e;return(0,s.yg)(rv,(0,p.A)({},pv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a runtime Motion Canvas plugin."))}sv.isMDXComponent=!0;const cv={toc:[]},av="wrapper";function iv(e){let{components:n,...t}=e;return(0,s.yg)(av,(0,p.A)({},cv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name should be unique across the entire ecosystem of Motion Canvas.\nIf a plugin with the same name has already been registered, this plugin\nwill be ignored."),(0,s.yg)("p",null,"If you intend to publish your plugin to npm, it is recommended to prefix\nthis name with the name of your npm package."),(0,s.yg)("p",null,"Other identifiers defined by the plugin, such as a tab id, will be\nautomatically prefixed with this name and as such don't have to be unique."))}iv.isMDXComponent=!0;const lv={toc:[]},uv="wrapper";function mv(e){let{components:n,...t}=e;return(0,s.yg)(uv,(0,p.A)({},lv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A unique name of the plugin."))}mv.isMDXComponent=!0;const yv={toc:[]},dv="wrapper";function hv(e){let{components:n,...t}=e;return(0,s.yg)(dv,(0,p.A)({},yv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provide custom exporters for the project."))}hv.isMDXComponent=!0;const gv={toc:[]},fv="wrapper";function Dv(e){let{components:n,...t}=e;return(0,s.yg)(fv,(0,p.A)({},gv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The project instance."))}Dv.isMDXComponent=!0;const Mv={toc:[]},Xv="wrapper";function _v(e){let{components:n,...t}=e;return(0,s.yg)(Xv,(0,p.A)({},Mv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Receive the player instance right after it is initialized."))}_v.isMDXComponent=!0;const wv={toc:[]},Tv="wrapper";function Cv(e){let{components:n,...t}=e;return(0,s.yg)(Tv,(0,p.A)({},wv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The player instance."))}Cv.isMDXComponent=!0;const xv={toc:[]},Av="wrapper";function vv(e){let{components:n,...t}=e;return(0,s.yg)(Av,(0,p.A)({},xv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Receive the presenter instance right after it is initialized."))}vv.isMDXComponent=!0;const Lv={toc:[]},bv="wrapper";function Nv(e){let{components:n,...t}=e;return(0,s.yg)(bv,(0,p.A)({},Lv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The presenter instance."))}Nv.isMDXComponent=!0;const kv={toc:[]},zv="wrapper";function Pv(e){let{components:n,...t}=e;return(0,s.yg)(zv,(0,p.A)({},kv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Receive the project instance right after it is initialized."))}Pv.isMDXComponent=!0;const Iv={toc:[]},Rv="wrapper";function Wv(e){let{components:n,...t}=e;return(0,s.yg)(Rv,(0,p.A)({},Iv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The project instance."))}Wv.isMDXComponent=!0;const Sv={toc:[]},Bv="wrapper";function Ev(e){let{components:n,...t}=e;return(0,s.yg)(Bv,(0,p.A)({},Sv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Receive the renderer instance right after it is initialized."))}Ev.isMDXComponent=!0;const Gv={toc:[]},Ov="wrapper";function Uv(e){let{components:n,...t}=e;return(0,s.yg)(Ov,(0,p.A)({},Gv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The renderer instance."))}Uv.isMDXComponent=!0;const Fv={toc:[]},Vv="wrapper";function qv(e){let{components:n,...t}=e;return(0,s.yg)(Vv,(0,p.A)({},Fv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Modify the project settings before the project is initialized."))}qv.isMDXComponent=!0;const jv={toc:[]},Hv="wrapper";function Yv(e){let{components:n,...t}=e;return(0,s.yg)(Hv,(0,p.A)({},jv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The project settings."))}Yv.isMDXComponent=!0;const Qv={toc:[]},$v="wrapper";function Kv(e){let{components:n,...t}=e;return(0,s.yg)($v,(0,p.A)({},Qv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"export default makePlugin({\n  name: 'my-custom-plugin',\n});\n")))}Kv.isMDXComponent=!0;const Jv={toc:[]},Zv="wrapper";function eL(e){let{components:n,...t}=e;return(0,s.yg)(Zv,(0,p.A)({},Jv,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper function for exporting Motion Canvas plugins."))}eL.isMDXComponent=!0;const nL={toc:[]},tL="wrapper";function oL(e){let{components:n,...t}=e;return(0,s.yg)(tL,(0,p.A)({},nL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The plugin configuration."))}oL.isMDXComponent=!0;const pL={toc:[]},rL="wrapper";function sL(e){let{components:n,...t}=e;return(0,s.yg)(rL,(0,p.A)({},pL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Abstract scene representations and related utilities."))}sL.isMDXComponent=!0;const cL={toc:[]},aL="wrapper";function iL(e){let{components:n,...t}=e;return(0,s.yg)(aL,(0,p.A)({},cL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Signifies the various stages of a ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.yg)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}iL.isMDXComponent=!0;const lL={toc:[]},uL="wrapper";function mL(e){let{components:n,...t}=e;return(0,s.yg)(uL,(0,p.A)({},lL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Occurs after a render ends."))}mL.isMDXComponent=!0;const yL={toc:[]},dL="wrapper";function hL(e){let{components:n,...t}=e;return(0,s.yg)(dL,(0,p.A)({},yL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}hL.isMDXComponent=!0;const gL={toc:[]},fL="wrapper";function DL(e){let{components:n,...t}=e;return(0,s.yg)(fL,(0,p.A)({},gL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,s.yg)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}DL.isMDXComponent=!0;const ML={toc:[]},XL="wrapper";function _L(e){let{components:n,...t}=e;return(0,s.yg)(XL,(0,p.A)({},ML,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Occurs at the end of a render when the Scene's\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,s.yg)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}_L.isMDXComponent=!0;const wL={toc:[]},TL="wrapper";function CL(e){let{components:n,...t}=e;return(0,s.yg)(TL,(0,p.A)({},wL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes the state of a scene."))}CL.isMDXComponent=!0;const xL={toc:[]},AL="wrapper";function vL(e){let{components:n,...t}=e;return(0,s.yg)(AL,(0,p.A)({},xL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}vL.isMDXComponent=!0;const LL={toc:[]},bL="wrapper";function NL(e){let{components:n,...t}=e;return(0,s.yg)(bL,(0,p.A)({},LL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The scene has finished transitioning in."))}NL.isMDXComponent=!0;const kL={toc:[]},zL="wrapper";function PL(e){let{components:n,...t}=e;return(0,s.yg)(zL,(0,p.A)({},kL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.yg)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.yg)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}PL.isMDXComponent=!0;const IL={toc:[]},RL="wrapper";function WL(e){let{components:n,...t}=e;return(0,s.yg)(RL,(0,p.A)({},IL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The scene is ready to transition out."))}WL.isMDXComponent=!0;const SL={toc:[]},BL="wrapper";function EL(e){let{components:n,...t}=e;return(0,s.yg)(BL,(0,p.A)({},SL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Invoking ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.yg)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}EL.isMDXComponent=!0;const GL={toc:[]},OL="wrapper";function UL(e){let{components:n,...t}=e;return(0,s.yg)(OL,(0,p.A)({},GL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The scene has finished."))}UL.isMDXComponent=!0;const FL={toc:[]},VL="wrapper";function qL(e){let{components:n,...t}=e;return(0,s.yg)(VL,(0,p.A)({},FL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The scene has just been created/reset."))}qL.isMDXComponent=!0;const jL={toc:[]},HL="wrapper";function YL(e){let{components:n,...t}=e;return(0,s.yg)(HL,(0,p.A)({},jL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The default implementation of the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.yg)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,s.yg)("p",null,"Uses generators to control the animation."))}YL.isMDXComponent=!0;const QL={toc:[]},$L="wrapper";function KL(e){let{components:n,...t}=e;return(0,s.yg)($L,(0,p.A)({},QL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The root path of the assets. Prefix for all relative paths."))}KL.isMDXComponent=!0;const JL={toc:[]},ZL="wrapper";function eb(e){let{components:n,...t}=e;return(0,s.yg)(ZL,(0,p.A)({},JL,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Will be passed as the second argument to the constructor."))}eb.isMDXComponent=!0;const nb={toc:[]},tb="wrapper";function ob(e){let{components:n,...t}=e;return(0,s.yg)(tb,(0,p.A)({},nb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Name of the scene."))}ob.isMDXComponent=!0;const pb={toc:[]},rb="wrapper";function sb(e){let{components:n,...t}=e;return(0,s.yg)(rb,(0,p.A)({},pb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reference to the project."))}sb.isMDXComponent=!0;const cb={toc:[]},ab="wrapper";function ib(e){let{components:n,...t}=e;return(0,s.yg)(ab,(0,p.A)({},cb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Should this scene be rendered below the previous scene during a transition?"))}ib.isMDXComponent=!0;const lb={toc:[]},ub="wrapper";function mb(e){let{components:n,...t}=e;return(0,s.yg)(ub,(0,p.A)({},lb,t,{components:n,mdxType:"MDXLayout"}))}mb.isMDXComponent=!0;const yb={toc:[]},db="wrapper";function hb(e){let{components:n,...t}=e;return(0,s.yg)(db,(0,p.A)({},yb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lifecycleEvents"},(0,s.yg)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}hb.isMDXComponent=!0;const gb={toc:[]},fb="wrapper";function Db(e){let{components:n,...t}=e;return(0,s.yg)(fb,(0,p.A)({},gb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.yg)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}Db.isMDXComponent=!0;const Mb={toc:[]},Xb="wrapper";function _b(e){let{components:n,...t}=e;return(0,s.yg)(Xb,(0,p.A)({},Mb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame at which this scene starts."))}_b.isMDXComponent=!0;const wb={toc:[]},Tb="wrapper";function Cb(e){let{components:n,...t}=e;return(0,s.yg)(Tb,(0,p.A)({},wb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame at which this scene ends."))}Cb.isMDXComponent=!0;const xb={toc:[]},Ab="wrapper";function vb(e){let{components:n,...t}=e;return(0,s.yg)(Ab,(0,p.A)({},xb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the cached data changes."))}vb.isMDXComponent=!0;const Lb={toc:[]},bb="wrapper";function Nb(e){let{components:n,...t}=e;return(0,s.yg)(bb,(0,p.A)({},Lb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered after scene is recalculated."))}Nb.isMDXComponent=!0;const kb={toc:[]},zb="wrapper";function Pb(e){let{components:n,...t}=e;return(0,s.yg)(zb,(0,p.A)({},kb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the scene is reloaded."))}Pb.isMDXComponent=!0;const Ib={toc:[]},Rb="wrapper";function Wb(e){let{components:n,...t}=e;return(0,s.yg)(Rb,(0,p.A)({},Ib,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Wb.isMDXComponent=!0;const Sb={toc:[]},Bb="wrapper";function Eb(e){let{components:n,...t}=e;return(0,s.yg)(Bb,(0,p.A)({},Sb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the scene is reset."))}Eb.isMDXComponent=!0;const Gb={toc:[]},Ob="wrapper";function Ub(e){let{components:n,...t}=e;return(0,s.yg)(Ob,(0,p.A)({},Gb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the main thread changes."))}Ub.isMDXComponent=!0;const Fb={toc:[]},Vb="wrapper";function qb(e){let{components:n,...t}=e;return(0,s.yg)(Vb,(0,p.A)({},Fb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The scene directly before this scene, or null if omitted for performance."))}qb.isMDXComponent=!0;const jb={toc:[]},Hb="wrapper";function Yb(e){let{components:n,...t}=e;return(0,s.yg)(Hb,(0,p.A)({},jb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene in the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.yg)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}Yb.isMDXComponent=!0;const Qb={toc:[]},$b="wrapper";function Kb(e){let{components:n,...t}=e;return(0,s.yg)($b,(0,p.A)({},Qb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enter the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.yg)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}Kb.isMDXComponent=!0;const Jb={toc:[]},Zb="wrapper";function eN(e){let{components:n,...t}=e;return(0,s.yg)(Zb,(0,p.A)({},Jb,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enter the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.yg)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}eN.isMDXComponent=!0;const nN={toc:[]},tN="wrapper";function oN(e){let{components:n,...t}=e;return(0,s.yg)(tN,(0,p.A)({},nN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enter the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.yg)("inlineCode",{parentName:"a"},"Initial"))," state."))}oN.isMDXComponent=!0;const pN={toc:[]},rN="wrapper";function sN(e){let{components:n,...t}=e;return(0,s.yg)(rN,(0,p.A)({},pN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}sN.isMDXComponent=!0;const cN={toc:[]},aN="wrapper";function iN(e){let{components:n,...t}=e;return(0,s.yg)(aN,(0,p.A)({},cN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Invoke the given callback in the context of this scene."))}iN.isMDXComponent=!0;const lN={toc:[]},uN="wrapper";function mN(e){let{components:n,...t}=e;return(0,s.yg)(uN,(0,p.A)({},lN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The callback to invoke."))}mN.isMDXComponent=!0;const yN={toc:[]},dN="wrapper";function hN(e){let{components:n,...t}=e;return(0,s.yg)(dN,(0,p.A)({},yN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get all media assets"))}hN.isMDXComponent=!0;const gN={toc:[]},fN="wrapper";function DN(e){let{components:n,...t}=e;return(0,s.yg)(fN,(0,p.A)({},gN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Returns the size of the scene multiplied by the resolution scale.\nThis is the actual size of the canvas onto which the scene is rendered."))}DN.isMDXComponent=!0;const MN={toc:[]},XN="wrapper";function _N(e){let{components:n,...t}=e;return(0,s.yg)(XN,(0,p.A)({},MN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the real size of this scene."))}_N.isMDXComponent=!0;const wN={toc:[]},TN="wrapper";function CN(e){let{components:n,...t}=e;return(0,s.yg)(TN,(0,p.A)({},wN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Usually returns ",(0,s.yg)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}CN.isMDXComponent=!0;const xN={toc:[]},AN="wrapper";function vN(e){let{components:n,...t}=e;return(0,s.yg)(AN,(0,p.A)({},xN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the size of this scene."))}vN.isMDXComponent=!0;const LN={toc:[]},bN="wrapper";function NN(e){let{components:n,...t}=e;return(0,s.yg)(bN,(0,p.A)({},LN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene in the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.yg)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}NN.isMDXComponent=!0;const kN={toc:[]},zN="wrapper";function PN(e){let{components:n,...t}=e;return(0,s.yg)(zN,(0,p.A)({},kN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Used only by ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.yg)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.yg)("p",null,"Should always return ",(0,s.yg)("inlineCode",{parentName:"p"},"true"),"."))}PN.isMDXComponent=!0;const IN={toc:[]},RN="wrapper";function WN(e){let{components:n,...t}=e;return(0,s.yg)(RN,(0,p.A)({},IN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene cached?"))}WN.isMDXComponent=!0;const SN={toc:[]},BN="wrapper";function EN(e){let{components:n,...t}=e;return(0,s.yg)(BN,(0,p.A)({},SN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene in the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.yg)("inlineCode",{parentName:"a"},"Finished"))," state?"))}EN.isMDXComponent=!0;const GN={toc:[]},ON="wrapper";function UN(e){let{components:n,...t}=e;return(0,s.yg)(ON,(0,p.A)({},GN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Progress this scene one frame forward."))}UN.isMDXComponent=!0;const FN={toc:[]},VN="wrapper";function qN(e){let{components:n,...t}=e;return(0,s.yg)(VN,(0,p.A)({},FN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.yg)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,s.yg)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.yg)("p",null,"At the end of execution, this method should set ",(0,s.yg)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,s.yg)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.yg)("p",null,"Should trigger ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,s.yg)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}qN.isMDXComponent=!0;const jN={toc:[]},HN="wrapper";function YN(e){let{components:n,...t}=e;return(0,s.yg)(HN,(0,p.A)({},jN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Recalculate the scene."))}YN.isMDXComponent=!0;const QN={toc:[]},$N="wrapper";function KN(e){let{components:n,...t}=e;return(0,s.yg)($N,(0,p.A)({},QN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.yg)("p",null,"Should trigger ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,s.yg)("inlineCode",{parentName:"a"},"onReloaded")),"."))}KN.isMDXComponent=!0;const JN={toc:[]},ZN="wrapper";function ek(e){let{components:n,...t}=e;return(0,s.yg)(ZN,(0,p.A)({},JN,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reload the scene."))}ek.isMDXComponent=!0;const nk={toc:[]},tk="wrapper";function ok(e){let{components:n,...t}=e;return(0,s.yg)(tk,(0,p.A)({},nk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If present, an updated version of the description."))}ok.isMDXComponent=!0;const pk={toc:[]},rk="wrapper";function sk(e){let{components:n,...t}=e;return(0,s.yg)(rk,(0,p.A)({},pk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render the scene onto a canvas."))}sk.isMDXComponent=!0;const ck={toc:[]},ak="wrapper";function ik(e){let{components:n,...t}=e;return(0,s.yg)(ak,(0,p.A)({},ck,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to used when rendering."))}ik.isMDXComponent=!0;const lk={toc:[]},uk="wrapper";function mk(e){let{components:n,...t}=e;return(0,s.yg)(uk,(0,p.A)({},lk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset this scene to its initial state."))}mk.isMDXComponent=!0;const yk={toc:[]},dk="wrapper";function hk(e){let{components:n,...t}=e;return(0,s.yg)(dk,(0,p.A)({},yk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If present, the previous scene."))}hk.isMDXComponent=!0;const gk={toc:[]},fk="wrapper";function Dk(e){let{components:n,...t}=e;return(0,s.yg)(fk,(0,p.A)({},gk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the view."),(0,s.yg)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.yg)("p",null,"Can modify the state of the view."))}Dk.isMDXComponent=!0;const Mk={toc:[]},Xk="wrapper";function _k(e){let{components:n,...t}=e;return(0,s.yg)(Xk,(0,p.A)({},Mk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Lifecycle events for ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.yg)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}_k.isMDXComponent=!0;const wk={toc:[]},Tk="wrapper";function Ck(e){let{components:n,...t}=e;return(0,s.yg)(Tk,(0,p.A)({},wk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A random number generator based on\n",(0,s.yg)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,s.yg)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}Ck.isMDXComponent=!0;const xk={toc:[]},Ak="wrapper";function vk(e){let{components:n,...t}=e;return(0,s.yg)(Ak,(0,p.A)({},xk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get an array filled with random floats in the given range."))}vk.isMDXComponent=!0;const Lk={toc:[]},bk="wrapper";function Nk(e){let{components:n,...t}=e;return(0,s.yg)(bk,(0,p.A)({},Lk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The size of the array."))}Nk.isMDXComponent=!0;const kk={toc:[]},zk="wrapper";function Pk(e){let{components:n,...t}=e;return(0,s.yg)(zk,(0,p.A)({},kk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start of the range."))}Pk.isMDXComponent=!0;const Ik={toc:[]},Rk="wrapper";function Wk(e){let{components:n,...t}=e;return(0,s.yg)(Rk,(0,p.A)({},Ik,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end of the range."))}Wk.isMDXComponent=!0;const Sk={toc:[]},Bk="wrapper";function Ek(e){let{components:n,...t}=e;return(0,s.yg)(Bk,(0,p.A)({},Sk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a random float from a gaussian distribution."))}Ek.isMDXComponent=!0;const Gk={toc:[]},Ok="wrapper";function Uk(e){let{components:n,...t}=e;return(0,s.yg)(Ok,(0,p.A)({},Gk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The mean of the distribution."))}Uk.isMDXComponent=!0;const Fk={toc:[]},Vk="wrapper";function qk(e){let{components:n,...t}=e;return(0,s.yg)(Vk,(0,p.A)({},Fk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The standard deviation of the distribution."))}qk.isMDXComponent=!0;const jk={toc:[]},Hk="wrapper";function Yk(e){let{components:n,...t}=e;return(0,s.yg)(Hk,(0,p.A)({},jk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get an array filled with random integers in the given range."),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"}),(0,s.yg)("li",{parentName:"ul"})))}Yk.isMDXComponent=!0;const Qk={toc:[]},$k="wrapper";function Kk(e){let{components:n,...t}=e;return(0,s.yg)($k,(0,p.A)({},Qk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The size of the array."),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"})))}Kk.isMDXComponent=!0;const Jk={toc:[]},Zk="wrapper";function ez(e){let{components:n,...t}=e;return(0,s.yg)(Zk,(0,p.A)({},Jk,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start of the range."),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"})))}ez.isMDXComponent=!0;const nz={toc:[]},tz="wrapper";function oz(e){let{components:n,...t}=e;return(0,s.yg)(tz,(0,p.A)({},nz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end of the range. Exclusive."))}oz.isMDXComponent=!0;const pz={toc:[]},rz="wrapper";function sz(e){let{components:n,...t}=e;return(0,s.yg)(rz,(0,p.A)({},pz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the next random float in the given range."))}sz.isMDXComponent=!0;const cz={toc:[]},az="wrapper";function iz(e){let{components:n,...t}=e;return(0,s.yg)(az,(0,p.A)({},cz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start of the range."))}iz.isMDXComponent=!0;const lz={toc:[]},uz="wrapper";function mz(e){let{components:n,...t}=e;return(0,s.yg)(uz,(0,p.A)({},lz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end of the range."))}mz.isMDXComponent=!0;const yz={toc:[]},dz="wrapper";function hz(e){let{components:n,...t}=e;return(0,s.yg)(dz,(0,p.A)({},yz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the next random integer in the given range."))}hz.isMDXComponent=!0;const gz={toc:[]},fz="wrapper";function Dz(e){let{components:n,...t}=e;return(0,s.yg)(fz,(0,p.A)({},gz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start of the range."))}Dz.isMDXComponent=!0;const Mz={toc:[]},Xz="wrapper";function _z(e){let{components:n,...t}=e;return(0,s.yg)(Xz,(0,p.A)({},Mz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end of the range. Exclusive."))}_z.isMDXComponent=!0;const wz={toc:[]},Tz="wrapper";function Cz(e){let{components:n,...t}=e;return(0,s.yg)(Tz,(0,p.A)({},wz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a new independent generator."))}Cz.isMDXComponent=!0;const xz={toc:[]},Az="wrapper";function vz(e){let{components:n,...t}=e;return(0,s.yg)(Az,(0,p.A)({},xz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get variable signal if exists or create signal if not"))}vz.isMDXComponent=!0;const Lz={toc:[]},bz="wrapper";function Nz(e){let{components:n,...t}=e;return(0,s.yg)(bz,(0,p.A)({},Lz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of the variable."))}Nz.isMDXComponent=!0;const kz={toc:[]},zz="wrapper";function Pz(e){let{components:n,...t}=e;return(0,s.yg)(zz,(0,p.A)({},kz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of the variable. It will be used if the\nvariable was not configured from the outside."))}Pz.isMDXComponent=!0;const Iz={toc:[]},Rz="wrapper";function Wz(e){let{components:n,...t}=e;return(0,s.yg)(Rz,(0,p.A)({},Iz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get variable signal if exists or create signal if not"))}Wz.isMDXComponent=!0;const Sz={toc:[]},Bz="wrapper";function Ez(e){let{components:n,...t}=e;return(0,s.yg)(Bz,(0,p.A)({},Sz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset all stored signals."))}Ez.isMDXComponent=!0;const Gz={toc:[]},Oz="wrapper";function Uz(e){let{components:n,...t}=e;return(0,s.yg)(Oz,(0,p.A)({},Gz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update all signals with new project variable values."))}Uz.isMDXComponent=!0;const Fz={toc:[]},Vz="wrapper";function qz(e){let{components:n,...t}=e;return(0,s.yg)(Vz,(0,p.A)({},Fz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes cached information about the timing of a scene."))}qz.isMDXComponent=!0;const jz={toc:[]},Hz="wrapper";function Yz(e){let{components:n,...t}=e;return(0,s.yg)(Hz,(0,p.A)({},jz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes a complete scene together with the meta file."))}Yz.isMDXComponent=!0;const Qz={toc:[]},$z="wrapper";function Kz(e){let{components:n,...t}=e;return(0,s.yg)($z,(0,p.A)({},Qz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Configuration object."))}Kz.isMDXComponent=!0;const Jz={toc:[]},Zz="wrapper";function eP(e){let{components:n,...t}=e;return(0,s.yg)(Zz,(0,p.A)({},Jz,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The class used to instantiate the scene."))}eP.isMDXComponent=!0;const nP={toc:[]},tP="wrapper";function oP(e){let{components:n,...t}=e;return(0,s.yg)(tP,(0,p.A)({},nP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of plugins to include in the project."))}oP.isMDXComponent=!0;const pP={toc:[]},rP="wrapper";function sP(e){let{components:n,...t}=e;return(0,s.yg)(rP,(0,p.A)({},pP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The stack trace at the moment of creation."))}sP.isMDXComponent=!0;const cP={toc:[]},aP="wrapper";function iP(e){let{components:n,...t}=e;return(0,s.yg)(aP,(0,p.A)({},cP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the configuration object."))}iP.isMDXComponent=!0;const lP={toc:[]},uP="wrapper";function mP(e){let{components:n,...t}=e;return(0,s.yg)(uP,(0,p.A)({},lP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}mP.isMDXComponent=!0;const yP={toc:[]},dP="wrapper";function hP(e){let{components:n,...t}=e;return(0,s.yg)(dP,(0,p.A)({},yP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}hP.isMDXComponent=!0;const gP={toc:[]},fP="wrapper";function DP(e){let{components:n,...t}=e;return(0,s.yg)(fP,(0,p.A)({},gP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for the inspected element."))}DP.isMDXComponent=!0;const MP={toc:[]},XP="wrapper";function _P(e){let{components:n,...t}=e;return(0,s.yg)(XP,(0,p.A)({},MP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The element for which to draw an overlay."))}_P.isMDXComponent=!0;const wP={toc:[]},TP="wrapper";function CP(e){let{components:n,...t}=e;return(0,s.yg)(TP,(0,p.A)({},wP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}CP.isMDXComponent=!0;const xP={toc:[]},AP="wrapper";function vP(e){let{components:n,...t}=e;return(0,s.yg)(AP,(0,p.A)({},xP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}vP.isMDXComponent=!0;const LP={toc:[]},bP="wrapper";function NP(e){let{components:n,...t}=e;return(0,s.yg)(bP,(0,p.A)({},LP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,'This information will be displayed in the "Properties" panel.'))}NP.isMDXComponent=!0;const kP={toc:[]},zP="wrapper";function PP(e){let{components:n,...t}=e;return(0,s.yg)(zP,(0,p.A)({},kP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the attributes of the inspected element."))}PP.isMDXComponent=!0;const IP={toc:[]},RP="wrapper";function WP(e){let{components:n,...t}=e;return(0,s.yg)(RP,(0,p.A)({},IP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The element to inspect."))}WP.isMDXComponent=!0;const SP={toc:[]},BP="wrapper";function EP(e){let{components:n,...t}=e;return(0,s.yg)(BP,(0,p.A)({},SP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a possible element to inspect at a given position."))}EP.isMDXComponent=!0;const GP={toc:[]},OP="wrapper";function UP(e){let{components:n,...t}=e;return(0,s.yg)(OP,(0,p.A)({},GP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The x coordinate."))}UP.isMDXComponent=!0;const FP={toc:[]},VP="wrapper";function qP(e){let{components:n,...t}=e;return(0,s.yg)(VP,(0,p.A)({},FP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The y coordinate."))}qP.isMDXComponent=!0;const jP={toc:[]},HP="wrapper";function YP(e){let{components:n,...t}=e;return(0,s.yg)(HP,(0,p.A)({},jP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Transform the absolute mouse coordinates into the scene's coordinate system."))}YP.isMDXComponent=!0;const QP={toc:[]},$P="wrapper";function KP(e){let{components:n,...t}=e;return(0,s.yg)($P,(0,p.A)({},QP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The x coordinate."))}KP.isMDXComponent=!0;const JP={toc:[]},ZP="wrapper";function eI(e){let{components:n,...t}=e;return(0,s.yg)(ZP,(0,p.A)({},JP,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The y coordinate."))}eI.isMDXComponent=!0;const nI={toc:[]},tI="wrapper";function oI(e){let{components:n,...t}=e;return(0,s.yg)(tI,(0,p.A)({},nI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}oI.isMDXComponent=!0;const pI={toc:[]},rI="wrapper";function sI(e){let{components:n,...t}=e;return(0,s.yg)(rI,(0,p.A)({},pI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the inspected element is still valid."))}sI.isMDXComponent=!0;const cI={toc:[]},aI="wrapper";function iI(e){let{components:n,...t}=e;return(0,s.yg)(aI,(0,p.A)({},cI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The element to validate."))}iI.isMDXComponent=!0;const lI={toc:[]},uI="wrapper";function mI(e){let{components:n,...t}=e;return(0,s.yg)(uI,(0,p.A)({},lI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,s.yg)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}mI.isMDXComponent=!0;const yI={toc:[]},dI="wrapper";function hI(e){let{components:n,...t}=e;return(0,s.yg)(dI,(0,p.A)({},yI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The main interface for scenes."))}hI.isMDXComponent=!0;const gI={toc:[]},fI="wrapper";function DI(e){let{components:n,...t}=e;return(0,s.yg)(fI,(0,p.A)({},gI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The root path of the assets. Prefix for all relative paths."))}DI.isMDXComponent=!0;const MI={toc:[]},XI="wrapper";function _I(e){let{components:n,...t}=e;return(0,s.yg)(XI,(0,p.A)({},MI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Will be passed as the second argument to the constructor."))}_I.isMDXComponent=!0;const wI={toc:[]},TI="wrapper";function CI(e){let{components:n,...t}=e;return(0,s.yg)(TI,(0,p.A)({},wI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Name of the scene."))}CI.isMDXComponent=!0;const xI={toc:[]},AI="wrapper";function vI(e){let{components:n,...t}=e;return(0,s.yg)(AI,(0,p.A)({},xI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reference to the project."))}vI.isMDXComponent=!0;const LI={toc:[]},bI="wrapper";function NI(e){let{components:n,...t}=e;return(0,s.yg)(bI,(0,p.A)({},LI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Should this scene be rendered below the previous scene during a transition?"))}NI.isMDXComponent=!0;const kI={toc:[]},zI="wrapper";function PI(e){let{components:n,...t}=e;return(0,s.yg)(zI,(0,p.A)({},kI,t,{components:n,mdxType:"MDXLayout"}))}PI.isMDXComponent=!0;const II={toc:[]},RI="wrapper";function WI(e){let{components:n,...t}=e;return(0,s.yg)(RI,(0,p.A)({},II,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene#lifecycleEvents"},(0,s.yg)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}WI.isMDXComponent=!0;const SI={toc:[]},BI="wrapper";function EI(e){let{components:n,...t}=e;return(0,s.yg)(BI,(0,p.A)({},SI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.yg)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}EI.isMDXComponent=!0;const GI={toc:[]},OI="wrapper";function UI(e){let{components:n,...t}=e;return(0,s.yg)(OI,(0,p.A)({},GI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether experimental features are enabled."))}UI.isMDXComponent=!0;const FI={toc:[]},VI="wrapper";function qI(e){let{components:n,...t}=e;return(0,s.yg)(VI,(0,p.A)({},FI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame at which this scene starts."))}qI.isMDXComponent=!0;const jI={toc:[]},HI="wrapper";function YI(e){let{components:n,...t}=e;return(0,s.yg)(HI,(0,p.A)({},jI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The frame at which this scene ends."))}YI.isMDXComponent=!0;const QI={toc:[]},$I="wrapper";function KI(e){let{components:n,...t}=e;return(0,s.yg)($I,(0,p.A)({},QI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.yg)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}KI.isMDXComponent=!0;const JI={toc:[]},ZI="wrapper";function eR(e){let{components:n,...t}=e;return(0,s.yg)(ZI,(0,p.A)({},JI,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the cached data changes."))}eR.isMDXComponent=!0;const nR={toc:[]},tR="wrapper";function oR(e){let{components:n,...t}=e;return(0,s.yg)(tR,(0,p.A)({},nR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered after scene is recalculated."))}oR.isMDXComponent=!0;const pR={toc:[]},rR="wrapper";function sR(e){let{components:n,...t}=e;return(0,s.yg)(rR,(0,p.A)({},pR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the scene is reloaded."))}sR.isMDXComponent=!0;const cR={toc:[]},aR="wrapper";function iR(e){let{components:n,...t}=e;return(0,s.yg)(aR,(0,p.A)({},cR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}iR.isMDXComponent=!0;const lR={toc:[]},uR="wrapper";function mR(e){let{components:n,...t}=e;return(0,s.yg)(uR,(0,p.A)({},lR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the scene is reset."))}mR.isMDXComponent=!0;const yR={toc:[]},dR="wrapper";function hR(e){let{components:n,...t}=e;return(0,s.yg)(dR,(0,p.A)({},yR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The scene directly before this scene, or null if omitted for performance."))}hR.isMDXComponent=!0;const gR={toc:[]},fR="wrapper";function DR(e){let{components:n,...t}=e;return(0,s.yg)(fR,(0,p.A)({},gR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene in the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.yg)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}DR.isMDXComponent=!0;const MR={toc:[]},XR="wrapper";function _R(e){let{components:n,...t}=e;return(0,s.yg)(XR,(0,p.A)({},MR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enter the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.yg)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}_R.isMDXComponent=!0;const wR={toc:[]},TR="wrapper";function CR(e){let{components:n,...t}=e;return(0,s.yg)(TR,(0,p.A)({},wR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enter the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.yg)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}CR.isMDXComponent=!0;const xR={toc:[]},AR="wrapper";function vR(e){let{components:n,...t}=e;return(0,s.yg)(AR,(0,p.A)({},xR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enter the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.yg)("inlineCode",{parentName:"a"},"Initial"))," state."))}vR.isMDXComponent=!0;const LR={toc:[]},bR="wrapper";function NR(e){let{components:n,...t}=e;return(0,s.yg)(bR,(0,p.A)({},LR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get all media assets"))}NR.isMDXComponent=!0;const kR={toc:[]},zR="wrapper";function PR(e){let{components:n,...t}=e;return(0,s.yg)(zR,(0,p.A)({},kR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Returns the size of the scene multiplied by the resolution scale.\nThis is the actual size of the canvas onto which the scene is rendered."))}PR.isMDXComponent=!0;const IR={toc:[]},RR="wrapper";function WR(e){let{components:n,...t}=e;return(0,s.yg)(RR,(0,p.A)({},IR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the real size of this scene."))}WR.isMDXComponent=!0;const SR={toc:[]},BR="wrapper";function ER(e){let{components:n,...t}=e;return(0,s.yg)(BR,(0,p.A)({},SR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Usually returns ",(0,s.yg)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}ER.isMDXComponent=!0;const GR={toc:[]},OR="wrapper";function UR(e){let{components:n,...t}=e;return(0,s.yg)(OR,(0,p.A)({},GR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the size of this scene."))}UR.isMDXComponent=!0;const FR={toc:[]},VR="wrapper";function qR(e){let{components:n,...t}=e;return(0,s.yg)(VR,(0,p.A)({},FR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene in the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.yg)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}qR.isMDXComponent=!0;const jR={toc:[]},HR="wrapper";function YR(e){let{components:n,...t}=e;return(0,s.yg)(HR,(0,p.A)({},jR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Used only by ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.yg)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.yg)("p",null,"Should always return ",(0,s.yg)("inlineCode",{parentName:"p"},"true"),"."))}YR.isMDXComponent=!0;const QR={toc:[]},$R="wrapper";function KR(e){let{components:n,...t}=e;return(0,s.yg)($R,(0,p.A)({},QR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene cached?"))}KR.isMDXComponent=!0;const JR={toc:[]},ZR="wrapper";function eW(e){let{components:n,...t}=e;return(0,s.yg)(ZR,(0,p.A)({},JR,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is this scene in the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.yg)("inlineCode",{parentName:"a"},"Finished"))," state?"))}eW.isMDXComponent=!0;const nW={toc:[]},tW="wrapper";function oW(e){let{components:n,...t}=e;return(0,s.yg)(tW,(0,p.A)({},nW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Progress this scene one frame forward."))}oW.isMDXComponent=!0;const pW={toc:[]},rW="wrapper";function sW(e){let{components:n,...t}=e;return(0,s.yg)(rW,(0,p.A)({},pW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.yg)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,s.yg)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.yg)("p",null,"At the end of execution, this method should set ",(0,s.yg)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,s.yg)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.yg)("p",null,"Should trigger ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,s.yg)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}sW.isMDXComponent=!0;const cW={toc:[]},aW="wrapper";function iW(e){let{components:n,...t}=e;return(0,s.yg)(aW,(0,p.A)({},cW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Recalculate the scene."))}iW.isMDXComponent=!0;const lW={toc:[]},uW="wrapper";function mW(e){let{components:n,...t}=e;return(0,s.yg)(uW,(0,p.A)({},lW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.yg)("p",null,"Should trigger ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,s.yg)("inlineCode",{parentName:"a"},"onReloaded")),"."))}mW.isMDXComponent=!0;const yW={toc:[]},dW="wrapper";function hW(e){let{components:n,...t}=e;return(0,s.yg)(dW,(0,p.A)({},yW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reload the scene."))}hW.isMDXComponent=!0;const gW={toc:[]},fW="wrapper";function DW(e){let{components:n,...t}=e;return(0,s.yg)(fW,(0,p.A)({},gW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If present, an updated version of the description."))}DW.isMDXComponent=!0;const MW={toc:[]},XW="wrapper";function _W(e){let{components:n,...t}=e;return(0,s.yg)(XW,(0,p.A)({},MW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render the scene onto a canvas."))}_W.isMDXComponent=!0;const wW={toc:[]},TW="wrapper";function CW(e){let{components:n,...t}=e;return(0,s.yg)(TW,(0,p.A)({},wW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to used when rendering."))}CW.isMDXComponent=!0;const xW={toc:[]},AW="wrapper";function vW(e){let{components:n,...t}=e;return(0,s.yg)(AW,(0,p.A)({},xW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset this scene to its initial state."))}vW.isMDXComponent=!0;const LW={toc:[]},bW="wrapper";function NW(e){let{components:n,...t}=e;return(0,s.yg)(bW,(0,p.A)({},LW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If present, the previous scene."))}NW.isMDXComponent=!0;const kW={toc:[]},zW="wrapper";function PW(e){let{components:n,...t}=e;return(0,s.yg)(zW,(0,p.A)({},kW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the configuration object."))}PW.isMDXComponent=!0;const IW={toc:[]},RW="wrapper";function WW(e){let{components:n,...t}=e;return(0,s.yg)(RW,(0,p.A)({},IW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Each class implementing the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.yg)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}WW.isMDXComponent=!0;const SW={toc:[]},BW="wrapper";function EW(e){let{components:n,...t}=e;return(0,s.yg)(BW,(0,p.A)({},SW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constructor used when creating new scenes."))}EW.isMDXComponent=!0;const GW={toc:[]},OW="wrapper";function UW(e){let{components:n,...t}=e;return(0,s.yg)(OW,(0,p.A)({},GW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,s.yg)("inlineCode",{parentName:"a"},"config")),"."))}UW.isMDXComponent=!0;const FW={toc:[]},VW="wrapper";function qW(e){let{components:n,...t}=e;return(0,s.yg)(VW,(0,p.A)({},FW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes a scene exposed by scene files."))}qW.isMDXComponent=!0;const jW={toc:[]},HW="wrapper";function YW(e){let{components:n,...t}=e;return(0,s.yg)(HW,(0,p.A)({},jW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Configuration object."))}YW.isMDXComponent=!0;const QW={toc:[]},$W="wrapper";function KW(e){let{components:n,...t}=e;return(0,s.yg)($W,(0,p.A)({},QW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The class used to instantiate the scene."))}KW.isMDXComponent=!0;const JW={toc:[]},ZW="wrapper";function eS(e){let{components:n,...t}=e;return(0,s.yg)(ZW,(0,p.A)({},JW,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of plugins to include in the project."))}eS.isMDXComponent=!0;const nS={toc:[]},tS="wrapper";function oS(e){let{components:n,...t}=e;return(0,s.yg)(tS,(0,p.A)({},nS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The stack trace at the moment of creation."))}oS.isMDXComponent=!0;const pS={toc:[]},rS="wrapper";function sS(e){let{components:n,...t}=e;return(0,s.yg)(rS,(0,p.A)({},pS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the configuration object."))}sS.isMDXComponent=!0;const cS={toc:[]},aS="wrapper";function iS(e){let{components:n,...t}=e;return(0,s.yg)(aS,(0,p.A)({},cS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A part of the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription"},(0,s.yg)("inlineCode",{parentName:"a"},"SceneDescription"))," that can be updated during reload."))}iS.isMDXComponent=!0;const lS={toc:[]},uS="wrapper";function mS(e){let{components:n,...t}=e;return(0,s.yg)(uS,(0,p.A)({},lS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the configuration object."))}mS.isMDXComponent=!0;const yS={toc:[]},dS="wrapper";function hS(e){let{components:n,...t}=e;return(0,s.yg)(dS,(0,p.A)({},yS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This interface is only useful when a scene uses thread generators to run."))}hS.isMDXComponent=!0;const gS={toc:[]},fS="wrapper";function DS(e){let{components:n,...t}=e;return(0,s.yg)(fS,(0,p.A)({},gS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}DS.isMDXComponent=!0;const MS={toc:[]},XS="wrapper";function _S(e){let{components:n,...t}=e;return(0,s.yg)(XS,(0,p.A)({},MS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Triggered when the main thread changes."))}_S.isMDXComponent=!0;const wS={toc:[]},TS="wrapper";function CS(e){let{components:n,...t}=e;return(0,s.yg)(TS,(0,p.A)({},wS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents attributes of an inspected element."))}CS.isMDXComponent=!0;const xS={toc:[]},AS="wrapper";function vS(e){let{components:n,...t}=e;return(0,s.yg)(AS,(0,p.A)({},xS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}vS.isMDXComponent=!0;const LS={toc:[]},bS="wrapper";function NS(e){let{components:n,...t}=e;return(0,s.yg)(bS,(0,p.A)({},LS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents an element to inspect."))}NS.isMDXComponent=!0;const kS={toc:[]},zS="wrapper";function PS(e){let{components:n,...t}=e;return(0,s.yg)(zS,(0,p.A)({},kS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A runtime representation of the scene metadata."))}PS.isMDXComponent=!0;const IS={toc:[]},RS="wrapper";function WS(e){let{components:n,...t}=e;return(0,s.yg)(RS,(0,p.A)({},IS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a runtime representation of the scene metadata."))}WS.isMDXComponent=!0;const SS={toc:[]},BS="wrapper";function ES(e){let{components:n,...t}=e;return(0,s.yg)(BS,(0,p.A)({},SS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}ES.isMDXComponent=!0;const GS={toc:[]},OS="wrapper";function US(e){let{components:n,...t}=e;return(0,s.yg)(OS,(0,p.A)({},GS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the initial value of this signal."))}US.isMDXComponent=!0;const FS={toc:[]},VS="wrapper";function qS(e){let{components:n,...t}=e;return(0,s.yg)(VS,(0,p.A)({},FS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}qS.isMDXComponent=!0;const jS={toc:[]},HS="wrapper";function YS(e){let{components:n,...t}=e;return(0,s.yg)(HS,(0,p.A)({},jS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the signal is currently using its initial value."))}YS.isMDXComponent=!0;const QS={toc:[]},$S="wrapper";function KS(e){let{components:n,...t}=e;return(0,s.yg)($S,(0,p.A)({},QS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is the signal undergoing a tween?"))}KS.isMDXComponent=!0;const JS={toc:[]},ZS="wrapper";function eB(e){let{components:n,...t}=e;return(0,s.yg)(ZS,(0,p.A)({},JS,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.yg)("p",null,"This method can be used to create copies of signals."))}eB.isMDXComponent=!0;const nB={toc:[]},tB="wrapper";function oB(e){let{components:n,...t}=e;return(0,s.yg)(tB,(0,p.A)({},nB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}oB.isMDXComponent=!0;const pB={toc:[]},rB="wrapper";function sB(e){let{components:n,...t}=e;return(0,s.yg)(rB,(0,p.A)({},pB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the raw value of this signal."))}sB.isMDXComponent=!0;const cB={toc:[]},aB="wrapper";function iB(e){let{components:n,...t}=e;return(0,s.yg)(aB,(0,p.A)({},cB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}iB.isMDXComponent=!0;const lB={toc:[]},uB="wrapper";function mB(e){let{components:n,...t}=e;return(0,s.yg)(uB,(0,p.A)({},lB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset the signal to its initial value (if one has been set)."))}mB.isMDXComponent=!0;const yB={toc:[]},dB="wrapper";function hB(e){let{components:n,...t}=e;return(0,s.yg)(dB,(0,p.A)({},yB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}hB.isMDXComponent=!0;const gB={toc:[]},fB="wrapper";function DB(e){let{components:n,...t}=e;return(0,s.yg)(fB,(0,p.A)({},gB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}DB.isMDXComponent=!0;const MB={toc:[]},XB="wrapper";function _B(e){let{components:n,...t}=e;return(0,s.yg)(XB,(0,p.A)({},MB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Compute the current value of the signal and immediately set it."))}_B.isMDXComponent=!0;const wB={toc:[]},TB="wrapper";function CB(e){let{components:n,...t}=e;return(0,s.yg)(TB,(0,p.A)({},wB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the initial value of this signal."))}CB.isMDXComponent=!0;const xB={toc:[]},AB="wrapper";function vB(e){let{components:n,...t}=e;return(0,s.yg)(AB,(0,p.A)({},xB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}vB.isMDXComponent=!0;const LB={toc:[]},bB="wrapper";function NB(e){let{components:n,...t}=e;return(0,s.yg)(bB,(0,p.A)({},LB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the signal is currently using its initial value."))}NB.isMDXComponent=!0;const kB={toc:[]},zB="wrapper";function PB(e){let{components:n,...t}=e;return(0,s.yg)(zB,(0,p.A)({},kB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is the signal undergoing a tween?"))}PB.isMDXComponent=!0;const IB={toc:[]},RB="wrapper";function WB(e){let{components:n,...t}=e;return(0,s.yg)(RB,(0,p.A)({},IB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.yg)("p",null,"This method can be used to create copies of signals."))}WB.isMDXComponent=!0;const SB={toc:[]},BB="wrapper";function EB(e){let{components:n,...t}=e;return(0,s.yg)(BB,(0,p.A)({},SB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}EB.isMDXComponent=!0;const GB={toc:[]},OB="wrapper";function UB(e){let{components:n,...t}=e;return(0,s.yg)(OB,(0,p.A)({},GB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the raw value of this signal."))}UB.isMDXComponent=!0;const FB={toc:[]},VB="wrapper";function qB(e){let{components:n,...t}=e;return(0,s.yg)(VB,(0,p.A)({},FB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}qB.isMDXComponent=!0;const jB={toc:[]},HB="wrapper";function YB(e){let{components:n,...t}=e;return(0,s.yg)(HB,(0,p.A)({},jB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset the signal to its initial value (if one has been set)."))}YB.isMDXComponent=!0;const QB={toc:[]},$B="wrapper";function KB(e){let{components:n,...t}=e;return(0,s.yg)($B,(0,p.A)({},QB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}KB.isMDXComponent=!0;const JB={toc:[]},ZB="wrapper";function eE(e){let{components:n,...t}=e;return(0,s.yg)(ZB,(0,p.A)({},JB,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}eE.isMDXComponent=!0;const nE={toc:[]},tE="wrapper";function oE(e){let{components:n,...t}=e;return(0,s.yg)(tE,(0,p.A)({},nE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Compute the current value of the signal and immediately set it."))}oE.isMDXComponent=!0;const pE={toc:[]},rE="wrapper";function sE(e){let{components:n,...t}=e;return(0,s.yg)(rE,(0,p.A)({},pE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the signal is currently using its initial value."))}sE.isMDXComponent=!0;const cE={toc:[]},aE="wrapper";function iE(e){let{components:n,...t}=e;return(0,s.yg)(aE,(0,p.A)({},cE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset the signal to its initial value (if one has been set)."))}iE.isMDXComponent=!0;const lE={toc:[]},uE="wrapper";function mE(e){let{components:n,...t}=e;return(0,s.yg)(uE,(0,p.A)({},lE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}mE.isMDXComponent=!0;const yE={toc:[]},dE="wrapper";function hE(e){let{components:n,...t}=e;return(0,s.yg)(dE,(0,p.A)({},yE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Compute the current value of the signal and immediately set it."))}hE.isMDXComponent=!0;const gE={toc:[]},fE="wrapper";function DE(e){let{components:n,...t}=e;return(0,s.yg)(fE,(0,p.A)({},gE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween back to the original value."))}DE.isMDXComponent=!0;const ME={toc:[]},XE="wrapper";function _E(e){let{components:n,...t}=e;return(0,s.yg)(XE,(0,p.A)({},ME,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the tween."))}_E.isMDXComponent=!0;const wE={toc:[]},TE="wrapper";function CE(e){let{components:n,...t}=e;return(0,s.yg)(TE,(0,p.A)({},wE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function of the tween."))}CE.isMDXComponent=!0;const xE={toc:[]},AE="wrapper";function vE(e){let{components:n,...t}=e;return(0,s.yg)(AE,(0,p.A)({},xE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The interpolation function of the tween."))}vE.isMDXComponent=!0;const LE={toc:[]},bE="wrapper";function NE(e){let{components:n,...t}=e;return(0,s.yg)(bE,(0,p.A)({},LE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Invoke the given callback."))}NE.isMDXComponent=!0;const kE={toc:[]},zE="wrapper";function PE(e){let{components:n,...t}=e;return(0,s.yg)(zE,(0,p.A)({},kE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The callback to invoke."))}PE.isMDXComponent=!0;const IE={toc:[]},RE="wrapper";function WE(e){let{components:n,...t}=e;return(0,s.yg)(RE,(0,p.A)({},IE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run the given task."))}WE.isMDXComponent=!0;const SE={toc:[]},BE="wrapper";function EE(e){let{components:n,...t}=e;return(0,s.yg)(BE,(0,p.A)({},SE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The generator to run."))}EE.isMDXComponent=!0;const GE={toc:[]},OE="wrapper";function UE(e){let{components:n,...t}=e;return(0,s.yg)(OE,(0,p.A)({},GE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween to the specified value."))}UE.isMDXComponent=!0;const FE={toc:[]},VE="wrapper";function qE(e){let{components:n,...t}=e;return(0,s.yg)(VE,(0,p.A)({},FE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for the specified duration."))}qE.isMDXComponent=!0;const jE={toc:[]},HE="wrapper";function YE(e){let{components:n,...t}=e;return(0,s.yg)(HE,(0,p.A)({},jE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration to wait."))}YE.isMDXComponent=!0;const QE={toc:[]},$E="wrapper";function KE(e){let{components:n,...t}=e;return(0,s.yg)($E,(0,p.A)({},QE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Thread management."))}KE.isMDXComponent=!0;const JE={toc:[]},ZE="wrapper";function eG(e){let{components:n,...t}=e;return(0,s.yg)(ZE,(0,p.A)({},JE,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,s.yg)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}eG.isMDXComponent=!0;const nG={toc:[]},tG="wrapper";function oG(e){let{components:n,...t}=e;return(0,s.yg)(tG,(0,p.A)({},nG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A class representing an individual thread."))}oG.isMDXComponent=!0;const pG={toc:[]},rG="wrapper";function sG(e){let{components:n,...t}=e;return(0,s.yg)(rG,(0,p.A)({},pG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The generator wrapped by this thread."))}sG.isMDXComponent=!0;const cG={toc:[]},aG="wrapper";function iG(e){let{components:n,...t}=e;return(0,s.yg)(aG,(0,p.A)({},cG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The generator wrapped by this thread."))}iG.isMDXComponent=!0;const lG={toc:[]},uG="wrapper";function mG(e){let{components:n,...t}=e;return(0,s.yg)(uG,(0,p.A)({},lG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Used by ",(0,s.yg)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.yg)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}mG.isMDXComponent=!0;const yG={toc:[]},dG="wrapper";function hG(e){let{components:n,...t}=e;return(0,s.yg)(dG,(0,p.A)({},yG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The current time of this thread."))}hG.isMDXComponent=!0;const gG={toc:[]},fG="wrapper";function DG(e){let{components:n,...t}=e;return(0,s.yg)(fG,(0,p.A)({},gG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The next value to be passed to the wrapped generator."))}DG.isMDXComponent=!0;const MG={toc:[]},XG="wrapper";function _G(e){let{components:n,...t}=e;return(0,s.yg)(XG,(0,p.A)({},MG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if this thread or any of its ancestors has been canceled."))}_G.isMDXComponent=!0;const wG={toc:[]},TG="wrapper";function CG(e){let{components:n,...t}=e;return(0,s.yg)(TG,(0,p.A)({},wG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Fixed time is a multiple of the frame duration. It can be used to account\nfor the difference between this thread's ",(0,s.yg)("a",{parentName:"p",href:"/api/core/threading/Thread#time"},(0,s.yg)("inlineCode",{parentName:"a"},"time"))," and the time of the\ncurrent animation frame."))}CG.isMDXComponent=!0;const xG={toc:[]},AG="wrapper";function vG(e){let{components:n,...t}=e;return(0,s.yg)(AG,(0,p.A)({},xG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The fixed time of this thread."))}vG.isMDXComponent=!0;const LG={toc:[]},bG="wrapper";function NG(e){let{components:n,...t}=e;return(0,s.yg)(bG,(0,p.A)({},LG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Progress the wrapped generator once."))}NG.isMDXComponent=!0;const kG={toc:[]},zG="wrapper";function PG(e){let{components:n,...t}=e;return(0,s.yg)(zG,(0,p.A)({},kG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the thread for the next update cycle."))}PG.isMDXComponent=!0;const IG={toc:[]},RG="wrapper";function WG(e){let{components:n,...t}=e;return(0,s.yg)(RG,(0,p.A)({},IG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The delta time of the next cycle."))}WG.isMDXComponent=!0;const SG={toc:[]},BG="wrapper";function EG(e){let{components:n,...t}=e;return(0,s.yg)(BG,(0,p.A)({},SG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A generator function or a normal function that returns a generator."))}EG.isMDXComponent=!0;const GG={toc:[]},OG="wrapper";function UG(e){let{components:n,...t}=e;return(0,s.yg)(OG,(0,p.A)({},GG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Yielded values can be used to control the flow of animation:"),(0,s.yg)("p",null,"Progress to the next frame:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,s.yg)("p",null,"Run another generator synchronously:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,s.yg)("p",null,"Run another generator concurrently:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,s.yg)("p",null,"Await a Promise:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}UG.isMDXComponent=!0;const FG={toc:[]},VG="wrapper";function qG(e){let{components:n,...t}=e;return(0,s.yg)(VG,(0,p.A)({},FG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}qG.isMDXComponent=!0;const jG={toc:[]},HG="wrapper";function YG(e){let{components:n,...t}=e;return(0,s.yg)(HG,(0,p.A)({},jG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Cancel all listed tasks."),(0,s.yg)("p",null,"Example:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}YG.isMDXComponent=!0;const QG={toc:[]},$G="wrapper";function KG(e){let{components:n,...t}=e;return(0,s.yg)($G,(0,p.A)({},QG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of tasks to cancel."))}KG.isMDXComponent=!0;const JG={toc:[]},ZG="wrapper";function eO(e){let{components:n,...t}=e;return(0,s.yg)(ZG,(0,p.A)({},JG,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the given value is a ","[Promise][promise]","."))}eO.isMDXComponent=!0;const nO={toc:[]},tO="wrapper";function oO(e){let{components:n,...t}=e;return(0,s.yg)(tO,(0,p.A)({},nO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A possible ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}oO.isMDXComponent=!0;const pO={toc:[]},rO="wrapper";function sO(e){let{components:n,...t}=e;return(0,s.yg)(rO,(0,p.A)({},pO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the given value is a ",(0,s.yg)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.yg)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}sO.isMDXComponent=!0;const cO={toc:[]},aO="wrapper";function iO(e){let{components:n,...t}=e;return(0,s.yg)(aO,(0,p.A)({},cO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A possible thread ",(0,s.yg)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.yg)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}iO.isMDXComponent=!0;const lO={toc:[]},uO="wrapper";function mO(e){let{components:n,...t}=e;return(0,s.yg)(uO,(0,p.A)({},lO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}mO.isMDXComponent=!0;const yO={toc:[]},dO="wrapper";function hO(e){let{components:n,...t}=e;return(0,s.yg)(dO,(0,p.A)({},yO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Pause the current generator until all listed tasks are finished."))}hO.isMDXComponent=!0;const gO={toc:[]},fO="wrapper";function DO(e){let{components:n,...t}=e;return(0,s.yg)(fO,(0,p.A)({},gO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of tasks to join."))}DO.isMDXComponent=!0;const MO={toc:[]},XO="wrapper";function _O(e){let{components:n,...t}=e;return(0,s.yg)(XO,(0,p.A)({},MO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}_O.isMDXComponent=!0;const wO={toc:[]},TO="wrapper";function CO(e){let{components:n,...t}=e;return(0,s.yg)(TO,(0,p.A)({},wO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Pause the current generator until listed tasks are finished."))}CO.isMDXComponent=!0;const xO={toc:[]},AO="wrapper";function vO(e){let{components:n,...t}=e;return(0,s.yg)(AO,(0,p.A)({},xO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether we should wait for all tasks or for at least one."))}vO.isMDXComponent=!0;const LO={toc:[]},bO="wrapper";function NO(e){let{components:n,...t}=e;return(0,s.yg)(bO,(0,p.A)({},LO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A list of tasks to join."))}NO.isMDXComponent=!0;const kO={toc:[]},zO="wrapper";function PO(e){let{components:n,...t}=e;return(0,s.yg)(zO,(0,p.A)({},kO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Using an existing task:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"spawn(rect().opacity(1, 1));\n")),(0,s.yg)("p",null,"Using a generator function:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"spawn(function* () {\n  yield* rect().opacity(1, 1);\n  yield* waitFor('click');\n  yield* rect().opacity(0, 1);\n});\n")),(0,s.yg)("p",null,"Await the spawned task:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const task = spawn(rect().opacity(1, 1));\n// do some other things\nyield* join(task); // await the task\n")))}PO.isMDXComponent=!0;const IO={toc:[]},RO="wrapper";function WO(e){let{components:n,...t}=e;return(0,s.yg)(RO,(0,p.A)({},IO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Run the given task concurrently."))}WO.isMDXComponent=!0;const SO={toc:[]},BO="wrapper";function EO(e){let{components:n,...t}=e;return(0,s.yg)(BO,(0,p.A)({},SO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Either a generator function or a task to run."))}EO.isMDXComponent=!0;const GO={toc:[]},OO="wrapper";function UO(e){let{components:n,...t}=e;return(0,s.yg)(OO,(0,p.A)({},GO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"From the perspective of the external generator, ",(0,s.yg)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,s.yg)("inlineCode",{parentName:"p"},"threads")," generator."))}UO.isMDXComponent=!0;const FO={toc:[]},VO="wrapper";function qO(e){let{components:n,...t}=e;return(0,s.yg)(VO,(0,p.A)({},FO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}qO.isMDXComponent=!0;const jO={toc:[]},HO="wrapper";function YO(e){let{components:n,...t}=e;return(0,s.yg)(HO,(0,p.A)({},jO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a context in which generators can be run concurrently."))}YO.isMDXComponent=!0;const QO={toc:[]},$O="wrapper";function KO(e){let{components:n,...t}=e;return(0,s.yg)($O,(0,p.A)({},QO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns the generator to run."))}KO.isMDXComponent=!0;const JO={toc:[]},ZO="wrapper";function eU(e){let{components:n,...t}=e;return(0,s.yg)(ZO,(0,p.A)({},JO,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}eU.isMDXComponent=!0;const nU={toc:[]},tU="wrapper";function oU(e){let{components:n,...t}=e;return(0,s.yg)(tU,(0,p.A)({},nU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Transitions between scenes."))}oU.isMDXComponent=!0;const pU={toc:[]},rU="wrapper";function sU(e){let{components:n,...t}=e;return(0,s.yg)(rU,(0,p.A)({},pU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Perform a transition that fades between the scenes."))}sU.isMDXComponent=!0;const cU={toc:[]},aU="wrapper";function iU(e){let{components:n,...t}=e;return(0,s.yg)(aU,(0,p.A)({},cU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}iU.isMDXComponent=!0;const lU={toc:[]},uU="wrapper";function mU(e){let{components:n,...t}=e;return(0,s.yg)(uU,(0,p.A)({},lU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Perform a transition that slides the scene in the given direction."))}mU.isMDXComponent=!0;const yU={toc:[]},dU="wrapper";function hU(e){let{components:n,...t}=e;return(0,s.yg)(dU,(0,p.A)({},yU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The direction in which to slide."))}hU.isMDXComponent=!0;const gU={toc:[]},fU="wrapper";function DU(e){let{components:n,...t}=e;return(0,s.yg)(fU,(0,p.A)({},gU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}DU.isMDXComponent=!0;const MU={toc:[]},XU="wrapper";function _U(e){let{components:n,...t}=e;return(0,s.yg)(XU,(0,p.A)({},MU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Perform a transition that slides the scene towards the given origin."))}_U.isMDXComponent=!0;const wU={toc:[]},TU="wrapper";function CU(e){let{components:n,...t}=e;return(0,s.yg)(TU,(0,p.A)({},wU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The origin towards which to slide."))}CU.isMDXComponent=!0;const xU={toc:[]},AU="wrapper";function vU(e){let{components:n,...t}=e;return(0,s.yg)(AU,(0,p.A)({},xU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}vU.isMDXComponent=!0;const LU={toc:[]},bU="wrapper";function NU(e){let{components:n,...t}=e;return(0,s.yg)(bU,(0,p.A)({},LU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}NU.isMDXComponent=!0;const kU={toc:[]},zU="wrapper";function PU(e){let{components:n,...t}=e;return(0,s.yg)(zU,(0,p.A)({},kU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The callback to use before the current scene is rendered."))}PU.isMDXComponent=!0;const IU={toc:[]},RU="wrapper";function WU(e){let{components:n,...t}=e;return(0,s.yg)(RU,(0,p.A)({},IU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The callback to use before the previous scene is rendered."))}WU.isMDXComponent=!0;const SU={toc:[]},BU="wrapper";function EU(e){let{components:n,...t}=e;return(0,s.yg)(BU,(0,p.A)({},SU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the previous scene should be rendered on top."))}EU.isMDXComponent=!0;const GU={toc:[]},OU="wrapper";function UU(e){let{components:n,...t}=e;return(0,s.yg)(OU,(0,p.A)({},GU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Perform a transition that zooms in on a given area of the scene."))}UU.isMDXComponent=!0;const FU={toc:[]},VU="wrapper";function qU(e){let{components:n,...t}=e;return(0,s.yg)(VU,(0,p.A)({},FU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The area on which to zoom in."))}qU.isMDXComponent=!0;const jU={toc:[]},HU="wrapper";function YU(e){let{components:n,...t}=e;return(0,s.yg)(HU,(0,p.A)({},jU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}YU.isMDXComponent=!0;const QU={toc:[]},$U="wrapper";function KU(e){let{components:n,...t}=e;return(0,s.yg)($U,(0,p.A)({},QU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Perform a transition that zooms out from a given area of the scene."))}KU.isMDXComponent=!0;const JU={toc:[]},ZU="wrapper";function eF(e){let{components:n,...t}=e;return(0,s.yg)(ZU,(0,p.A)({},JU,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The area from which to zoom out."))}eF.isMDXComponent=!0;const nF={toc:[]},tF="wrapper";function oF(e){let{components:n,...t}=e;return(0,s.yg)(tF,(0,p.A)({},nF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}oF.isMDXComponent=!0;const pF={toc:[]},rF="wrapper";function sF(e){let{components:n,...t}=e;return(0,s.yg)(rF,(0,p.A)({},pF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Interpolation and timing of tweens."))}sF.isMDXComponent=!0;const cF={toc:[]},aF="wrapper";function iF(e){let{components:n,...t}=e;return(0,s.yg)(aF,(0,p.A)({},cF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Any old key that is missing in ",(0,s.yg)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,s.yg)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,s.yg)("ol",null,(0,s.yg)("li",{parentName:"ol"})))}iF.isMDXComponent=!0;const lF={toc:[]},uF="wrapper";function mF(e){let{components:n,...t}=e;return(0,s.yg)(uF,(0,p.A)({},lF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A value matching the structure of from and to."))}mF.isMDXComponent=!0;const yF={toc:[]},dF="wrapper";function hF(e){let{components:n,...t}=e;return(0,s.yg)(dF,(0,p.A)({},yF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}hF.isMDXComponent=!0;const gF={toc:[]},fF="wrapper";function DF(e){let{components:n,...t}=e;return(0,s.yg)(fF,(0,p.A)({},gF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The input to favor when value is 0."))}DF.isMDXComponent=!0;const MF={toc:[]},XF="wrapper";function _F(e){let{components:n,...t}=e;return(0,s.yg)(XF,(0,p.A)({},MF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The input to favor when value is 1."))}_F.isMDXComponent=!0;const wF={toc:[]},TF="wrapper";function CF(e){let{components:n,...t}=e;return(0,s.yg)(TF,(0,p.A)({},wF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}CF.isMDXComponent=!0;const xF={toc:[]},AF="wrapper";function vF(e){let{components:n,...t}=e;return(0,s.yg)(AF,(0,p.A)({},xF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A value matching the structure of from and to."))}vF.isMDXComponent=!0;const LF={toc:[]},bF="wrapper";function NF(e){let{components:n,...t}=e;return(0,s.yg)(bF,(0,p.A)({},LF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}NF.isMDXComponent=!0;const kF={toc:[]},zF="wrapper";function PF(e){let{components:n,...t}=e;return(0,s.yg)(zF,(0,p.A)({},kF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The input to favor when value is 0."))}PF.isMDXComponent=!0;const IF={toc:[]},RF="wrapper";function WF(e){let{components:n,...t}=e;return(0,s.yg)(RF,(0,p.A)({},IF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The input to favor when value is 1."))}WF.isMDXComponent=!0;const SF={toc:[]},BF="wrapper";function EF(e){let{components:n,...t}=e;return(0,s.yg)(BF,(0,p.A)({},SF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}EF.isMDXComponent=!0;const GF={toc:[]},OF="wrapper";function UF(e){let{components:n,...t}=e;return(0,s.yg)(OF,(0,p.A)({},GF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Complex types used in animations."))}UF.isMDXComponent=!0;const FF={toc:[]},VF="wrapper";function qF(e){let{components:n,...t}=e;return(0,s.yg)(VF,(0,p.A)({},FF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/core/types/BBox#expand"},(0,s.yg)("inlineCode",{parentName:"a"},"expand"))," instead."))}qF.isMDXComponent=!0;const jF={toc:[]},HF="wrapper";function YF(e){let{components:n,...t}=e;return(0,s.yg)(HF,(0,p.A)({},jF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Expand the bounding box to accommodate the given spacing."))}YF.isMDXComponent=!0;const QF={toc:[]},$F="wrapper";function KF(e){let{components:n,...t}=e;return(0,s.yg)($F,(0,p.A)({},QF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value to expand the bounding box by."))}KF.isMDXComponent=!0;const JF={toc:[]},ZF="wrapper";function eV(e){let{components:n,...t}=e;return(0,s.yg)(ZF,(0,p.A)({},JF,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Expand the bounding box to accommodate the given spacing."))}eV.isMDXComponent=!0;const nV={toc:[]},tV="wrapper";function oV(e){let{components:n,...t}=e;return(0,s.yg)(tV,(0,p.A)({},nV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value to expand the bounding box by."))}oV.isMDXComponent=!0;const pV={toc:[]},rV="wrapper";function sV(e){let{components:n,...t}=e;return(0,s.yg)(rV,(0,p.A)({},pV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A specialized 2x3 Matrix representing a 2D transformation."),(0,s.yg)("p",null,"A Matrix2D contains six elements defined as\n","[a, b,\nc, d,\ntx, ty]"),(0,s.yg)("p",null,"This is a shortcut for a 3x3 matrix of the form\n","[a, b, 0,\nc, d, 0\ntx, ty, 1]"),(0,s.yg)("p",null,'Note that because a Matrix2D ignores the z-values of each component vectors,\nit does not satisfy all properties of a "real" 3x3 matrix.'),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},"A Matrix2D has no transpose"),(0,s.yg)("li",{parentName:"ul"},"A(B + C) = AB + AC does not hold for a Matrix2D"),(0,s.yg)("li",{parentName:"ul"},"(rA)^-1 = r^-1 A^-1, r != 0 does not hold for a Matrix2D"),(0,s.yg)("li",{parentName:"ul"},"r(AB) = (rA)B = A(rB) does not hold for a Matrix2D")))}sV.isMDXComponent=!0;const cV={toc:[]},aV="wrapper";function iV(e){let{components:n,...t}=e;return(0,s.yg)(aV,(0,p.A)({},cV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the determinant of the matrix."))}iV.isMDXComponent=!0;const lV={toc:[]},uV="wrapper";function mV(e){let{components:n,...t}=e;return(0,s.yg)(uV,(0,p.A)({},lV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the matrix is not invertible, i.e. its determinant is ",(0,s.yg)("inlineCode",{parentName:"p"},"0"),", this will\nreturn ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", instead."))}mV.isMDXComponent=!0;const yV={toc:[]},dV="wrapper";function hV(e){let{components:n,...t}=e;return(0,s.yg)(dV,(0,p.A)({},yV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst inverse = matrix.inverse;\n// => Matrix2D(\n//      [-2, 1],\n//      [1.5, -0.5],\n//      [1, -2],\n//   )\n")))}hV.isMDXComponent=!0;const gV={toc:[]},fV="wrapper";function DV(e){let{components:n,...t}=e;return(0,s.yg)(fV,(0,p.A)({},gV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the inverse of the matrix."))}DV.isMDXComponent=!0;const MV={toc:[]},XV="wrapper";function _V(e){let{components:n,...t}=e;return(0,s.yg)(XV,(0,p.A)({},MV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}_V.isMDXComponent=!0;const wV={toc:[]},TV="wrapper";function CV(e){let{components:n,...t}=e;return(0,s.yg)(TV,(0,p.A)({},wV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.add(b);\n// => Matrix2D(\n//      [8, 10],\n//      [12, 14],\n//      [16, 18],\n//    )\n")))}CV.isMDXComponent=!0;const xV={toc:[]},AV="wrapper";function vV(e){let{components:n,...t}=e;return(0,s.yg)(AV,(0,p.A)({},xV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the provided matrix to this matrix."))}vV.isMDXComponent=!0;const LV={toc:[]},bV="wrapper";function NV(e){let{components:n,...t}=e;return(0,s.yg)(bV,(0,p.A)({},LV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The matrix to add"))}NV.isMDXComponent=!0;const kV={toc:[]},zV="wrapper";function PV(e){let{components:n,...t}=e;return(0,s.yg)(zV,(0,p.A)({},kV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst x = matrix.column(0);\n// Vector2(1, 0)\n\nconst y = matrix.column(1);\n// Vector2(0, 0)\n\nconst z = matrix.column(1);\n// Vector2(1, 0)\n")))}PV.isMDXComponent=!0;const IV={toc:[]},RV="wrapper";function WV(e){let{components:n,...t}=e;return(0,s.yg)(RV,(0,p.A)({},IV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth component vector of the matrix. Only defined for 0, 1, and 2."))}WV.isMDXComponent=!0;const SV={toc:[]},BV="wrapper";function EV(e){let{components:n,...t}=e;return(0,s.yg)(BV,(0,p.A)({},SV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the component vector to retrieve."))}EV.isMDXComponent=!0;const GV={toc:[]},OV="wrapper";function UV(e){let{components:n,...t}=e;return(0,s.yg)(OV,(0,p.A)({},GV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}UV.isMDXComponent=!0;const FV={toc:[]},VV="wrapper";function qV(e){let{components:n,...t}=e;return(0,s.yg)(VV,(0,p.A)({},FV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [0, 1],\n  [1, 1],\n);\nconst b = new Matrix2D(\n  [2, 1],\n  [1, 1],\n  [1, 1],\n);\n\nconst result = a.mul(b);\n// => Matrix2D(\n//     [2, 5],\n//     [1, 3],\n//     [2, 4],\n//   )\n")))}qV.isMDXComponent=!0;const jV={toc:[]},HV="wrapper";function YV(e){let{components:n,...t}=e;return(0,s.yg)(HV,(0,p.A)({},jV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Returns the matrix product of this matrix with the provided matrix."))}YV.isMDXComponent=!0;const QV={toc:[]},$V="wrapper";function KV(e){let{components:n,...t}=e;return(0,s.yg)($V,(0,p.A)({},QV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The matrix to multiply with"))}KV.isMDXComponent=!0;const JV={toc:[]},ZV="wrapper";function eq(e){let{components:n,...t}=e;return(0,s.yg)(ZV,(0,p.A)({},JV,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.mulScalar(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [10, 12],\n//    )\n")))}eq.isMDXComponent=!0;const nq={toc:[]},tq="wrapper";function oq(e){let{components:n,...t}=e;return(0,s.yg)(tq,(0,p.A)({},nq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Multiply each value of the matrix by a scalar."),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"})))}oq.isMDXComponent=!0;const pq={toc:[]},rq="wrapper";function sq(e){let{components:n,...t}=e;return(0,s.yg)(rq,(0,p.A)({},pq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value by which to scale each term"))}sq.isMDXComponent=!0;const cq={toc:[]},aq="wrapper";function iq(e){let{components:n,...t}=e;return(0,s.yg)(aq,(0,p.A)({},cq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}iq.isMDXComponent=!0;const lq={toc:[]},uq="wrapper";function mq(e){let{components:n,...t}=e;return(0,s.yg)(uq,(0,p.A)({},lq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result = a.rotate(90);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n\n// Provide the angle in radians\nconst result = a.rotate(Math.PI * 0.5, true);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n")))}mq.isMDXComponent=!0;const yq={toc:[]},dq="wrapper";function hq(e){let{components:n,...t}=e;return(0,s.yg)(dq,(0,p.A)({},yq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rotate the matrix by the provided angle. By default, the angle is\nprovided in degrees."))}hq.isMDXComponent=!0;const gq={toc:[]},fq="wrapper";function Dq(e){let{components:n,...t}=e;return(0,s.yg)(fq,(0,p.A)({},gq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The angle by which to rotate the matrix."))}Dq.isMDXComponent=!0;const Mq={toc:[]},Xq="wrapper";function _q(e){let{components:n,...t}=e;return(0,s.yg)(Xq,(0,p.A)({},Mq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the angle is provided in degrees."))}_q.isMDXComponent=!0;const wq={toc:[]},Tq="wrapper";function Cq(e){let{components:n,...t}=e;return(0,s.yg)(Tq,(0,p.A)({},wq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst firstRow = matrix.column(0);\n// [1, 0, 1]\n\nconst secondRow = matrix.column(1);\n// [0, 0, 0]\n")))}Cq.isMDXComponent=!0;const xq={toc:[]},Aq="wrapper";function vq(e){let{components:n,...t}=e;return(0,s.yg)(Aq,(0,p.A)({},xq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Returns the nth row of the matrix. Only defined for 0 and 1."))}vq.isMDXComponent=!0;const Lq={toc:[]},bq="wrapper";function Nq(e){let{components:n,...t}=e;return(0,s.yg)(bq,(0,p.A)({},Lq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the row to retrieve."))}Nq.isMDXComponent=!0;const kq={toc:[]},zq="wrapper";function Pq(e){let{components:n,...t}=e;return(0,s.yg)(zq,(0,p.A)({},kq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If ",(0,s.yg)("inlineCode",{parentName:"p"},"vec")," is provided as a vector, the x and y component vectors of the\nmatrix will be scaled by the x and y parts of the vector, respectively."),(0,s.yg)("p",null,"If ",(0,s.yg)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, the x and y component vectors will be\nscaled uniformly by this factor."),(0,s.yg)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Pq.isMDXComponent=!0;const Iq={toc:[]},Rq="wrapper";function Wq(e){let{components:n,...t}=e;return(0,s.yg)(Rq,(0,p.A)({},Iq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.scale([2, 3]);\n// => new Matrix2D(\n//      [2, 4],\n//      [9, 12],\n//      [5, 6],\n//    )\n\nconst result2 = matrix.scale(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [5, 6],\n//    )\n")))}Wq.isMDXComponent=!0;const Sq={toc:[]},Bq="wrapper";function Eq(e){let{components:n,...t}=e;return(0,s.yg)(Bq,(0,p.A)({},Sq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Scale the x and y component vectors of the matrix."))}Eq.isMDXComponent=!0;const Gq={toc:[]},Oq="wrapper";function Uq(e){let{components:n,...t}=e;return(0,s.yg)(Oq,(0,p.A)({},Gq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The factor by which to scale the matrix"))}Uq.isMDXComponent=!0;const Fq={toc:[]},Vq="wrapper";function qq(e){let{components:n,...t}=e;return(0,s.yg)(Vq,(0,p.A)({},Fq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}qq.isMDXComponent=!0;const jq={toc:[]},Hq="wrapper";function Yq(e){let{components:n,...t}=e;return(0,s.yg)(Hq,(0,p.A)({},jq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.sub(b);\n// => Matrix2D(\n//      [-6, -6],\n//      [-6, -6],\n//      [-6, -6],\n//    )\n")))}Yq.isMDXComponent=!0;const Qq={toc:[]},$q="wrapper";function Kq(e){let{components:n,...t}=e;return(0,s.yg)($q,(0,p.A)({},Qq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Subtract the provided matrix from this matrix."))}Kq.isMDXComponent=!0;const Jq={toc:[]},Zq="wrapper";function ej(e){let{components:n,...t}=e;return(0,s.yg)(Zq,(0,p.A)({},Jq,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The matrix to subract"))}ej.isMDXComponent=!0;const nj={toc:[]},tj="wrapper";function oj(e){let{components:n,...t}=e;return(0,s.yg)(tj,(0,p.A)({},nj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If ",(0,s.yg)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, matrix will be translated uniformly\nby this factor."),(0,s.yg)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}oj.isMDXComponent=!0;const pj={toc:[]},rj="wrapper";function sj(e){let{components:n,...t}=e;return(0,s.yg)(rj,(0,p.A)({},pj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.translate([2, 3]);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [16, 22],\n//    )\n\nconst result2 = matrix.translate(2);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [13, 18],\n//    )\n")))}sj.isMDXComponent=!0;const cj={toc:[]},aj="wrapper";function ij(e){let{components:n,...t}=e;return(0,s.yg)(aj,(0,p.A)({},cj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Translate the matrix by the dimensions of the provided vector."))}ij.isMDXComponent=!0;const lj={toc:[]},uj="wrapper";function mj(e){let{components:n,...t}=e;return(0,s.yg)(uj,(0,p.A)({},lj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The vector by which to translate the matrix"))}mj.isMDXComponent=!0;const yj={toc:[]},dj="wrapper";function hj(e){let{components:n,...t}=e;return(0,s.yg)(dj,(0,p.A)({},yj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a two-dimensional vector."))}hj.isMDXComponent=!0;const gj={toc:[]},fj="wrapper";function Dj(e){let{components:n,...t}=e;return(0,s.yg)(fj,(0,p.A)({},gj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant equal to ",(0,s.yg)("inlineCode",{parentName:"p"},"Vector2(0, 1)")))}Dj.isMDXComponent=!0;const Mj={toc:[]},Xj="wrapper";function _j(e){let{components:n,...t}=e;return(0,s.yg)(Xj,(0,p.A)({},Mj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant equal to ",(0,s.yg)("inlineCode",{parentName:"p"},"Vector2(-1, 1)")))}_j.isMDXComponent=!0;const wj={toc:[]},Tj="wrapper";function Cj(e){let{components:n,...t}=e;return(0,s.yg)(Tj,(0,p.A)({},wj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant equal to ",(0,s.yg)("inlineCode",{parentName:"p"},"Vector2(1, 1)")))}Cj.isMDXComponent=!0;const xj={toc:[]},Aj="wrapper";function vj(e){let{components:n,...t}=e;return(0,s.yg)(Aj,(0,p.A)({},xj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant equal to ",(0,s.yg)("inlineCode",{parentName:"p"},"Vector2(0, -1)")))}vj.isMDXComponent=!0;const Lj={toc:[]},bj="wrapper";function Nj(e){let{components:n,...t}=e;return(0,s.yg)(bj,(0,p.A)({},Lj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant equal to ",(0,s.yg)("inlineCode",{parentName:"p"},"Vector2(-1, -1)")))}Nj.isMDXComponent=!0;const kj={toc:[]},zj="wrapper";function Pj(e){let{components:n,...t}=e;return(0,s.yg)(zj,(0,p.A)({},kj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant equal to ",(0,s.yg)("inlineCode",{parentName:"p"},"Vector2(1, -1)")))}Pj.isMDXComponent=!0;const Ij={toc:[]},Rj="wrapper";function Wj(e){let{components:n,...t}=e;return(0,s.yg)(Rj,(0,p.A)({},Ij,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned angle will be between -180 and 180 degrees."))}Wj.isMDXComponent=!0;const Sj={toc:[]},Bj="wrapper";function Ej(e){let{components:n,...t}=e;return(0,s.yg)(Bj,(0,p.A)({},Sj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the angle in degrees between the vector and the positive x-axis."))}Ej.isMDXComponent=!0;const Gj={toc:[]},Oj="wrapper";function Uj(e){let{components:n,...t}=e;return(0,s.yg)(Oj,(0,p.A)({},Gj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the angle in radians between the vector and the positive x-axis."))}Uj.isMDXComponent=!0;const Fj={toc:[]},Vj="wrapper";function qj(e){let{components:n,...t}=e;return(0,s.yg)(Vj,(0,p.A)({},Fj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method allows passing an allowed error margin when comparing vectors\nto compensate for floating point inaccuracies. To check if two vectors are\nexactly equal, use the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/types/Vector2#exactlyEquals"},(0,s.yg)("inlineCode",{parentName:"a"},"exactlyEquals"))," method, instead."))}qj.isMDXComponent=!0;const jj={toc:[]},Hj="wrapper";function Yj(e){let{components:n,...t}=e;return(0,s.yg)(Hj,(0,p.A)({},jj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if two vectors are equal to each other."))}Yj.isMDXComponent=!0;const Qj={toc:[]},$j="wrapper";function Kj(e){let{components:n,...t}=e;return(0,s.yg)($j,(0,p.A)({},Qj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The vector to compare."))}Kj.isMDXComponent=!0;const Jj={toc:[]},Zj="wrapper";function eH(e){let{components:n,...t}=e;return(0,s.yg)(Zj,(0,p.A)({},Jj,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The allowed error threshold when comparing the vectors."))}eH.isMDXComponent=!0;const nH={toc:[]},tH="wrapper";function oH(e){let{components:n,...t}=e;return(0,s.yg)(tH,(0,p.A)({},nH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If you need to compensate for floating point inaccuracies, use the\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/types/Vector2#equals"},(0,s.yg)("inlineCode",{parentName:"a"},"equals"))," method, instead."))}oH.isMDXComponent=!0;const pH={toc:[]},rH="wrapper";function sH(e){let{components:n,...t}=e;return(0,s.yg)(rH,(0,p.A)({},pH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if two vectors are exactly equal to each other."))}sH.isMDXComponent=!0;const cH={toc:[]},aH="wrapper";function iH(e){let{components:n,...t}=e;return(0,s.yg)(aH,(0,p.A)({},cH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The vector to compare."))}iH.isMDXComponent=!0;const lH={toc:[]},uH="wrapper";function mH(e){let{components:n,...t}=e;return(0,s.yg)(uH,(0,p.A)({},lH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rotates the vector around a point by the provided angle."))}mH.isMDXComponent=!0;const yH={toc:[]},dH="wrapper";function hH(e){let{components:n,...t}=e;return(0,s.yg)(dH,(0,p.A)({},yH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The angle by which to rotate in degrees."))}hH.isMDXComponent=!0;const gH={toc:[]},fH="wrapper";function DH(e){let{components:n,...t}=e;return(0,s.yg)(fH,(0,p.A)({},gH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The center of rotation. Defaults to the origin."))}DH.isMDXComponent=!0;const MH={toc:[]},XH="wrapper";function _H(e){let{components:n,...t}=e;return(0,s.yg)(XH,(0,p.A)({},MH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Helper function to create a ",(0,s.yg)("a",{parentName:"p",href:"/api/core/types/Vector2#static-polarLerp"},(0,s.yg)("inlineCode",{parentName:"a"},"polarLerp"))," interpolation\nfunction with additional parameters."))}_H.isMDXComponent=!0;const wH={toc:[]},TH="wrapper";function CH(e){let{components:n,...t}=e;return(0,s.yg)(TH,(0,p.A)({},wH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the point should get rotated\ncounterclockwise."))}CH.isMDXComponent=!0;const xH={toc:[]},AH="wrapper";function vH(e){let{components:n,...t}=e;return(0,s.yg)(AH,(0,p.A)({},xH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The center of rotation. Defaults to the origin."))}vH.isMDXComponent=!0;const LH={toc:[]},bH="wrapper";function NH(e){let{components:n,...t}=e;return(0,s.yg)(bH,(0,p.A)({},LH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned angle will be between -180 and 180 degrees."))}NH.isMDXComponent=!0;const kH={toc:[]},zH="wrapper";function PH(e){let{components:n,...t}=e;return(0,s.yg)(zH,(0,p.A)({},kH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the angle in degrees between the vector described by x and y and the\npositive x-axis."))}PH.isMDXComponent=!0;const IH={toc:[]},RH="wrapper";function WH(e){let{components:n,...t}=e;return(0,s.yg)(RH,(0,p.A)({},IH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The x component of the vector."))}WH.isMDXComponent=!0;const SH={toc:[]},BH="wrapper";function EH(e){let{components:n,...t}=e;return(0,s.yg)(BH,(0,p.A)({},SH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The y component of the vector."))}EH.isMDXComponent=!0;const GH={toc:[]},OH="wrapper";function UH(e){let{components:n,...t}=e;return(0,s.yg)(OH,(0,p.A)({},GH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This function is useful when used in conjunction with ",(0,s.yg)("a",{parentName:"p",href:"/api/core/types/Vector2#rotate"},(0,s.yg)("inlineCode",{parentName:"a"},"rotate"))," to\nanimate an object's position on a circular arc (see examples)."))}UH.isMDXComponent=!0;const FH={toc:[]},VH="wrapper";function qH(e){let{components:n,...t}=e;return(0,s.yg)(VH,(0,p.A)({},FH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Animating an object in a circle around the origin"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"circle().position(\n  circle().position().rotate(180),\n  1,\n  easeInOutCubic,\n  Vector2.polarLerp\n);\n")))}qH.isMDXComponent=!0;const jH={toc:[]},HH="wrapper";function YH(e){let{components:n,...t}=e;return(0,s.yg)(HH,(0,p.A)({},jH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rotating an object around the point ",(0,s.yg)("inlineCode",{parentName:"p"},"[-200, 100]")),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"circle().position(\n  circle().position().rotate(180, [-200, 100]),\n  1,\n  easeInOutCubic,\n  Vector2.createPolarLerp(false, [-200, 100]),\n);\n")))}YH.isMDXComponent=!0;const QH={toc:[]},$H="wrapper";function KH(e){let{components:n,...t}=e;return(0,s.yg)($H,(0,p.A)({},QH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rotating an object counterclockwise around the origin"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"circle().position(\n  circle().position().rotate(180),\n  1,\n  easeInOutCubic,\n  Vector2.createPolarLerp(true),\n);\n")))}KH.isMDXComponent=!0;const JH={toc:[]},ZH="wrapper";function eY(e){let{components:n,...t}=e;return(0,s.yg)(ZH,(0,p.A)({},JH,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Interpolates between two vectors on the polar plane by interpolating\nthe angles and magnitudes of the vectors individually."))}eY.isMDXComponent=!0;const nY={toc:[]},tY="wrapper";function oY(e){let{components:n,...t}=e;return(0,s.yg)(tY,(0,p.A)({},nY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The starting vector."))}oY.isMDXComponent=!0;const pY={toc:[]},rY="wrapper";function sY(e){let{components:n,...t}=e;return(0,s.yg)(rY,(0,p.A)({},pY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The target vector."))}sY.isMDXComponent=!0;const cY={toc:[]},aY="wrapper";function iY(e){let{components:n,...t}=e;return(0,s.yg)(aY,(0,p.A)({},cY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The t-value of the interpolation."))}iY.isMDXComponent=!0;const lY={toc:[]},uY="wrapper";function mY(e){let{components:n,...t}=e;return(0,s.yg)(uY,(0,p.A)({},lY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the vector should get rotated\ncounterclockwise. Defaults to ",(0,s.yg)("inlineCode",{parentName:"p"},"false"),"."))}mY.isMDXComponent=!0;const yY={toc:[]},dY="wrapper";function hY(e){let{components:n,...t}=e;return(0,s.yg)(dY,(0,p.A)({},yY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The center of rotation. Defaults to the origin."))}hY.isMDXComponent=!0;const gY={toc:[]},fY="wrapper";function DY(e){let{components:n,...t}=e;return(0,s.yg)(fY,(0,p.A)({},gY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the angle in radians between the vector described by x and y and the\npositive x-axis."))}DY.isMDXComponent=!0;const MY={toc:[]},XY="wrapper";function _Y(e){let{components:n,...t}=e;return(0,s.yg)(XY,(0,p.A)({},MY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The x component of the vector."))}_Y.isMDXComponent=!0;const wY={toc:[]},TY="wrapper";function CY(e){let{components:n,...t}=e;return(0,s.yg)(TY,(0,p.A)({},wY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The y component of the vector."))}CY.isMDXComponent=!0;const xY={toc:[]},AY="wrapper";function vY(e){let{components:n,...t}=e;return(0,s.yg)(AY,(0,p.A)({},xY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same class as the one created by\n",(0,s.yg)("a",{parentName:"p",href:"https://gka.github.io/chroma.js/"},(0,s.yg)("inlineCode",{parentName:"a"},"chroma.js")),". Check out their\ndocumentation for more information on how to use it."))}vY.isMDXComponent=!0;const LY={toc:[]},bY="wrapper";function NY(e){let{components:n,...t}=e;return(0,s.yg)(bY,(0,p.A)({},LY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a color."))}NY.isMDXComponent=!0;const kY={toc:[]},zY="wrapper";function PY(e){let{components:n,...t}=e;return(0,s.yg)(zY,(0,p.A)({},kY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}PY.isMDXComponent=!0;const IY={toc:[]},RY="wrapper";function WY(e){let{components:n,...t}=e;return(0,s.yg)(RY,(0,p.A)({},IY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert the given origin to a vector representing its offset."))}WY.isMDXComponent=!0;const SY={toc:[]},BY="wrapper";function EY(e){let{components:n,...t}=e;return(0,s.yg)(BY,(0,p.A)({},SY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The origin to convert."))}EY.isMDXComponent=!0;const GY={toc:[]},OY="wrapper";function UY(e){let{components:n,...t}=e;return(0,s.yg)(OY,(0,p.A)({},GY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"General utilities and helper functions."))}UY.isMDXComponent=!0;const FY={toc:[]},VY="wrapper";function qY(e){let{components:n,...t}=e;return(0,s.yg)(VY,(0,p.A)({},FY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Can be used to display any duration related to the log.\nThe value is always visible next to the message."))}qY.isMDXComponent=!0;const jY={toc:[]},HY="wrapper";function YY(e){let{components:n,...t}=e;return(0,s.yg)(HY,(0,p.A)({},jY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional duration in milliseconds."))}YY.isMDXComponent=!0;const QY={toc:[]},$Y="wrapper";function KY(e){let{components:n,...t}=e;return(0,s.yg)($Y,(0,p.A)({},QY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This will be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Inspectable"},(0,s.yg)("inlineCode",{parentName:"a"},"Inspectable")),' interface to\ndisplay additional information about the inspected object.\nWhen specified, the log will have an "inspect" button that will open the\n"Properties" tab and select the inspected object.'))}KY.isMDXComponent=!0;const JY={toc:[]},ZY="wrapper";function eQ(e){let{components:n,...t}=e;return(0,s.yg)(ZY,(0,p.A)({},JY,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional key used to inspect a related object."))}eQ.isMDXComponent=!0;const nQ={toc:[]},tQ="wrapper";function oQ(e){let{components:n,...t}=e;return(0,s.yg)(tQ,(0,p.A)({},nQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Visible only when the log is expanded."))}oQ.isMDXComponent=!0;const pQ={toc:[]},rQ="wrapper";function sQ(e){let{components:n,...t}=e;return(0,s.yg)(rQ,(0,p.A)({},pQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An object that will be serialized as JSON and displayed under the message."))}sQ.isMDXComponent=!0;const cQ={toc:[]},aQ="wrapper";function iQ(e){let{components:n,...t}=e;return(0,s.yg)(aQ,(0,p.A)({},cQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Always visible."))}iQ.isMDXComponent=!0;const lQ={toc:[]},uQ="wrapper";function mQ(e){let{components:n,...t}=e;return(0,s.yg)(uQ,(0,p.A)({},lQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The main message of the log."))}mQ.isMDXComponent=!0;const yQ={toc:[]},dQ="wrapper";function hQ(e){let{components:n,...t}=e;return(0,s.yg)(dQ,(0,p.A)({},yQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}hQ.isMDXComponent=!0;const gQ={toc:[]},fQ="wrapper";function DQ(e){let{components:n,...t}=e;return(0,s.yg)(fQ,(0,p.A)({},gQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Optional override for formatting stack traces"))}DQ.isMDXComponent=!0;const MQ={toc:[]},XQ="wrapper";function _Q(e){let{components:n,...t}=e;return(0,s.yg)(XQ,(0,p.A)({},MQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create .stack property on a target object"))}_Q.isMDXComponent=!0;const wQ={toc:[]},TQ="wrapper";function CQ(e){let{components:n,...t}=e;return(0,s.yg)(TQ,(0,p.A)({},wQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Can be used to display any duration related to the log.\nThe value is always visible next to the message."))}CQ.isMDXComponent=!0;const xQ={toc:[]},AQ="wrapper";function vQ(e){let{components:n,...t}=e;return(0,s.yg)(AQ,(0,p.A)({},xQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional duration in milliseconds."))}vQ.isMDXComponent=!0;const LQ={toc:[]},bQ="wrapper";function NQ(e){let{components:n,...t}=e;return(0,s.yg)(bQ,(0,p.A)({},LQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This will be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/core/scenes/Inspectable"},(0,s.yg)("inlineCode",{parentName:"a"},"Inspectable")),' interface to\ndisplay additional information about the inspected object.\nWhen specified, the log will have an "inspect" button that will open the\n"Properties" tab and select the inspected object.'))}NQ.isMDXComponent=!0;const kQ={toc:[]},zQ="wrapper";function PQ(e){let{components:n,...t}=e;return(0,s.yg)(zQ,(0,p.A)({},kQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional key used to inspect a related object."))}PQ.isMDXComponent=!0;const IQ={toc:[]},RQ="wrapper";function WQ(e){let{components:n,...t}=e;return(0,s.yg)(RQ,(0,p.A)({},IQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Visible only when the log is expanded."))}WQ.isMDXComponent=!0;const SQ={toc:[]},BQ="wrapper";function EQ(e){let{components:n,...t}=e;return(0,s.yg)(BQ,(0,p.A)({},SQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An object that will be serialized as JSON and displayed under the message."))}EQ.isMDXComponent=!0;const GQ={toc:[]},OQ="wrapper";function UQ(e){let{components:n,...t}=e;return(0,s.yg)(OQ,(0,p.A)({},GQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Always visible."))}UQ.isMDXComponent=!0;const FQ={toc:[]},VQ="wrapper";function qQ(e){let{components:n,...t}=e;return(0,s.yg)(VQ,(0,p.A)({},FQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The main message of the log."))}qQ.isMDXComponent=!0;const jQ={toc:[]},HQ="wrapper";function YQ(e){let{components:n,...t}=e;return(0,s.yg)(HQ,(0,p.A)({},jQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}YQ.isMDXComponent=!0;const QQ={toc:[]},$Q="wrapper";function KQ(e){let{components:n,...t}=e;return(0,s.yg)($Q,(0,p.A)({},QQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Optional override for formatting stack traces"))}KQ.isMDXComponent=!0;const JQ={toc:[]},ZQ="wrapper";function e$(e){let{components:n,...t}=e;return(0,s.yg)(ZQ,(0,p.A)({},JQ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create .stack property on a target object"))}e$.isMDXComponent=!0;const n$={toc:[]},t$="wrapper";function o$(e){let{components:n,...t}=e;return(0,s.yg)(t$,(0,p.A)({},n$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An array of the transformed references."))}o$.isMDXComponent=!0;const p$={toc:[]},r$="wrapper";function s$(e){let{components:n,...t}=e;return(0,s.yg)(r$,(0,p.A)({},p$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Maps the references in this group to a new array."))}s$.isMDXComponent=!0;const c$={toc:[]},a$="wrapper";function i$(e){let{components:n,...t}=e;return(0,s.yg)(a$,(0,p.A)({},c$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The function to transform each reference."))}i$.isMDXComponent=!0;const l$={toc:[]},u$="wrapper";function m$(e){let{components:n,...t}=e;return(0,s.yg)(u$,(0,p.A)({},l$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const radians = 30 * DEG2RAD;\n")))}m$.isMDXComponent=!0;const y$={toc:[]},d$="wrapper";function h$(e){let{components:n,...t}=e;return(0,s.yg)(d$,(0,p.A)({},y$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant for converting degrees to radians"))}h$.isMDXComponent=!0;const g$={toc:[]},f$="wrapper";function D$(e){let{components:n,...t}=e;return(0,s.yg)(f$,(0,p.A)({},g$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const degrees = 0.6 * RAD2DEG;\n")))}D$.isMDXComponent=!0;const M$={toc:[]},X$="wrapper";function _$(e){let{components:n,...t}=e;return(0,s.yg)(X$,(0,p.A)({},M$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A constant for converting radians to degrees"))}_$.isMDXComponent=!0;const w$={toc:[]},T$="wrapper";function C$(e){let{components:n,...t}=e;return(0,s.yg)(T$,(0,p.A)({},w$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned object is both an array and a reference that can be passed\ndirectly to the ",(0,s.yg)("inlineCode",{parentName:"p"},"ref")," property of a node."))}C$.isMDXComponent=!0;const x$={toc:[]},A$="wrapper";function v$(e){let{components:n,...t}=e;return(0,s.yg)(A$,(0,p.A)({},x$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const labels = createRefArray<Txt>();\n\nview.add(['A', 'B'].map(text => <Txt ref={labels}>{text}</Txt>));\nview.add(<Txt ref={labels}>C</Txt>);\n\n// accessing the references individually:\nyield* labels[0].text('A changes', 0.3);\nyield* labels[1].text('B changes', 0.3);\nyield* labels[2].text('C changes', 0.3);\n\n// accessing all references at once:\nyield* all(...labels.map(label => label.fill('white', 0.3)));\n")))}v$.isMDXComponent=!0;const L$={toc:[]},b$="wrapper";function N$(e){let{components:n,...t}=e;return(0,s.yg)(b$,(0,p.A)({},L$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an array of references."))}N$.isMDXComponent=!0;const k$={toc:[]},z$="wrapper";function P$(e){let{components:n,...t}=e;return(0,s.yg)(z$,(0,p.A)({},k$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned object lets you easily create multiple references to the same\ntype without initializing them individually."),(0,s.yg)("p",null,"You can retrieve references by accessing the object's properties. If the\nreference for a given property does not exist, it will be created\nautomatically."))}P$.isMDXComponent=!0;const I$={toc:[]},R$="wrapper";function W$(e){let{components:n,...t}=e;return(0,s.yg)(R$,(0,p.A)({},I$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const labels = createRefMap<Txt>();\n\nview.add(\n  <>\n    <Txt ref={labels.a}>A</Txt>\n    <Txt ref={labels.b}>B</Txt>\n    <Txt ref={labels.c}>C</Txt>\n  </>,\n);\n\n// accessing the references individually:\nyield* labels.a().text('A changes', 0.3);\nyield* labels.b().text('B changes', 0.3);\nyield* labels.c().text('C changes', 0.3);\n\n// checking if the given reference exists:\nif ('d' in labels) {\n  yield* labels.d().text('D changes', 0.3);\n}\n\n// accessing all references at once:\nyield* all(...labels.mapRefs(label => label.fill('white', 0.3)));\n")))}W$.isMDXComponent=!0;const S$={toc:[]},B$="wrapper";function E$(e){let{components:n,...t}=e;return(0,s.yg)(B$,(0,p.A)({},S$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a group of references."))}E$.isMDXComponent=!0;const G$={toc:[]},O$="wrapper";function U$(e){let{components:n,...t}=e;return(0,s.yg)(O$,(0,p.A)({},G$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is a shortcut for calling ",(0,s.yg)("inlineCode",{parentName:"p"},"useLogger().debug()")," which allows\nyou to more easily log non-string values as well."))}U$.isMDXComponent=!0;const F$={toc:[]},V$="wrapper";function q$(e){let{components:n,...t}=e;return(0,s.yg)(V$,(0,p.A)({},F$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  debug(circle().position());\n});\n")))}q$.isMDXComponent=!0;const j$={toc:[]},H$="wrapper";function Y$(e){let{components:n,...t}=e;return(0,s.yg)(H$,(0,p.A)({},j$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Logs a debug message with an arbitrary payload."))}Y$.isMDXComponent=!0;const Q$={toc:[]},$$="wrapper";function K$(e){let{components:n,...t}=e;return(0,s.yg)($$,(0,p.A)({},Q$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The payload to log"))}K$.isMDXComponent=!0;const J$={toc:[]},Z$="wrapper";function eK(e){let{components:n,...t}=e;return(0,s.yg)(Z$,(0,p.A)({},J$,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Mark the given function as deprecated."))}eK.isMDXComponent=!0;const nK={toc:[]},tK="wrapper";function oK(e){let{components:n,...t}=e;return(0,s.yg)(tK,(0,p.A)({},nK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The function to deprecate."))}oK.isMDXComponent=!0;const pK={toc:[]},rK="wrapper";function sK(e){let{components:n,...t}=e;return(0,s.yg)(rK,(0,p.A)({},pK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The log message."))}sK.isMDXComponent=!0;const cK={toc:[]},aK="wrapper";function iK(e){let{components:n,...t}=e;return(0,s.yg)(aK,(0,p.A)({},cK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The optional log remarks."))}iK.isMDXComponent=!0;const lK={toc:[]},uK="wrapper";function mK(e){let{components:n,...t}=e;return(0,s.yg)(uK,(0,p.A)({},lK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Usually used together with transitions. When a scene is marked as finished,\nthe transition will start but the scene generator will continue running."))}mK.isMDXComponent=!0;const yK={toc:[]},dK="wrapper";function hK(e){let{components:n,...t}=e;return(0,s.yg)(dK,(0,p.A)({},yK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Mark the current scene as ready to transition out."))}hK.isMDXComponent=!0;const gK={toc:[]},fK="wrapper";function DK(e){let{components:n,...t}=e;return(0,s.yg)(fK,(0,p.A)({},gK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value can either be 'true' of 'false'\n(as strings) if present, or be undefined if not run\nfrom a vite context or run without the MC Plugin."))}DK.isMDXComponent=!0;const MK={toc:[]},XK="wrapper";function _K(e){let{components:n,...t}=e;return(0,s.yg)(XK,(0,p.A)({},MK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the proxy is enabled via the plugin by checking\nfor ",(0,s.yg)("inlineCode",{parentName:"p"},"import.meta.env.VITE_MC_PROXY_ENABLED")))}_K.isMDXComponent=!0;const wK={toc:[]},TK="wrapper";function CK(e){let{components:n,...t}=e;return(0,s.yg)(TK,(0,p.A)({},wK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3); // [0, 1, 2]\nconst array2 = range(-3); // [0, -1, -2]\n")))}CK.isMDXComponent=!0;const xK={toc:[]},AK="wrapper";function vK(e){let{components:n,...t}=e;return(0,s.yg)(AK,(0,p.A)({},xK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an array containing a range of numbers."))}vK.isMDXComponent=!0;const LK={toc:[]},bK="wrapper";function NK(e){let{components:n,...t}=e;return(0,s.yg)(bK,(0,p.A)({},LK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The length of the array."))}NK.isMDXComponent=!0;const kK={toc:[]},zK="wrapper";function PK(e){let{components:n,...t}=e;return(0,s.yg)(zK,(0,p.A)({},kK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3, 7); // [3, 4, 5, 6]\nconst array2 = range(7, 3); // [7, 6, 5, 4]\n")))}PK.isMDXComponent=!0;const IK={toc:[]},RK="wrapper";function WK(e){let{components:n,...t}=e;return(0,s.yg)(RK,(0,p.A)({},IK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an array containing a range of numbers."))}WK.isMDXComponent=!0;const SK={toc:[]},BK="wrapper";function EK(e){let{components:n,...t}=e;return(0,s.yg)(BK,(0,p.A)({},SK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start of the range."))}EK.isMDXComponent=!0;const GK={toc:[]},OK="wrapper";function UK(e){let{components:n,...t}=e;return(0,s.yg)(OK,(0,p.A)({},GK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end of the range. ",(0,s.yg)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}UK.isMDXComponent=!0;const FK={toc:[]},VK="wrapper";function qK(e){let{components:n,...t}=e;return(0,s.yg)(VK,(0,p.A)({},FK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(1, 2, 0.25); // [1, 1.25, 1.5, 1.75]\nconst array2 = range(2, 1, -0.25); // [2, 1.75, 1.5, 1.25]\n")))}qK.isMDXComponent=!0;const jK={toc:[]},HK="wrapper";function YK(e){let{components:n,...t}=e;return(0,s.yg)(HK,(0,p.A)({},jK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an array containing a range of numbers."))}YK.isMDXComponent=!0;const QK={toc:[]},$K="wrapper";function KK(e){let{components:n,...t}=e;return(0,s.yg)($K,(0,p.A)({},QK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start of the range."))}KK.isMDXComponent=!0;const JK={toc:[]},ZK="wrapper";function eJ(e){let{components:n,...t}=e;return(0,s.yg)(ZK,(0,p.A)({},JK,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end of the range. ",(0,s.yg)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}eJ.isMDXComponent=!0;const nJ={toc:[]},tJ="wrapper";function oJ(e){let{components:n,...t}=e;return(0,s.yg)(tJ,(0,p.A)({},nJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value by which to increment or decrement."))}oJ.isMDXComponent=!0;const pJ={toc:[]},rJ="wrapper";function sJ(e){let{components:n,...t}=e;return(0,s.yg)(rJ,(0,p.A)({},pJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}sJ.isMDXComponent=!0;const cJ={toc:[]},aJ="wrapper";function iJ(e){let{components:n,...t}=e;return(0,s.yg)(aJ,(0,p.A)({},cJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The function that will be provided the context before render."))}iJ.isMDXComponent=!0;const lJ={toc:[]},uJ="wrapper";function mJ(e){let{components:n,...t}=e;return(0,s.yg)(uJ,(0,p.A)({},lJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}mJ.isMDXComponent=!0;const yJ={toc:[]},dJ="wrapper";function hJ(e){let{components:n,...t}=e;return(0,s.yg)(dJ,(0,p.A)({},yJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The function that will be provided the context after render."))}hJ.isMDXComponent=!0;const gJ={toc:[]},fJ="wrapper";function DJ(e){let{components:n,...t}=e;return(0,s.yg)(fJ,(0,p.A)({},gJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This can be used to better specify when an animation should start\nas well as how long this animation should take"))}DJ.isMDXComponent=!0;const MJ={toc:[]},XJ="wrapper";function _J(e){let{components:n,...t}=e;return(0,s.yg)(XJ,(0,p.A)({},MJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  yield* circle().scale(2, useDuration('circleGrow'));\n});\n")))}_J.isMDXComponent=!0;const wJ={toc:[]},TJ="wrapper";function CJ(e){let{components:n,...t}=e;return(0,s.yg)(TJ,(0,p.A)({},wJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the event in seconds."))}CJ.isMDXComponent=!0;const xJ={toc:[]},AJ="wrapper";function vJ(e){let{components:n,...t}=e;return(0,s.yg)(AJ,(0,p.A)({},xJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Register a time event and get its duration in seconds."))}vJ.isMDXComponent=!0;const LJ={toc:[]},bJ="wrapper";function NJ(e){let{components:n,...t}=e;return(0,s.yg)(bJ,(0,p.A)({},LJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The name of the event."))}NJ.isMDXComponent=!0;const kJ={toc:[]},zJ="wrapper";function PJ(e){let{components:n,...t}=e;return(0,s.yg)(zJ,(0,p.A)({},kJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a reference to the playback status."))}PJ.isMDXComponent=!0;const IJ={toc:[]},RJ="wrapper";function WJ(e){let{components:n,...t}=e;return(0,s.yg)(RJ,(0,p.A)({},IJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the random number generator for the current scene."))}WJ.isMDXComponent=!0;const SJ={toc:[]},BJ="wrapper";function EJ(e){let{components:n,...t}=e;return(0,s.yg)(BJ,(0,p.A)({},SJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the random number generator for the given seed."))}EJ.isMDXComponent=!0;const GJ={toc:[]},OJ="wrapper";function UJ(e){let{components:n,...t}=e;return(0,s.yg)(OJ,(0,p.A)({},GJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The seed for the generator."))}UJ.isMDXComponent=!0;const FJ={toc:[]},VJ="wrapper";function qJ(e){let{components:n,...t}=e;return(0,s.yg)(VJ,(0,p.A)({},FJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}qJ.isMDXComponent=!0;const jJ={toc:[]},HJ="wrapper";function YJ(e){let{components:n,...t}=e;return(0,s.yg)(HJ,(0,p.A)({},jJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a reference to the current scene."))}YJ.isMDXComponent=!0;const QJ={toc:[]},$J="wrapper";function KJ(e){let{components:n,...t}=e;return(0,s.yg)($J,(0,p.A)({},QJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a reference to the current thread."))}KJ.isMDXComponent=!0;const JJ={toc:[]},ZJ="wrapper";function eZ(e){let{components:n,...t}=e;return(0,s.yg)(ZJ,(0,p.A)({},JJ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.yg)("inlineCode",{parentName:"a"},"waitFor")),"."))}eZ.isMDXComponent=!0;const nZ={toc:[]},tZ="wrapper";function oZ(e){let{components:n,...t}=e;return(0,s.yg)(tZ,(0,p.A)({},nZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}oZ.isMDXComponent=!0;const pZ={toc:[]},rZ="wrapper";function sZ(e){let{components:n,...t}=e;return(0,s.yg)(rZ,(0,p.A)({},pZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the real time since the start of the animation."))}sZ.isMDXComponent=!0;const cZ={toc:[]},aZ="wrapper";function iZ(e){let{components:n,...t}=e;return(0,s.yg)(aZ,(0,p.A)({},cZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This rewrites a remote url like ",(0,s.yg)("inlineCode",{parentName:"p"},"https://via.placeholder.com/300.png/09f/fff"),"\ninto a URI-Component-Encoded string like\n",(0,s.yg)("inlineCode",{parentName:"p"},"/cors-proxy/https%3A%2F%2Fvia.placeholder.com%2F300.png%2F09f%2Ffff")))}iZ.isMDXComponent=!0;const lZ={toc:[]},uZ="wrapper";function mZ(e){let{components:n,...t}=e;return(0,s.yg)(uZ,(0,p.A)({},lZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Route the given url through a local proxy."))}mZ.isMDXComponent=!0;const yZ={toc:[]},dZ="wrapper";function hZ(e){let{components:n,...t}=e;return(0,s.yg)(dZ,(0,p.A)({},yZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the initial value of this signal."))}hZ.isMDXComponent=!0;const gZ={toc:[]},fZ="wrapper";function DZ(e){let{components:n,...t}=e;return(0,s.yg)(fZ,(0,p.A)({},gZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}DZ.isMDXComponent=!0;const MZ={toc:[]},XZ="wrapper";function _Z(e){let{components:n,...t}=e;return(0,s.yg)(XZ,(0,p.A)({},MZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the signal is currently using its initial value."))}_Z.isMDXComponent=!0;const wZ={toc:[]},TZ="wrapper";function CZ(e){let{components:n,...t}=e;return(0,s.yg)(TZ,(0,p.A)({},wZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is the signal undergoing a tween?"))}CZ.isMDXComponent=!0;const xZ={toc:[]},AZ="wrapper";function vZ(e){let{components:n,...t}=e;return(0,s.yg)(AZ,(0,p.A)({},xZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.yg)("p",null,"This method can be used to create copies of signals."))}vZ.isMDXComponent=!0;const LZ={toc:[]},bZ="wrapper";function NZ(e){let{components:n,...t}=e;return(0,s.yg)(bZ,(0,p.A)({},LZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}NZ.isMDXComponent=!0;const kZ={toc:[]},zZ="wrapper";function PZ(e){let{components:n,...t}=e;return(0,s.yg)(zZ,(0,p.A)({},kZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the raw value of this signal."))}PZ.isMDXComponent=!0;const IZ={toc:[]},RZ="wrapper";function WZ(e){let{components:n,...t}=e;return(0,s.yg)(RZ,(0,p.A)({},IZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}WZ.isMDXComponent=!0;const SZ={toc:[]},BZ="wrapper";function EZ(e){let{components:n,...t}=e;return(0,s.yg)(BZ,(0,p.A)({},SZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset the signal to its initial value (if one has been set)."))}EZ.isMDXComponent=!0;const GZ={toc:[]},OZ="wrapper";function UZ(e){let{components:n,...t}=e;return(0,s.yg)(OZ,(0,p.A)({},GZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}UZ.isMDXComponent=!0;const FZ={toc:[]},VZ="wrapper";function qZ(e){let{components:n,...t}=e;return(0,s.yg)(VZ,(0,p.A)({},FZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}qZ.isMDXComponent=!0;const jZ={toc:[]},HZ="wrapper";function YZ(e){let{components:n,...t}=e;return(0,s.yg)(HZ,(0,p.A)({},jZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Compute the current value of the signal and immediately set it."))}YZ.isMDXComponent=!0;const QZ={toc:[]},$Z="wrapper";function KZ(e){let{components:n,...t}=e;return(0,s.yg)($Z,(0,p.A)({},QZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes custom highlighters used by the Code node."))}KZ.isMDXComponent=!0;const JZ={toc:[]},ZZ="wrapper";function e0(e){let{components:n,...t}=e;return(0,s.yg)(ZZ,(0,p.A)({},JZ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Highlights the code at the given index."))}e0.isMDXComponent=!0;const n0={toc:[]},t0="wrapper";function o0(e){let{components:n,...t}=e;return(0,s.yg)(t0,(0,p.A)({},n0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the code to highlight."))}o0.isMDXComponent=!0;const p0={toc:[]},r0="wrapper";function s0(e){let{components:n,...t}=e;return(0,s.yg)(r0,(0,p.A)({},p0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The result of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/LezerHighlighter#prepare"},(0,s.yg)("inlineCode",{parentName:"a"},"prepare")),"."))}s0.isMDXComponent=!0;const c0={toc:[]},a0="wrapper";function i0(e){let{components:n,...t}=e;return(0,s.yg)(a0,(0,p.A)({},c0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called when collecting async resources for the node.\nIt can be called multiple times so caching the initialization is\nrecommended."),(0,s.yg)("p",null,"If initialization is asynchronous, a promise should be registered using\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/signals/DependencyContext#static-collectPromise"},(0,s.yg)("inlineCode",{parentName:"a"},"DependencyContext.collectPromise"))," and the value of ",(0,s.yg)("inlineCode",{parentName:"p"},"false")," should\nbe returned. The hook will be called again when the promise resolves.\nThis process can be repeated until the value of ",(0,s.yg)("inlineCode",{parentName:"p"},"true")," is returned which\nwill mark the highlighter as ready."))}i0.isMDXComponent=!0;const l0={toc:[]},u0="wrapper";function m0(e){let{components:n,...t}=e;return(0,s.yg)(u0,(0,p.A)({},l0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializes the highlighter."))}m0.isMDXComponent=!0;const y0={toc:[]},d0="wrapper";function h0(e){let{components:n,...t}=e;return(0,s.yg)(d0,(0,p.A)({},y0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called each time the code changes. It can be used to do\nany preprocessing of the code before highlighting. The result of this\nmethod is cached and passed to ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/LezerHighlighter#highlight"},(0,s.yg)("inlineCode",{parentName:"a"},"highlight"))," when the code is\nhighlighted."))}h0.isMDXComponent=!0;const g0={toc:[]},f0="wrapper";function D0(e){let{components:n,...t}=e;return(0,s.yg)(f0,(0,p.A)({},g0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepares the code for highlighting."))}D0.isMDXComponent=!0;const M0={toc:[]},X0="wrapper";function _0(e){let{components:n,...t}=e;return(0,s.yg)(X0,(0,p.A)({},M0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to prepare."))}_0.isMDXComponent=!0;const w0={toc:[]},T0="wrapper";function C0(e){let{components:n,...t}=e;return(0,s.yg)(T0,(0,p.A)({},w0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The language in which the code is written."))}C0.isMDXComponent=!0;const x0={toc:[]},A0="wrapper";function v0(e){let{components:n,...t}=e;return(0,s.yg)(A0,(0,p.A)({},x0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tokenize the code."))}v0.isMDXComponent=!0;const L0={toc:[]},b0="wrapper";function N0(e){let{components:n,...t}=e;return(0,s.yg)(b0,(0,p.A)({},L0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to tokenize."))}N0.isMDXComponent=!0;const k0={toc:[]},z0="wrapper";function P0(e){let{components:n,...t}=e;return(0,s.yg)(z0,(0,p.A)({},k0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The language in which the code is written."))}P0.isMDXComponent=!0;const I0={toc:[]},R0="wrapper";function W0(e){let{components:n,...t}=e;return(0,s.yg)(R0,(0,p.A)({},I0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes custom highlighters used by the Code node."))}W0.isMDXComponent=!0;const S0={toc:[]},B0="wrapper";function E0(e){let{components:n,...t}=e;return(0,s.yg)(B0,(0,p.A)({},S0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Highlights the code at the given index."))}E0.isMDXComponent=!0;const G0={toc:[]},O0="wrapper";function U0(e){let{components:n,...t}=e;return(0,s.yg)(O0,(0,p.A)({},G0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the code to highlight."))}U0.isMDXComponent=!0;const F0={toc:[]},V0="wrapper";function q0(e){let{components:n,...t}=e;return(0,s.yg)(V0,(0,p.A)({},F0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The result of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/CodeHighlighter#prepare"},(0,s.yg)("inlineCode",{parentName:"a"},"prepare")),"."))}q0.isMDXComponent=!0;const j0={toc:[]},H0="wrapper";function Y0(e){let{components:n,...t}=e;return(0,s.yg)(H0,(0,p.A)({},j0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called when collecting async resources for the node.\nIt can be called multiple times so caching the initialization is\nrecommended."),(0,s.yg)("p",null,"If initialization is asynchronous, a promise should be registered using\n",(0,s.yg)("a",{parentName:"p",href:"/api/core/signals/DependencyContext#static-collectPromise"},(0,s.yg)("inlineCode",{parentName:"a"},"DependencyContext.collectPromise"))," and the value of ",(0,s.yg)("inlineCode",{parentName:"p"},"false")," should\nbe returned. The hook will be called again when the promise resolves.\nThis process can be repeated until the value of ",(0,s.yg)("inlineCode",{parentName:"p"},"true")," is returned which\nwill mark the highlighter as ready."))}Y0.isMDXComponent=!0;const Q0={toc:[]},$0="wrapper";function K0(e){let{components:n,...t}=e;return(0,s.yg)($0,(0,p.A)({},Q0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializes the highlighter."))}K0.isMDXComponent=!0;const J0={toc:[]},Z0="wrapper";function e3(e){let{components:n,...t}=e;return(0,s.yg)(Z0,(0,p.A)({},J0,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called each time the code changes. It can be used to do\nany preprocessing of the code before highlighting. The result of this\nmethod is cached and passed to ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/CodeHighlighter#highlight"},(0,s.yg)("inlineCode",{parentName:"a"},"highlight"))," when the code is\nhighlighted."))}e3.isMDXComponent=!0;const n3={toc:[]},t3="wrapper";function o3(e){let{components:n,...t}=e;return(0,s.yg)(t3,(0,p.A)({},n3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepares the code for highlighting."))}o3.isMDXComponent=!0;const p3={toc:[]},r3="wrapper";function s3(e){let{components:n,...t}=e;return(0,s.yg)(r3,(0,p.A)({},p3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to prepare."))}s3.isMDXComponent=!0;const c3={toc:[]},a3="wrapper";function i3(e){let{components:n,...t}=e;return(0,s.yg)(a3,(0,p.A)({},c3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The language in which the code is written."))}i3.isMDXComponent=!0;const l3={toc:[]},u3="wrapper";function m3(e){let{components:n,...t}=e;return(0,s.yg)(u3,(0,p.A)({},l3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tokenize the code."))}m3.isMDXComponent=!0;const y3={toc:[]},d3="wrapper";function h3(e){let{components:n,...t}=e;return(0,s.yg)(d3,(0,p.A)({},y3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to tokenize."))}h3.isMDXComponent=!0;const g3={toc:[]},f3="wrapper";function D3(e){let{components:n,...t}=e;return(0,s.yg)(f3,(0,p.A)({},g3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The language in which the code is written."))}D3.isMDXComponent=!0;const M3={toc:[]},X3="wrapper";function _3(e){let{components:n,...t}=e;return(0,s.yg)(X3,(0,p.A)({},M3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The type of the cache used by the highlighter."))}_3.isMDXComponent=!0;const w3={toc:[]},T3="wrapper";function C3(e){let{components:n,...t}=e;return(0,s.yg)(T3,(0,p.A)({},w3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes the result of a highlight operation."))}C3.isMDXComponent=!0;const x3={toc:[]},A3="wrapper";function v3(e){let{components:n,...t}=e;return(0,s.yg)(A3,(0,p.A)({},x3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The color of the code at the given index."))}v3.isMDXComponent=!0;const L3={toc:[]},b3="wrapper";function N3(e){let{components:n,...t}=e;return(0,s.yg)(b3,(0,p.A)({},L3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This should be used to skip to the end of the currently highlighted token.\nThe returned style will be used for the skipped characters, and they will\nbe drawn as one continuous string keeping emojis and ligatures intact."),(0,s.yg)("p",null,"The returned value is the number of characters to skip ahead, not the\nindex of the end of the token."))}N3.isMDXComponent=!0;const k3={toc:[]},z3="wrapper";function P3(e){let{components:n,...t}=e;return(0,s.yg)(z3,(0,p.A)({},k3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The number of characters to skip ahead."))}P3.isMDXComponent=!0;const I3={toc:[]},R3="wrapper";function W3(e){let{components:n,...t}=e;return(0,s.yg)(R3,(0,p.A)({},I3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that compares two code snippets and returns a list of\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#CodeTag"},(0,s.yg)("inlineCode",{parentName:"a"},"CodeTag")),"s describing a transition between them."))}W3.isMDXComponent=!0;const S3={toc:[]},B3="wrapper";function E3(e){let{components:n,...t}=e;return(0,s.yg)(B3,(0,p.A)({},S3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Default diffing function utilizing ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#patienceDiff"},(0,s.yg)("inlineCode",{parentName:"a"},"patienceDiff")),"."))}E3.isMDXComponent=!0;const G3={toc:[]},O3="wrapper";function U3(e){let{components:n,...t}=e;return(0,s.yg)(O3,(0,p.A)({},G3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The original code scope."))}U3.isMDXComponent=!0;const F3={toc:[]},V3="wrapper";function q3(e){let{components:n,...t}=e;return(0,s.yg)(V3,(0,p.A)({},F3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new code scope."))}q3.isMDXComponent=!0;const j3={toc:[]},H3="wrapper";function Y3(e){let{components:n,...t}=e;return(0,s.yg)(H3,(0,p.A)({},j3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The inherited tokenizer to use."))}Y3.isMDXComponent=!0;const Q3={toc:[]},$3="wrapper";function K3(e){let{components:n,...t}=e;return(0,s.yg)($3,(0,p.A)({},Q3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Default tokenizer function used by ownerless code signals."))}K3.isMDXComponent=!0;const J3={toc:[]},Z3="wrapper";function e1(e){let{components:n,...t}=e;return(0,s.yg)(Z3,(0,p.A)({},J3,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to tokenize."))}e1.isMDXComponent=!0;const n1={toc:[]},t1="wrapper";function o1(e){let{components:n,...t}=e;return(0,s.yg)(t1,(0,p.A)({},n1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This function will try to preserve the original fragments, resolving them\nonly if they overlap with the range."))}o1.isMDXComponent=!0;const p1={toc:[]},r1="wrapper";function s1(e){let{components:n,...t}=e;return(0,s.yg)(r1,(0,p.A)({},p1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A tuple containing the transformed fragments and the index of the\nisolated fragment within."))}s1.isMDXComponent=!0;const c1={toc:[]},a1="wrapper";function i1(e){let{components:n,...t}=e;return(0,s.yg)(a1,(0,p.A)({},c1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Transform the fragments to isolate the given range into its own fragment."))}i1.isMDXComponent=!0;const l1={toc:[]},u1="wrapper";function m1(e){let{components:n,...t}=e;return(0,s.yg)(u1,(0,p.A)({},l1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The range to extract."))}m1.isMDXComponent=!0;const y1={toc:[]},d1="wrapper";function h1(e){let{components:n,...t}=e;return(0,s.yg)(d1,(0,p.A)({},y1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The fragments to transform."))}h1.isMDXComponent=!0;const g1={toc:[]},f1="wrapper";function D1(e){let{components:n,...t}=e;return(0,s.yg)(f1,(0,p.A)({},g1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all code ranges that match the given pattern."))}D1.isMDXComponent=!0;const M1={toc:[]},X1="wrapper";function _1(e){let{components:n,...t}=e;return(0,s.yg)(X1,(0,p.A)({},M1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to search in."))}_1.isMDXComponent=!0;const w1={toc:[]},T1="wrapper";function C1(e){let{components:n,...t}=e;return(0,s.yg)(T1,(0,p.A)({},w1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Either a string or a regular expression to search for."))}C1.isMDXComponent=!0;const x1={toc:[]},A1="wrapper";function v1(e){let{components:n,...t}=e;return(0,s.yg)(A1,(0,p.A)({},x1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An optional limit on the number of ranges to find."))}v1.isMDXComponent=!0;const L1={toc:[]},b1="wrapper";function N1(e){let{components:n,...t}=e;return(0,s.yg)(b1,(0,p.A)({},L1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Can be used in conjunction with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/CodeSignalHelpers#edit"},(0,s.yg)("inlineCode",{parentName:"a"},"edit")),"."))}N1.isMDXComponent=!0;const k1={toc:[]},z1="wrapper";function P1(e){let{components:n,...t}=e;return(0,s.yg)(z1,(0,p.A)({},k1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a code fragment that represents an insertion of code."))}P1.isMDXComponent=!0;const I1={toc:[]},R1="wrapper";function W1(e){let{components:n,...t}=e;return(0,s.yg)(R1,(0,p.A)({},I1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to insert."))}W1.isMDXComponent=!0;const S1={toc:[]},B1="wrapper";function E1(e){let{components:n,...t}=e;return(0,s.yg)(B1,(0,p.A)({},S1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a code range that spans the given lines."))}E1.isMDXComponent=!0;const G1={toc:[]},O1="wrapper";function U1(e){let{components:n,...t}=e;return(0,s.yg)(O1,(0,p.A)({},G1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The line from which the range starts."))}U1.isMDXComponent=!0;const F1={toc:[]},V1="wrapper";function q1(e){let{components:n,...t}=e;return(0,s.yg)(V1,(0,p.A)({},F1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The line at which the range ends. If omitted, the range will\ncover only one line."))}q1.isMDXComponent=!0;const j1={toc:[]},H1="wrapper";function Y1(e){let{components:n,...t}=e;return(0,s.yg)(H1,(0,p.A)({},j1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Performs a patience diff on two arrays of strings, returning an object\ncontaining the lines that were deleted, inserted, and potentially moved\nlines. The plus parameter can result in a significant performance hit due\nto additional Longest Common Substring searches."))}Y1.isMDXComponent=!0;const Q1={toc:[]},$1="wrapper";function K1(e){let{components:n,...t}=e;return(0,s.yg)($1,(0,p.A)({},Q1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The original array of strings"))}K1.isMDXComponent=!0;const J1={toc:[]},Z1="wrapper";function e9(e){let{components:n,...t}=e;return(0,s.yg)(Z1,(0,p.A)({},J1,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new array of strings"))}e9.isMDXComponent=!0;const n9={toc:[]},t9="wrapper";function o9(e){let{components:n,...t}=e;return(0,s.yg)(t9,(0,p.A)({},n9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a custom selection range."))}o9.isMDXComponent=!0;const p9={toc:[]},r9="wrapper";function s9(e){let{components:n,...t}=e;return(0,s.yg)(r9,(0,p.A)({},p9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The line at which the selection starts."))}s9.isMDXComponent=!0;const c9={toc:[]},a9="wrapper";function i9(e){let{components:n,...t}=e;return(0,s.yg)(a9,(0,p.A)({},c9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The column at which the selection starts."))}i9.isMDXComponent=!0;const l9={toc:[]},u9="wrapper";function m9(e){let{components:n,...t}=e;return(0,s.yg)(u9,(0,p.A)({},l9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The line at which the selection ends."))}m9.isMDXComponent=!0;const y9={toc:[]},d9="wrapper";function h9(e){let{components:n,...t}=e;return(0,s.yg)(d9,(0,p.A)({},y9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The column at which the selection ends."))}h9.isMDXComponent=!0;const g9={toc:[]},f9="wrapper";function D9(e){let{components:n,...t}=e;return(0,s.yg)(f9,(0,p.A)({},g9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Can be used in conjunction with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/CodeSignalHelpers#edit"},(0,s.yg)("inlineCode",{parentName:"a"},"edit")),"."))}D9.isMDXComponent=!0;const M9={toc:[]},X9="wrapper";function _9(e){let{components:n,...t}=e;return(0,s.yg)(X9,(0,p.A)({},M9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a code fragment that represents a removal of code."))}_9.isMDXComponent=!0;const w9={toc:[]},T9="wrapper";function C9(e){let{components:n,...t}=e;return(0,s.yg)(T9,(0,p.A)({},w9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to remove."))}C9.isMDXComponent=!0;const x9={toc:[]},A9="wrapper";function v9(e){let{components:n,...t}=e;return(0,s.yg)(A9,(0,p.A)({},x9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Can be used in conjunction with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/CodeSignalHelpers#edit"},(0,s.yg)("inlineCode",{parentName:"a"},"edit")),"."))}v9.isMDXComponent=!0;const L9={toc:[]},b9="wrapper";function N9(e){let{components:n,...t}=e;return(0,s.yg)(b9,(0,p.A)({},L9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a code fragment that represents a change from one piece of code to\nanother."))}N9.isMDXComponent=!0;const k9={toc:[]},z9="wrapper";function P9(e){let{components:n,...t}=e;return(0,s.yg)(z9,(0,p.A)({},k9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to change from."))}P9.isMDXComponent=!0;const I9={toc:[]},R9="wrapper";function W9(e){let{components:n,...t}=e;return(0,s.yg)(R9,(0,p.A)({},I9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to change to."))}W9.isMDXComponent=!0;const S9={toc:[]},B9="wrapper";function E9(e){let{components:n,...t}=e;return(0,s.yg)(B9,(0,p.A)({},S9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a code range that highlights the given word."))}E9.isMDXComponent=!0;const G9={toc:[]},O9="wrapper";function U9(e){let{components:n,...t}=e;return(0,s.yg)(O9,(0,p.A)({},G9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The line at which the word appears."))}U9.isMDXComponent=!0;const F9={toc:[]},V9="wrapper";function q9(e){let{components:n,...t}=e;return(0,s.yg)(V9,(0,p.A)({},F9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The column at which the word starts."))}q9.isMDXComponent=!0;const j9={toc:[]},H9="wrapper";function Y9(e){let{components:n,...t}=e;return(0,s.yg)(H9,(0,p.A)({},j9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The length of the word. If omitted, the range will cover the\nrest of the line."))}Y9.isMDXComponent=!0;const Q9={toc:[]},$9="wrapper";function K9(e){let{components:n,...t}=e;return(0,s.yg)($9,(0,p.A)({},Q9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}K9.isMDXComponent=!0;const J9={toc:[]},Z9="wrapper";function e2(e){let{components:n,...t}=e;return(0,s.yg)(Z9,(0,p.A)({},J9,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}e2.isMDXComponent=!0;const n2={toc:[]},t2="wrapper";function o2(e){let{components:n,...t}=e;return(0,s.yg)(t2,(0,p.A)({},n2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}o2.isMDXComponent=!0;const p2={toc:[]},r2="wrapper";function s2(e){let{components:n,...t}=e;return(0,s.yg)(r2,(0,p.A)({},p2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}s2.isMDXComponent=!0;const c2={toc:[]},a2="wrapper";function i2(e){let{components:n,...t}=e;return(0,s.yg)(a2,(0,p.A)({},c2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}i2.isMDXComponent=!0;const l2={toc:[]},u2="wrapper";function m2(e){let{components:n,...t}=e;return(0,s.yg)(u2,(0,p.A)({},l2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}m2.isMDXComponent=!0;const y2={toc:[]},d2="wrapper";function h2(e){let{components:n,...t}=e;return(0,s.yg)(d2,(0,p.A)({},y2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}h2.isMDXComponent=!0;const g2={toc:[]},f2="wrapper";function D2(e){let{components:n,...t}=e;return(0,s.yg)(f2,(0,p.A)({},g2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}D2.isMDXComponent=!0;const M2={toc:[]},X2="wrapper";function _2(e){let{components:n,...t}=e;return(0,s.yg)(X2,(0,p.A)({},M2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}_2.isMDXComponent=!0;const w2={toc:[]},T2="wrapper";function C2(e){let{components:n,...t}=e;return(0,s.yg)(T2,(0,p.A)({},w2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}C2.isMDXComponent=!0;const x2={toc:[]},A2="wrapper";function v2(e){let{components:n,...t}=e;return(0,s.yg)(A2,(0,p.A)({},x2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}v2.isMDXComponent=!0;const L2={toc:[]},b2="wrapper";function N2(e){let{components:n,...t}=e;return(0,s.yg)(b2,(0,p.A)({},L2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}N2.isMDXComponent=!0;const k2={toc:[]},z2="wrapper";function P2(e){let{components:n,...t}=e;return(0,s.yg)(z2,(0,p.A)({},k2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}P2.isMDXComponent=!0;const I2={toc:[]},R2="wrapper";function W2(e){let{components:n,...t}=e;return(0,s.yg)(R2,(0,p.A)({},I2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}W2.isMDXComponent=!0;const S2={toc:[]},B2="wrapper";function E2(e){let{components:n,...t}=e;return(0,s.yg)(B2,(0,p.A)({},S2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}E2.isMDXComponent=!0;const G2={toc:[]},O2="wrapper";function U2(e){let{components:n,...t}=e;return(0,s.yg)(O2,(0,p.A)({},G2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}U2.isMDXComponent=!0;const F2={toc:[]},V2="wrapper";function q2(e){let{components:n,...t}=e;return(0,s.yg)(V2,(0,p.A)({},F2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}q2.isMDXComponent=!0;const j2={toc:[]},H2="wrapper";function Y2(e){let{components:n,...t}=e;return(0,s.yg)(H2,(0,p.A)({},j2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}Y2.isMDXComponent=!0;const Q2={toc:[]},$2="wrapper";function K2(e){let{components:n,...t}=e;return(0,s.yg)($2,(0,p.A)({},Q2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}K2.isMDXComponent=!0;const J2={toc:[]},Z2="wrapper";function e4(e){let{components:n,...t}=e;return(0,s.yg)(Z2,(0,p.A)({},J2,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}e4.isMDXComponent=!0;const n4={toc:[]},t4="wrapper";function o4(e){let{components:n,...t}=e;return(0,s.yg)(t4,(0,p.A)({},n4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}o4.isMDXComponent=!0;const p4={toc:[]},r4="wrapper";function s4(e){let{components:n,...t}=e;return(0,s.yg)(r4,(0,p.A)({},p4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}s4.isMDXComponent=!0;const c4={toc:[]},a4="wrapper";function i4(e){let{components:n,...t}=e;return(0,s.yg)(a4,(0,p.A)({},c4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}i4.isMDXComponent=!0;const l4={toc:[]},u4="wrapper";function m4(e){let{components:n,...t}=e;return(0,s.yg)(u4,(0,p.A)({},l4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}m4.isMDXComponent=!0;const y4={toc:[]},d4="wrapper";function h4(e){let{components:n,...t}=e;return(0,s.yg)(d4,(0,p.A)({},y4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}h4.isMDXComponent=!0;const g4={toc:[]},f4="wrapper";function D4(e){let{components:n,...t}=e;return(0,s.yg)(f4,(0,p.A)({},g4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}D4.isMDXComponent=!0;const M4={toc:[]},X4="wrapper";function _4(e){let{components:n,...t}=e;return(0,s.yg)(X4,(0,p.A)({},M4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}_4.isMDXComponent=!0;const w4={toc:[]},T4="wrapper";function C4(e){let{components:n,...t}=e;return(0,s.yg)(T4,(0,p.A)({},w4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}C4.isMDXComponent=!0;const x4={toc:[]},A4="wrapper";function v4(e){let{components:n,...t}=e;return(0,s.yg)(A4,(0,p.A)({},x4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}v4.isMDXComponent=!0;const L4={toc:[]},b4="wrapper";function N4(e){let{components:n,...t}=e;return(0,s.yg)(b4,(0,p.A)({},L4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}N4.isMDXComponent=!0;const k4={toc:[]},z4="wrapper";function P4(e){let{components:n,...t}=e;return(0,s.yg)(z4,(0,p.A)({},k4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}P4.isMDXComponent=!0;const I4={toc:[]},R4="wrapper";function W4(e){let{components:n,...t}=e;return(0,s.yg)(R4,(0,p.A)({},I4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}W4.isMDXComponent=!0;const S4={toc:[]},B4="wrapper";function E4(e){let{components:n,...t}=e;return(0,s.yg)(B4,(0,p.A)({},S4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}E4.isMDXComponent=!0;const G4={toc:[]},O4="wrapper";function U4(e){let{components:n,...t}=e;return(0,s.yg)(O4,(0,p.A)({},G4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}U4.isMDXComponent=!0;const F4={toc:[]},V4="wrapper";function q4(e){let{components:n,...t}=e;return(0,s.yg)(V4,(0,p.A)({},F4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}q4.isMDXComponent=!0;const j4={toc:[]},H4="wrapper";function Y4(e){let{components:n,...t}=e;return(0,s.yg)(H4,(0,p.A)({},j4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Y4.isMDXComponent=!0;const Q4={toc:[]},$4="wrapper";function K4(e){let{components:n,...t}=e;return(0,s.yg)($4,(0,p.A)({},Q4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}K4.isMDXComponent=!0;const J4={toc:[]},Z4="wrapper";function e6(e){let{components:n,...t}=e;return(0,s.yg)(Z4,(0,p.A)({},J4,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}e6.isMDXComponent=!0;const n6={toc:[]},t6="wrapper";function o6(e){let{components:n,...t}=e;return(0,s.yg)(t6,(0,p.A)({},n6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"One uniform radius:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}o6.isMDXComponent=!0;const p6={toc:[]},r6="wrapper";function s6(e){let{components:n,...t}=e;return(0,s.yg)(r6,(0,p.A)({},p6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Individual radii for each corner:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}s6.isMDXComponent=!0;const c6={toc:[]},a6="wrapper";function i6(e){let{components:n,...t}=e;return(0,s.yg)(a6,(0,p.A)({},c6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}i6.isMDXComponent=!0;const l6={toc:[]},u6="wrapper";function m6(e){let{components:n,...t}=e;return(0,s.yg)(u6,(0,p.A)({},l6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}m6.isMDXComponent=!0;const y6={toc:[]},d6="wrapper";function h6(e){let{components:n,...t}=e;return(0,s.yg)(d6,(0,p.A)({},y6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}h6.isMDXComponent=!0;const g6={toc:[]},f6="wrapper";function D6(e){let{components:n,...t}=e;return(0,s.yg)(f6,(0,p.A)({},g6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}D6.isMDXComponent=!0;const M6={toc:[]},X6="wrapper";function _6(e){let{components:n,...t}=e;return(0,s.yg)(X6,(0,p.A)({},M6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}_6.isMDXComponent=!0;const w6={toc:[]},T6="wrapper";function C6(e){let{components:n,...t}=e;return(0,s.yg)(T6,(0,p.A)({},w6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}C6.isMDXComponent=!0;const x6={toc:[]},A6="wrapper";function v6(e){let{components:n,...t}=e;return(0,s.yg)(A6,(0,p.A)({},x6,t,{components:n,mdxType:"MDXLayout"}))}v6.isMDXComponent=!0;const L6={toc:[]},b6="wrapper";function N6(e){let{components:n,...t}=e;return(0,s.yg)(b6,(0,p.A)({},L6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}N6.isMDXComponent=!0;const k6={toc:[]},z6="wrapper";function P6(e){let{components:n,...t}=e;return(0,s.yg)(z6,(0,p.A)({},k6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}P6.isMDXComponent=!0;const I6={toc:[]},R6="wrapper";function W6(e){let{components:n,...t}=e;return(0,s.yg)(R6,(0,p.A)({},I6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}W6.isMDXComponent=!0;const S6={toc:[]},B6="wrapper";function E6(e){let{components:n,...t}=e;return(0,s.yg)(B6,(0,p.A)({},S6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}E6.isMDXComponent=!0;const G6={toc:[]},O6="wrapper";function U6(e){let{components:n,...t}=e;return(0,s.yg)(O6,(0,p.A)({},G6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}U6.isMDXComponent=!0;const F6={toc:[]},V6="wrapper";function q6(e){let{components:n,...t}=e;return(0,s.yg)(V6,(0,p.A)({},F6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}q6.isMDXComponent=!0;const j6={toc:[]},H6="wrapper";function Y6(e){let{components:n,...t}=e;return(0,s.yg)(H6,(0,p.A)({},j6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}Y6.isMDXComponent=!0;const Q6={toc:[]},$6="wrapper";function K6(e){let{components:n,...t}=e;return(0,s.yg)($6,(0,p.A)({},Q6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}K6.isMDXComponent=!0;const J6={toc:[]},Z6="wrapper";function e8(e){let{components:n,...t}=e;return(0,s.yg)(Z6,(0,p.A)({},J6,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}e8.isMDXComponent=!0;const n8={toc:[]},t8="wrapper";function o8(e){let{components:n,...t}=e;return(0,s.yg)(t8,(0,p.A)({},n8,t,{components:n,mdxType:"MDXLayout"}))}o8.isMDXComponent=!0;const p8={toc:[]},r8="wrapper";function s8(e){let{components:n,...t}=e;return(0,s.yg)(r8,(0,p.A)({},p8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}s8.isMDXComponent=!0;const c8={toc:[]},a8="wrapper";function i8(e){let{components:n,...t}=e;return(0,s.yg)(a8,(0,p.A)({},c8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}i8.isMDXComponent=!0;const l8={toc:[]},u8="wrapper";function m8(e){let{components:n,...t}=e;return(0,s.yg)(u8,(0,p.A)({},l8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}m8.isMDXComponent=!0;const y8={toc:[]},d8="wrapper";function h8(e){let{components:n,...t}=e;return(0,s.yg)(d8,(0,p.A)({},y8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}h8.isMDXComponent=!0;const g8={toc:[]},f8="wrapper";function D8(e){let{components:n,...t}=e;return(0,s.yg)(f8,(0,p.A)({},g8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}D8.isMDXComponent=!0;const M8={toc:[]},X8="wrapper";function _8(e){let{components:n,...t}=e;return(0,s.yg)(X8,(0,p.A)({},M8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}_8.isMDXComponent=!0;const w8={toc:[]},T8="wrapper";function C8(e){let{components:n,...t}=e;return(0,s.yg)(T8,(0,p.A)({},w8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}C8.isMDXComponent=!0;const x8={toc:[]},A8="wrapper";function v8(e){let{components:n,...t}=e;return(0,s.yg)(A8,(0,p.A)({},x8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}v8.isMDXComponent=!0;const L8={toc:[]},b8="wrapper";function N8(e){let{components:n,...t}=e;return(0,s.yg)(b8,(0,p.A)({},L8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}N8.isMDXComponent=!0;const k8={toc:[]},z8="wrapper";function P8(e){let{components:n,...t}=e;return(0,s.yg)(z8,(0,p.A)({},k8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}P8.isMDXComponent=!0;const I8={toc:[]},R8="wrapper";function W8(e){let{components:n,...t}=e;return(0,s.yg)(R8,(0,p.A)({},I8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}W8.isMDXComponent=!0;const S8={toc:[]},B8="wrapper";function E8(e){let{components:n,...t}=e;return(0,s.yg)(B8,(0,p.A)({},S8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}E8.isMDXComponent=!0;const G8={toc:[]},O8="wrapper";function U8(e){let{components:n,...t}=e;return(0,s.yg)(O8,(0,p.A)({},G8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}U8.isMDXComponent=!0;const F8={toc:[]},V8="wrapper";function q8(e){let{components:n,...t}=e;return(0,s.yg)(V8,(0,p.A)({},F8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}q8.isMDXComponent=!0;const j8={toc:[]},H8="wrapper";function Y8(e){let{components:n,...t}=e;return(0,s.yg)(H8,(0,p.A)({},j8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}Y8.isMDXComponent=!0;const Q8={toc:[]},$8="wrapper";function K8(e){let{components:n,...t}=e;return(0,s.yg)($8,(0,p.A)({},Q8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}K8.isMDXComponent=!0;const J8={toc:[]},Z8="wrapper";function e5(e){let{components:n,...t}=e;return(0,s.yg)(Z8,(0,p.A)({},J8,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}e5.isMDXComponent=!0;const n5={toc:[]},t5="wrapper";function o5(e){let{components:n,...t}=e;return(0,s.yg)(t5,(0,p.A)({},n5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}o5.isMDXComponent=!0;const p5={toc:[]},r5="wrapper";function s5(e){let{components:n,...t}=e;return(0,s.yg)(r5,(0,p.A)({},p5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}s5.isMDXComponent=!0;const c5={toc:[]},a5="wrapper";function i5(e){let{components:n,...t}=e;return(0,s.yg)(a5,(0,p.A)({},c5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}i5.isMDXComponent=!0;const l5={toc:[]},u5="wrapper";function m5(e){let{components:n,...t}=e;return(0,s.yg)(u5,(0,p.A)({},l5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}m5.isMDXComponent=!0;const y5={toc:[]},d5="wrapper";function h5(e){let{components:n,...t}=e;return(0,s.yg)(d5,(0,p.A)({},y5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}h5.isMDXComponent=!0;const g5={toc:[]},f5="wrapper";function D5(e){let{components:n,...t}=e;return(0,s.yg)(f5,(0,p.A)({},g5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}D5.isMDXComponent=!0;const M5={toc:[]},X5="wrapper";function _5(e){let{components:n,...t}=e;return(0,s.yg)(X5,(0,p.A)({},M5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}_5.isMDXComponent=!0;const w5={toc:[]},T5="wrapper";function C5(e){let{components:n,...t}=e;return(0,s.yg)(T5,(0,p.A)({},w5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}C5.isMDXComponent=!0;const x5={toc:[]},A5="wrapper";function v5(e){let{components:n,...t}=e;return(0,s.yg)(A5,(0,p.A)({},x5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}v5.isMDXComponent=!0;const L5={toc:[]},b5="wrapper";function N5(e){let{components:n,...t}=e;return(0,s.yg)(b5,(0,p.A)({},L5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}N5.isMDXComponent=!0;const k5={toc:[]},z5="wrapper";function P5(e){let{components:n,...t}=e;return(0,s.yg)(z5,(0,p.A)({},k5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}P5.isMDXComponent=!0;const I5={toc:[]},R5="wrapper";function W5(e){let{components:n,...t}=e;return(0,s.yg)(R5,(0,p.A)({},I5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}W5.isMDXComponent=!0;const S5={toc:[]},B5="wrapper";function E5(e){let{components:n,...t}=e;return(0,s.yg)(B5,(0,p.A)({},S5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}E5.isMDXComponent=!0;const G5={toc:[]},O5="wrapper";function U5(e){let{components:n,...t}=e;return(0,s.yg)(O5,(0,p.A)({},G5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}U5.isMDXComponent=!0;const F5={toc:[]},V5="wrapper";function q5(e){let{components:n,...t}=e;return(0,s.yg)(V5,(0,p.A)({},F5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}q5.isMDXComponent=!0;const j5={toc:[]},H5="wrapper";function Y5(e){let{components:n,...t}=e;return(0,s.yg)(H5,(0,p.A)({},j5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Y5.isMDXComponent=!0;const Q5={toc:[]},$5="wrapper";function K5(e){let{components:n,...t}=e;return(0,s.yg)($5,(0,p.A)({},Q5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}K5.isMDXComponent=!0;const J5={toc:[]},Z5="wrapper";function e7(e){let{components:n,...t}=e;return(0,s.yg)(Z5,(0,p.A)({},J5,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}e7.isMDXComponent=!0;const n7={toc:[]},t7="wrapper";function o7(e){let{components:n,...t}=e;return(0,s.yg)(t7,(0,p.A)({},n7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}o7.isMDXComponent=!0;const p7={toc:[]},r7="wrapper";function s7(e){let{components:n,...t}=e;return(0,s.yg)(r7,(0,p.A)({},p7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}s7.isMDXComponent=!0;const c7={toc:[]},a7="wrapper";function i7(e){let{components:n,...t}=e;return(0,s.yg)(a7,(0,p.A)({},c7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}i7.isMDXComponent=!0;const l7={toc:[]},u7="wrapper";function m7(e){let{components:n,...t}=e;return(0,s.yg)(u7,(0,p.A)({},l7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}m7.isMDXComponent=!0;const y7={toc:[]},d7="wrapper";function h7(e){let{components:n,...t}=e;return(0,s.yg)(d7,(0,p.A)({},y7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}h7.isMDXComponent=!0;const g7={toc:[]},f7="wrapper";function D7(e){let{components:n,...t}=e;return(0,s.yg)(f7,(0,p.A)({},g7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}D7.isMDXComponent=!0;const M7={toc:[]},X7="wrapper";function _7(e){let{components:n,...t}=e;return(0,s.yg)(X7,(0,p.A)({},M7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}_7.isMDXComponent=!0;const w7={toc:[]},T7="wrapper";function C7(e){let{components:n,...t}=e;return(0,s.yg)(T7,(0,p.A)({},w7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}C7.isMDXComponent=!0;const x7={toc:[]},A7="wrapper";function v7(e){let{components:n,...t}=e;return(0,s.yg)(A7,(0,p.A)({},x7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}v7.isMDXComponent=!0;const L7={toc:[]},b7="wrapper";function N7(e){let{components:n,...t}=e;return(0,s.yg)(b7,(0,p.A)({},L7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}N7.isMDXComponent=!0;const k7={toc:[]},z7="wrapper";function P7(e){let{components:n,...t}=e;return(0,s.yg)(z7,(0,p.A)({},k7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}P7.isMDXComponent=!0;const I7={toc:[]},R7="wrapper";function W7(e){let{components:n,...t}=e;return(0,s.yg)(R7,(0,p.A)({},I7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}W7.isMDXComponent=!0;const S7={toc:[]},B7="wrapper";function E7(e){let{components:n,...t}=e;return(0,s.yg)(B7,(0,p.A)({},S7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}E7.isMDXComponent=!0;const G7={toc:[]},O7="wrapper";function U7(e){let{components:n,...t}=e;return(0,s.yg)(O7,(0,p.A)({},G7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}U7.isMDXComponent=!0;const F7={toc:[]},V7="wrapper";function q7(e){let{components:n,...t}=e;return(0,s.yg)(V7,(0,p.A)({},F7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}q7.isMDXComponent=!0;const j7={toc:[]},H7="wrapper";function Y7(e){let{components:n,...t}=e;return(0,s.yg)(H7,(0,p.A)({},j7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Y7.isMDXComponent=!0;const Q7={toc:[]},$7="wrapper";function K7(e){let{components:n,...t}=e;return(0,s.yg)($7,(0,p.A)({},Q7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}K7.isMDXComponent=!0;const J7={toc:[]},Z7="wrapper";function eee(e){let{components:n,...t}=e;return(0,s.yg)(Z7,(0,p.A)({},J7,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}eee.isMDXComponent=!0;const nee={toc:[]},tee="wrapper";function oee(e){let{components:n,...t}=e;return(0,s.yg)(tee,(0,p.A)({},nee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}oee.isMDXComponent=!0;const pee={toc:[]},ree="wrapper";function see(e){let{components:n,...t}=e;return(0,s.yg)(ree,(0,p.A)({},pee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}see.isMDXComponent=!0;const cee={toc:[]},aee="wrapper";function iee(e){let{components:n,...t}=e;return(0,s.yg)(aee,(0,p.A)({},cee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}iee.isMDXComponent=!0;const lee={toc:[]},uee="wrapper";function mee(e){let{components:n,...t}=e;return(0,s.yg)(uee,(0,p.A)({},lee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}mee.isMDXComponent=!0;const yee={toc:[]},dee="wrapper";function hee(e){let{components:n,...t}=e;return(0,s.yg)(dee,(0,p.A)({},yee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}hee.isMDXComponent=!0;const gee={toc:[]},fee="wrapper";function Dee(e){let{components:n,...t}=e;return(0,s.yg)(fee,(0,p.A)({},gee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Dee.isMDXComponent=!0;const Mee={toc:[]},Xee="wrapper";function _ee(e){let{components:n,...t}=e;return(0,s.yg)(Xee,(0,p.A)({},Mee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}_ee.isMDXComponent=!0;const wee={toc:[]},Tee="wrapper";function Cee(e){let{components:n,...t}=e;return(0,s.yg)(Tee,(0,p.A)({},wee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}Cee.isMDXComponent=!0;const xee={toc:[]},Aee="wrapper";function vee(e){let{components:n,...t}=e;return(0,s.yg)(Aee,(0,p.A)({},xee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}vee.isMDXComponent=!0;const Lee={toc:[]},bee="wrapper";function Nee(e){let{components:n,...t}=e;return(0,s.yg)(bee,(0,p.A)({},Lee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}Nee.isMDXComponent=!0;const kee={toc:[]},zee="wrapper";function Pee(e){let{components:n,...t}=e;return(0,s.yg)(zee,(0,p.A)({},kee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}Pee.isMDXComponent=!0;const Iee={toc:[]},Ree="wrapper";function Wee(e){let{components:n,...t}=e;return(0,s.yg)(Ree,(0,p.A)({},Iee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Wee.isMDXComponent=!0;const See={toc:[]},Bee="wrapper";function Eee(e){let{components:n,...t}=e;return(0,s.yg)(Bee,(0,p.A)({},See,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}Eee.isMDXComponent=!0;const Gee={toc:[]},Oee="wrapper";function Uee(e){let{components:n,...t}=e;return(0,s.yg)(Oee,(0,p.A)({},Gee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Uee.isMDXComponent=!0;const Fee={toc:[]},Vee="wrapper";function qee(e){let{components:n,...t}=e;return(0,s.yg)(Vee,(0,p.A)({},Fee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}qee.isMDXComponent=!0;const jee={toc:[]},Hee="wrapper";function Yee(e){let{components:n,...t}=e;return(0,s.yg)(Hee,(0,p.A)({},jee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}Yee.isMDXComponent=!0;const Qee={toc:[]},$ee="wrapper";function Kee(e){let{components:n,...t}=e;return(0,s.yg)($ee,(0,p.A)({},Qee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Kee.isMDXComponent=!0;const Jee={toc:[]},Zee="wrapper";function ene(e){let{components:n,...t}=e;return(0,s.yg)(Zee,(0,p.A)({},Jee,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}ene.isMDXComponent=!0;const nne={toc:[]},tne="wrapper";function one(e){let{components:n,...t}=e;return(0,s.yg)(tne,(0,p.A)({},nne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}one.isMDXComponent=!0;const pne={toc:[]},rne="wrapper";function sne(e){let{components:n,...t}=e;return(0,s.yg)(rne,(0,p.A)({},pne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}sne.isMDXComponent=!0;const cne={toc:[]},ane="wrapper";function ine(e){let{components:n,...t}=e;return(0,s.yg)(ane,(0,p.A)({},cne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}ine.isMDXComponent=!0;const lne={toc:[]},une="wrapper";function mne(e){let{components:n,...t}=e;return(0,s.yg)(une,(0,p.A)({},lne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}mne.isMDXComponent=!0;const yne={toc:[]},dne="wrapper";function hne(e){let{components:n,...t}=e;return(0,s.yg)(dne,(0,p.A)({},yne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}hne.isMDXComponent=!0;const gne={toc:[]},fne="wrapper";function Dne(e){let{components:n,...t}=e;return(0,s.yg)(fne,(0,p.A)({},gne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Dne.isMDXComponent=!0;const Mne={toc:[]},Xne="wrapper";function _ne(e){let{components:n,...t}=e;return(0,s.yg)(Xne,(0,p.A)({},Mne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}_ne.isMDXComponent=!0;const wne={toc:[]},Tne="wrapper";function Cne(e){let{components:n,...t}=e;return(0,s.yg)(Tne,(0,p.A)({},wne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Cne.isMDXComponent=!0;const xne={toc:[]},Ane="wrapper";function vne(e){let{components:n,...t}=e;return(0,s.yg)(Ane,(0,p.A)({},xne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}vne.isMDXComponent=!0;const Lne={toc:[]},bne="wrapper";function Nne(e){let{components:n,...t}=e;return(0,s.yg)(bne,(0,p.A)({},Lne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Nne.isMDXComponent=!0;const kne={toc:[]},zne="wrapper";function Pne(e){let{components:n,...t}=e;return(0,s.yg)(zne,(0,p.A)({},kne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}Pne.isMDXComponent=!0;const Ine={toc:[]},Rne="wrapper";function Wne(e){let{components:n,...t}=e;return(0,s.yg)(Rne,(0,p.A)({},Ine,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Wne.isMDXComponent=!0;const Sne={toc:[]},Bne="wrapper";function Ene(e){let{components:n,...t}=e;return(0,s.yg)(Bne,(0,p.A)({},Sne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}Ene.isMDXComponent=!0;const Gne={toc:[]},One="wrapper";function Une(e){let{components:n,...t}=e;return(0,s.yg)(One,(0,p.A)({},Gne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Une.isMDXComponent=!0;const Fne={toc:[]},Vne="wrapper";function qne(e){let{components:n,...t}=e;return(0,s.yg)(Vne,(0,p.A)({},Fne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}qne.isMDXComponent=!0;const jne={toc:[]},Hne="wrapper";function Yne(e){let{components:n,...t}=e;return(0,s.yg)(Hne,(0,p.A)({},jne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}Yne.isMDXComponent=!0;const Qne={toc:[]},$ne="wrapper";function Kne(e){let{components:n,...t}=e;return(0,s.yg)($ne,(0,p.A)({},Qne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Kne.isMDXComponent=!0;const Jne={toc:[]},Zne="wrapper";function ete(e){let{components:n,...t}=e;return(0,s.yg)(Zne,(0,p.A)({},Jne,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}ete.isMDXComponent=!0;const nte={toc:[]},tte="wrapper";function ote(e){let{components:n,...t}=e;return(0,s.yg)(tte,(0,p.A)({},nte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}ote.isMDXComponent=!0;const pte={toc:[]},rte="wrapper";function ste(e){let{components:n,...t}=e;return(0,s.yg)(rte,(0,p.A)({},pte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}ste.isMDXComponent=!0;const cte={toc:[]},ate="wrapper";function ite(e){let{components:n,...t}=e;return(0,s.yg)(ate,(0,p.A)({},cte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}ite.isMDXComponent=!0;const lte={toc:[]},ute="wrapper";function mte(e){let{components:n,...t}=e;return(0,s.yg)(ute,(0,p.A)({},lte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}mte.isMDXComponent=!0;const yte={toc:[]},dte="wrapper";function hte(e){let{components:n,...t}=e;return(0,s.yg)(dte,(0,p.A)({},yte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}hte.isMDXComponent=!0;const gte={toc:[]},fte="wrapper";function Dte(e){let{components:n,...t}=e;return(0,s.yg)(fte,(0,p.A)({},gte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}Dte.isMDXComponent=!0;const Mte={toc:[]},Xte="wrapper";function _te(e){let{components:n,...t}=e;return(0,s.yg)(Xte,(0,p.A)({},Mte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}_te.isMDXComponent=!0;const wte={toc:[]},Tte="wrapper";function Cte(e){let{components:n,...t}=e;return(0,s.yg)(Tte,(0,p.A)({},wte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Cte.isMDXComponent=!0;const xte={toc:[]},Ate="wrapper";function vte(e){let{components:n,...t}=e;return(0,s.yg)(Ate,(0,p.A)({},xte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}vte.isMDXComponent=!0;const Lte={toc:[]},bte="wrapper";function Nte(e){let{components:n,...t}=e;return(0,s.yg)(bte,(0,p.A)({},Lte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}Nte.isMDXComponent=!0;const kte={toc:[]},zte="wrapper";function Pte(e){let{components:n,...t}=e;return(0,s.yg)(zte,(0,p.A)({},kte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}Pte.isMDXComponent=!0;const Ite={toc:[]},Rte="wrapper";function Wte(e){let{components:n,...t}=e;return(0,s.yg)(Rte,(0,p.A)({},Ite,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Wte.isMDXComponent=!0;const Ste={toc:[]},Bte="wrapper";function Ete(e){let{components:n,...t}=e;return(0,s.yg)(Bte,(0,p.A)({},Ste,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}Ete.isMDXComponent=!0;const Gte={toc:[]},Ote="wrapper";function Ute(e){let{components:n,...t}=e;return(0,s.yg)(Ote,(0,p.A)({},Gte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}Ute.isMDXComponent=!0;const Fte={toc:[]},Vte="wrapper";function qte(e){let{components:n,...t}=e;return(0,s.yg)(Vte,(0,p.A)({},Fte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}qte.isMDXComponent=!0;const jte={toc:[]},Hte="wrapper";function Yte(e){let{components:n,...t}=e;return(0,s.yg)(Hte,(0,p.A)({},jte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}Yte.isMDXComponent=!0;const Qte={toc:[]},$te="wrapper";function Kte(e){let{components:n,...t}=e;return(0,s.yg)($te,(0,p.A)({},Qte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Kte.isMDXComponent=!0;const Jte={toc:[]},Zte="wrapper";function eoe(e){let{components:n,...t}=e;return(0,s.yg)(Zte,(0,p.A)({},Jte,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}eoe.isMDXComponent=!0;const noe={toc:[]},toe="wrapper";function ooe(e){let{components:n,...t}=e;return(0,s.yg)(toe,(0,p.A)({},noe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}ooe.isMDXComponent=!0;const poe={toc:[]},roe="wrapper";function soe(e){let{components:n,...t}=e;return(0,s.yg)(roe,(0,p.A)({},poe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}soe.isMDXComponent=!0;const coe={toc:[]},aoe="wrapper";function ioe(e){let{components:n,...t}=e;return(0,s.yg)(aoe,(0,p.A)({},coe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}ioe.isMDXComponent=!0;const loe={toc:[]},uoe="wrapper";function moe(e){let{components:n,...t}=e;return(0,s.yg)(uoe,(0,p.A)({},loe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}moe.isMDXComponent=!0;const yoe={toc:[]},doe="wrapper";function hoe(e){let{components:n,...t}=e;return(0,s.yg)(doe,(0,p.A)({},yoe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}hoe.isMDXComponent=!0;const goe={toc:[]},foe="wrapper";function Doe(e){let{components:n,...t}=e;return(0,s.yg)(foe,(0,p.A)({},goe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Doe.isMDXComponent=!0;const Moe={toc:[]},Xoe="wrapper";function _oe(e){let{components:n,...t}=e;return(0,s.yg)(Xoe,(0,p.A)({},Moe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}_oe.isMDXComponent=!0;const woe={toc:[]},Toe="wrapper";function Coe(e){let{components:n,...t}=e;return(0,s.yg)(Toe,(0,p.A)({},woe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Coe.isMDXComponent=!0;const xoe={toc:[]},Aoe="wrapper";function voe(e){let{components:n,...t}=e;return(0,s.yg)(Aoe,(0,p.A)({},xoe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}voe.isMDXComponent=!0;const Loe={toc:[]},boe="wrapper";function Noe(e){let{components:n,...t}=e;return(0,s.yg)(boe,(0,p.A)({},Loe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}Noe.isMDXComponent=!0;const koe={toc:[]},zoe="wrapper";function Poe(e){let{components:n,...t}=e;return(0,s.yg)(zoe,(0,p.A)({},koe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Poe.isMDXComponent=!0;const Ioe={toc:[]},Roe="wrapper";function Woe(e){let{components:n,...t}=e;return(0,s.yg)(Roe,(0,p.A)({},Ioe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}Woe.isMDXComponent=!0;const Soe={toc:[]},Boe="wrapper";function Eoe(e){let{components:n,...t}=e;return(0,s.yg)(Boe,(0,p.A)({},Soe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Eoe.isMDXComponent=!0;const Goe={toc:[]},Ooe="wrapper";function Uoe(e){let{components:n,...t}=e;return(0,s.yg)(Ooe,(0,p.A)({},Goe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Uoe.isMDXComponent=!0;const Foe={toc:[]},Voe="wrapper";function qoe(e){let{components:n,...t}=e;return(0,s.yg)(Voe,(0,p.A)({},Foe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}qoe.isMDXComponent=!0;const joe={toc:[]},Hoe="wrapper";function Yoe(e){let{components:n,...t}=e;return(0,s.yg)(Hoe,(0,p.A)({},joe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Yoe.isMDXComponent=!0;const Qoe={toc:[]},$oe="wrapper";function Koe(e){let{components:n,...t}=e;return(0,s.yg)($oe,(0,p.A)({},Qoe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Koe.isMDXComponent=!0;const Joe={toc:[]},Zoe="wrapper";function epe(e){let{components:n,...t}=e;return(0,s.yg)(Zoe,(0,p.A)({},Joe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}epe.isMDXComponent=!0;const npe={toc:[]},tpe="wrapper";function ope(e){let{components:n,...t}=e;return(0,s.yg)(tpe,(0,p.A)({},npe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}ope.isMDXComponent=!0;const ppe={toc:[]},rpe="wrapper";function spe(e){let{components:n,...t}=e;return(0,s.yg)(rpe,(0,p.A)({},ppe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}spe.isMDXComponent=!0;const cpe={toc:[]},ape="wrapper";function ipe(e){let{components:n,...t}=e;return(0,s.yg)(ape,(0,p.A)({},cpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}ipe.isMDXComponent=!0;const lpe={toc:[]},upe="wrapper";function mpe(e){let{components:n,...t}=e;return(0,s.yg)(upe,(0,p.A)({},lpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}mpe.isMDXComponent=!0;const ype={toc:[]},dpe="wrapper";function hpe(e){let{components:n,...t}=e;return(0,s.yg)(dpe,(0,p.A)({},ype,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}hpe.isMDXComponent=!0;const gpe={toc:[]},fpe="wrapper";function Dpe(e){let{components:n,...t}=e;return(0,s.yg)(fpe,(0,p.A)({},gpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}Dpe.isMDXComponent=!0;const Mpe={toc:[]},Xpe="wrapper";function _pe(e){let{components:n,...t}=e;return(0,s.yg)(Xpe,(0,p.A)({},Mpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}_pe.isMDXComponent=!0;const wpe={toc:[]},Tpe="wrapper";function Cpe(e){let{components:n,...t}=e;return(0,s.yg)(Tpe,(0,p.A)({},wpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Cpe.isMDXComponent=!0;const xpe={toc:[]},Ape="wrapper";function vpe(e){let{components:n,...t}=e;return(0,s.yg)(Ape,(0,p.A)({},xpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}vpe.isMDXComponent=!0;const Lpe={toc:[]},bpe="wrapper";function Npe(e){let{components:n,...t}=e;return(0,s.yg)(bpe,(0,p.A)({},Lpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Npe.isMDXComponent=!0;const kpe={toc:[]},zpe="wrapper";function Ppe(e){let{components:n,...t}=e;return(0,s.yg)(zpe,(0,p.A)({},kpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Ppe.isMDXComponent=!0;const Ipe={toc:[]},Rpe="wrapper";function Wpe(e){let{components:n,...t}=e;return(0,s.yg)(Rpe,(0,p.A)({},Ipe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Wpe.isMDXComponent=!0;const Spe={toc:[]},Bpe="wrapper";function Epe(e){let{components:n,...t}=e;return(0,s.yg)(Bpe,(0,p.A)({},Spe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Epe.isMDXComponent=!0;const Gpe={toc:[]},Ope="wrapper";function Upe(e){let{components:n,...t}=e;return(0,s.yg)(Ope,(0,p.A)({},Gpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Upe.isMDXComponent=!0;const Fpe={toc:[]},Vpe="wrapper";function qpe(e){let{components:n,...t}=e;return(0,s.yg)(Vpe,(0,p.A)({},Fpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}qpe.isMDXComponent=!0;const jpe={toc:[]},Hpe="wrapper";function Ype(e){let{components:n,...t}=e;return(0,s.yg)(Hpe,(0,p.A)({},jpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}Ype.isMDXComponent=!0;const Qpe={toc:[]},$pe="wrapper";function Kpe(e){let{components:n,...t}=e;return(0,s.yg)($pe,(0,p.A)({},Qpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Audio#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Kpe.isMDXComponent=!0;const Jpe={toc:[]},Zpe="wrapper";function ere(e){let{components:n,...t}=e;return(0,s.yg)(Zpe,(0,p.A)({},Jpe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}ere.isMDXComponent=!0;const nre={toc:[]},tre="wrapper";function ore(e){let{components:n,...t}=e;return(0,s.yg)(tre,(0,p.A)({},nre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}ore.isMDXComponent=!0;const pre={toc:[]},rre="wrapper";function sre(e){let{components:n,...t}=e;return(0,s.yg)(rre,(0,p.A)({},pre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}sre.isMDXComponent=!0;const cre={toc:[]},are="wrapper";function ire(e){let{components:n,...t}=e;return(0,s.yg)(are,(0,p.A)({},cre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}ire.isMDXComponent=!0;const lre={toc:[]},ure="wrapper";function mre(e){let{components:n,...t}=e;return(0,s.yg)(ure,(0,p.A)({},lre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}mre.isMDXComponent=!0;const yre={toc:[]},dre="wrapper";function hre(e){let{components:n,...t}=e;return(0,s.yg)(dre,(0,p.A)({},yre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}hre.isMDXComponent=!0;const gre={toc:[]},fre="wrapper";function Dre(e){let{components:n,...t}=e;return(0,s.yg)(fre,(0,p.A)({},gre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Dre.isMDXComponent=!0;const Mre={toc:[]},Xre="wrapper";function _re(e){let{components:n,...t}=e;return(0,s.yg)(Xre,(0,p.A)({},Mre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}_re.isMDXComponent=!0;const wre={toc:[]},Tre="wrapper";function Cre(e){let{components:n,...t}=e;return(0,s.yg)(Tre,(0,p.A)({},wre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Cre.isMDXComponent=!0;const xre={toc:[]},Are="wrapper";function vre(e){let{components:n,...t}=e;return(0,s.yg)(Are,(0,p.A)({},xre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}vre.isMDXComponent=!0;const Lre={toc:[]},bre="wrapper";function Nre(e){let{components:n,...t}=e;return(0,s.yg)(bre,(0,p.A)({},Lre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Nre.isMDXComponent=!0;const kre={toc:[]},zre="wrapper";function Pre(e){let{components:n,...t}=e;return(0,s.yg)(zre,(0,p.A)({},kre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}Pre.isMDXComponent=!0;const Ire={toc:[]},Rre="wrapper";function Wre(e){let{components:n,...t}=e;return(0,s.yg)(Rre,(0,p.A)({},Ire,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Wre.isMDXComponent=!0;const Sre={toc:[]},Bre="wrapper";function Ere(e){let{components:n,...t}=e;return(0,s.yg)(Bre,(0,p.A)({},Sre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}Ere.isMDXComponent=!0;const Gre={toc:[]},Ore="wrapper";function Ure(e){let{components:n,...t}=e;return(0,s.yg)(Ore,(0,p.A)({},Gre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Ure.isMDXComponent=!0;const Fre={toc:[]},Vre="wrapper";function qre(e){let{components:n,...t}=e;return(0,s.yg)(Vre,(0,p.A)({},Fre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}qre.isMDXComponent=!0;const jre={toc:[]},Hre="wrapper";function Yre(e){let{components:n,...t}=e;return(0,s.yg)(Hre,(0,p.A)({},jre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Yre.isMDXComponent=!0;const Qre={toc:[]},$re="wrapper";function Kre(e){let{components:n,...t}=e;return(0,s.yg)($re,(0,p.A)({},Qre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Kre.isMDXComponent=!0;const Jre={toc:[]},Zre="wrapper";function ese(e){let{components:n,...t}=e;return(0,s.yg)(Zre,(0,p.A)({},Jre,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}ese.isMDXComponent=!0;const nse={toc:[]},tse="wrapper";function ose(e){let{components:n,...t}=e;return(0,s.yg)(tse,(0,p.A)({},nse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}ose.isMDXComponent=!0;const pse={toc:[]},rse="wrapper";function sse(e){let{components:n,...t}=e;return(0,s.yg)(rse,(0,p.A)({},pse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}sse.isMDXComponent=!0;const cse={toc:[]},ase="wrapper";function ise(e){let{components:n,...t}=e;return(0,s.yg)(ase,(0,p.A)({},cse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}ise.isMDXComponent=!0;const lse={toc:[]},use="wrapper";function mse(e){let{components:n,...t}=e;return(0,s.yg)(use,(0,p.A)({},lse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}mse.isMDXComponent=!0;const yse={toc:[]},dse="wrapper";function hse(e){let{components:n,...t}=e;return(0,s.yg)(dse,(0,p.A)({},yse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}hse.isMDXComponent=!0;const gse={toc:[]},fse="wrapper";function Dse(e){let{components:n,...t}=e;return(0,s.yg)(fse,(0,p.A)({},gse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Dse.isMDXComponent=!0;const Mse={toc:[]},Xse="wrapper";function _se(e){let{components:n,...t}=e;return(0,s.yg)(Xse,(0,p.A)({},Mse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}_se.isMDXComponent=!0;const wse={toc:[]},Tse="wrapper";function Cse(e){let{components:n,...t}=e;return(0,s.yg)(Tse,(0,p.A)({},wse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Cse.isMDXComponent=!0;const xse={toc:[]},Ase="wrapper";function vse(e){let{components:n,...t}=e;return(0,s.yg)(Ase,(0,p.A)({},xse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}vse.isMDXComponent=!0;const Lse={toc:[]},bse="wrapper";function Nse(e){let{components:n,...t}=e;return(0,s.yg)(bse,(0,p.A)({},Lse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Nse.isMDXComponent=!0;const kse={toc:[]},zse="wrapper";function Pse(e){let{components:n,...t}=e;return(0,s.yg)(zse,(0,p.A)({},kse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}Pse.isMDXComponent=!0;const Ise={toc:[]},Rse="wrapper";function Wse(e){let{components:n,...t}=e;return(0,s.yg)(Rse,(0,p.A)({},Ise,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Wse.isMDXComponent=!0;const Sse={toc:[]},Bse="wrapper";function Ese(e){let{components:n,...t}=e;return(0,s.yg)(Bse,(0,p.A)({},Sse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Ese.isMDXComponent=!0;const Gse={toc:[]},Ose="wrapper";function Use(e){let{components:n,...t}=e;return(0,s.yg)(Ose,(0,p.A)({},Gse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Use.isMDXComponent=!0;const Fse={toc:[]},Vse="wrapper";function qse(e){let{components:n,...t}=e;return(0,s.yg)(Vse,(0,p.A)({},Fse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}qse.isMDXComponent=!0;const jse={toc:[]},Hse="wrapper";function Yse(e){let{components:n,...t}=e;return(0,s.yg)(Hse,(0,p.A)({},jse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Yse.isMDXComponent=!0;const Qse={toc:[]},$se="wrapper";function Kse(e){let{components:n,...t}=e;return(0,s.yg)($se,(0,p.A)({},Qse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}Kse.isMDXComponent=!0;const Jse={toc:[]},Zse="wrapper";function ece(e){let{components:n,...t}=e;return(0,s.yg)(Zse,(0,p.A)({},Jse,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}ece.isMDXComponent=!0;const nce={toc:[]},tce="wrapper";function oce(e){let{components:n,...t}=e;return(0,s.yg)(tce,(0,p.A)({},nce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}oce.isMDXComponent=!0;const pce={toc:[]},rce="wrapper";function sce(e){let{components:n,...t}=e;return(0,s.yg)(rce,(0,p.A)({},pce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}sce.isMDXComponent=!0;const cce={toc:[]},ace="wrapper";function ice(e){let{components:n,...t}=e;return(0,s.yg)(ace,(0,p.A)({},cce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}ice.isMDXComponent=!0;const lce={toc:[]},uce="wrapper";function mce(e){let{components:n,...t}=e;return(0,s.yg)(uce,(0,p.A)({},lce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}mce.isMDXComponent=!0;const yce={toc:[]},dce="wrapper";function hce(e){let{components:n,...t}=e;return(0,s.yg)(dce,(0,p.A)({},yce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}hce.isMDXComponent=!0;const gce={toc:[]},fce="wrapper";function Dce(e){let{components:n,...t}=e;return(0,s.yg)(fce,(0,p.A)({},gce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Dce.isMDXComponent=!0;const Mce={toc:[]},Xce="wrapper";function _ce(e){let{components:n,...t}=e;return(0,s.yg)(Xce,(0,p.A)({},Mce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}_ce.isMDXComponent=!0;const wce={toc:[]},Tce="wrapper";function Cce(e){let{components:n,...t}=e;return(0,s.yg)(Tce,(0,p.A)({},wce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}Cce.isMDXComponent=!0;const xce={toc:[]},Ace="wrapper";function vce(e){let{components:n,...t}=e;return(0,s.yg)(Ace,(0,p.A)({},xce,t,{components:n,mdxType:"MDXLayout"}))}vce.isMDXComponent=!0;const Lce={toc:[]},bce="wrapper";function Nce(e){let{components:n,...t}=e;return(0,s.yg)(bce,(0,p.A)({},Lce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Nce.isMDXComponent=!0;const kce={toc:[]},zce="wrapper";function Pce(e){let{components:n,...t}=e;return(0,s.yg)(zce,(0,p.A)({},kce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Pce.isMDXComponent=!0;const Ice={toc:[]},Rce="wrapper";function Wce(e){let{components:n,...t}=e;return(0,s.yg)(Rce,(0,p.A)({},Ice,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}Wce.isMDXComponent=!0;const Sce={toc:[]},Bce="wrapper";function Ece(e){let{components:n,...t}=e;return(0,s.yg)(Bce,(0,p.A)({},Sce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Ece.isMDXComponent=!0;const Gce={toc:[]},Oce="wrapper";function Uce(e){let{components:n,...t}=e;return(0,s.yg)(Oce,(0,p.A)({},Gce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}Uce.isMDXComponent=!0;const Fce={toc:[]},Vce="wrapper";function qce(e){let{components:n,...t}=e;return(0,s.yg)(Vce,(0,p.A)({},Fce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}qce.isMDXComponent=!0;const jce={toc:[]},Hce="wrapper";function Yce(e){let{components:n,...t}=e;return(0,s.yg)(Hce,(0,p.A)({},jce,t,{components:n,mdxType:"MDXLayout"}))}Yce.isMDXComponent=!0;const Qce={toc:[]},$ce="wrapper";function Kce(e){let{components:n,...t}=e;return(0,s.yg)($ce,(0,p.A)({},Qce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Kce.isMDXComponent=!0;const Jce={toc:[]},Zce="wrapper";function eae(e){let{components:n,...t}=e;return(0,s.yg)(Zce,(0,p.A)({},Jce,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}eae.isMDXComponent=!0;const nae={toc:[]},tae="wrapper";function oae(e){let{components:n,...t}=e;return(0,s.yg)(tae,(0,p.A)({},nae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}oae.isMDXComponent=!0;const pae={toc:[]},rae="wrapper";function sae(e){let{components:n,...t}=e;return(0,s.yg)(rae,(0,p.A)({},pae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}sae.isMDXComponent=!0;const cae={toc:[]},aae="wrapper";function iae(e){let{components:n,...t}=e;return(0,s.yg)(aae,(0,p.A)({},cae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}iae.isMDXComponent=!0;const lae={toc:[]},uae="wrapper";function mae(e){let{components:n,...t}=e;return(0,s.yg)(uae,(0,p.A)({},lae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}mae.isMDXComponent=!0;const yae={toc:[]},dae="wrapper";function hae(e){let{components:n,...t}=e;return(0,s.yg)(dae,(0,p.A)({},yae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}hae.isMDXComponent=!0;const gae={toc:[]},fae="wrapper";function Dae(e){let{components:n,...t}=e;return(0,s.yg)(fae,(0,p.A)({},gae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Dae.isMDXComponent=!0;const Mae={toc:[]},Xae="wrapper";function _ae(e){let{components:n,...t}=e;return(0,s.yg)(Xae,(0,p.A)({},Mae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}_ae.isMDXComponent=!0;const wae={toc:[]},Tae="wrapper";function Cae(e){let{components:n,...t}=e;return(0,s.yg)(Tae,(0,p.A)({},wae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Cae.isMDXComponent=!0;const xae={toc:[]},Aae="wrapper";function vae(e){let{components:n,...t}=e;return(0,s.yg)(Aae,(0,p.A)({},xae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}vae.isMDXComponent=!0;const Lae={toc:[]},bae="wrapper";function Nae(e){let{components:n,...t}=e;return(0,s.yg)(bae,(0,p.A)({},Lae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Nae.isMDXComponent=!0;const kae={toc:[]},zae="wrapper";function Pae(e){let{components:n,...t}=e;return(0,s.yg)(zae,(0,p.A)({},kae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}Pae.isMDXComponent=!0;const Iae={toc:[]},Rae="wrapper";function Wae(e){let{components:n,...t}=e;return(0,s.yg)(Rae,(0,p.A)({},Iae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Wae.isMDXComponent=!0;const Sae={toc:[]},Bae="wrapper";function Eae(e){let{components:n,...t}=e;return(0,s.yg)(Bae,(0,p.A)({},Sae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}Eae.isMDXComponent=!0;const Gae={toc:[]},Oae="wrapper";function Uae(e){let{components:n,...t}=e;return(0,s.yg)(Oae,(0,p.A)({},Gae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}Uae.isMDXComponent=!0;const Fae={toc:[]},Vae="wrapper";function qae(e){let{components:n,...t}=e;return(0,s.yg)(Vae,(0,p.A)({},Fae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}qae.isMDXComponent=!0;const jae={toc:[]},Hae="wrapper";function Yae(e){let{components:n,...t}=e;return(0,s.yg)(Hae,(0,p.A)({},jae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}Yae.isMDXComponent=!0;const Qae={toc:[]},$ae="wrapper";function Kae(e){let{components:n,...t}=e;return(0,s.yg)($ae,(0,p.A)({},Qae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Kae.isMDXComponent=!0;const Jae={toc:[]},Zae="wrapper";function eie(e){let{components:n,...t}=e;return(0,s.yg)(Zae,(0,p.A)({},Jae,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}eie.isMDXComponent=!0;const nie={toc:[]},tie="wrapper";function oie(e){let{components:n,...t}=e;return(0,s.yg)(tie,(0,p.A)({},nie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}oie.isMDXComponent=!0;const pie={toc:[]},rie="wrapper";function sie(e){let{components:n,...t}=e;return(0,s.yg)(rie,(0,p.A)({},pie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}sie.isMDXComponent=!0;const cie={toc:[]},aie="wrapper";function iie(e){let{components:n,...t}=e;return(0,s.yg)(aie,(0,p.A)({},cie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}iie.isMDXComponent=!0;const lie={toc:[]},uie="wrapper";function mie(e){let{components:n,...t}=e;return(0,s.yg)(uie,(0,p.A)({},lie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}mie.isMDXComponent=!0;const yie={toc:[]},die="wrapper";function hie(e){let{components:n,...t}=e;return(0,s.yg)(die,(0,p.A)({},yie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}hie.isMDXComponent=!0;const gie={toc:[]},fie="wrapper";function Die(e){let{components:n,...t}=e;return(0,s.yg)(fie,(0,p.A)({},gie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}Die.isMDXComponent=!0;const Mie={toc:[]},Xie="wrapper";function _ie(e){let{components:n,...t}=e;return(0,s.yg)(Xie,(0,p.A)({},Mie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}_ie.isMDXComponent=!0;const wie={toc:[]},Tie="wrapper";function Cie(e){let{components:n,...t}=e;return(0,s.yg)(Tie,(0,p.A)({},wie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Cie.isMDXComponent=!0;const xie={toc:[]},Aie="wrapper";function vie(e){let{components:n,...t}=e;return(0,s.yg)(Aie,(0,p.A)({},xie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}vie.isMDXComponent=!0;const Lie={toc:[]},bie="wrapper";function Nie(e){let{components:n,...t}=e;return(0,s.yg)(bie,(0,p.A)({},Lie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}Nie.isMDXComponent=!0;const kie={toc:[]},zie="wrapper";function Pie(e){let{components:n,...t}=e;return(0,s.yg)(zie,(0,p.A)({},kie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}Pie.isMDXComponent=!0;const Iie={toc:[]},Rie="wrapper";function Wie(e){let{components:n,...t}=e;return(0,s.yg)(Rie,(0,p.A)({},Iie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Wie.isMDXComponent=!0;const Sie={toc:[]},Bie="wrapper";function Eie(e){let{components:n,...t}=e;return(0,s.yg)(Bie,(0,p.A)({},Sie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Eie.isMDXComponent=!0;const Gie={toc:[]},Oie="wrapper";function Uie(e){let{components:n,...t}=e;return(0,s.yg)(Oie,(0,p.A)({},Gie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}Uie.isMDXComponent=!0;const Fie={toc:[]},Vie="wrapper";function qie(e){let{components:n,...t}=e;return(0,s.yg)(Vie,(0,p.A)({},Fie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}qie.isMDXComponent=!0;const jie={toc:[]},Hie="wrapper";function Yie(e){let{components:n,...t}=e;return(0,s.yg)(Hie,(0,p.A)({},jie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}Yie.isMDXComponent=!0;const Qie={toc:[]},$ie="wrapper";function Kie(e){let{components:n,...t}=e;return(0,s.yg)($ie,(0,p.A)({},Qie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Kie.isMDXComponent=!0;const Jie={toc:[]},Zie="wrapper";function ele(e){let{components:n,...t}=e;return(0,s.yg)(Zie,(0,p.A)({},Jie,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}ele.isMDXComponent=!0;const nle={toc:[]},tle="wrapper";function ole(e){let{components:n,...t}=e;return(0,s.yg)(tle,(0,p.A)({},nle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}ole.isMDXComponent=!0;const ple={toc:[]},rle="wrapper";function sle(e){let{components:n,...t}=e;return(0,s.yg)(rle,(0,p.A)({},ple,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}sle.isMDXComponent=!0;const cle={toc:[]},ale="wrapper";function ile(e){let{components:n,...t}=e;return(0,s.yg)(ale,(0,p.A)({},cle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}ile.isMDXComponent=!0;const lle={toc:[]},ule="wrapper";function mle(e){let{components:n,...t}=e;return(0,s.yg)(ule,(0,p.A)({},lle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}mle.isMDXComponent=!0;const yle={toc:[]},dle="wrapper";function hle(e){let{components:n,...t}=e;return(0,s.yg)(dle,(0,p.A)({},yle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}hle.isMDXComponent=!0;const gle={toc:[]},fle="wrapper";function Dle(e){let{components:n,...t}=e;return(0,s.yg)(fle,(0,p.A)({},gle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}Dle.isMDXComponent=!0;const Mle={toc:[]},Xle="wrapper";function _le(e){let{components:n,...t}=e;return(0,s.yg)(Xle,(0,p.A)({},Mle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}_le.isMDXComponent=!0;const wle={toc:[]},Tle="wrapper";function Cle(e){let{components:n,...t}=e;return(0,s.yg)(Tle,(0,p.A)({},wle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Cle.isMDXComponent=!0;const xle={toc:[]},Ale="wrapper";function vle(e){let{components:n,...t}=e;return(0,s.yg)(Ale,(0,p.A)({},xle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}vle.isMDXComponent=!0;const Lle={toc:[]},ble="wrapper";function Nle(e){let{components:n,...t}=e;return(0,s.yg)(ble,(0,p.A)({},Lle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Nle.isMDXComponent=!0;const kle={toc:[]},zle="wrapper";function Ple(e){let{components:n,...t}=e;return(0,s.yg)(zle,(0,p.A)({},kle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Ple.isMDXComponent=!0;const Ile={toc:[]},Rle="wrapper";function Wle(e){let{components:n,...t}=e;return(0,s.yg)(Rle,(0,p.A)({},Ile,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}Wle.isMDXComponent=!0;const Sle={toc:[]},Ble="wrapper";function Ele(e){let{components:n,...t}=e;return(0,s.yg)(Ble,(0,p.A)({},Sle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Ele.isMDXComponent=!0;const Gle={toc:[]},Ole="wrapper";function Ule(e){let{components:n,...t}=e;return(0,s.yg)(Ole,(0,p.A)({},Gle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}Ule.isMDXComponent=!0;const Fle={toc:[]},Vle="wrapper";function qle(e){let{components:n,...t}=e;return(0,s.yg)(Vle,(0,p.A)({},Fle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}qle.isMDXComponent=!0;const jle={toc:[]},Hle="wrapper";function Yle(e){let{components:n,...t}=e;return(0,s.yg)(Hle,(0,p.A)({},jle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Yle.isMDXComponent=!0;const Qle={toc:[]},$le="wrapper";function Kle(e){let{components:n,...t}=e;return(0,s.yg)($le,(0,p.A)({},Qle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Kle.isMDXComponent=!0;const Jle={toc:[]},Zle="wrapper";function eue(e){let{components:n,...t}=e;return(0,s.yg)(Zle,(0,p.A)({},Jle,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}eue.isMDXComponent=!0;const nue={toc:[]},tue="wrapper";function oue(e){let{components:n,...t}=e;return(0,s.yg)(tue,(0,p.A)({},nue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}oue.isMDXComponent=!0;const pue={toc:[]},rue="wrapper";function sue(e){let{components:n,...t}=e;return(0,s.yg)(rue,(0,p.A)({},pue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}sue.isMDXComponent=!0;const cue={toc:[]},aue="wrapper";function iue(e){let{components:n,...t}=e;return(0,s.yg)(aue,(0,p.A)({},cue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}iue.isMDXComponent=!0;const lue={toc:[]},uue="wrapper";function mue(e){let{components:n,...t}=e;return(0,s.yg)(uue,(0,p.A)({},lue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}mue.isMDXComponent=!0;const yue={toc:[]},due="wrapper";function hue(e){let{components:n,...t}=e;return(0,s.yg)(due,(0,p.A)({},yue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}hue.isMDXComponent=!0;const gue={toc:[]},fue="wrapper";function Due(e){let{components:n,...t}=e;return(0,s.yg)(fue,(0,p.A)({},gue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Due.isMDXComponent=!0;const Mue={toc:[]},Xue="wrapper";function _ue(e){let{components:n,...t}=e;return(0,s.yg)(Xue,(0,p.A)({},Mue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}_ue.isMDXComponent=!0;const wue={toc:[]},Tue="wrapper";function Cue(e){let{components:n,...t}=e;return(0,s.yg)(Tue,(0,p.A)({},wue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Cue.isMDXComponent=!0;const xue={toc:[]},Aue="wrapper";function vue(e){let{components:n,...t}=e;return(0,s.yg)(Aue,(0,p.A)({},xue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}vue.isMDXComponent=!0;const Lue={toc:[]},bue="wrapper";function Nue(e){let{components:n,...t}=e;return(0,s.yg)(bue,(0,p.A)({},Lue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Nue.isMDXComponent=!0;const kue={toc:[]},zue="wrapper";function Pue(e){let{components:n,...t}=e;return(0,s.yg)(zue,(0,p.A)({},kue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Pue.isMDXComponent=!0;const Iue={toc:[]},Rue="wrapper";function Wue(e){let{components:n,...t}=e;return(0,s.yg)(Rue,(0,p.A)({},Iue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Wue.isMDXComponent=!0;const Sue={toc:[]},Bue="wrapper";function Eue(e){let{components:n,...t}=e;return(0,s.yg)(Bue,(0,p.A)({},Sue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Eue.isMDXComponent=!0;const Gue={toc:[]},Oue="wrapper";function Uue(e){let{components:n,...t}=e;return(0,s.yg)(Oue,(0,p.A)({},Gue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Uue.isMDXComponent=!0;const Fue={toc:[]},Vue="wrapper";function que(e){let{components:n,...t}=e;return(0,s.yg)(Vue,(0,p.A)({},Fue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}que.isMDXComponent=!0;const jue={toc:[]},Hue="wrapper";function Yue(e){let{components:n,...t}=e;return(0,s.yg)(Hue,(0,p.A)({},jue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}Yue.isMDXComponent=!0;const Que={toc:[]},$ue="wrapper";function Kue(e){let{components:n,...t}=e;return(0,s.yg)($ue,(0,p.A)({},Que,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Kue.isMDXComponent=!0;const Jue={toc:[]},Zue="wrapper";function eme(e){let{components:n,...t}=e;return(0,s.yg)(Zue,(0,p.A)({},Jue,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}eme.isMDXComponent=!0;const nme={toc:[]},tme="wrapper";function ome(e){let{components:n,...t}=e;return(0,s.yg)(tme,(0,p.A)({},nme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}ome.isMDXComponent=!0;const pme={toc:[]},rme="wrapper";function sme(e){let{components:n,...t}=e;return(0,s.yg)(rme,(0,p.A)({},pme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}sme.isMDXComponent=!0;const cme={toc:[]},ame="wrapper";function ime(e){let{components:n,...t}=e;return(0,s.yg)(ame,(0,p.A)({},cme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}ime.isMDXComponent=!0;const lme={toc:[]},ume="wrapper";function mme(e){let{components:n,...t}=e;return(0,s.yg)(ume,(0,p.A)({},lme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}mme.isMDXComponent=!0;const yme={toc:[]},dme="wrapper";function hme(e){let{components:n,...t}=e;return(0,s.yg)(dme,(0,p.A)({},yme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}hme.isMDXComponent=!0;const gme={toc:[]},fme="wrapper";function Dme(e){let{components:n,...t}=e;return(0,s.yg)(fme,(0,p.A)({},gme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}Dme.isMDXComponent=!0;const Mme={toc:[]},Xme="wrapper";function _me(e){let{components:n,...t}=e;return(0,s.yg)(Xme,(0,p.A)({},Mme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}_me.isMDXComponent=!0;const wme={toc:[]},Tme="wrapper";function Cme(e){let{components:n,...t}=e;return(0,s.yg)(Tme,(0,p.A)({},wme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}Cme.isMDXComponent=!0;const xme={toc:[]},Ame="wrapper";function vme(e){let{components:n,...t}=e;return(0,s.yg)(Ame,(0,p.A)({},xme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}vme.isMDXComponent=!0;const Lme={toc:[]},bme="wrapper";function Nme(e){let{components:n,...t}=e;return(0,s.yg)(bme,(0,p.A)({},Lme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}Nme.isMDXComponent=!0;const kme={toc:[]},zme="wrapper";function Pme(e){let{components:n,...t}=e;return(0,s.yg)(zme,(0,p.A)({},kme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Pme.isMDXComponent=!0;const Ime={toc:[]},Rme="wrapper";function Wme(e){let{components:n,...t}=e;return(0,s.yg)(Rme,(0,p.A)({},Ime,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}Wme.isMDXComponent=!0;const Sme={toc:[]},Bme="wrapper";function Eme(e){let{components:n,...t}=e;return(0,s.yg)(Bme,(0,p.A)({},Sme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Eme.isMDXComponent=!0;const Gme={toc:[]},Ome="wrapper";function Ume(e){let{components:n,...t}=e;return(0,s.yg)(Ome,(0,p.A)({},Gme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Ume.isMDXComponent=!0;const Fme={toc:[]},Vme="wrapper";function qme(e){let{components:n,...t}=e;return(0,s.yg)(Vme,(0,p.A)({},Fme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}qme.isMDXComponent=!0;const jme={toc:[]},Hme="wrapper";function Yme(e){let{components:n,...t}=e;return(0,s.yg)(Hme,(0,p.A)({},jme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Yme.isMDXComponent=!0;const Qme={toc:[]},$me="wrapper";function Kme(e){let{components:n,...t}=e;return(0,s.yg)($me,(0,p.A)({},Qme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}Kme.isMDXComponent=!0;const Jme={toc:[]},Zme="wrapper";function eye(e){let{components:n,...t}=e;return(0,s.yg)(Zme,(0,p.A)({},Jme,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}eye.isMDXComponent=!0;const nye={toc:[]},tye="wrapper";function oye(e){let{components:n,...t}=e;return(0,s.yg)(tye,(0,p.A)({},nye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}oye.isMDXComponent=!0;const pye={toc:[]},rye="wrapper";function sye(e){let{components:n,...t}=e;return(0,s.yg)(rye,(0,p.A)({},pye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}sye.isMDXComponent=!0;const cye={toc:[]},aye="wrapper";function iye(e){let{components:n,...t}=e;return(0,s.yg)(aye,(0,p.A)({},cye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}iye.isMDXComponent=!0;const lye={toc:[]},uye="wrapper";function mye(e){let{components:n,...t}=e;return(0,s.yg)(uye,(0,p.A)({},lye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}mye.isMDXComponent=!0;const yye={toc:[]},dye="wrapper";function hye(e){let{components:n,...t}=e;return(0,s.yg)(dye,(0,p.A)({},yye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}hye.isMDXComponent=!0;const gye={toc:[]},fye="wrapper";function Dye(e){let{components:n,...t}=e;return(0,s.yg)(fye,(0,p.A)({},gye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}Dye.isMDXComponent=!0;const Mye={toc:[]},Xye="wrapper";function _ye(e){let{components:n,...t}=e;return(0,s.yg)(Xye,(0,p.A)({},Mye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}_ye.isMDXComponent=!0;const wye={toc:[]},Tye="wrapper";function Cye(e){let{components:n,...t}=e;return(0,s.yg)(Tye,(0,p.A)({},wye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Cye.isMDXComponent=!0;const xye={toc:[]},Aye="wrapper";function vye(e){let{components:n,...t}=e;return(0,s.yg)(Aye,(0,p.A)({},xye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}vye.isMDXComponent=!0;const Lye={toc:[]},bye="wrapper";function Nye(e){let{components:n,...t}=e;return(0,s.yg)(bye,(0,p.A)({},Lye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}Nye.isMDXComponent=!0;const kye={toc:[]},zye="wrapper";function Pye(e){let{components:n,...t}=e;return(0,s.yg)(zye,(0,p.A)({},kye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Pye.isMDXComponent=!0;const Iye={toc:[]},Rye="wrapper";function Wye(e){let{components:n,...t}=e;return(0,s.yg)(Rye,(0,p.A)({},Iye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}Wye.isMDXComponent=!0;const Sye={toc:[]},Bye="wrapper";function Eye(e){let{components:n,...t}=e;return(0,s.yg)(Bye,(0,p.A)({},Sye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Eye.isMDXComponent=!0;const Gye={toc:[]},Oye="wrapper";function Uye(e){let{components:n,...t}=e;return(0,s.yg)(Oye,(0,p.A)({},Gye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}Uye.isMDXComponent=!0;const Fye={toc:[]},Vye="wrapper";function qye(e){let{components:n,...t}=e;return(0,s.yg)(Vye,(0,p.A)({},Fye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}qye.isMDXComponent=!0;const jye={toc:[]},Hye="wrapper";function Yye(e){let{components:n,...t}=e;return(0,s.yg)(Hye,(0,p.A)({},jye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Yye.isMDXComponent=!0;const Qye={toc:[]},$ye="wrapper";function Kye(e){let{components:n,...t}=e;return(0,s.yg)($ye,(0,p.A)({},Qye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}Kye.isMDXComponent=!0;const Jye={toc:[]},Zye="wrapper";function ede(e){let{components:n,...t}=e;return(0,s.yg)(Zye,(0,p.A)({},Jye,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}ede.isMDXComponent=!0;const nde={toc:[]},tde="wrapper";function ode(e){let{components:n,...t}=e;return(0,s.yg)(tde,(0,p.A)({},nde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}ode.isMDXComponent=!0;const pde={toc:[]},rde="wrapper";function sde(e){let{components:n,...t}=e;return(0,s.yg)(rde,(0,p.A)({},pde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}sde.isMDXComponent=!0;const cde={toc:[]},ade="wrapper";function ide(e){let{components:n,...t}=e;return(0,s.yg)(ade,(0,p.A)({},cde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}ide.isMDXComponent=!0;const lde={toc:[]},ude="wrapper";function mde(e){let{components:n,...t}=e;return(0,s.yg)(ude,(0,p.A)({},lde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}mde.isMDXComponent=!0;const yde={toc:[]},dde="wrapper";function hde(e){let{components:n,...t}=e;return(0,s.yg)(dde,(0,p.A)({},yde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}hde.isMDXComponent=!0;const gde={toc:[]},fde="wrapper";function Dde(e){let{components:n,...t}=e;return(0,s.yg)(fde,(0,p.A)({},gde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}Dde.isMDXComponent=!0;const Mde={toc:[]},Xde="wrapper";function _de(e){let{components:n,...t}=e;return(0,s.yg)(Xde,(0,p.A)({},Mde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}_de.isMDXComponent=!0;const wde={toc:[]},Tde="wrapper";function Cde(e){let{components:n,...t}=e;return(0,s.yg)(Tde,(0,p.A)({},wde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}Cde.isMDXComponent=!0;const xde={toc:[]},Ade="wrapper";function vde(e){let{components:n,...t}=e;return(0,s.yg)(Ade,(0,p.A)({},xde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}vde.isMDXComponent=!0;const Lde={toc:[]},bde="wrapper";function Nde(e){let{components:n,...t}=e;return(0,s.yg)(bde,(0,p.A)({},Lde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}Nde.isMDXComponent=!0;const kde={toc:[]},zde="wrapper";function Pde(e){let{components:n,...t}=e;return(0,s.yg)(zde,(0,p.A)({},kde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Pde.isMDXComponent=!0;const Ide={toc:[]},Rde="wrapper";function Wde(e){let{components:n,...t}=e;return(0,s.yg)(Rde,(0,p.A)({},Ide,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}Wde.isMDXComponent=!0;const Sde={toc:[]},Bde="wrapper";function Ede(e){let{components:n,...t}=e;return(0,s.yg)(Bde,(0,p.A)({},Sde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}Ede.isMDXComponent=!0;const Gde={toc:[]},Ode="wrapper";function Ude(e){let{components:n,...t}=e;return(0,s.yg)(Ode,(0,p.A)({},Gde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Ude.isMDXComponent=!0;const Fde={toc:[]},Vde="wrapper";function qde(e){let{components:n,...t}=e;return(0,s.yg)(Vde,(0,p.A)({},Fde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}qde.isMDXComponent=!0;const jde={toc:[]},Hde="wrapper";function Yde(e){let{components:n,...t}=e;return(0,s.yg)(Hde,(0,p.A)({},jde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Yde.isMDXComponent=!0;const Qde={toc:[]},$de="wrapper";function Kde(e){let{components:n,...t}=e;return(0,s.yg)($de,(0,p.A)({},Qde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}Kde.isMDXComponent=!0;const Jde={toc:[]},Zde="wrapper";function ehe(e){let{components:n,...t}=e;return(0,s.yg)(Zde,(0,p.A)({},Jde,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}ehe.isMDXComponent=!0;const nhe={toc:[]},the="wrapper";function ohe(e){let{components:n,...t}=e;return(0,s.yg)(the,(0,p.A)({},nhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}ohe.isMDXComponent=!0;const phe={toc:[]},rhe="wrapper";function she(e){let{components:n,...t}=e;return(0,s.yg)(rhe,(0,p.A)({},phe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}she.isMDXComponent=!0;const che={toc:[]},ahe="wrapper";function ihe(e){let{components:n,...t}=e;return(0,s.yg)(ahe,(0,p.A)({},che,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}ihe.isMDXComponent=!0;const lhe={toc:[]},uhe="wrapper";function mhe(e){let{components:n,...t}=e;return(0,s.yg)(uhe,(0,p.A)({},lhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}mhe.isMDXComponent=!0;const yhe={toc:[]},dhe="wrapper";function hhe(e){let{components:n,...t}=e;return(0,s.yg)(dhe,(0,p.A)({},yhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}hhe.isMDXComponent=!0;const ghe={toc:[]},fhe="wrapper";function Dhe(e){let{components:n,...t}=e;return(0,s.yg)(fhe,(0,p.A)({},ghe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}Dhe.isMDXComponent=!0;const Mhe={toc:[]},Xhe="wrapper";function _he(e){let{components:n,...t}=e;return(0,s.yg)(Xhe,(0,p.A)({},Mhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}_he.isMDXComponent=!0;const whe={toc:[]},The="wrapper";function Che(e){let{components:n,...t}=e;return(0,s.yg)(The,(0,p.A)({},whe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}Che.isMDXComponent=!0;const xhe={toc:[]},Ahe="wrapper";function vhe(e){let{components:n,...t}=e;return(0,s.yg)(Ahe,(0,p.A)({},xhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}vhe.isMDXComponent=!0;const Lhe={toc:[]},bhe="wrapper";function Nhe(e){let{components:n,...t}=e;return(0,s.yg)(bhe,(0,p.A)({},Lhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Nhe.isMDXComponent=!0;const khe={toc:[]},zhe="wrapper";function Phe(e){let{components:n,...t}=e;return(0,s.yg)(zhe,(0,p.A)({},khe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}Phe.isMDXComponent=!0;const Ihe={toc:[]},Rhe="wrapper";function Whe(e){let{components:n,...t}=e;return(0,s.yg)(Rhe,(0,p.A)({},Ihe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Whe.isMDXComponent=!0;const She={toc:[]},Bhe="wrapper";function Ehe(e){let{components:n,...t}=e;return(0,s.yg)(Bhe,(0,p.A)({},She,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Ehe.isMDXComponent=!0;const Ghe={toc:[]},Ohe="wrapper";function Uhe(e){let{components:n,...t}=e;return(0,s.yg)(Ohe,(0,p.A)({},Ghe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}Uhe.isMDXComponent=!0;const Fhe={toc:[]},Vhe="wrapper";function qhe(e){let{components:n,...t}=e;return(0,s.yg)(Vhe,(0,p.A)({},Fhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}qhe.isMDXComponent=!0;const jhe={toc:[]},Hhe="wrapper";function Yhe(e){let{components:n,...t}=e;return(0,s.yg)(Hhe,(0,p.A)({},jhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Yhe.isMDXComponent=!0;const Qhe={toc:[]},$he="wrapper";function Khe(e){let{components:n,...t}=e;return(0,s.yg)($he,(0,p.A)({},Qhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}Khe.isMDXComponent=!0;const Jhe={toc:[]},Zhe="wrapper";function ege(e){let{components:n,...t}=e;return(0,s.yg)(Zhe,(0,p.A)({},Jhe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}ege.isMDXComponent=!0;const nge={toc:[]},tge="wrapper";function oge(e){let{components:n,...t}=e;return(0,s.yg)(tge,(0,p.A)({},nge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}oge.isMDXComponent=!0;const pge={toc:[]},rge="wrapper";function sge(e){let{components:n,...t}=e;return(0,s.yg)(rge,(0,p.A)({},pge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}sge.isMDXComponent=!0;const cge={toc:[]},age="wrapper";function ige(e){let{components:n,...t}=e;return(0,s.yg)(age,(0,p.A)({},cge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}ige.isMDXComponent=!0;const lge={toc:[]},uge="wrapper";function mge(e){let{components:n,...t}=e;return(0,s.yg)(uge,(0,p.A)({},lge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}mge.isMDXComponent=!0;const yge={toc:[]},dge="wrapper";function hge(e){let{components:n,...t}=e;return(0,s.yg)(dge,(0,p.A)({},yge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}hge.isMDXComponent=!0;const gge={toc:[]},fge="wrapper";function Dge(e){let{components:n,...t}=e;return(0,s.yg)(fge,(0,p.A)({},gge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}Dge.isMDXComponent=!0;const Mge={toc:[]},Xge="wrapper";function _ge(e){let{components:n,...t}=e;return(0,s.yg)(Xge,(0,p.A)({},Mge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}_ge.isMDXComponent=!0;const wge={toc:[]},Tge="wrapper";function Cge(e){let{components:n,...t}=e;return(0,s.yg)(Tge,(0,p.A)({},wge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}Cge.isMDXComponent=!0;const xge={toc:[]},Age="wrapper";function vge(e){let{components:n,...t}=e;return(0,s.yg)(Age,(0,p.A)({},xge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}vge.isMDXComponent=!0;const Lge={toc:[]},bge="wrapper";function Nge(e){let{components:n,...t}=e;return(0,s.yg)(bge,(0,p.A)({},Lge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Nge.isMDXComponent=!0;const kge={toc:[]},zge="wrapper";function Pge(e){let{components:n,...t}=e;return(0,s.yg)(zge,(0,p.A)({},kge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Pge.isMDXComponent=!0;const Ige={toc:[]},Rge="wrapper";function Wge(e){let{components:n,...t}=e;return(0,s.yg)(Rge,(0,p.A)({},Ige,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Wge.isMDXComponent=!0;const Sge={toc:[]},Bge="wrapper";function Ege(e){let{components:n,...t}=e;return(0,s.yg)(Bge,(0,p.A)({},Sge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Ege.isMDXComponent=!0;const Gge={toc:[]},Oge="wrapper";function Uge(e){let{components:n,...t}=e;return(0,s.yg)(Oge,(0,p.A)({},Gge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Uge.isMDXComponent=!0;const Fge={toc:[]},Vge="wrapper";function qge(e){let{components:n,...t}=e;return(0,s.yg)(Vge,(0,p.A)({},Fge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}qge.isMDXComponent=!0;const jge={toc:[]},Hge="wrapper";function Yge(e){let{components:n,...t}=e;return(0,s.yg)(Hge,(0,p.A)({},jge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Bezier#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Yge.isMDXComponent=!0;const Qge={toc:[]},$ge="wrapper";function Kge(e){let{components:n,...t}=e;return(0,s.yg)($ge,(0,p.A)({},Qge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Kge.isMDXComponent=!0;const Jge={toc:[]},Zge="wrapper";function efe(e){let{components:n,...t}=e;return(0,s.yg)(Zge,(0,p.A)({},Jge,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}efe.isMDXComponent=!0;const nfe={toc:[]},tfe="wrapper";function ofe(e){let{components:n,...t}=e;return(0,s.yg)(tfe,(0,p.A)({},nfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}ofe.isMDXComponent=!0;const pfe={toc:[]},rfe="wrapper";function sfe(e){let{components:n,...t}=e;return(0,s.yg)(rfe,(0,p.A)({},pfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}sfe.isMDXComponent=!0;const cfe={toc:[]},afe="wrapper";function ife(e){let{components:n,...t}=e;return(0,s.yg)(afe,(0,p.A)({},cfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}ife.isMDXComponent=!0;const lfe={toc:[]},ufe="wrapper";function mfe(e){let{components:n,...t}=e;return(0,s.yg)(ufe,(0,p.A)({},lfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}mfe.isMDXComponent=!0;const yfe={toc:[]},dfe="wrapper";function hfe(e){let{components:n,...t}=e;return(0,s.yg)(dfe,(0,p.A)({},yfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This node can be used to render shapes such as: circle, ellipse, arc, and\nsector (pie chart)."))}hfe.isMDXComponent=!0;const gfe={toc:[]},ffe="wrapper";function Dfe(e){let{components:n,...t}=e;return(0,s.yg)(ffe,(0,p.A)({},gfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Simple circle\nimport {makeScene2D, Circle} from '@revideo/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      size={160}\n      fill={'lightseagreen'}\n    />\n   );\n});\n\n// snippet Ellipse\nimport {makeScene2D, Circle} from '@revideo/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      width={160}\n      height={80}\n      fill={'lightseagreen'}\n    />\n  );\n});\n\n// snippet Sector (pie chart):\nimport {makeScene2D, Circle} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      fill={'lightseagreen'}\n      startAngle={30}\n      endAngle={270}\n      closed={true}\n    />\n  );\n\n  yield* ref().startAngle(270, 2).to(30, 2);\n});\n\n// snippet Arc:\nimport {makeScene2D, Circle} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      startAngle={-90}\n      endAngle={90}\n    />\n  );\n\n  yield* ref().startAngle(-270, 2).to(-90, 2);\n});\n\n// snippet Curve properties:\nimport {makeScene2D, Circle} from '@revideo/2d';\nimport {all, createRef, easeInCubic, easeOutCubic} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      endAngle={270}\n      endArrow\n    />,\n  );\n\n  yield* all(ref().start(1, 1), ref().rotation(180, 1, easeInCubic));\n  ref().start(0).end(0);\n  yield* all(ref().end(1, 1), ref().rotation(360, 1, easeOutCubic));\n});\n")))}Dfe.isMDXComponent=!0;const Mfe={toc:[]},Xfe="wrapper";function _fe(e){let{components:n,...t}=e;return(0,s.yg)(Xfe,(0,p.A)({},Mfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing circular shapes."))}_fe.isMDXComponent=!0;const wfe={toc:[]},Tfe="wrapper";function Cfe(e){let{components:n,...t}=e;return(0,s.yg)(Tfe,(0,p.A)({},wfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Cfe.isMDXComponent=!0;const xfe={toc:[]},Afe="wrapper";function vfe(e){let{components:n,...t}=e;return(0,s.yg)(Afe,(0,p.A)({},xfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}vfe.isMDXComponent=!0;const Lfe={toc:[]},bfe="wrapper";function Nfe(e){let{components:n,...t}=e;return(0,s.yg)(bfe,(0,p.A)({},Lfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Nfe.isMDXComponent=!0;const kfe={toc:[]},zfe="wrapper";function Pfe(e){let{components:n,...t}=e;return(0,s.yg)(zfe,(0,p.A)({},kfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}Pfe.isMDXComponent=!0;const Ife={toc:[]},Rfe="wrapper";function Wfe(e){let{components:n,...t}=e;return(0,s.yg)(Rfe,(0,p.A)({},Ife,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Wfe.isMDXComponent=!0;const Sfe={toc:[]},Bfe="wrapper";function Efe(e){let{components:n,...t}=e;return(0,s.yg)(Bfe,(0,p.A)({},Sfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}Efe.isMDXComponent=!0;const Gfe={toc:[]},Ofe="wrapper";function Ufe(e){let{components:n,...t}=e;return(0,s.yg)(Ofe,(0,p.A)({},Gfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Ufe.isMDXComponent=!0;const Ffe={toc:[]},Vfe="wrapper";function qfe(e){let{components:n,...t}=e;return(0,s.yg)(Vfe,(0,p.A)({},Ffe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}qfe.isMDXComponent=!0;const jfe={toc:[]},Hfe="wrapper";function Yfe(e){let{components:n,...t}=e;return(0,s.yg)(Hfe,(0,p.A)({},jfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Yfe.isMDXComponent=!0;const Qfe={toc:[]},$fe="wrapper";function Kfe(e){let{components:n,...t}=e;return(0,s.yg)($fe,(0,p.A)({},Qfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Kfe.isMDXComponent=!0;const Jfe={toc:[]},Zfe="wrapper";function eDe(e){let{components:n,...t}=e;return(0,s.yg)(Zfe,(0,p.A)({},Jfe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}eDe.isMDXComponent=!0;const nDe={toc:[]},tDe="wrapper";function oDe(e){let{components:n,...t}=e;return(0,s.yg)(tDe,(0,p.A)({},nDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}oDe.isMDXComponent=!0;const pDe={toc:[]},rDe="wrapper";function sDe(e){let{components:n,...t}=e;return(0,s.yg)(rDe,(0,p.A)({},pDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}sDe.isMDXComponent=!0;const cDe={toc:[]},aDe="wrapper";function iDe(e){let{components:n,...t}=e;return(0,s.yg)(aDe,(0,p.A)({},cDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}iDe.isMDXComponent=!0;const lDe={toc:[]},uDe="wrapper";function mDe(e){let{components:n,...t}=e;return(0,s.yg)(uDe,(0,p.A)({},lDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}mDe.isMDXComponent=!0;const yDe={toc:[]},dDe="wrapper";function hDe(e){let{components:n,...t}=e;return(0,s.yg)(dDe,(0,p.A)({},yDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}hDe.isMDXComponent=!0;const gDe={toc:[]},fDe="wrapper";function DDe(e){let{components:n,...t}=e;return(0,s.yg)(fDe,(0,p.A)({},gDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}DDe.isMDXComponent=!0;const MDe={toc:[]},XDe="wrapper";function _De(e){let{components:n,...t}=e;return(0,s.yg)(XDe,(0,p.A)({},MDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A closed circle will look like a pie chart:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  fill={'lightseagreen'}\n  endAngle={230}\n  closed={true}\n/>\n")),(0,s.yg)("p",null,"An open one will look like an arc:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  stroke={'lightseagreen'}\n  lineWidth={8}\n  endAngle={230}\n  closed={false}\n/>\n")))}_De.isMDXComponent=!0;const wDe={toc:[]},TDe="wrapper";function CDe(e){let{components:n,...t}=e;return(0,s.yg)(TDe,(0,p.A)({},wDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"false"))}CDe.isMDXComponent=!0;const xDe={toc:[]},ADe="wrapper";function vDe(e){let{components:n,...t}=e;return(0,s.yg)(ADe,(0,p.A)({},xDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the path of this circle should be closed."))}vDe.isMDXComponent=!0;const LDe={toc:[]},bDe="wrapper";function NDe(e){let{components:n,...t}=e;return(0,s.yg)(bDe,(0,p.A)({},LDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the circle begins at ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"startAngle"))," and is drawn clockwise\nuntil reaching ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"endAngle")),". Setting this property to true will reverse\nthis direction."))}NDe.isMDXComponent=!0;const kDe={toc:[]},zDe="wrapper";function PDe(e){let{components:n,...t}=e;return(0,s.yg)(zDe,(0,p.A)({},kDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the circle sector should be drawn counterclockwise."))}PDe.isMDXComponent=!0;const IDe={toc:[]},RDe="wrapper";function WDe(e){let{components:n,...t}=e;return(0,s.yg)(RDe,(0,p.A)({},IDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}WDe.isMDXComponent=!0;const SDe={toc:[]},BDe="wrapper";function EDe(e){let{components:n,...t}=e;return(0,s.yg)(BDe,(0,p.A)({},SDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}EDe.isMDXComponent=!0;const GDe={toc:[]},ODe="wrapper";function UDe(e){let{components:n,...t}=e;return(0,s.yg)(ODe,(0,p.A)({},GDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property can be used together with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}UDe.isMDXComponent=!0;const FDe={toc:[]},VDe="wrapper";function qDe(e){let{components:n,...t}=e;return(0,s.yg)(VDe,(0,p.A)({},FDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"360"))}qDe.isMDXComponent=!0;const jDe={toc:[]},HDe="wrapper";function YDe(e){let{components:n,...t}=e;return(0,s.yg)(HDe,(0,p.A)({},jDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ending angle in degrees for the circle sector."))}YDe.isMDXComponent=!0;const QDe={toc:[]},$De="wrapper";function KDe(e){let{components:n,...t}=e;return(0,s.yg)($De,(0,p.A)({},QDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}KDe.isMDXComponent=!0;const JDe={toc:[]},ZDe="wrapper";function eMe(e){let{components:n,...t}=e;return(0,s.yg)(ZDe,(0,p.A)({},JDe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}eMe.isMDXComponent=!0;const nMe={toc:[]},tMe="wrapper";function oMe(e){let{components:n,...t}=e;return(0,s.yg)(tMe,(0,p.A)({},nMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}oMe.isMDXComponent=!0;const pMe={toc:[]},rMe="wrapper";function sMe(e){let{components:n,...t}=e;return(0,s.yg)(rMe,(0,p.A)({},pMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}sMe.isMDXComponent=!0;const cMe={toc:[]},aMe="wrapper";function iMe(e){let{components:n,...t}=e;return(0,s.yg)(aMe,(0,p.A)({},cMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}iMe.isMDXComponent=!0;const lMe={toc:[]},uMe="wrapper";function mMe(e){let{components:n,...t}=e;return(0,s.yg)(uMe,(0,p.A)({},lMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}mMe.isMDXComponent=!0;const yMe={toc:[]},dMe="wrapper";function hMe(e){let{components:n,...t}=e;return(0,s.yg)(dMe,(0,p.A)({},yMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}hMe.isMDXComponent=!0;const gMe={toc:[]},fMe="wrapper";function DMe(e){let{components:n,...t}=e;return(0,s.yg)(fMe,(0,p.A)({},gMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}DMe.isMDXComponent=!0;const MMe={toc:[]},XMe="wrapper";function _Me(e){let{components:n,...t}=e;return(0,s.yg)(XMe,(0,p.A)({},MMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}_Me.isMDXComponent=!0;const wMe={toc:[]},TMe="wrapper";function CMe(e){let{components:n,...t}=e;return(0,s.yg)(TMe,(0,p.A)({},wMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}CMe.isMDXComponent=!0;const xMe={toc:[]},AMe="wrapper";function vMe(e){let{components:n,...t}=e;return(0,s.yg)(AMe,(0,p.A)({},xMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}vMe.isMDXComponent=!0;const LMe={toc:[]},bMe="wrapper";function NMe(e){let{components:n,...t}=e;return(0,s.yg)(bMe,(0,p.A)({},LMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}NMe.isMDXComponent=!0;const kMe={toc:[]},zMe="wrapper";function PMe(e){let{components:n,...t}=e;return(0,s.yg)(zMe,(0,p.A)({},kMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}PMe.isMDXComponent=!0;const IMe={toc:[]},RMe="wrapper";function WMe(e){let{components:n,...t}=e;return(0,s.yg)(RMe,(0,p.A)({},IMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}WMe.isMDXComponent=!0;const SMe={toc:[]},BMe="wrapper";function EMe(e){let{components:n,...t}=e;return(0,s.yg)(BMe,(0,p.A)({},SMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}EMe.isMDXComponent=!0;const GMe={toc:[]},OMe="wrapper";function UMe(e){let{components:n,...t}=e;return(0,s.yg)(OMe,(0,p.A)({},GMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}UMe.isMDXComponent=!0;const FMe={toc:[]},VMe="wrapper";function qMe(e){let{components:n,...t}=e;return(0,s.yg)(VMe,(0,p.A)({},FMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}qMe.isMDXComponent=!0;const jMe={toc:[]},HMe="wrapper";function YMe(e){let{components:n,...t}=e;return(0,s.yg)(HMe,(0,p.A)({},jMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}YMe.isMDXComponent=!0;const QMe={toc:[]},$Me="wrapper";function KMe(e){let{components:n,...t}=e;return(0,s.yg)($Me,(0,p.A)({},QMe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}KMe.isMDXComponent=!0;const JMe={toc:[]},ZMe="wrapper";function eXe(e){let{components:n,...t}=e;return(0,s.yg)(ZMe,(0,p.A)({},JMe,t,{components:n,mdxType:"MDXLayout"}))}eXe.isMDXComponent=!0;const nXe={toc:[]},tXe="wrapper";function oXe(e){let{components:n,...t}=e;return(0,s.yg)(tXe,(0,p.A)({},nXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}oXe.isMDXComponent=!0;const pXe={toc:[]},rXe="wrapper";function sXe(e){let{components:n,...t}=e;return(0,s.yg)(rXe,(0,p.A)({},pXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}sXe.isMDXComponent=!0;const cXe={toc:[]},aXe="wrapper";function iXe(e){let{components:n,...t}=e;return(0,s.yg)(aXe,(0,p.A)({},cXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}iXe.isMDXComponent=!0;const lXe={toc:[]},uXe="wrapper";function mXe(e){let{components:n,...t}=e;return(0,s.yg)(uXe,(0,p.A)({},lXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}mXe.isMDXComponent=!0;const yXe={toc:[]},dXe="wrapper";function hXe(e){let{components:n,...t}=e;return(0,s.yg)(dXe,(0,p.A)({},yXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}hXe.isMDXComponent=!0;const gXe={toc:[]},fXe="wrapper";function DXe(e){let{components:n,...t}=e;return(0,s.yg)(fXe,(0,p.A)({},gXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}DXe.isMDXComponent=!0;const MXe={toc:[]},XXe="wrapper";function _Xe(e){let{components:n,...t}=e;return(0,s.yg)(XXe,(0,p.A)({},MXe,t,{components:n,mdxType:"MDXLayout"}))}_Xe.isMDXComponent=!0;const wXe={toc:[]},TXe="wrapper";function CXe(e){let{components:n,...t}=e;return(0,s.yg)(TXe,(0,p.A)({},wXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}CXe.isMDXComponent=!0;const xXe={toc:[]},AXe="wrapper";function vXe(e){let{components:n,...t}=e;return(0,s.yg)(AXe,(0,p.A)({},xXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}vXe.isMDXComponent=!0;const LXe={toc:[]},bXe="wrapper";function NXe(e){let{components:n,...t}=e;return(0,s.yg)(bXe,(0,p.A)({},LXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property can be used together with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}NXe.isMDXComponent=!0;const kXe={toc:[]},zXe="wrapper";function PXe(e){let{components:n,...t}=e;return(0,s.yg)(zXe,(0,p.A)({},kXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"0"))}PXe.isMDXComponent=!0;const IXe={toc:[]},RXe="wrapper";function WXe(e){let{components:n,...t}=e;return(0,s.yg)(RXe,(0,p.A)({},IXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The starting angle in degrees for the circle sector."))}WXe.isMDXComponent=!0;const SXe={toc:[]},BXe="wrapper";function EXe(e){let{components:n,...t}=e;return(0,s.yg)(BXe,(0,p.A)({},SXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}EXe.isMDXComponent=!0;const GXe={toc:[]},OXe="wrapper";function UXe(e){let{components:n,...t}=e;return(0,s.yg)(OXe,(0,p.A)({},GXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}UXe.isMDXComponent=!0;const FXe={toc:[]},VXe="wrapper";function qXe(e){let{components:n,...t}=e;return(0,s.yg)(VXe,(0,p.A)({},FXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}qXe.isMDXComponent=!0;const jXe={toc:[]},HXe="wrapper";function YXe(e){let{components:n,...t}=e;return(0,s.yg)(HXe,(0,p.A)({},jXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}YXe.isMDXComponent=!0;const QXe={toc:[]},$Xe="wrapper";function KXe(e){let{components:n,...t}=e;return(0,s.yg)($Xe,(0,p.A)({},QXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}KXe.isMDXComponent=!0;const JXe={toc:[]},ZXe="wrapper";function e_e(e){let{components:n,...t}=e;return(0,s.yg)(ZXe,(0,p.A)({},JXe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}e_e.isMDXComponent=!0;const n_e={toc:[]},t_e="wrapper";function o_e(e){let{components:n,...t}=e;return(0,s.yg)(t_e,(0,p.A)({},n_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}o_e.isMDXComponent=!0;const p_e={toc:[]},r_e="wrapper";function s_e(e){let{components:n,...t}=e;return(0,s.yg)(r_e,(0,p.A)({},p_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}s_e.isMDXComponent=!0;const c_e={toc:[]},a_e="wrapper";function i_e(e){let{components:n,...t}=e;return(0,s.yg)(a_e,(0,p.A)({},c_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}i_e.isMDXComponent=!0;const l_e={toc:[]},u_e="wrapper";function m_e(e){let{components:n,...t}=e;return(0,s.yg)(u_e,(0,p.A)({},l_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}m_e.isMDXComponent=!0;const y_e={toc:[]},d_e="wrapper";function h_e(e){let{components:n,...t}=e;return(0,s.yg)(d_e,(0,p.A)({},y_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}h_e.isMDXComponent=!0;const g_e={toc:[]},f_e="wrapper";function D_e(e){let{components:n,...t}=e;return(0,s.yg)(f_e,(0,p.A)({},g_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}D_e.isMDXComponent=!0;const M_e={toc:[]},X_e="wrapper";function __e(e){let{components:n,...t}=e;return(0,s.yg)(X_e,(0,p.A)({},M_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}__e.isMDXComponent=!0;const w_e={toc:[]},T_e="wrapper";function C_e(e){let{components:n,...t}=e;return(0,s.yg)(T_e,(0,p.A)({},w_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}C_e.isMDXComponent=!0;const x_e={toc:[]},A_e="wrapper";function v_e(e){let{components:n,...t}=e;return(0,s.yg)(A_e,(0,p.A)({},x_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}v_e.isMDXComponent=!0;const L_e={toc:[]},b_e="wrapper";function N_e(e){let{components:n,...t}=e;return(0,s.yg)(b_e,(0,p.A)({},L_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}N_e.isMDXComponent=!0;const k_e={toc:[]},z_e="wrapper";function P_e(e){let{components:n,...t}=e;return(0,s.yg)(z_e,(0,p.A)({},k_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}P_e.isMDXComponent=!0;const I_e={toc:[]},R_e="wrapper";function W_e(e){let{components:n,...t}=e;return(0,s.yg)(R_e,(0,p.A)({},I_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}W_e.isMDXComponent=!0;const S_e={toc:[]},B_e="wrapper";function E_e(e){let{components:n,...t}=e;return(0,s.yg)(B_e,(0,p.A)({},S_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}E_e.isMDXComponent=!0;const G_e={toc:[]},O_e="wrapper";function U_e(e){let{components:n,...t}=e;return(0,s.yg)(O_e,(0,p.A)({},G_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}U_e.isMDXComponent=!0;const F_e={toc:[]},V_e="wrapper";function q_e(e){let{components:n,...t}=e;return(0,s.yg)(V_e,(0,p.A)({},F_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}q_e.isMDXComponent=!0;const j_e={toc:[]},H_e="wrapper";function Y_e(e){let{components:n,...t}=e;return(0,s.yg)(H_e,(0,p.A)({},j_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}Y_e.isMDXComponent=!0;const Q_e={toc:[]},$_e="wrapper";function K_e(e){let{components:n,...t}=e;return(0,s.yg)($_e,(0,p.A)({},Q_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}K_e.isMDXComponent=!0;const J_e={toc:[]},Z_e="wrapper";function ewe(e){let{components:n,...t}=e;return(0,s.yg)(Z_e,(0,p.A)({},J_e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}ewe.isMDXComponent=!0;const nwe={toc:[]},twe="wrapper";function owe(e){let{components:n,...t}=e;return(0,s.yg)(twe,(0,p.A)({},nwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}owe.isMDXComponent=!0;const pwe={toc:[]},rwe="wrapper";function swe(e){let{components:n,...t}=e;return(0,s.yg)(rwe,(0,p.A)({},pwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}swe.isMDXComponent=!0;const cwe={toc:[]},awe="wrapper";function iwe(e){let{components:n,...t}=e;return(0,s.yg)(awe,(0,p.A)({},cwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}iwe.isMDXComponent=!0;const lwe={toc:[]},uwe="wrapper";function mwe(e){let{components:n,...t}=e;return(0,s.yg)(uwe,(0,p.A)({},lwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}mwe.isMDXComponent=!0;const ywe={toc:[]},dwe="wrapper";function hwe(e){let{components:n,...t}=e;return(0,s.yg)(dwe,(0,p.A)({},ywe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}hwe.isMDXComponent=!0;const gwe={toc:[]},fwe="wrapper";function Dwe(e){let{components:n,...t}=e;return(0,s.yg)(fwe,(0,p.A)({},gwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Dwe.isMDXComponent=!0;const Mwe={toc:[]},Xwe="wrapper";function _we(e){let{components:n,...t}=e;return(0,s.yg)(Xwe,(0,p.A)({},Mwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}_we.isMDXComponent=!0;const wwe={toc:[]},Twe="wrapper";function Cwe(e){let{components:n,...t}=e;return(0,s.yg)(Twe,(0,p.A)({},wwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}Cwe.isMDXComponent=!0;const xwe={toc:[]},Awe="wrapper";function vwe(e){let{components:n,...t}=e;return(0,s.yg)(Awe,(0,p.A)({},xwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}vwe.isMDXComponent=!0;const Lwe={toc:[]},bwe="wrapper";function Nwe(e){let{components:n,...t}=e;return(0,s.yg)(bwe,(0,p.A)({},Lwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}Nwe.isMDXComponent=!0;const kwe={toc:[]},zwe="wrapper";function Pwe(e){let{components:n,...t}=e;return(0,s.yg)(zwe,(0,p.A)({},kwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Pwe.isMDXComponent=!0;const Iwe={toc:[]},Rwe="wrapper";function Wwe(e){let{components:n,...t}=e;return(0,s.yg)(Rwe,(0,p.A)({},Iwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}Wwe.isMDXComponent=!0;const Swe={toc:[]},Bwe="wrapper";function Ewe(e){let{components:n,...t}=e;return(0,s.yg)(Bwe,(0,p.A)({},Swe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Ewe.isMDXComponent=!0;const Gwe={toc:[]},Owe="wrapper";function Uwe(e){let{components:n,...t}=e;return(0,s.yg)(Owe,(0,p.A)({},Gwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}Uwe.isMDXComponent=!0;const Fwe={toc:[]},Vwe="wrapper";function qwe(e){let{components:n,...t}=e;return(0,s.yg)(Vwe,(0,p.A)({},Fwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}qwe.isMDXComponent=!0;const jwe={toc:[]},Hwe="wrapper";function Ywe(e){let{components:n,...t}=e;return(0,s.yg)(Hwe,(0,p.A)({},jwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}Ywe.isMDXComponent=!0;const Qwe={toc:[]},$we="wrapper";function Kwe(e){let{components:n,...t}=e;return(0,s.yg)($we,(0,p.A)({},Qwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Kwe.isMDXComponent=!0;const Jwe={toc:[]},Zwe="wrapper";function eTe(e){let{components:n,...t}=e;return(0,s.yg)(Zwe,(0,p.A)({},Jwe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}eTe.isMDXComponent=!0;const nTe={toc:[]},tTe="wrapper";function oTe(e){let{components:n,...t}=e;return(0,s.yg)(tTe,(0,p.A)({},nTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}oTe.isMDXComponent=!0;const pTe={toc:[]},rTe="wrapper";function sTe(e){let{components:n,...t}=e;return(0,s.yg)(rTe,(0,p.A)({},pTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}sTe.isMDXComponent=!0;const cTe={toc:[]},aTe="wrapper";function iTe(e){let{components:n,...t}=e;return(0,s.yg)(aTe,(0,p.A)({},cTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}iTe.isMDXComponent=!0;const lTe={toc:[]},uTe="wrapper";function mTe(e){let{components:n,...t}=e;return(0,s.yg)(uTe,(0,p.A)({},lTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}mTe.isMDXComponent=!0;const yTe={toc:[]},dTe="wrapper";function hTe(e){let{components:n,...t}=e;return(0,s.yg)(dTe,(0,p.A)({},yTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}hTe.isMDXComponent=!0;const gTe={toc:[]},fTe="wrapper";function DTe(e){let{components:n,...t}=e;return(0,s.yg)(fTe,(0,p.A)({},gTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}DTe.isMDXComponent=!0;const MTe={toc:[]},XTe="wrapper";function _Te(e){let{components:n,...t}=e;return(0,s.yg)(XTe,(0,p.A)({},MTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}_Te.isMDXComponent=!0;const wTe={toc:[]},TTe="wrapper";function CTe(e){let{components:n,...t}=e;return(0,s.yg)(TTe,(0,p.A)({},wTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}CTe.isMDXComponent=!0;const xTe={toc:[]},ATe="wrapper";function vTe(e){let{components:n,...t}=e;return(0,s.yg)(ATe,(0,p.A)({},xTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}vTe.isMDXComponent=!0;const LTe={toc:[]},bTe="wrapper";function NTe(e){let{components:n,...t}=e;return(0,s.yg)(bTe,(0,p.A)({},LTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}NTe.isMDXComponent=!0;const kTe={toc:[]},zTe="wrapper";function PTe(e){let{components:n,...t}=e;return(0,s.yg)(zTe,(0,p.A)({},kTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}PTe.isMDXComponent=!0;const ITe={toc:[]},RTe="wrapper";function WTe(e){let{components:n,...t}=e;return(0,s.yg)(RTe,(0,p.A)({},ITe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}WTe.isMDXComponent=!0;const STe={toc:[]},BTe="wrapper";function ETe(e){let{components:n,...t}=e;return(0,s.yg)(BTe,(0,p.A)({},STe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}ETe.isMDXComponent=!0;const GTe={toc:[]},OTe="wrapper";function UTe(e){let{components:n,...t}=e;return(0,s.yg)(OTe,(0,p.A)({},GTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}UTe.isMDXComponent=!0;const FTe={toc:[]},VTe="wrapper";function qTe(e){let{components:n,...t}=e;return(0,s.yg)(VTe,(0,p.A)({},FTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}qTe.isMDXComponent=!0;const jTe={toc:[]},HTe="wrapper";function YTe(e){let{components:n,...t}=e;return(0,s.yg)(HTe,(0,p.A)({},jTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}YTe.isMDXComponent=!0;const QTe={toc:[]},$Te="wrapper";function KTe(e){let{components:n,...t}=e;return(0,s.yg)($Te,(0,p.A)({},QTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}KTe.isMDXComponent=!0;const JTe={toc:[]},ZTe="wrapper";function eCe(e){let{components:n,...t}=e;return(0,s.yg)(ZTe,(0,p.A)({},JTe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}eCe.isMDXComponent=!0;const nCe={toc:[]},tCe="wrapper";function oCe(e){let{components:n,...t}=e;return(0,s.yg)(tCe,(0,p.A)({},nCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}oCe.isMDXComponent=!0;const pCe={toc:[]},rCe="wrapper";function sCe(e){let{components:n,...t}=e;return(0,s.yg)(rCe,(0,p.A)({},pCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}sCe.isMDXComponent=!0;const cCe={toc:[]},aCe="wrapper";function iCe(e){let{components:n,...t}=e;return(0,s.yg)(aCe,(0,p.A)({},cCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}iCe.isMDXComponent=!0;const lCe={toc:[]},uCe="wrapper";function mCe(e){let{components:n,...t}=e;return(0,s.yg)(uCe,(0,p.A)({},lCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}mCe.isMDXComponent=!0;const yCe={toc:[]},dCe="wrapper";function hCe(e){let{components:n,...t}=e;return(0,s.yg)(dCe,(0,p.A)({},yCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}hCe.isMDXComponent=!0;const gCe={toc:[]},fCe="wrapper";function DCe(e){let{components:n,...t}=e;return(0,s.yg)(fCe,(0,p.A)({},gCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}DCe.isMDXComponent=!0;const MCe={toc:[]},XCe="wrapper";function _Ce(e){let{components:n,...t}=e;return(0,s.yg)(XCe,(0,p.A)({},MCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}_Ce.isMDXComponent=!0;const wCe={toc:[]},TCe="wrapper";function CCe(e){let{components:n,...t}=e;return(0,s.yg)(TCe,(0,p.A)({},wCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}CCe.isMDXComponent=!0;const xCe={toc:[]},ACe="wrapper";function vCe(e){let{components:n,...t}=e;return(0,s.yg)(ACe,(0,p.A)({},xCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}vCe.isMDXComponent=!0;const LCe={toc:[]},bCe="wrapper";function NCe(e){let{components:n,...t}=e;return(0,s.yg)(bCe,(0,p.A)({},LCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}NCe.isMDXComponent=!0;const kCe={toc:[]},zCe="wrapper";function PCe(e){let{components:n,...t}=e;return(0,s.yg)(zCe,(0,p.A)({},kCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}PCe.isMDXComponent=!0;const ICe={toc:[]},RCe="wrapper";function WCe(e){let{components:n,...t}=e;return(0,s.yg)(RCe,(0,p.A)({},ICe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}WCe.isMDXComponent=!0;const SCe={toc:[]},BCe="wrapper";function ECe(e){let{components:n,...t}=e;return(0,s.yg)(BCe,(0,p.A)({},SCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}ECe.isMDXComponent=!0;const GCe={toc:[]},OCe="wrapper";function UCe(e){let{components:n,...t}=e;return(0,s.yg)(OCe,(0,p.A)({},GCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}UCe.isMDXComponent=!0;const FCe={toc:[]},VCe="wrapper";function qCe(e){let{components:n,...t}=e;return(0,s.yg)(VCe,(0,p.A)({},FCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}qCe.isMDXComponent=!0;const jCe={toc:[]},HCe="wrapper";function YCe(e){let{components:n,...t}=e;return(0,s.yg)(HCe,(0,p.A)({},jCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}YCe.isMDXComponent=!0;const QCe={toc:[]},$Ce="wrapper";function KCe(e){let{components:n,...t}=e;return(0,s.yg)($Ce,(0,p.A)({},QCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}KCe.isMDXComponent=!0;const JCe={toc:[]},ZCe="wrapper";function exe(e){let{components:n,...t}=e;return(0,s.yg)(ZCe,(0,p.A)({},JCe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}exe.isMDXComponent=!0;const nxe={toc:[]},txe="wrapper";function oxe(e){let{components:n,...t}=e;return(0,s.yg)(txe,(0,p.A)({},nxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}oxe.isMDXComponent=!0;const pxe={toc:[]},rxe="wrapper";function sxe(e){let{components:n,...t}=e;return(0,s.yg)(rxe,(0,p.A)({},pxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}sxe.isMDXComponent=!0;const cxe={toc:[]},axe="wrapper";function ixe(e){let{components:n,...t}=e;return(0,s.yg)(axe,(0,p.A)({},cxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}ixe.isMDXComponent=!0;const lxe={toc:[]},uxe="wrapper";function mxe(e){let{components:n,...t}=e;return(0,s.yg)(uxe,(0,p.A)({},lxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}mxe.isMDXComponent=!0;const yxe={toc:[]},dxe="wrapper";function hxe(e){let{components:n,...t}=e;return(0,s.yg)(dxe,(0,p.A)({},yxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}hxe.isMDXComponent=!0;const gxe={toc:[]},fxe="wrapper";function Dxe(e){let{components:n,...t}=e;return(0,s.yg)(fxe,(0,p.A)({},gxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}Dxe.isMDXComponent=!0;const Mxe={toc:[]},Xxe="wrapper";function _xe(e){let{components:n,...t}=e;return(0,s.yg)(Xxe,(0,p.A)({},Mxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}_xe.isMDXComponent=!0;const wxe={toc:[]},Txe="wrapper";function Cxe(e){let{components:n,...t}=e;return(0,s.yg)(Txe,(0,p.A)({},wxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Cxe.isMDXComponent=!0;const xxe={toc:[]},Axe="wrapper";function vxe(e){let{components:n,...t}=e;return(0,s.yg)(Axe,(0,p.A)({},xxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}vxe.isMDXComponent=!0;const Lxe={toc:[]},bxe="wrapper";function Nxe(e){let{components:n,...t}=e;return(0,s.yg)(bxe,(0,p.A)({},Lxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Nxe.isMDXComponent=!0;const kxe={toc:[]},zxe="wrapper";function Pxe(e){let{components:n,...t}=e;return(0,s.yg)(zxe,(0,p.A)({},kxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}Pxe.isMDXComponent=!0;const Ixe={toc:[]},Rxe="wrapper";function Wxe(e){let{components:n,...t}=e;return(0,s.yg)(Rxe,(0,p.A)({},Ixe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}Wxe.isMDXComponent=!0;const Sxe={toc:[]},Bxe="wrapper";function Exe(e){let{components:n,...t}=e;return(0,s.yg)(Bxe,(0,p.A)({},Sxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Exe.isMDXComponent=!0;const Gxe={toc:[]},Oxe="wrapper";function Uxe(e){let{components:n,...t}=e;return(0,s.yg)(Oxe,(0,p.A)({},Gxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}Uxe.isMDXComponent=!0;const Fxe={toc:[]},Vxe="wrapper";function qxe(e){let{components:n,...t}=e;return(0,s.yg)(Vxe,(0,p.A)({},Fxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}qxe.isMDXComponent=!0;const jxe={toc:[]},Hxe="wrapper";function Yxe(e){let{components:n,...t}=e;return(0,s.yg)(Hxe,(0,p.A)({},jxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Yxe.isMDXComponent=!0;const Qxe={toc:[]},$xe="wrapper";function Kxe(e){let{components:n,...t}=e;return(0,s.yg)($xe,(0,p.A)({},Qxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Kxe.isMDXComponent=!0;const Jxe={toc:[]},Zxe="wrapper";function eAe(e){let{components:n,...t}=e;return(0,s.yg)(Zxe,(0,p.A)({},Jxe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}eAe.isMDXComponent=!0;const nAe={toc:[]},tAe="wrapper";function oAe(e){let{components:n,...t}=e;return(0,s.yg)(tAe,(0,p.A)({},nAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}oAe.isMDXComponent=!0;const pAe={toc:[]},rAe="wrapper";function sAe(e){let{components:n,...t}=e;return(0,s.yg)(rAe,(0,p.A)({},pAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}sAe.isMDXComponent=!0;const cAe={toc:[]},aAe="wrapper";function iAe(e){let{components:n,...t}=e;return(0,s.yg)(aAe,(0,p.A)({},cAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}iAe.isMDXComponent=!0;const lAe={toc:[]},uAe="wrapper";function mAe(e){let{components:n,...t}=e;return(0,s.yg)(uAe,(0,p.A)({},lAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}mAe.isMDXComponent=!0;const yAe={toc:[]},dAe="wrapper";function hAe(e){let{components:n,...t}=e;return(0,s.yg)(dAe,(0,p.A)({},yAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}hAe.isMDXComponent=!0;const gAe={toc:[]},fAe="wrapper";function DAe(e){let{components:n,...t}=e;return(0,s.yg)(fAe,(0,p.A)({},gAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}DAe.isMDXComponent=!0;const MAe={toc:[]},XAe="wrapper";function _Ae(e){let{components:n,...t}=e;return(0,s.yg)(XAe,(0,p.A)({},MAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}_Ae.isMDXComponent=!0;const wAe={toc:[]},TAe="wrapper";function CAe(e){let{components:n,...t}=e;return(0,s.yg)(TAe,(0,p.A)({},wAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}CAe.isMDXComponent=!0;const xAe={toc:[]},AAe="wrapper";function vAe(e){let{components:n,...t}=e;return(0,s.yg)(AAe,(0,p.A)({},xAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}vAe.isMDXComponent=!0;const LAe={toc:[]},bAe="wrapper";function NAe(e){let{components:n,...t}=e;return(0,s.yg)(bAe,(0,p.A)({},LAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}NAe.isMDXComponent=!0;const kAe={toc:[]},zAe="wrapper";function PAe(e){let{components:n,...t}=e;return(0,s.yg)(zAe,(0,p.A)({},kAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}PAe.isMDXComponent=!0;const IAe={toc:[]},RAe="wrapper";function WAe(e){let{components:n,...t}=e;return(0,s.yg)(RAe,(0,p.A)({},IAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}WAe.isMDXComponent=!0;const SAe={toc:[]},BAe="wrapper";function EAe(e){let{components:n,...t}=e;return(0,s.yg)(BAe,(0,p.A)({},SAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}EAe.isMDXComponent=!0;const GAe={toc:[]},OAe="wrapper";function UAe(e){let{components:n,...t}=e;return(0,s.yg)(OAe,(0,p.A)({},GAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}UAe.isMDXComponent=!0;const FAe={toc:[]},VAe="wrapper";function qAe(e){let{components:n,...t}=e;return(0,s.yg)(VAe,(0,p.A)({},FAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}qAe.isMDXComponent=!0;const jAe={toc:[]},HAe="wrapper";function YAe(e){let{components:n,...t}=e;return(0,s.yg)(HAe,(0,p.A)({},jAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}YAe.isMDXComponent=!0;const QAe={toc:[]},$Ae="wrapper";function KAe(e){let{components:n,...t}=e;return(0,s.yg)($Ae,(0,p.A)({},QAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}KAe.isMDXComponent=!0;const JAe={toc:[]},ZAe="wrapper";function eve(e){let{components:n,...t}=e;return(0,s.yg)(ZAe,(0,p.A)({},JAe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}eve.isMDXComponent=!0;const nve={toc:[]},tve="wrapper";function ove(e){let{components:n,...t}=e;return(0,s.yg)(tve,(0,p.A)({},nve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}ove.isMDXComponent=!0;const pve={toc:[]},rve="wrapper";function sve(e){let{components:n,...t}=e;return(0,s.yg)(rve,(0,p.A)({},pve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}sve.isMDXComponent=!0;const cve={toc:[]},ave="wrapper";function ive(e){let{components:n,...t}=e;return(0,s.yg)(ave,(0,p.A)({},cve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}ive.isMDXComponent=!0;const lve={toc:[]},uve="wrapper";function mve(e){let{components:n,...t}=e;return(0,s.yg)(uve,(0,p.A)({},lve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}mve.isMDXComponent=!0;const yve={toc:[]},dve="wrapper";function hve(e){let{components:n,...t}=e;return(0,s.yg)(dve,(0,p.A)({},yve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}hve.isMDXComponent=!0;const gve={toc:[]},fve="wrapper";function Dve(e){let{components:n,...t}=e;return(0,s.yg)(fve,(0,p.A)({},gve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}Dve.isMDXComponent=!0;const Mve={toc:[]},Xve="wrapper";function _ve(e){let{components:n,...t}=e;return(0,s.yg)(Xve,(0,p.A)({},Mve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}_ve.isMDXComponent=!0;const wve={toc:[]},Tve="wrapper";function Cve(e){let{components:n,...t}=e;return(0,s.yg)(Tve,(0,p.A)({},wve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Cve.isMDXComponent=!0;const xve={toc:[]},Ave="wrapper";function vve(e){let{components:n,...t}=e;return(0,s.yg)(Ave,(0,p.A)({},xve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}vve.isMDXComponent=!0;const Lve={toc:[]},bve="wrapper";function Nve(e){let{components:n,...t}=e;return(0,s.yg)(bve,(0,p.A)({},Lve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Nve.isMDXComponent=!0;const kve={toc:[]},zve="wrapper";function Pve(e){let{components:n,...t}=e;return(0,s.yg)(zve,(0,p.A)({},kve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}Pve.isMDXComponent=!0;const Ive={toc:[]},Rve="wrapper";function Wve(e){let{components:n,...t}=e;return(0,s.yg)(Rve,(0,p.A)({},Ive,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}Wve.isMDXComponent=!0;const Sve={toc:[]},Bve="wrapper";function Eve(e){let{components:n,...t}=e;return(0,s.yg)(Bve,(0,p.A)({},Sve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}Eve.isMDXComponent=!0;const Gve={toc:[]},Ove="wrapper";function Uve(e){let{components:n,...t}=e;return(0,s.yg)(Ove,(0,p.A)({},Gve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}Uve.isMDXComponent=!0;const Fve={toc:[]},Vve="wrapper";function qve(e){let{components:n,...t}=e;return(0,s.yg)(Vve,(0,p.A)({},Fve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}qve.isMDXComponent=!0;const jve={toc:[]},Hve="wrapper";function Yve(e){let{components:n,...t}=e;return(0,s.yg)(Hve,(0,p.A)({},jve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Yve.isMDXComponent=!0;const Qve={toc:[]},$ve="wrapper";function Kve(e){let{components:n,...t}=e;return(0,s.yg)($ve,(0,p.A)({},Qve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Kve.isMDXComponent=!0;const Jve={toc:[]},Zve="wrapper";function eLe(e){let{components:n,...t}=e;return(0,s.yg)(Zve,(0,p.A)({},Jve,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}eLe.isMDXComponent=!0;const nLe={toc:[]},tLe="wrapper";function oLe(e){let{components:n,...t}=e;return(0,s.yg)(tLe,(0,p.A)({},nLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}oLe.isMDXComponent=!0;const pLe={toc:[]},rLe="wrapper";function sLe(e){let{components:n,...t}=e;return(0,s.yg)(rLe,(0,p.A)({},pLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}sLe.isMDXComponent=!0;const cLe={toc:[]},aLe="wrapper";function iLe(e){let{components:n,...t}=e;return(0,s.yg)(aLe,(0,p.A)({},cLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}iLe.isMDXComponent=!0;const lLe={toc:[]},uLe="wrapper";function mLe(e){let{components:n,...t}=e;return(0,s.yg)(uLe,(0,p.A)({},lLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}mLe.isMDXComponent=!0;const yLe={toc:[]},dLe="wrapper";function hLe(e){let{components:n,...t}=e;return(0,s.yg)(dLe,(0,p.A)({},yLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}hLe.isMDXComponent=!0;const gLe={toc:[]},fLe="wrapper";function DLe(e){let{components:n,...t}=e;return(0,s.yg)(fLe,(0,p.A)({},gLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}DLe.isMDXComponent=!0;const MLe={toc:[]},XLe="wrapper";function _Le(e){let{components:n,...t}=e;return(0,s.yg)(XLe,(0,p.A)({},MLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}_Le.isMDXComponent=!0;const wLe={toc:[]},TLe="wrapper";function CLe(e){let{components:n,...t}=e;return(0,s.yg)(TLe,(0,p.A)({},wLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}CLe.isMDXComponent=!0;const xLe={toc:[]},ALe="wrapper";function vLe(e){let{components:n,...t}=e;return(0,s.yg)(ALe,(0,p.A)({},xLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}vLe.isMDXComponent=!0;const LLe={toc:[]},bLe="wrapper";function NLe(e){let{components:n,...t}=e;return(0,s.yg)(bLe,(0,p.A)({},LLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}NLe.isMDXComponent=!0;const kLe={toc:[]},zLe="wrapper";function PLe(e){let{components:n,...t}=e;return(0,s.yg)(zLe,(0,p.A)({},kLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}PLe.isMDXComponent=!0;const ILe={toc:[]},RLe="wrapper";function WLe(e){let{components:n,...t}=e;return(0,s.yg)(RLe,(0,p.A)({},ILe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}WLe.isMDXComponent=!0;const SLe={toc:[]},BLe="wrapper";function ELe(e){let{components:n,...t}=e;return(0,s.yg)(BLe,(0,p.A)({},SLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}ELe.isMDXComponent=!0;const GLe={toc:[]},OLe="wrapper";function ULe(e){let{components:n,...t}=e;return(0,s.yg)(OLe,(0,p.A)({},GLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}ULe.isMDXComponent=!0;const FLe={toc:[]},VLe="wrapper";function qLe(e){let{components:n,...t}=e;return(0,s.yg)(VLe,(0,p.A)({},FLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}qLe.isMDXComponent=!0;const jLe={toc:[]},HLe="wrapper";function YLe(e){let{components:n,...t}=e;return(0,s.yg)(HLe,(0,p.A)({},jLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}YLe.isMDXComponent=!0;const QLe={toc:[]},$Le="wrapper";function KLe(e){let{components:n,...t}=e;return(0,s.yg)($Le,(0,p.A)({},QLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}KLe.isMDXComponent=!0;const JLe={toc:[]},ZLe="wrapper";function ebe(e){let{components:n,...t}=e;return(0,s.yg)(ZLe,(0,p.A)({},JLe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}ebe.isMDXComponent=!0;const nbe={toc:[]},tbe="wrapper";function obe(e){let{components:n,...t}=e;return(0,s.yg)(tbe,(0,p.A)({},nbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}obe.isMDXComponent=!0;const pbe={toc:[]},rbe="wrapper";function sbe(e){let{components:n,...t}=e;return(0,s.yg)(rbe,(0,p.A)({},pbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}sbe.isMDXComponent=!0;const cbe={toc:[]},abe="wrapper";function ibe(e){let{components:n,...t}=e;return(0,s.yg)(abe,(0,p.A)({},cbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}ibe.isMDXComponent=!0;const lbe={toc:[]},ube="wrapper";function mbe(e){let{components:n,...t}=e;return(0,s.yg)(ube,(0,p.A)({},lbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}mbe.isMDXComponent=!0;const ybe={toc:[]},dbe="wrapper";function hbe(e){let{components:n,...t}=e;return(0,s.yg)(dbe,(0,p.A)({},ybe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}hbe.isMDXComponent=!0;const gbe={toc:[]},fbe="wrapper";function Dbe(e){let{components:n,...t}=e;return(0,s.yg)(fbe,(0,p.A)({},gbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Dbe.isMDXComponent=!0;const Mbe={toc:[]},Xbe="wrapper";function _be(e){let{components:n,...t}=e;return(0,s.yg)(Xbe,(0,p.A)({},Mbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}_be.isMDXComponent=!0;const wbe={toc:[]},Tbe="wrapper";function Cbe(e){let{components:n,...t}=e;return(0,s.yg)(Tbe,(0,p.A)({},wbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Cbe.isMDXComponent=!0;const xbe={toc:[]},Abe="wrapper";function vbe(e){let{components:n,...t}=e;return(0,s.yg)(Abe,(0,p.A)({},xbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}vbe.isMDXComponent=!0;const Lbe={toc:[]},bbe="wrapper";function Nbe(e){let{components:n,...t}=e;return(0,s.yg)(bbe,(0,p.A)({},Lbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Circle#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Nbe.isMDXComponent=!0;const kbe={toc:[]},zbe="wrapper";function Pbe(e){let{components:n,...t}=e;return(0,s.yg)(zbe,(0,p.A)({},kbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Pbe.isMDXComponent=!0;const Ibe={toc:[]},Rbe="wrapper";function Wbe(e){let{components:n,...t}=e;return(0,s.yg)(Rbe,(0,p.A)({},Ibe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Wbe.isMDXComponent=!0;const Sbe={toc:[]},Bbe="wrapper";function Ebe(e){let{components:n,...t}=e;return(0,s.yg)(Bbe,(0,p.A)({},Sbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Ebe.isMDXComponent=!0;const Gbe={toc:[]},Obe="wrapper";function Ube(e){let{components:n,...t}=e;return(0,s.yg)(Obe,(0,p.A)({},Gbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}Ube.isMDXComponent=!0;const Fbe={toc:[]},Vbe="wrapper";function qbe(e){let{components:n,...t}=e;return(0,s.yg)(Vbe,(0,p.A)({},Fbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}qbe.isMDXComponent=!0;const jbe={toc:[]},Hbe="wrapper";function Ybe(e){let{components:n,...t}=e;return(0,s.yg)(Hbe,(0,p.A)({},jbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}Ybe.isMDXComponent=!0;const Qbe={toc:[]},$be="wrapper";function Kbe(e){let{components:n,...t}=e;return(0,s.yg)($be,(0,p.A)({},Qbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {parser} from '@lezer/javascript';\nimport {Code, LezerHighlighter, makeScene2D} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  LezerHighlighter.registerParser(parser);\n  const code = createRef<Code>();\n\n  view.add(\n    <Code\n      ref={code}\n      offset={-1}\n      position={view.size().scale(-0.5).add(60)}\n      fontFamily={'JetBrains Mono, monospace'}\n      fontSize={36}\n      code={`\\\nfunction hello() {\n  console.log('Hello');\n}`}\n    />,\n  );\n\n  yield* code()\n    .code(\n      `\\\nfunction hello() {\n  console.warn('Hello World');\n}`,\n      1,\n    )\n    .wait(0.5)\n    .back(1)\n    .wait(0.5);\n});\n")))}Kbe.isMDXComponent=!0;const Jbe={toc:[]},Zbe="wrapper";function eNe(e){let{components:n,...t}=e;return(0,s.yg)(Zbe,(0,p.A)({},Jbe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for displaying and animating code."))}eNe.isMDXComponent=!0;const nNe={toc:[]},tNe="wrapper";function oNe(e){let{components:n,...t}=e;return(0,s.yg)(tNe,(0,p.A)({},nNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}oNe.isMDXComponent=!0;const pNe={toc:[]},rNe="wrapper";function sNe(e){let{components:n,...t}=e;return(0,s.yg)(rNe,(0,p.A)({},pNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}sNe.isMDXComponent=!0;const cNe={toc:[]},aNe="wrapper";function iNe(e){let{components:n,...t}=e;return(0,s.yg)(aNe,(0,p.A)({},cNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}iNe.isMDXComponent=!0;const lNe={toc:[]},uNe="wrapper";function mNe(e){let{components:n,...t}=e;return(0,s.yg)(uNe,(0,p.A)({},lNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}mNe.isMDXComponent=!0;const yNe={toc:[]},dNe="wrapper";function hNe(e){let{components:n,...t}=e;return(0,s.yg)(dNe,(0,p.A)({},yNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}hNe.isMDXComponent=!0;const gNe={toc:[]},fNe="wrapper";function DNe(e){let{components:n,...t}=e;return(0,s.yg)(fNe,(0,p.A)({},gNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}DNe.isMDXComponent=!0;const MNe={toc:[]},XNe="wrapper";function _Ne(e){let{components:n,...t}=e;return(0,s.yg)(XNe,(0,p.A)({},MNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}_Ne.isMDXComponent=!0;const wNe={toc:[]},TNe="wrapper";function CNe(e){let{components:n,...t}=e;return(0,s.yg)(TNe,(0,p.A)({},wNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}CNe.isMDXComponent=!0;const xNe={toc:[]},ANe="wrapper";function vNe(e){let{components:n,...t}=e;return(0,s.yg)(ANe,(0,p.A)({},xNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}vNe.isMDXComponent=!0;const LNe={toc:[]},bNe="wrapper";function NNe(e){let{components:n,...t}=e;return(0,s.yg)(bNe,(0,p.A)({},LNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}NNe.isMDXComponent=!0;const kNe={toc:[]},zNe="wrapper";function PNe(e){let{components:n,...t}=e;return(0,s.yg)(zNe,(0,p.A)({},kNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}PNe.isMDXComponent=!0;const INe={toc:[]},RNe="wrapper";function WNe(e){let{components:n,...t}=e;return(0,s.yg)(RNe,(0,p.A)({},INe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}WNe.isMDXComponent=!0;const SNe={toc:[]},BNe="wrapper";function ENe(e){let{components:n,...t}=e;return(0,s.yg)(BNe,(0,p.A)({},SNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}ENe.isMDXComponent=!0;const GNe={toc:[]},ONe="wrapper";function UNe(e){let{components:n,...t}=e;return(0,s.yg)(ONe,(0,p.A)({},GNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}UNe.isMDXComponent=!0;const FNe={toc:[]},VNe="wrapper";function qNe(e){let{components:n,...t}=e;return(0,s.yg)(VNe,(0,p.A)({},FNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to display."))}qNe.isMDXComponent=!0;const jNe={toc:[]},HNe="wrapper";function YNe(e){let{components:n,...t}=e;return(0,s.yg)(HNe,(0,p.A)({},jNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This value will be passed to the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/CodeHighlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"CodeHighlighter")),"\ndefined by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#highlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"highlighter"))," property. Different highlighters may use\nit differently."),(0,s.yg)("p",null,"The default ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/LezerHighlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"LezerHighlighter"))," uses it to select\nthe language parser to use. The parser for the given dialect can be\nregistered as follows:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// Import the lezer parser:\nimport {parser} from '@lezer/javascript';\n\n// Register it in the highlighter:\nLezerHighlighter.registerParser(parser, 'js');\n\n// Use the dialect in a code node:\n<Code dialect=\"js\" code=\"const a = 7;\" />\n")),(0,s.yg)("p",null,"When no dialect is provided, the highlighter will use the default\nparser:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},'// Register the default parser by omitting the dialect:\nLezerHighlighter.registerParser(parser);\n\n// Code nodes with no dialect will now use the default parser:\n<Code code="const a = 7;" />\n')))}YNe.isMDXComponent=!0;const QNe={toc:[]},$Ne="wrapper";function KNe(e){let{components:n,...t}=e;return(0,s.yg)($Ne,(0,p.A)({},QNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The dialect to use for highlighting the code."))}KNe.isMDXComponent=!0;const JNe={toc:[]},ZNe="wrapper";function eke(e){let{components:n,...t}=e;return(0,s.yg)(ZNe,(0,p.A)({},JNe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check out ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/DrawHooks"},(0,s.yg)("inlineCode",{parentName:"a"},"DrawHooks"))," for available render hooks."))}eke.isMDXComponent=!0;const nke={toc:[]},tke="wrapper";function oke(e){let{components:n,...t}=e;return(0,s.yg)(tke,(0,p.A)({},nke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Make the unselected code blurry and transparent:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Code\n  drawHooks={{\n    token(ctx, text, position, color, selection) {\n      const blur = map(3, 0, selection);\n      const alpha = map(0.5, 1, selection);\n      ctx.globalAlpha *= alpha;\n      ctx.filter = `blur(${blur}px)`;\n      ctx.fillStyle = color;\n      ctx.fillText(text, position.x, position.y);\n    },\n  }}\n  // ...\n/>\n")))}oke.isMDXComponent=!0;const pke={toc:[]},rke="wrapper";function ske(e){let{components:n,...t}=e;return(0,s.yg)(rke,(0,p.A)({},pke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Custom drawing logic for the code."))}ske.isMDXComponent=!0;const cke={toc:[]},ake="wrapper";function ike(e){let{components:n,...t}=e;return(0,s.yg)(ake,(0,p.A)({},cke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Defaults to a shared ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/LezerHighlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"LezerHighlighter")),"."))}ike.isMDXComponent=!0;const lke={toc:[]},uke="wrapper";function mke(e){let{components:n,...t}=e;return(0,s.yg)(uke,(0,p.A)({},lke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code highlighter to use for this code node."))}mke.isMDXComponent=!0;const yke={toc:[]},dke="wrapper";function hke(e){let{components:n,...t}=e;return(0,s.yg)(dke,(0,p.A)({},yke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}hke.isMDXComponent=!0;const gke={toc:[]},fke="wrapper";function Dke(e){let{components:n,...t}=e;return(0,s.yg)(fke,(0,p.A)({},gke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Dke.isMDXComponent=!0;const Mke={toc:[]},Xke="wrapper";function _ke(e){let{components:n,...t}=e;return(0,s.yg)(Xke,(0,p.A)({},Mke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}_ke.isMDXComponent=!0;const wke={toc:[]},Tke="wrapper";function Cke(e){let{components:n,...t}=e;return(0,s.yg)(Tke,(0,p.A)({},wke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Cke.isMDXComponent=!0;const xke={toc:[]},Ake="wrapper";function vke(e){let{components:n,...t}=e;return(0,s.yg)(Ake,(0,p.A)({},xke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}vke.isMDXComponent=!0;const Lke={toc:[]},bke="wrapper";function Nke(e){let{components:n,...t}=e;return(0,s.yg)(bke,(0,p.A)({},Lke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}Nke.isMDXComponent=!0;const kke={toc:[]},zke="wrapper";function Pke(e){let{components:n,...t}=e;return(0,s.yg)(zke,(0,p.A)({},kke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}Pke.isMDXComponent=!0;const Ike={toc:[]},Rke="wrapper";function Wke(e){let{components:n,...t}=e;return(0,s.yg)(Rke,(0,p.A)({},Ike,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}Wke.isMDXComponent=!0;const Ske={toc:[]},Bke="wrapper";function Eke(e){let{components:n,...t}=e;return(0,s.yg)(Bke,(0,p.A)({},Ske,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Eke.isMDXComponent=!0;const Gke={toc:[]},Oke="wrapper";function Uke(e){let{components:n,...t}=e;return(0,s.yg)(Oke,(0,p.A)({},Gke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}Uke.isMDXComponent=!0;const Fke={toc:[]},Vke="wrapper";function qke(e){let{components:n,...t}=e;return(0,s.yg)(Vke,(0,p.A)({},Fke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}qke.isMDXComponent=!0;const jke={toc:[]},Hke="wrapper";function Yke(e){let{components:n,...t}=e;return(0,s.yg)(Hke,(0,p.A)({},jke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Yke.isMDXComponent=!0;const Qke={toc:[]},$ke="wrapper";function Kke(e){let{components:n,...t}=e;return(0,s.yg)($ke,(0,p.A)({},Qke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Kke.isMDXComponent=!0;const Jke={toc:[]},Zke="wrapper";function eze(e){let{components:n,...t}=e;return(0,s.yg)(Zke,(0,p.A)({},Jke,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}eze.isMDXComponent=!0;const nze={toc:[]},tze="wrapper";function oze(e){let{components:n,...t}=e;return(0,s.yg)(tze,(0,p.A)({},nze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}oze.isMDXComponent=!0;const pze={toc:[]},rze="wrapper";function sze(e){let{components:n,...t}=e;return(0,s.yg)(rze,(0,p.A)({},pze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Either a single ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#CodeRange"},(0,s.yg)("inlineCode",{parentName:"a"},"CodeRange"))," or an array of them\ndescribing which parts of the code should be visually emphasized."),(0,s.yg)("p",null,"You can use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#word"},(0,s.yg)("inlineCode",{parentName:"a"},"word"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#lines"},(0,s.yg)("inlineCode",{parentName:"a"},"lines"))," to quickly create ranges."))}sze.isMDXComponent=!0;const cze={toc:[]},aze="wrapper";function ize(e){let{components:n,...t}=e;return(0,s.yg)(aze,(0,p.A)({},cze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,'The following will select the word "console" in the code.\nBoth lines and columns are 0-based. So it will select a 7-character-long\n(',(0,s.yg)("inlineCode",{parentName:"p"},"7"),") word in the second line (",(0,s.yg)("inlineCode",{parentName:"p"},"1"),") starting at the third character (",(0,s.yg)("inlineCode",{parentName:"p"},"2"),")."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Code\n  selection={word(1, 2, 7)}\n  code={`\\\nfunction hello() => {\n  console.log('Hello');\n}`}\n  // ...\n/>\n")))}ize.isMDXComponent=!0;const lze={toc:[]},uze="wrapper";function mze(e){let{components:n,...t}=e;return(0,s.yg)(uze,(0,p.A)({},lze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The currently selected code range."))}mze.isMDXComponent=!0;const yze={toc:[]},dze="wrapper";function hze(e){let{components:n,...t}=e;return(0,s.yg)(dze,(0,p.A)({},yze,t,{components:n,mdxType:"MDXLayout"}))}hze.isMDXComponent=!0;const gze={toc:[]},fze="wrapper";function Dze(e){let{components:n,...t}=e;return(0,s.yg)(fze,(0,p.A)({},gze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Dze.isMDXComponent=!0;const Mze={toc:[]},Xze="wrapper";function _ze(e){let{components:n,...t}=e;return(0,s.yg)(Xze,(0,p.A)({},Mze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}_ze.isMDXComponent=!0;const wze={toc:[]},Tze="wrapper";function Cze(e){let{components:n,...t}=e;return(0,s.yg)(Tze,(0,p.A)({},wze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}Cze.isMDXComponent=!0;const xze={toc:[]},Aze="wrapper";function vze(e){let{components:n,...t}=e;return(0,s.yg)(Aze,(0,p.A)({},xze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}vze.isMDXComponent=!0;const Lze={toc:[]},bze="wrapper";function Nze(e){let{components:n,...t}=e;return(0,s.yg)(bze,(0,p.A)({},Lze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}Nze.isMDXComponent=!0;const kze={toc:[]},zze="wrapper";function Pze(e){let{components:n,...t}=e;return(0,s.yg)(zze,(0,p.A)({},kze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Pze.isMDXComponent=!0;const Ize={toc:[]},Rze="wrapper";function Wze(e){let{components:n,...t}=e;return(0,s.yg)(Rze,(0,p.A)({},Ize,t,{components:n,mdxType:"MDXLayout"}))}Wze.isMDXComponent=!0;const Sze={toc:[]},Bze="wrapper";function Eze(e){let{components:n,...t}=e;return(0,s.yg)(Bze,(0,p.A)({},Sze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Eze.isMDXComponent=!0;const Gze={toc:[]},Oze="wrapper";function Uze(e){let{components:n,...t}=e;return(0,s.yg)(Oze,(0,p.A)({},Gze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Uze.isMDXComponent=!0;const Fze={toc:[]},Vze="wrapper";function qze(e){let{components:n,...t}=e;return(0,s.yg)(Vze,(0,p.A)({},Fze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}qze.isMDXComponent=!0;const jze={toc:[]},Hze="wrapper";function Yze(e){let{components:n,...t}=e;return(0,s.yg)(Hze,(0,p.A)({},jze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Yze.isMDXComponent=!0;const Qze={toc:[]},$ze="wrapper";function Kze(e){let{components:n,...t}=e;return(0,s.yg)($ze,(0,p.A)({},Qze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Kze.isMDXComponent=!0;const Jze={toc:[]},Zze="wrapper";function ePe(e){let{components:n,...t}=e;return(0,s.yg)(Zze,(0,p.A)({},Jze,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}ePe.isMDXComponent=!0;const nPe={toc:[]},tPe="wrapper";function oPe(e){let{components:n,...t}=e;return(0,s.yg)(tPe,(0,p.A)({},nPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}oPe.isMDXComponent=!0;const pPe={toc:[]},rPe="wrapper";function sPe(e){let{components:n,...t}=e;return(0,s.yg)(rPe,(0,p.A)({},pPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}sPe.isMDXComponent=!0;const cPe={toc:[]},aPe="wrapper";function iPe(e){let{components:n,...t}=e;return(0,s.yg)(aPe,(0,p.A)({},cPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}iPe.isMDXComponent=!0;const lPe={toc:[]},uPe="wrapper";function mPe(e){let{components:n,...t}=e;return(0,s.yg)(uPe,(0,p.A)({},lPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}mPe.isMDXComponent=!0;const yPe={toc:[]},dPe="wrapper";function hPe(e){let{components:n,...t}=e;return(0,s.yg)(dPe,(0,p.A)({},yPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}hPe.isMDXComponent=!0;const gPe={toc:[]},fPe="wrapper";function DPe(e){let{components:n,...t}=e;return(0,s.yg)(fPe,(0,p.A)({},gPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}DPe.isMDXComponent=!0;const MPe={toc:[]},XPe="wrapper";function _Pe(e){let{components:n,...t}=e;return(0,s.yg)(XPe,(0,p.A)({},MPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}_Pe.isMDXComponent=!0;const wPe={toc:[]},TPe="wrapper";function CPe(e){let{components:n,...t}=e;return(0,s.yg)(TPe,(0,p.A)({},wPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}CPe.isMDXComponent=!0;const xPe={toc:[]},APe="wrapper";function vPe(e){let{components:n,...t}=e;return(0,s.yg)(APe,(0,p.A)({},xPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}vPe.isMDXComponent=!0;const LPe={toc:[]},bPe="wrapper";function NPe(e){let{components:n,...t}=e;return(0,s.yg)(bPe,(0,p.A)({},LPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}NPe.isMDXComponent=!0;const kPe={toc:[]},zPe="wrapper";function PPe(e){let{components:n,...t}=e;return(0,s.yg)(zPe,(0,p.A)({},kPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}PPe.isMDXComponent=!0;const IPe={toc:[]},RPe="wrapper";function WPe(e){let{components:n,...t}=e;return(0,s.yg)(RPe,(0,p.A)({},IPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}WPe.isMDXComponent=!0;const SPe={toc:[]},BPe="wrapper";function EPe(e){let{components:n,...t}=e;return(0,s.yg)(BPe,(0,p.A)({},SPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}EPe.isMDXComponent=!0;const GPe={toc:[]},OPe="wrapper";function UPe(e){let{components:n,...t}=e;return(0,s.yg)(OPe,(0,p.A)({},GPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}UPe.isMDXComponent=!0;const FPe={toc:[]},VPe="wrapper";function qPe(e){let{components:n,...t}=e;return(0,s.yg)(VPe,(0,p.A)({},FPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}qPe.isMDXComponent=!0;const jPe={toc:[]},HPe="wrapper";function YPe(e){let{components:n,...t}=e;return(0,s.yg)(HPe,(0,p.A)({},jPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}YPe.isMDXComponent=!0;const QPe={toc:[]},$Pe="wrapper";function KPe(e){let{components:n,...t}=e;return(0,s.yg)($Pe,(0,p.A)({},QPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}KPe.isMDXComponent=!0;const JPe={toc:[]},ZPe="wrapper";function eIe(e){let{components:n,...t}=e;return(0,s.yg)(ZPe,(0,p.A)({},JPe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}eIe.isMDXComponent=!0;const nIe={toc:[]},tIe="wrapper";function oIe(e){let{components:n,...t}=e;return(0,s.yg)(tIe,(0,p.A)({},nIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}oIe.isMDXComponent=!0;const pIe={toc:[]},rIe="wrapper";function sIe(e){let{components:n,...t}=e;return(0,s.yg)(rIe,(0,p.A)({},pIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}sIe.isMDXComponent=!0;const cIe={toc:[]},aIe="wrapper";function iIe(e){let{components:n,...t}=e;return(0,s.yg)(aIe,(0,p.A)({},cIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a child code signal."))}iIe.isMDXComponent=!0;const lIe={toc:[]},uIe="wrapper";function mIe(e){let{components:n,...t}=e;return(0,s.yg)(uIe,(0,p.A)({},lIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial code."))}mIe.isMDXComponent=!0;const yIe={toc:[]},dIe="wrapper";function hIe(e){let{components:n,...t}=e;return(0,s.yg)(dIe,(0,p.A)({},yIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}hIe.isMDXComponent=!0;const gIe={toc:[]},fIe="wrapper";function DIe(e){let{components:n,...t}=e;return(0,s.yg)(fIe,(0,p.A)({},gIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}DIe.isMDXComponent=!0;const MIe={toc:[]},XIe="wrapper";function _Ie(e){let{components:n,...t}=e;return(0,s.yg)(XIe,(0,p.A)({},MIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}_Ie.isMDXComponent=!0;const wIe={toc:[]},TIe="wrapper";function CIe(e){let{components:n,...t}=e;return(0,s.yg)(TIe,(0,p.A)({},wIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}CIe.isMDXComponent=!0;const xIe={toc:[]},AIe="wrapper";function vIe(e){let{components:n,...t}=e;return(0,s.yg)(AIe,(0,p.A)({},xIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}vIe.isMDXComponent=!0;const LIe={toc:[]},bIe="wrapper";function NIe(e){let{components:n,...t}=e;return(0,s.yg)(bIe,(0,p.A)({},LIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}NIe.isMDXComponent=!0;const kIe={toc:[]},zIe="wrapper";function PIe(e){let{components:n,...t}=e;return(0,s.yg)(zIe,(0,p.A)({},kIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}PIe.isMDXComponent=!0;const IIe={toc:[]},RIe="wrapper";function WIe(e){let{components:n,...t}=e;return(0,s.yg)(RIe,(0,p.A)({},IIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}WIe.isMDXComponent=!0;const SIe={toc:[]},BIe="wrapper";function EIe(e){let{components:n,...t}=e;return(0,s.yg)(BIe,(0,p.A)({},SIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}EIe.isMDXComponent=!0;const GIe={toc:[]},OIe="wrapper";function UIe(e){let{components:n,...t}=e;return(0,s.yg)(OIe,(0,p.A)({},GIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}UIe.isMDXComponent=!0;const FIe={toc:[]},VIe="wrapper";function qIe(e){let{components:n,...t}=e;return(0,s.yg)(VIe,(0,p.A)({},FIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}qIe.isMDXComponent=!0;const jIe={toc:[]},HIe="wrapper";function YIe(e){let{components:n,...t}=e;return(0,s.yg)(HIe,(0,p.A)({},jIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}YIe.isMDXComponent=!0;const QIe={toc:[]},$Ie="wrapper";function KIe(e){let{components:n,...t}=e;return(0,s.yg)($Ie,(0,p.A)({},QIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}KIe.isMDXComponent=!0;const JIe={toc:[]},ZIe="wrapper";function eRe(e){let{components:n,...t}=e;return(0,s.yg)(ZIe,(0,p.A)({},JIe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}eRe.isMDXComponent=!0;const nRe={toc:[]},tRe="wrapper";function oRe(e){let{components:n,...t}=e;return(0,s.yg)(tRe,(0,p.A)({},nRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}oRe.isMDXComponent=!0;const pRe={toc:[]},rRe="wrapper";function sRe(e){let{components:n,...t}=e;return(0,s.yg)(rRe,(0,p.A)({},pRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all code ranges that match the given pattern."))}sRe.isMDXComponent=!0;const cRe={toc:[]},aRe="wrapper";function iRe(e){let{components:n,...t}=e;return(0,s.yg)(aRe,(0,p.A)({},cRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Either a string or a regular expression to match."))}iRe.isMDXComponent=!0;const lRe={toc:[]},uRe="wrapper";function mRe(e){let{components:n,...t}=e;return(0,s.yg)(uRe,(0,p.A)({},lRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}mRe.isMDXComponent=!0;const yRe={toc:[]},dRe="wrapper";function hRe(e){let{components:n,...t}=e;return(0,s.yg)(dRe,(0,p.A)({},yRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}hRe.isMDXComponent=!0;const gRe={toc:[]},fRe="wrapper";function DRe(e){let{components:n,...t}=e;return(0,s.yg)(fRe,(0,p.A)({},gRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}DRe.isMDXComponent=!0;const MRe={toc:[]},XRe="wrapper";function _Re(e){let{components:n,...t}=e;return(0,s.yg)(XRe,(0,p.A)({},MRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}_Re.isMDXComponent=!0;const wRe={toc:[]},TRe="wrapper";function CRe(e){let{components:n,...t}=e;return(0,s.yg)(TRe,(0,p.A)({},wRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}CRe.isMDXComponent=!0;const xRe={toc:[]},ARe="wrapper";function vRe(e){let{components:n,...t}=e;return(0,s.yg)(ARe,(0,p.A)({},xRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}vRe.isMDXComponent=!0;const LRe={toc:[]},bRe="wrapper";function NRe(e){let{components:n,...t}=e;return(0,s.yg)(bRe,(0,p.A)({},LRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}NRe.isMDXComponent=!0;const kRe={toc:[]},zRe="wrapper";function PRe(e){let{components:n,...t}=e;return(0,s.yg)(zRe,(0,p.A)({},kRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}PRe.isMDXComponent=!0;const IRe={toc:[]},RRe="wrapper";function WRe(e){let{components:n,...t}=e;return(0,s.yg)(RRe,(0,p.A)({},IRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first code range that matches the given pattern."))}WRe.isMDXComponent=!0;const SRe={toc:[]},BRe="wrapper";function ERe(e){let{components:n,...t}=e;return(0,s.yg)(BRe,(0,p.A)({},SRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Either a string or a regular expression to match."))}ERe.isMDXComponent=!0;const GRe={toc:[]},ORe="wrapper";function URe(e){let{components:n,...t}=e;return(0,s.yg)(ORe,(0,p.A)({},GRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}URe.isMDXComponent=!0;const FRe={toc:[]},VRe="wrapper";function qRe(e){let{components:n,...t}=e;return(0,s.yg)(VRe,(0,p.A)({},FRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}qRe.isMDXComponent=!0;const jRe={toc:[]},HRe="wrapper";function YRe(e){let{components:n,...t}=e;return(0,s.yg)(HRe,(0,p.A)({},jRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}YRe.isMDXComponent=!0;const QRe={toc:[]},$Re="wrapper";function KRe(e){let{components:n,...t}=e;return(0,s.yg)($Re,(0,p.A)({},QRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}KRe.isMDXComponent=!0;const JRe={toc:[]},ZRe="wrapper";function eWe(e){let{components:n,...t}=e;return(0,s.yg)(ZRe,(0,p.A)({},JRe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last code range that matches the given pattern."))}eWe.isMDXComponent=!0;const nWe={toc:[]},tWe="wrapper";function oWe(e){let{components:n,...t}=e;return(0,s.yg)(tWe,(0,p.A)({},nWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Either a string or a regular expression to match."))}oWe.isMDXComponent=!0;const pWe={toc:[]},rWe="wrapper";function sWe(e){let{components:n,...t}=e;return(0,s.yg)(rWe,(0,p.A)({},pWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}sWe.isMDXComponent=!0;const cWe={toc:[]},aWe="wrapper";function iWe(e){let{components:n,...t}=e;return(0,s.yg)(aWe,(0,p.A)({},cWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}iWe.isMDXComponent=!0;const lWe={toc:[]},uWe="wrapper";function mWe(e){let{components:n,...t}=e;return(0,s.yg)(uWe,(0,p.A)({},lWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}mWe.isMDXComponent=!0;const yWe={toc:[]},dWe="wrapper";function hWe(e){let{components:n,...t}=e;return(0,s.yg)(dWe,(0,p.A)({},yWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}hWe.isMDXComponent=!0;const gWe={toc:[]},fWe="wrapper";function DWe(e){let{components:n,...t}=e;return(0,s.yg)(fWe,(0,p.A)({},gWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bound box is in local space of the ",(0,s.yg)("inlineCode",{parentName:"p"},"Code")," node."))}DWe.isMDXComponent=!0;const MWe={toc:[]},XWe="wrapper";function _We(e){let{components:n,...t}=e;return(0,s.yg)(XWe,(0,p.A)({},MWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the bounding box of the given point (character) in the code."))}_We.isMDXComponent=!0;const wWe={toc:[]},TWe="wrapper";function CWe(e){let{components:n,...t}=e;return(0,s.yg)(TWe,(0,p.A)({},wWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The point to get the bounding box for."))}CWe.isMDXComponent=!0;const xWe={toc:[]},AWe="wrapper";function vWe(e){let{components:n,...t}=e;return(0,s.yg)(AWe,(0,p.A)({},xWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bound boxes are in local space of the ",(0,s.yg)("inlineCode",{parentName:"p"},"Code")," node.\nEach line of code has a separate bounding box."))}vWe.isMDXComponent=!0;const LWe={toc:[]},bWe="wrapper";function NWe(e){let{components:n,...t}=e;return(0,s.yg)(bWe,(0,p.A)({},LWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return bounding boxes of all characters in the selection."))}NWe.isMDXComponent=!0;const kWe={toc:[]},zWe="wrapper";function PWe(e){let{components:n,...t}=e;return(0,s.yg)(zWe,(0,p.A)({},kWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The selection to get the bounding boxes for."))}PWe.isMDXComponent=!0;const IWe={toc:[]},RWe="wrapper";function WWe(e){let{components:n,...t}=e;return(0,s.yg)(RWe,(0,p.A)({},IWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}WWe.isMDXComponent=!0;const SWe={toc:[]},BWe="wrapper";function EWe(e){let{components:n,...t}=e;return(0,s.yg)(BWe,(0,p.A)({},SWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}EWe.isMDXComponent=!0;const GWe={toc:[]},OWe="wrapper";function UWe(e){let{components:n,...t}=e;return(0,s.yg)(OWe,(0,p.A)({},GWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}UWe.isMDXComponent=!0;const FWe={toc:[]},VWe="wrapper";function qWe(e){let{components:n,...t}=e;return(0,s.yg)(VWe,(0,p.A)({},FWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}qWe.isMDXComponent=!0;const jWe={toc:[]},HWe="wrapper";function YWe(e){let{components:n,...t}=e;return(0,s.yg)(HWe,(0,p.A)({},jWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}YWe.isMDXComponent=!0;const QWe={toc:[]},$We="wrapper";function KWe(e){let{components:n,...t}=e;return(0,s.yg)($We,(0,p.A)({},QWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}KWe.isMDXComponent=!0;const JWe={toc:[]},ZWe="wrapper";function eSe(e){let{components:n,...t}=e;return(0,s.yg)(ZWe,(0,p.A)({},JWe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}eSe.isMDXComponent=!0;const nSe={toc:[]},tSe="wrapper";function oSe(e){let{components:n,...t}=e;return(0,s.yg)(tSe,(0,p.A)({},nSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}oSe.isMDXComponent=!0;const pSe={toc:[]},rSe="wrapper";function sSe(e){let{components:n,...t}=e;return(0,s.yg)(rSe,(0,p.A)({},pSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}sSe.isMDXComponent=!0;const cSe={toc:[]},aSe="wrapper";function iSe(e){let{components:n,...t}=e;return(0,s.yg)(aSe,(0,p.A)({},cSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}iSe.isMDXComponent=!0;const lSe={toc:[]},uSe="wrapper";function mSe(e){let{components:n,...t}=e;return(0,s.yg)(uSe,(0,p.A)({},lSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}mSe.isMDXComponent=!0;const ySe={toc:[]},dSe="wrapper";function hSe(e){let{components:n,...t}=e;return(0,s.yg)(dSe,(0,p.A)({},ySe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}hSe.isMDXComponent=!0;const gSe={toc:[]},fSe="wrapper";function DSe(e){let{components:n,...t}=e;return(0,s.yg)(fSe,(0,p.A)({},gSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}DSe.isMDXComponent=!0;const MSe={toc:[]},XSe="wrapper";function _Se(e){let{components:n,...t}=e;return(0,s.yg)(XSe,(0,p.A)({},MSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}_Se.isMDXComponent=!0;const wSe={toc:[]},TSe="wrapper";function CSe(e){let{components:n,...t}=e;return(0,s.yg)(TSe,(0,p.A)({},wSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}CSe.isMDXComponent=!0;const xSe={toc:[]},ASe="wrapper";function vSe(e){let{components:n,...t}=e;return(0,s.yg)(ASe,(0,p.A)({},xSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}vSe.isMDXComponent=!0;const LSe={toc:[]},bSe="wrapper";function NSe(e){let{components:n,...t}=e;return(0,s.yg)(bSe,(0,p.A)({},LSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}NSe.isMDXComponent=!0;const kSe={toc:[]},zSe="wrapper";function PSe(e){let{components:n,...t}=e;return(0,s.yg)(zSe,(0,p.A)({},kSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}PSe.isMDXComponent=!0;const ISe={toc:[]},RSe="wrapper";function WSe(e){let{components:n,...t}=e;return(0,s.yg)(RSe,(0,p.A)({},ISe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}WSe.isMDXComponent=!0;const SSe={toc:[]},BSe="wrapper";function ESe(e){let{components:n,...t}=e;return(0,s.yg)(BSe,(0,p.A)({},SSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}ESe.isMDXComponent=!0;const GSe={toc:[]},OSe="wrapper";function USe(e){let{components:n,...t}=e;return(0,s.yg)(OSe,(0,p.A)({},GSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}USe.isMDXComponent=!0;const FSe={toc:[]},VSe="wrapper";function qSe(e){let{components:n,...t}=e;return(0,s.yg)(VSe,(0,p.A)({},FSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}qSe.isMDXComponent=!0;const jSe={toc:[]},HSe="wrapper";function YSe(e){let{components:n,...t}=e;return(0,s.yg)(HSe,(0,p.A)({},jSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}YSe.isMDXComponent=!0;const QSe={toc:[]},$Se="wrapper";function KSe(e){let{components:n,...t}=e;return(0,s.yg)($Se,(0,p.A)({},QSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}KSe.isMDXComponent=!0;const JSe={toc:[]},ZSe="wrapper";function eBe(e){let{components:n,...t}=e;return(0,s.yg)(ZSe,(0,p.A)({},JSe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}eBe.isMDXComponent=!0;const nBe={toc:[]},tBe="wrapper";function oBe(e){let{components:n,...t}=e;return(0,s.yg)(tBe,(0,p.A)({},nBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}oBe.isMDXComponent=!0;const pBe={toc:[]},rBe="wrapper";function sBe(e){let{components:n,...t}=e;return(0,s.yg)(rBe,(0,p.A)({},pBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}sBe.isMDXComponent=!0;const cBe={toc:[]},aBe="wrapper";function iBe(e){let{components:n,...t}=e;return(0,s.yg)(aBe,(0,p.A)({},cBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}iBe.isMDXComponent=!0;const lBe={toc:[]},uBe="wrapper";function mBe(e){let{components:n,...t}=e;return(0,s.yg)(uBe,(0,p.A)({},lBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}mBe.isMDXComponent=!0;const yBe={toc:[]},dBe="wrapper";function hBe(e){let{components:n,...t}=e;return(0,s.yg)(dBe,(0,p.A)({},yBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}hBe.isMDXComponent=!0;const gBe={toc:[]},fBe="wrapper";function DBe(e){let{components:n,...t}=e;return(0,s.yg)(fBe,(0,p.A)({},gBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}DBe.isMDXComponent=!0;const MBe={toc:[]},XBe="wrapper";function _Be(e){let{components:n,...t}=e;return(0,s.yg)(XBe,(0,p.A)({},MBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}_Be.isMDXComponent=!0;const wBe={toc:[]},TBe="wrapper";function CBe(e){let{components:n,...t}=e;return(0,s.yg)(TBe,(0,p.A)({},wBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}CBe.isMDXComponent=!0;const xBe={toc:[]},ABe="wrapper";function vBe(e){let{components:n,...t}=e;return(0,s.yg)(ABe,(0,p.A)({},xBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}vBe.isMDXComponent=!0;const LBe={toc:[]},bBe="wrapper";function NBe(e){let{components:n,...t}=e;return(0,s.yg)(bBe,(0,p.A)({},LBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}NBe.isMDXComponent=!0;const kBe={toc:[]},zBe="wrapper";function PBe(e){let{components:n,...t}=e;return(0,s.yg)(zBe,(0,p.A)({},kBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}PBe.isMDXComponent=!0;const IBe={toc:[]},RBe="wrapper";function WBe(e){let{components:n,...t}=e;return(0,s.yg)(RBe,(0,p.A)({},IBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}WBe.isMDXComponent=!0;const SBe={toc:[]},BBe="wrapper";function EBe(e){let{components:n,...t}=e;return(0,s.yg)(BBe,(0,p.A)({},SBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}EBe.isMDXComponent=!0;const GBe={toc:[]},OBe="wrapper";function UBe(e){let{components:n,...t}=e;return(0,s.yg)(OBe,(0,p.A)({},GBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}UBe.isMDXComponent=!0;const FBe={toc:[]},VBe="wrapper";function qBe(e){let{components:n,...t}=e;return(0,s.yg)(VBe,(0,p.A)({},FBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}qBe.isMDXComponent=!0;const jBe={toc:[]},HBe="wrapper";function YBe(e){let{components:n,...t}=e;return(0,s.yg)(HBe,(0,p.A)({},jBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}YBe.isMDXComponent=!0;const QBe={toc:[]},$Be="wrapper";function KBe(e){let{components:n,...t}=e;return(0,s.yg)($Be,(0,p.A)({},QBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}KBe.isMDXComponent=!0;const JBe={toc:[]},ZBe="wrapper";function eEe(e){let{components:n,...t}=e;return(0,s.yg)(ZBe,(0,p.A)({},JBe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}eEe.isMDXComponent=!0;const nEe={toc:[]},tEe="wrapper";function oEe(e){let{components:n,...t}=e;return(0,s.yg)(tEe,(0,p.A)({},nEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}oEe.isMDXComponent=!0;const pEe={toc:[]},rEe="wrapper";function sEe(e){let{components:n,...t}=e;return(0,s.yg)(rEe,(0,p.A)({},pEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the currently displayed code as a string."))}sEe.isMDXComponent=!0;const cEe={toc:[]},aEe="wrapper";function iEe(e){let{components:n,...t}=e;return(0,s.yg)(aEe,(0,p.A)({},cEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}iEe.isMDXComponent=!0;const lEe={toc:[]},uEe="wrapper";function mEe(e){let{components:n,...t}=e;return(0,s.yg)(uEe,(0,p.A)({},lEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}mEe.isMDXComponent=!0;const yEe={toc:[]},dEe="wrapper";function hEe(e){let{components:n,...t}=e;return(0,s.yg)(dEe,(0,p.A)({},yEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}hEe.isMDXComponent=!0;const gEe={toc:[]},fEe="wrapper";function DEe(e){let{components:n,...t}=e;return(0,s.yg)(fEe,(0,p.A)({},gEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}DEe.isMDXComponent=!0;const MEe={toc:[]},XEe="wrapper";function _Ee(e){let{components:n,...t}=e;return(0,s.yg)(XEe,(0,p.A)({},MEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}_Ee.isMDXComponent=!0;const wEe={toc:[]},TEe="wrapper";function CEe(e){let{components:n,...t}=e;return(0,s.yg)(TEe,(0,p.A)({},wEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}CEe.isMDXComponent=!0;const xEe={toc:[]},AEe="wrapper";function vEe(e){let{components:n,...t}=e;return(0,s.yg)(AEe,(0,p.A)({},xEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}vEe.isMDXComponent=!0;const LEe={toc:[]},bEe="wrapper";function NEe(e){let{components:n,...t}=e;return(0,s.yg)(bEe,(0,p.A)({},LEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}NEe.isMDXComponent=!0;const kEe={toc:[]},zEe="wrapper";function PEe(e){let{components:n,...t}=e;return(0,s.yg)(zEe,(0,p.A)({},kEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}PEe.isMDXComponent=!0;const IEe={toc:[]},REe="wrapper";function WEe(e){let{components:n,...t}=e;return(0,s.yg)(REe,(0,p.A)({},IEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}WEe.isMDXComponent=!0;const SEe={toc:[]},BEe="wrapper";function EEe(e){let{components:n,...t}=e;return(0,s.yg)(BEe,(0,p.A)({},SEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}EEe.isMDXComponent=!0;const GEe={toc:[]},OEe="wrapper";function UEe(e){let{components:n,...t}=e;return(0,s.yg)(OEe,(0,p.A)({},GEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}UEe.isMDXComponent=!0;const FEe={toc:[]},VEe="wrapper";function qEe(e){let{components:n,...t}=e;return(0,s.yg)(VEe,(0,p.A)({},FEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}qEe.isMDXComponent=!0;const jEe={toc:[]},HEe="wrapper";function YEe(e){let{components:n,...t}=e;return(0,s.yg)(HEe,(0,p.A)({},jEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}YEe.isMDXComponent=!0;const QEe={toc:[]},$Ee="wrapper";function KEe(e){let{components:n,...t}=e;return(0,s.yg)($Ee,(0,p.A)({},QEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}KEe.isMDXComponent=!0;const JEe={toc:[]},ZEe="wrapper";function eGe(e){let{components:n,...t}=e;return(0,s.yg)(ZEe,(0,p.A)({},JEe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}eGe.isMDXComponent=!0;const nGe={toc:[]},tGe="wrapper";function oGe(e){let{components:n,...t}=e;return(0,s.yg)(tGe,(0,p.A)({},nGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}oGe.isMDXComponent=!0;const pGe={toc:[]},rGe="wrapper";function sGe(e){let{components:n,...t}=e;return(0,s.yg)(rGe,(0,p.A)({},pGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}sGe.isMDXComponent=!0;const cGe={toc:[]},aGe="wrapper";function iGe(e){let{components:n,...t}=e;return(0,s.yg)(aGe,(0,p.A)({},cGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}iGe.isMDXComponent=!0;const lGe={toc:[]},uGe="wrapper";function mGe(e){let{components:n,...t}=e;return(0,s.yg)(uGe,(0,p.A)({},lGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}mGe.isMDXComponent=!0;const yGe={toc:[]},dGe="wrapper";function hGe(e){let{components:n,...t}=e;return(0,s.yg)(dGe,(0,p.A)({},yGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}hGe.isMDXComponent=!0;const gGe={toc:[]},fGe="wrapper";function DGe(e){let{components:n,...t}=e;return(0,s.yg)(fGe,(0,p.A)({},gGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}DGe.isMDXComponent=!0;const MGe={toc:[]},XGe="wrapper";function _Ge(e){let{components:n,...t}=e;return(0,s.yg)(XGe,(0,p.A)({},MGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}_Ge.isMDXComponent=!0;const wGe={toc:[]},TGe="wrapper";function CGe(e){let{components:n,...t}=e;return(0,s.yg)(TGe,(0,p.A)({},wGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}CGe.isMDXComponent=!0;const xGe={toc:[]},AGe="wrapper";function vGe(e){let{components:n,...t}=e;return(0,s.yg)(AGe,(0,p.A)({},xGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}vGe.isMDXComponent=!0;const LGe={toc:[]},bGe="wrapper";function NGe(e){let{components:n,...t}=e;return(0,s.yg)(bGe,(0,p.A)({},LGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}NGe.isMDXComponent=!0;const kGe={toc:[]},zGe="wrapper";function PGe(e){let{components:n,...t}=e;return(0,s.yg)(zGe,(0,p.A)({},kGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}PGe.isMDXComponent=!0;const IGe={toc:[]},RGe="wrapper";function WGe(e){let{components:n,...t}=e;return(0,s.yg)(RGe,(0,p.A)({},IGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}WGe.isMDXComponent=!0;const SGe={toc:[]},BGe="wrapper";function EGe(e){let{components:n,...t}=e;return(0,s.yg)(BGe,(0,p.A)({},SGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}EGe.isMDXComponent=!0;const GGe={toc:[]},OGe="wrapper";function UGe(e){let{components:n,...t}=e;return(0,s.yg)(OGe,(0,p.A)({},GGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}UGe.isMDXComponent=!0;const FGe={toc:[]},VGe="wrapper";function qGe(e){let{components:n,...t}=e;return(0,s.yg)(VGe,(0,p.A)({},FGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}qGe.isMDXComponent=!0;const jGe={toc:[]},HGe="wrapper";function YGe(e){let{components:n,...t}=e;return(0,s.yg)(HGe,(0,p.A)({},jGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}YGe.isMDXComponent=!0;const QGe={toc:[]},$Ge="wrapper";function KGe(e){let{components:n,...t}=e;return(0,s.yg)($Ge,(0,p.A)({},QGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}KGe.isMDXComponent=!0;const JGe={toc:[]},ZGe="wrapper";function eOe(e){let{components:n,...t}=e;return(0,s.yg)(ZGe,(0,p.A)({},JGe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}eOe.isMDXComponent=!0;const nOe={toc:[]},tOe="wrapper";function oOe(e){let{components:n,...t}=e;return(0,s.yg)(tOe,(0,p.A)({},nOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}oOe.isMDXComponent=!0;const pOe={toc:[]},rOe="wrapper";function sOe(e){let{components:n,...t}=e;return(0,s.yg)(rOe,(0,p.A)({},pOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}sOe.isMDXComponent=!0;const cOe={toc:[]},aOe="wrapper";function iOe(e){let{components:n,...t}=e;return(0,s.yg)(aOe,(0,p.A)({},cOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}iOe.isMDXComponent=!0;const lOe={toc:[]},uOe="wrapper";function mOe(e){let{components:n,...t}=e;return(0,s.yg)(uOe,(0,p.A)({},lOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}mOe.isMDXComponent=!0;const yOe={toc:[]},dOe="wrapper";function hOe(e){let{components:n,...t}=e;return(0,s.yg)(dOe,(0,p.A)({},yOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Code#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}hOe.isMDXComponent=!0;const gOe={toc:[]},fOe="wrapper";function DOe(e){let{components:n,...t}=e;return(0,s.yg)(fOe,(0,p.A)({},gOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}DOe.isMDXComponent=!0;const MOe={toc:[]},XOe="wrapper";function _Oe(e){let{components:n,...t}=e;return(0,s.yg)(XOe,(0,p.A)({},MOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}_Oe.isMDXComponent=!0;const wOe={toc:[]},TOe="wrapper";function COe(e){let{components:n,...t}=e;return(0,s.yg)(TOe,(0,p.A)({},wOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}COe.isMDXComponent=!0;const xOe={toc:[]},AOe="wrapper";function vOe(e){let{components:n,...t}=e;return(0,s.yg)(AOe,(0,p.A)({},xOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}vOe.isMDXComponent=!0;const LOe={toc:[]},bOe="wrapper";function NOe(e){let{components:n,...t}=e;return(0,s.yg)(bOe,(0,p.A)({},LOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}NOe.isMDXComponent=!0;const kOe={toc:[]},zOe="wrapper";function POe(e){let{components:n,...t}=e;return(0,s.yg)(zOe,(0,p.A)({},kOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}POe.isMDXComponent=!0;const IOe={toc:[]},ROe="wrapper";function WOe(e){let{components:n,...t}=e;return(0,s.yg)(ROe,(0,p.A)({},IOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a standalone code signal."))}WOe.isMDXComponent=!0;const SOe={toc:[]},BOe="wrapper";function EOe(e){let{components:n,...t}=e;return(0,s.yg)(BOe,(0,p.A)({},SOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial code."))}EOe.isMDXComponent=!0;const GOe={toc:[]},OOe="wrapper";function UOe(e){let{components:n,...t}=e;return(0,s.yg)(OOe,(0,p.A)({},GOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Custom highlighter to use."))}UOe.isMDXComponent=!0;const FOe={toc:[]},VOe="wrapper";function qOe(e){let{components:n,...t}=e;return(0,s.yg)(VOe,(0,p.A)({},FOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Custom dialect to use."))}qOe.isMDXComponent=!0;const jOe={toc:[]},HOe="wrapper";function YOe(e){let{components:n,...t}=e;return(0,s.yg)(HOe,(0,p.A)({},jOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, CubicBezier} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<CubicBezier>();\n\n  view.add(\n    <CubicBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, -100]}\n      p1={[100, -100]}\n      p2={[-100, 100]}\n      p3={[200, 100]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}YOe.isMDXComponent=!0;const QOe={toc:[]},$Oe="wrapper";function KOe(e){let{components:n,...t}=e;return(0,s.yg)($Oe,(0,p.A)({},QOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing a cubic B\xe9zier curve."))}KOe.isMDXComponent=!0;const JOe={toc:[]},ZOe="wrapper";function eUe(e){let{components:n,...t}=e;return(0,s.yg)(ZOe,(0,p.A)({},JOe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}eUe.isMDXComponent=!0;const nUe={toc:[]},tUe="wrapper";function oUe(e){let{components:n,...t}=e;return(0,s.yg)(tUe,(0,p.A)({},nUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}oUe.isMDXComponent=!0;const pUe={toc:[]},rUe="wrapper";function sUe(e){let{components:n,...t}=e;return(0,s.yg)(rUe,(0,p.A)({},pUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}sUe.isMDXComponent=!0;const cUe={toc:[]},aUe="wrapper";function iUe(e){let{components:n,...t}=e;return(0,s.yg)(aUe,(0,p.A)({},cUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}iUe.isMDXComponent=!0;const lUe={toc:[]},uUe="wrapper";function mUe(e){let{components:n,...t}=e;return(0,s.yg)(uUe,(0,p.A)({},lUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}mUe.isMDXComponent=!0;const yUe={toc:[]},dUe="wrapper";function hUe(e){let{components:n,...t}=e;return(0,s.yg)(dUe,(0,p.A)({},yUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}hUe.isMDXComponent=!0;const gUe={toc:[]},fUe="wrapper";function DUe(e){let{components:n,...t}=e;return(0,s.yg)(fUe,(0,p.A)({},gUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}DUe.isMDXComponent=!0;const MUe={toc:[]},XUe="wrapper";function _Ue(e){let{components:n,...t}=e;return(0,s.yg)(XUe,(0,p.A)({},MUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}_Ue.isMDXComponent=!0;const wUe={toc:[]},TUe="wrapper";function CUe(e){let{components:n,...t}=e;return(0,s.yg)(TUe,(0,p.A)({},wUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}CUe.isMDXComponent=!0;const xUe={toc:[]},AUe="wrapper";function vUe(e){let{components:n,...t}=e;return(0,s.yg)(AUe,(0,p.A)({},xUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}vUe.isMDXComponent=!0;const LUe={toc:[]},bUe="wrapper";function NUe(e){let{components:n,...t}=e;return(0,s.yg)(bUe,(0,p.A)({},LUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}NUe.isMDXComponent=!0;const kUe={toc:[]},zUe="wrapper";function PUe(e){let{components:n,...t}=e;return(0,s.yg)(zUe,(0,p.A)({},kUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}PUe.isMDXComponent=!0;const IUe={toc:[]},RUe="wrapper";function WUe(e){let{components:n,...t}=e;return(0,s.yg)(RUe,(0,p.A)({},IUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}WUe.isMDXComponent=!0;const SUe={toc:[]},BUe="wrapper";function EUe(e){let{components:n,...t}=e;return(0,s.yg)(BUe,(0,p.A)({},SUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}EUe.isMDXComponent=!0;const GUe={toc:[]},OUe="wrapper";function UUe(e){let{components:n,...t}=e;return(0,s.yg)(OUe,(0,p.A)({},GUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}UUe.isMDXComponent=!0;const FUe={toc:[]},VUe="wrapper";function qUe(e){let{components:n,...t}=e;return(0,s.yg)(VUe,(0,p.A)({},FUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}qUe.isMDXComponent=!0;const jUe={toc:[]},HUe="wrapper";function YUe(e){let{components:n,...t}=e;return(0,s.yg)(HUe,(0,p.A)({},jUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}YUe.isMDXComponent=!0;const QUe={toc:[]},$Ue="wrapper";function KUe(e){let{components:n,...t}=e;return(0,s.yg)($Ue,(0,p.A)({},QUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}KUe.isMDXComponent=!0;const JUe={toc:[]},ZUe="wrapper";function eFe(e){let{components:n,...t}=e;return(0,s.yg)(ZUe,(0,p.A)({},JUe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}eFe.isMDXComponent=!0;const nFe={toc:[]},tFe="wrapper";function oFe(e){let{components:n,...t}=e;return(0,s.yg)(tFe,(0,p.A)({},nFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}oFe.isMDXComponent=!0;const pFe={toc:[]},rFe="wrapper";function sFe(e){let{components:n,...t}=e;return(0,s.yg)(rFe,(0,p.A)({},pFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}sFe.isMDXComponent=!0;const cFe={toc:[]},aFe="wrapper";function iFe(e){let{components:n,...t}=e;return(0,s.yg)(aFe,(0,p.A)({},cFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}iFe.isMDXComponent=!0;const lFe={toc:[]},uFe="wrapper";function mFe(e){let{components:n,...t}=e;return(0,s.yg)(uFe,(0,p.A)({},lFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}mFe.isMDXComponent=!0;const yFe={toc:[]},dFe="wrapper";function hFe(e){let{components:n,...t}=e;return(0,s.yg)(dFe,(0,p.A)({},yFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}hFe.isMDXComponent=!0;const gFe={toc:[]},fFe="wrapper";function DFe(e){let{components:n,...t}=e;return(0,s.yg)(fFe,(0,p.A)({},gFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}DFe.isMDXComponent=!0;const MFe={toc:[]},XFe="wrapper";function _Fe(e){let{components:n,...t}=e;return(0,s.yg)(XFe,(0,p.A)({},MFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}_Fe.isMDXComponent=!0;const wFe={toc:[]},TFe="wrapper";function CFe(e){let{components:n,...t}=e;return(0,s.yg)(TFe,(0,p.A)({},wFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}CFe.isMDXComponent=!0;const xFe={toc:[]},AFe="wrapper";function vFe(e){let{components:n,...t}=e;return(0,s.yg)(AFe,(0,p.A)({},xFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}vFe.isMDXComponent=!0;const LFe={toc:[]},bFe="wrapper";function NFe(e){let{components:n,...t}=e;return(0,s.yg)(bFe,(0,p.A)({},LFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}NFe.isMDXComponent=!0;const kFe={toc:[]},zFe="wrapper";function PFe(e){let{components:n,...t}=e;return(0,s.yg)(zFe,(0,p.A)({},kFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}PFe.isMDXComponent=!0;const IFe={toc:[]},RFe="wrapper";function WFe(e){let{components:n,...t}=e;return(0,s.yg)(RFe,(0,p.A)({},IFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}WFe.isMDXComponent=!0;const SFe={toc:[]},BFe="wrapper";function EFe(e){let{components:n,...t}=e;return(0,s.yg)(BFe,(0,p.A)({},SFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}EFe.isMDXComponent=!0;const GFe={toc:[]},OFe="wrapper";function UFe(e){let{components:n,...t}=e;return(0,s.yg)(OFe,(0,p.A)({},GFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start point of the B\xe9zier curve."))}UFe.isMDXComponent=!0;const FFe={toc:[]},VFe="wrapper";function qFe(e){let{components:n,...t}=e;return(0,s.yg)(VFe,(0,p.A)({},FFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The first control point of the B\xe9zier curve."))}qFe.isMDXComponent=!0;const jFe={toc:[]},HFe="wrapper";function YFe(e){let{components:n,...t}=e;return(0,s.yg)(HFe,(0,p.A)({},jFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The second control point of the B\xe9zier curve."))}YFe.isMDXComponent=!0;const QFe={toc:[]},$Fe="wrapper";function KFe(e){let{components:n,...t}=e;return(0,s.yg)($Fe,(0,p.A)({},QFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end point of the B\xe9zier curve."))}KFe.isMDXComponent=!0;const JFe={toc:[]},ZFe="wrapper";function eVe(e){let{components:n,...t}=e;return(0,s.yg)(ZFe,(0,p.A)({},JFe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}eVe.isMDXComponent=!0;const nVe={toc:[]},tVe="wrapper";function oVe(e){let{components:n,...t}=e;return(0,s.yg)(tVe,(0,p.A)({},nVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}oVe.isMDXComponent=!0;const pVe={toc:[]},rVe="wrapper";function sVe(e){let{components:n,...t}=e;return(0,s.yg)(rVe,(0,p.A)({},pVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}sVe.isMDXComponent=!0;const cVe={toc:[]},aVe="wrapper";function iVe(e){let{components:n,...t}=e;return(0,s.yg)(aVe,(0,p.A)({},cVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}iVe.isMDXComponent=!0;const lVe={toc:[]},uVe="wrapper";function mVe(e){let{components:n,...t}=e;return(0,s.yg)(uVe,(0,p.A)({},lVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}mVe.isMDXComponent=!0;const yVe={toc:[]},dVe="wrapper";function hVe(e){let{components:n,...t}=e;return(0,s.yg)(dVe,(0,p.A)({},yVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}hVe.isMDXComponent=!0;const gVe={toc:[]},fVe="wrapper";function DVe(e){let{components:n,...t}=e;return(0,s.yg)(fVe,(0,p.A)({},gVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}DVe.isMDXComponent=!0;const MVe={toc:[]},XVe="wrapper";function _Ve(e){let{components:n,...t}=e;return(0,s.yg)(XVe,(0,p.A)({},MVe,t,{components:n,mdxType:"MDXLayout"}))}_Ve.isMDXComponent=!0;const wVe={toc:[]},TVe="wrapper";function CVe(e){let{components:n,...t}=e;return(0,s.yg)(TVe,(0,p.A)({},wVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}CVe.isMDXComponent=!0;const xVe={toc:[]},AVe="wrapper";function vVe(e){let{components:n,...t}=e;return(0,s.yg)(AVe,(0,p.A)({},xVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}vVe.isMDXComponent=!0;const LVe={toc:[]},bVe="wrapper";function NVe(e){let{components:n,...t}=e;return(0,s.yg)(bVe,(0,p.A)({},LVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}NVe.isMDXComponent=!0;const kVe={toc:[]},zVe="wrapper";function PVe(e){let{components:n,...t}=e;return(0,s.yg)(zVe,(0,p.A)({},kVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}PVe.isMDXComponent=!0;const IVe={toc:[]},RVe="wrapper";function WVe(e){let{components:n,...t}=e;return(0,s.yg)(RVe,(0,p.A)({},IVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}WVe.isMDXComponent=!0;const SVe={toc:[]},BVe="wrapper";function EVe(e){let{components:n,...t}=e;return(0,s.yg)(BVe,(0,p.A)({},SVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}EVe.isMDXComponent=!0;const GVe={toc:[]},OVe="wrapper";function UVe(e){let{components:n,...t}=e;return(0,s.yg)(OVe,(0,p.A)({},GVe,t,{components:n,mdxType:"MDXLayout"}))}UVe.isMDXComponent=!0;const FVe={toc:[]},VVe="wrapper";function qVe(e){let{components:n,...t}=e;return(0,s.yg)(VVe,(0,p.A)({},FVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}qVe.isMDXComponent=!0;const jVe={toc:[]},HVe="wrapper";function YVe(e){let{components:n,...t}=e;return(0,s.yg)(HVe,(0,p.A)({},jVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}YVe.isMDXComponent=!0;const QVe={toc:[]},$Ve="wrapper";function KVe(e){let{components:n,...t}=e;return(0,s.yg)($Ve,(0,p.A)({},QVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}KVe.isMDXComponent=!0;const JVe={toc:[]},ZVe="wrapper";function eqe(e){let{components:n,...t}=e;return(0,s.yg)(ZVe,(0,p.A)({},JVe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}eqe.isMDXComponent=!0;const nqe={toc:[]},tqe="wrapper";function oqe(e){let{components:n,...t}=e;return(0,s.yg)(tqe,(0,p.A)({},nqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}oqe.isMDXComponent=!0;const pqe={toc:[]},rqe="wrapper";function sqe(e){let{components:n,...t}=e;return(0,s.yg)(rqe,(0,p.A)({},pqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}sqe.isMDXComponent=!0;const cqe={toc:[]},aqe="wrapper";function iqe(e){let{components:n,...t}=e;return(0,s.yg)(aqe,(0,p.A)({},cqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}iqe.isMDXComponent=!0;const lqe={toc:[]},uqe="wrapper";function mqe(e){let{components:n,...t}=e;return(0,s.yg)(uqe,(0,p.A)({},lqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}mqe.isMDXComponent=!0;const yqe={toc:[]},dqe="wrapper";function hqe(e){let{components:n,...t}=e;return(0,s.yg)(dqe,(0,p.A)({},yqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}hqe.isMDXComponent=!0;const gqe={toc:[]},fqe="wrapper";function Dqe(e){let{components:n,...t}=e;return(0,s.yg)(fqe,(0,p.A)({},gqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Dqe.isMDXComponent=!0;const Mqe={toc:[]},Xqe="wrapper";function _qe(e){let{components:n,...t}=e;return(0,s.yg)(Xqe,(0,p.A)({},Mqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}_qe.isMDXComponent=!0;const wqe={toc:[]},Tqe="wrapper";function Cqe(e){let{components:n,...t}=e;return(0,s.yg)(Tqe,(0,p.A)({},wqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Cqe.isMDXComponent=!0;const xqe={toc:[]},Aqe="wrapper";function vqe(e){let{components:n,...t}=e;return(0,s.yg)(Aqe,(0,p.A)({},xqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}vqe.isMDXComponent=!0;const Lqe={toc:[]},bqe="wrapper";function Nqe(e){let{components:n,...t}=e;return(0,s.yg)(bqe,(0,p.A)({},Lqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Nqe.isMDXComponent=!0;const kqe={toc:[]},zqe="wrapper";function Pqe(e){let{components:n,...t}=e;return(0,s.yg)(zqe,(0,p.A)({},kqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}Pqe.isMDXComponent=!0;const Iqe={toc:[]},Rqe="wrapper";function Wqe(e){let{components:n,...t}=e;return(0,s.yg)(Rqe,(0,p.A)({},Iqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}Wqe.isMDXComponent=!0;const Sqe={toc:[]},Bqe="wrapper";function Eqe(e){let{components:n,...t}=e;return(0,s.yg)(Bqe,(0,p.A)({},Sqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Eqe.isMDXComponent=!0;const Gqe={toc:[]},Oqe="wrapper";function Uqe(e){let{components:n,...t}=e;return(0,s.yg)(Oqe,(0,p.A)({},Gqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}Uqe.isMDXComponent=!0;const Fqe={toc:[]},Vqe="wrapper";function qqe(e){let{components:n,...t}=e;return(0,s.yg)(Vqe,(0,p.A)({},Fqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}qqe.isMDXComponent=!0;const jqe={toc:[]},Hqe="wrapper";function Yqe(e){let{components:n,...t}=e;return(0,s.yg)(Hqe,(0,p.A)({},jqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}Yqe.isMDXComponent=!0;const Qqe={toc:[]},$qe="wrapper";function Kqe(e){let{components:n,...t}=e;return(0,s.yg)($qe,(0,p.A)({},Qqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Kqe.isMDXComponent=!0;const Jqe={toc:[]},Zqe="wrapper";function eje(e){let{components:n,...t}=e;return(0,s.yg)(Zqe,(0,p.A)({},Jqe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}eje.isMDXComponent=!0;const nje={toc:[]},tje="wrapper";function oje(e){let{components:n,...t}=e;return(0,s.yg)(tje,(0,p.A)({},nje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}oje.isMDXComponent=!0;const pje={toc:[]},rje="wrapper";function sje(e){let{components:n,...t}=e;return(0,s.yg)(rje,(0,p.A)({},pje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}sje.isMDXComponent=!0;const cje={toc:[]},aje="wrapper";function ije(e){let{components:n,...t}=e;return(0,s.yg)(aje,(0,p.A)({},cje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}ije.isMDXComponent=!0;const lje={toc:[]},uje="wrapper";function mje(e){let{components:n,...t}=e;return(0,s.yg)(uje,(0,p.A)({},lje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}mje.isMDXComponent=!0;const yje={toc:[]},dje="wrapper";function hje(e){let{components:n,...t}=e;return(0,s.yg)(dje,(0,p.A)({},yje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}hje.isMDXComponent=!0;const gje={toc:[]},fje="wrapper";function Dje(e){let{components:n,...t}=e;return(0,s.yg)(fje,(0,p.A)({},gje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Dje.isMDXComponent=!0;const Mje={toc:[]},Xje="wrapper";function _je(e){let{components:n,...t}=e;return(0,s.yg)(Xje,(0,p.A)({},Mje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}_je.isMDXComponent=!0;const wje={toc:[]},Tje="wrapper";function Cje(e){let{components:n,...t}=e;return(0,s.yg)(Tje,(0,p.A)({},wje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}Cje.isMDXComponent=!0;const xje={toc:[]},Aje="wrapper";function vje(e){let{components:n,...t}=e;return(0,s.yg)(Aje,(0,p.A)({},xje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}vje.isMDXComponent=!0;const Lje={toc:[]},bje="wrapper";function Nje(e){let{components:n,...t}=e;return(0,s.yg)(bje,(0,p.A)({},Lje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Nje.isMDXComponent=!0;const kje={toc:[]},zje="wrapper";function Pje(e){let{components:n,...t}=e;return(0,s.yg)(zje,(0,p.A)({},kje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Pje.isMDXComponent=!0;const Ije={toc:[]},Rje="wrapper";function Wje(e){let{components:n,...t}=e;return(0,s.yg)(Rje,(0,p.A)({},Ije,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}Wje.isMDXComponent=!0;const Sje={toc:[]},Bje="wrapper";function Eje(e){let{components:n,...t}=e;return(0,s.yg)(Bje,(0,p.A)({},Sje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Eje.isMDXComponent=!0;const Gje={toc:[]},Oje="wrapper";function Uje(e){let{components:n,...t}=e;return(0,s.yg)(Oje,(0,p.A)({},Gje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}Uje.isMDXComponent=!0;const Fje={toc:[]},Vje="wrapper";function qje(e){let{components:n,...t}=e;return(0,s.yg)(Vje,(0,p.A)({},Fje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}qje.isMDXComponent=!0;const jje={toc:[]},Hje="wrapper";function Yje(e){let{components:n,...t}=e;return(0,s.yg)(Hje,(0,p.A)({},jje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}Yje.isMDXComponent=!0;const Qje={toc:[]},$je="wrapper";function Kje(e){let{components:n,...t}=e;return(0,s.yg)($je,(0,p.A)({},Qje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Kje.isMDXComponent=!0;const Jje={toc:[]},Zje="wrapper";function eHe(e){let{components:n,...t}=e;return(0,s.yg)(Zje,(0,p.A)({},Jje,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}eHe.isMDXComponent=!0;const nHe={toc:[]},tHe="wrapper";function oHe(e){let{components:n,...t}=e;return(0,s.yg)(tHe,(0,p.A)({},nHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}oHe.isMDXComponent=!0;const pHe={toc:[]},rHe="wrapper";function sHe(e){let{components:n,...t}=e;return(0,s.yg)(rHe,(0,p.A)({},pHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}sHe.isMDXComponent=!0;const cHe={toc:[]},aHe="wrapper";function iHe(e){let{components:n,...t}=e;return(0,s.yg)(aHe,(0,p.A)({},cHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}iHe.isMDXComponent=!0;const lHe={toc:[]},uHe="wrapper";function mHe(e){let{components:n,...t}=e;return(0,s.yg)(uHe,(0,p.A)({},lHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}mHe.isMDXComponent=!0;const yHe={toc:[]},dHe="wrapper";function hHe(e){let{components:n,...t}=e;return(0,s.yg)(dHe,(0,p.A)({},yHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}hHe.isMDXComponent=!0;const gHe={toc:[]},fHe="wrapper";function DHe(e){let{components:n,...t}=e;return(0,s.yg)(fHe,(0,p.A)({},gHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}DHe.isMDXComponent=!0;const MHe={toc:[]},XHe="wrapper";function _He(e){let{components:n,...t}=e;return(0,s.yg)(XHe,(0,p.A)({},MHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}_He.isMDXComponent=!0;const wHe={toc:[]},THe="wrapper";function CHe(e){let{components:n,...t}=e;return(0,s.yg)(THe,(0,p.A)({},wHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}CHe.isMDXComponent=!0;const xHe={toc:[]},AHe="wrapper";function vHe(e){let{components:n,...t}=e;return(0,s.yg)(AHe,(0,p.A)({},xHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}vHe.isMDXComponent=!0;const LHe={toc:[]},bHe="wrapper";function NHe(e){let{components:n,...t}=e;return(0,s.yg)(bHe,(0,p.A)({},LHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}NHe.isMDXComponent=!0;const kHe={toc:[]},zHe="wrapper";function PHe(e){let{components:n,...t}=e;return(0,s.yg)(zHe,(0,p.A)({},kHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}PHe.isMDXComponent=!0;const IHe={toc:[]},RHe="wrapper";function WHe(e){let{components:n,...t}=e;return(0,s.yg)(RHe,(0,p.A)({},IHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}WHe.isMDXComponent=!0;const SHe={toc:[]},BHe="wrapper";function EHe(e){let{components:n,...t}=e;return(0,s.yg)(BHe,(0,p.A)({},SHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}EHe.isMDXComponent=!0;const GHe={toc:[]},OHe="wrapper";function UHe(e){let{components:n,...t}=e;return(0,s.yg)(OHe,(0,p.A)({},GHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}UHe.isMDXComponent=!0;const FHe={toc:[]},VHe="wrapper";function qHe(e){let{components:n,...t}=e;return(0,s.yg)(VHe,(0,p.A)({},FHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}qHe.isMDXComponent=!0;const jHe={toc:[]},HHe="wrapper";function YHe(e){let{components:n,...t}=e;return(0,s.yg)(HHe,(0,p.A)({},jHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}YHe.isMDXComponent=!0;const QHe={toc:[]},$He="wrapper";function KHe(e){let{components:n,...t}=e;return(0,s.yg)($He,(0,p.A)({},QHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}KHe.isMDXComponent=!0;const JHe={toc:[]},ZHe="wrapper";function eYe(e){let{components:n,...t}=e;return(0,s.yg)(ZHe,(0,p.A)({},JHe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}eYe.isMDXComponent=!0;const nYe={toc:[]},tYe="wrapper";function oYe(e){let{components:n,...t}=e;return(0,s.yg)(tYe,(0,p.A)({},nYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}oYe.isMDXComponent=!0;const pYe={toc:[]},rYe="wrapper";function sYe(e){let{components:n,...t}=e;return(0,s.yg)(rYe,(0,p.A)({},pYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}sYe.isMDXComponent=!0;const cYe={toc:[]},aYe="wrapper";function iYe(e){let{components:n,...t}=e;return(0,s.yg)(aYe,(0,p.A)({},cYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}iYe.isMDXComponent=!0;const lYe={toc:[]},uYe="wrapper";function mYe(e){let{components:n,...t}=e;return(0,s.yg)(uYe,(0,p.A)({},lYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}mYe.isMDXComponent=!0;const yYe={toc:[]},dYe="wrapper";function hYe(e){let{components:n,...t}=e;return(0,s.yg)(dYe,(0,p.A)({},yYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}hYe.isMDXComponent=!0;const gYe={toc:[]},fYe="wrapper";function DYe(e){let{components:n,...t}=e;return(0,s.yg)(fYe,(0,p.A)({},gYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}DYe.isMDXComponent=!0;const MYe={toc:[]},XYe="wrapper";function _Ye(e){let{components:n,...t}=e;return(0,s.yg)(XYe,(0,p.A)({},MYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}_Ye.isMDXComponent=!0;const wYe={toc:[]},TYe="wrapper";function CYe(e){let{components:n,...t}=e;return(0,s.yg)(TYe,(0,p.A)({},wYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}CYe.isMDXComponent=!0;const xYe={toc:[]},AYe="wrapper";function vYe(e){let{components:n,...t}=e;return(0,s.yg)(AYe,(0,p.A)({},xYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}vYe.isMDXComponent=!0;const LYe={toc:[]},bYe="wrapper";function NYe(e){let{components:n,...t}=e;return(0,s.yg)(bYe,(0,p.A)({},LYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}NYe.isMDXComponent=!0;const kYe={toc:[]},zYe="wrapper";function PYe(e){let{components:n,...t}=e;return(0,s.yg)(zYe,(0,p.A)({},kYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}PYe.isMDXComponent=!0;const IYe={toc:[]},RYe="wrapper";function WYe(e){let{components:n,...t}=e;return(0,s.yg)(RYe,(0,p.A)({},IYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}WYe.isMDXComponent=!0;const SYe={toc:[]},BYe="wrapper";function EYe(e){let{components:n,...t}=e;return(0,s.yg)(BYe,(0,p.A)({},SYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}EYe.isMDXComponent=!0;const GYe={toc:[]},OYe="wrapper";function UYe(e){let{components:n,...t}=e;return(0,s.yg)(OYe,(0,p.A)({},GYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}UYe.isMDXComponent=!0;const FYe={toc:[]},VYe="wrapper";function qYe(e){let{components:n,...t}=e;return(0,s.yg)(VYe,(0,p.A)({},FYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}qYe.isMDXComponent=!0;const jYe={toc:[]},HYe="wrapper";function YYe(e){let{components:n,...t}=e;return(0,s.yg)(HYe,(0,p.A)({},jYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}YYe.isMDXComponent=!0;const QYe={toc:[]},$Ye="wrapper";function KYe(e){let{components:n,...t}=e;return(0,s.yg)($Ye,(0,p.A)({},QYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}KYe.isMDXComponent=!0;const JYe={toc:[]},ZYe="wrapper";function eQe(e){let{components:n,...t}=e;return(0,s.yg)(ZYe,(0,p.A)({},JYe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}eQe.isMDXComponent=!0;const nQe={toc:[]},tQe="wrapper";function oQe(e){let{components:n,...t}=e;return(0,s.yg)(tQe,(0,p.A)({},nQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}oQe.isMDXComponent=!0;const pQe={toc:[]},rQe="wrapper";function sQe(e){let{components:n,...t}=e;return(0,s.yg)(rQe,(0,p.A)({},pQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}sQe.isMDXComponent=!0;const cQe={toc:[]},aQe="wrapper";function iQe(e){let{components:n,...t}=e;return(0,s.yg)(aQe,(0,p.A)({},cQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}iQe.isMDXComponent=!0;const lQe={toc:[]},uQe="wrapper";function mQe(e){let{components:n,...t}=e;return(0,s.yg)(uQe,(0,p.A)({},lQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}mQe.isMDXComponent=!0;const yQe={toc:[]},dQe="wrapper";function hQe(e){let{components:n,...t}=e;return(0,s.yg)(dQe,(0,p.A)({},yQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}hQe.isMDXComponent=!0;const gQe={toc:[]},fQe="wrapper";function DQe(e){let{components:n,...t}=e;return(0,s.yg)(fQe,(0,p.A)({},gQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}DQe.isMDXComponent=!0;const MQe={toc:[]},XQe="wrapper";function _Qe(e){let{components:n,...t}=e;return(0,s.yg)(XQe,(0,p.A)({},MQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}_Qe.isMDXComponent=!0;const wQe={toc:[]},TQe="wrapper";function CQe(e){let{components:n,...t}=e;return(0,s.yg)(TQe,(0,p.A)({},wQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}CQe.isMDXComponent=!0;const xQe={toc:[]},AQe="wrapper";function vQe(e){let{components:n,...t}=e;return(0,s.yg)(AQe,(0,p.A)({},xQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}vQe.isMDXComponent=!0;const LQe={toc:[]},bQe="wrapper";function NQe(e){let{components:n,...t}=e;return(0,s.yg)(bQe,(0,p.A)({},LQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}NQe.isMDXComponent=!0;const kQe={toc:[]},zQe="wrapper";function PQe(e){let{components:n,...t}=e;return(0,s.yg)(zQe,(0,p.A)({},kQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}PQe.isMDXComponent=!0;const IQe={toc:[]},RQe="wrapper";function WQe(e){let{components:n,...t}=e;return(0,s.yg)(RQe,(0,p.A)({},IQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}WQe.isMDXComponent=!0;const SQe={toc:[]},BQe="wrapper";function EQe(e){let{components:n,...t}=e;return(0,s.yg)(BQe,(0,p.A)({},SQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}EQe.isMDXComponent=!0;const GQe={toc:[]},OQe="wrapper";function UQe(e){let{components:n,...t}=e;return(0,s.yg)(OQe,(0,p.A)({},GQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}UQe.isMDXComponent=!0;const FQe={toc:[]},VQe="wrapper";function qQe(e){let{components:n,...t}=e;return(0,s.yg)(VQe,(0,p.A)({},FQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}qQe.isMDXComponent=!0;const jQe={toc:[]},HQe="wrapper";function YQe(e){let{components:n,...t}=e;return(0,s.yg)(HQe,(0,p.A)({},jQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}YQe.isMDXComponent=!0;const QQe={toc:[]},$Qe="wrapper";function KQe(e){let{components:n,...t}=e;return(0,s.yg)($Qe,(0,p.A)({},QQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}KQe.isMDXComponent=!0;const JQe={toc:[]},ZQe="wrapper";function e$e(e){let{components:n,...t}=e;return(0,s.yg)(ZQe,(0,p.A)({},JQe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}e$e.isMDXComponent=!0;const n$e={toc:[]},t$e="wrapper";function o$e(e){let{components:n,...t}=e;return(0,s.yg)(t$e,(0,p.A)({},n$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}o$e.isMDXComponent=!0;const p$e={toc:[]},r$e="wrapper";function s$e(e){let{components:n,...t}=e;return(0,s.yg)(r$e,(0,p.A)({},p$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}s$e.isMDXComponent=!0;const c$e={toc:[]},a$e="wrapper";function i$e(e){let{components:n,...t}=e;return(0,s.yg)(a$e,(0,p.A)({},c$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}i$e.isMDXComponent=!0;const l$e={toc:[]},u$e="wrapper";function m$e(e){let{components:n,...t}=e;return(0,s.yg)(u$e,(0,p.A)({},l$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}m$e.isMDXComponent=!0;const y$e={toc:[]},d$e="wrapper";function h$e(e){let{components:n,...t}=e;return(0,s.yg)(d$e,(0,p.A)({},y$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}h$e.isMDXComponent=!0;const g$e={toc:[]},f$e="wrapper";function D$e(e){let{components:n,...t}=e;return(0,s.yg)(f$e,(0,p.A)({},g$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}D$e.isMDXComponent=!0;const M$e={toc:[]},X$e="wrapper";function _$e(e){let{components:n,...t}=e;return(0,s.yg)(X$e,(0,p.A)({},M$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}_$e.isMDXComponent=!0;const w$e={toc:[]},T$e="wrapper";function C$e(e){let{components:n,...t}=e;return(0,s.yg)(T$e,(0,p.A)({},w$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}C$e.isMDXComponent=!0;const x$e={toc:[]},A$e="wrapper";function v$e(e){let{components:n,...t}=e;return(0,s.yg)(A$e,(0,p.A)({},x$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}v$e.isMDXComponent=!0;const L$e={toc:[]},b$e="wrapper";function N$e(e){let{components:n,...t}=e;return(0,s.yg)(b$e,(0,p.A)({},L$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}N$e.isMDXComponent=!0;const k$e={toc:[]},z$e="wrapper";function P$e(e){let{components:n,...t}=e;return(0,s.yg)(z$e,(0,p.A)({},k$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}P$e.isMDXComponent=!0;const I$e={toc:[]},R$e="wrapper";function W$e(e){let{components:n,...t}=e;return(0,s.yg)(R$e,(0,p.A)({},I$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}W$e.isMDXComponent=!0;const S$e={toc:[]},B$e="wrapper";function E$e(e){let{components:n,...t}=e;return(0,s.yg)(B$e,(0,p.A)({},S$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}E$e.isMDXComponent=!0;const G$e={toc:[]},O$e="wrapper";function U$e(e){let{components:n,...t}=e;return(0,s.yg)(O$e,(0,p.A)({},G$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}U$e.isMDXComponent=!0;const F$e={toc:[]},V$e="wrapper";function q$e(e){let{components:n,...t}=e;return(0,s.yg)(V$e,(0,p.A)({},F$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}q$e.isMDXComponent=!0;const j$e={toc:[]},H$e="wrapper";function Y$e(e){let{components:n,...t}=e;return(0,s.yg)(H$e,(0,p.A)({},j$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Y$e.isMDXComponent=!0;const Q$e={toc:[]},$$e="wrapper";function K$e(e){let{components:n,...t}=e;return(0,s.yg)($$e,(0,p.A)({},Q$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}K$e.isMDXComponent=!0;const J$e={toc:[]},Z$e="wrapper";function eKe(e){let{components:n,...t}=e;return(0,s.yg)(Z$e,(0,p.A)({},J$e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}eKe.isMDXComponent=!0;const nKe={toc:[]},tKe="wrapper";function oKe(e){let{components:n,...t}=e;return(0,s.yg)(tKe,(0,p.A)({},nKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}oKe.isMDXComponent=!0;const pKe={toc:[]},rKe="wrapper";function sKe(e){let{components:n,...t}=e;return(0,s.yg)(rKe,(0,p.A)({},pKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}sKe.isMDXComponent=!0;const cKe={toc:[]},aKe="wrapper";function iKe(e){let{components:n,...t}=e;return(0,s.yg)(aKe,(0,p.A)({},cKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}iKe.isMDXComponent=!0;const lKe={toc:[]},uKe="wrapper";function mKe(e){let{components:n,...t}=e;return(0,s.yg)(uKe,(0,p.A)({},lKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}mKe.isMDXComponent=!0;const yKe={toc:[]},dKe="wrapper";function hKe(e){let{components:n,...t}=e;return(0,s.yg)(dKe,(0,p.A)({},yKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}hKe.isMDXComponent=!0;const gKe={toc:[]},fKe="wrapper";function DKe(e){let{components:n,...t}=e;return(0,s.yg)(fKe,(0,p.A)({},gKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}DKe.isMDXComponent=!0;const MKe={toc:[]},XKe="wrapper";function _Ke(e){let{components:n,...t}=e;return(0,s.yg)(XKe,(0,p.A)({},MKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}_Ke.isMDXComponent=!0;const wKe={toc:[]},TKe="wrapper";function CKe(e){let{components:n,...t}=e;return(0,s.yg)(TKe,(0,p.A)({},wKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}CKe.isMDXComponent=!0;const xKe={toc:[]},AKe="wrapper";function vKe(e){let{components:n,...t}=e;return(0,s.yg)(AKe,(0,p.A)({},xKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}vKe.isMDXComponent=!0;const LKe={toc:[]},bKe="wrapper";function NKe(e){let{components:n,...t}=e;return(0,s.yg)(bKe,(0,p.A)({},LKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}NKe.isMDXComponent=!0;const kKe={toc:[]},zKe="wrapper";function PKe(e){let{components:n,...t}=e;return(0,s.yg)(zKe,(0,p.A)({},kKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}PKe.isMDXComponent=!0;const IKe={toc:[]},RKe="wrapper";function WKe(e){let{components:n,...t}=e;return(0,s.yg)(RKe,(0,p.A)({},IKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}WKe.isMDXComponent=!0;const SKe={toc:[]},BKe="wrapper";function EKe(e){let{components:n,...t}=e;return(0,s.yg)(BKe,(0,p.A)({},SKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}EKe.isMDXComponent=!0;const GKe={toc:[]},OKe="wrapper";function UKe(e){let{components:n,...t}=e;return(0,s.yg)(OKe,(0,p.A)({},GKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}UKe.isMDXComponent=!0;const FKe={toc:[]},VKe="wrapper";function qKe(e){let{components:n,...t}=e;return(0,s.yg)(VKe,(0,p.A)({},FKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}qKe.isMDXComponent=!0;const jKe={toc:[]},HKe="wrapper";function YKe(e){let{components:n,...t}=e;return(0,s.yg)(HKe,(0,p.A)({},jKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}YKe.isMDXComponent=!0;const QKe={toc:[]},$Ke="wrapper";function KKe(e){let{components:n,...t}=e;return(0,s.yg)($Ke,(0,p.A)({},QKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}KKe.isMDXComponent=!0;const JKe={toc:[]},ZKe="wrapper";function eJe(e){let{components:n,...t}=e;return(0,s.yg)(ZKe,(0,p.A)({},JKe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}eJe.isMDXComponent=!0;const nJe={toc:[]},tJe="wrapper";function oJe(e){let{components:n,...t}=e;return(0,s.yg)(tJe,(0,p.A)({},nJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}oJe.isMDXComponent=!0;const pJe={toc:[]},rJe="wrapper";function sJe(e){let{components:n,...t}=e;return(0,s.yg)(rJe,(0,p.A)({},pJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}sJe.isMDXComponent=!0;const cJe={toc:[]},aJe="wrapper";function iJe(e){let{components:n,...t}=e;return(0,s.yg)(aJe,(0,p.A)({},cJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}iJe.isMDXComponent=!0;const lJe={toc:[]},uJe="wrapper";function mJe(e){let{components:n,...t}=e;return(0,s.yg)(uJe,(0,p.A)({},lJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}mJe.isMDXComponent=!0;const yJe={toc:[]},dJe="wrapper";function hJe(e){let{components:n,...t}=e;return(0,s.yg)(dJe,(0,p.A)({},yJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}hJe.isMDXComponent=!0;const gJe={toc:[]},fJe="wrapper";function DJe(e){let{components:n,...t}=e;return(0,s.yg)(fJe,(0,p.A)({},gJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}DJe.isMDXComponent=!0;const MJe={toc:[]},XJe="wrapper";function _Je(e){let{components:n,...t}=e;return(0,s.yg)(XJe,(0,p.A)({},MJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}_Je.isMDXComponent=!0;const wJe={toc:[]},TJe="wrapper";function CJe(e){let{components:n,...t}=e;return(0,s.yg)(TJe,(0,p.A)({},wJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}CJe.isMDXComponent=!0;const xJe={toc:[]},AJe="wrapper";function vJe(e){let{components:n,...t}=e;return(0,s.yg)(AJe,(0,p.A)({},xJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}vJe.isMDXComponent=!0;const LJe={toc:[]},bJe="wrapper";function NJe(e){let{components:n,...t}=e;return(0,s.yg)(bJe,(0,p.A)({},LJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}NJe.isMDXComponent=!0;const kJe={toc:[]},zJe="wrapper";function PJe(e){let{components:n,...t}=e;return(0,s.yg)(zJe,(0,p.A)({},kJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}PJe.isMDXComponent=!0;const IJe={toc:[]},RJe="wrapper";function WJe(e){let{components:n,...t}=e;return(0,s.yg)(RJe,(0,p.A)({},IJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}WJe.isMDXComponent=!0;const SJe={toc:[]},BJe="wrapper";function EJe(e){let{components:n,...t}=e;return(0,s.yg)(BJe,(0,p.A)({},SJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}EJe.isMDXComponent=!0;const GJe={toc:[]},OJe="wrapper";function UJe(e){let{components:n,...t}=e;return(0,s.yg)(OJe,(0,p.A)({},GJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}UJe.isMDXComponent=!0;const FJe={toc:[]},VJe="wrapper";function qJe(e){let{components:n,...t}=e;return(0,s.yg)(VJe,(0,p.A)({},FJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}qJe.isMDXComponent=!0;const jJe={toc:[]},HJe="wrapper";function YJe(e){let{components:n,...t}=e;return(0,s.yg)(HJe,(0,p.A)({},jJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}YJe.isMDXComponent=!0;const QJe={toc:[]},$Je="wrapper";function KJe(e){let{components:n,...t}=e;return(0,s.yg)($Je,(0,p.A)({},QJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}KJe.isMDXComponent=!0;const JJe={toc:[]},ZJe="wrapper";function eZe(e){let{components:n,...t}=e;return(0,s.yg)(ZJe,(0,p.A)({},JJe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}eZe.isMDXComponent=!0;const nZe={toc:[]},tZe="wrapper";function oZe(e){let{components:n,...t}=e;return(0,s.yg)(tZe,(0,p.A)({},nZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}oZe.isMDXComponent=!0;const pZe={toc:[]},rZe="wrapper";function sZe(e){let{components:n,...t}=e;return(0,s.yg)(rZe,(0,p.A)({},pZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}sZe.isMDXComponent=!0;const cZe={toc:[]},aZe="wrapper";function iZe(e){let{components:n,...t}=e;return(0,s.yg)(aZe,(0,p.A)({},cZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}iZe.isMDXComponent=!0;const lZe={toc:[]},uZe="wrapper";function mZe(e){let{components:n,...t}=e;return(0,s.yg)(uZe,(0,p.A)({},lZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}mZe.isMDXComponent=!0;const yZe={toc:[]},dZe="wrapper";function hZe(e){let{components:n,...t}=e;return(0,s.yg)(dZe,(0,p.A)({},yZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}hZe.isMDXComponent=!0;const gZe={toc:[]},fZe="wrapper";function DZe(e){let{components:n,...t}=e;return(0,s.yg)(fZe,(0,p.A)({},gZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}DZe.isMDXComponent=!0;const MZe={toc:[]},XZe="wrapper";function _Ze(e){let{components:n,...t}=e;return(0,s.yg)(XZe,(0,p.A)({},MZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}_Ze.isMDXComponent=!0;const wZe={toc:[]},TZe="wrapper";function CZe(e){let{components:n,...t}=e;return(0,s.yg)(TZe,(0,p.A)({},wZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}CZe.isMDXComponent=!0;const xZe={toc:[]},AZe="wrapper";function vZe(e){let{components:n,...t}=e;return(0,s.yg)(AZe,(0,p.A)({},xZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}vZe.isMDXComponent=!0;const LZe={toc:[]},bZe="wrapper";function NZe(e){let{components:n,...t}=e;return(0,s.yg)(bZe,(0,p.A)({},LZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}NZe.isMDXComponent=!0;const kZe={toc:[]},zZe="wrapper";function PZe(e){let{components:n,...t}=e;return(0,s.yg)(zZe,(0,p.A)({},kZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}PZe.isMDXComponent=!0;const IZe={toc:[]},RZe="wrapper";function WZe(e){let{components:n,...t}=e;return(0,s.yg)(RZe,(0,p.A)({},IZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}WZe.isMDXComponent=!0;const SZe={toc:[]},BZe="wrapper";function EZe(e){let{components:n,...t}=e;return(0,s.yg)(BZe,(0,p.A)({},SZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}EZe.isMDXComponent=!0;const GZe={toc:[]},OZe="wrapper";function UZe(e){let{components:n,...t}=e;return(0,s.yg)(OZe,(0,p.A)({},GZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}UZe.isMDXComponent=!0;const FZe={toc:[]},VZe="wrapper";function qZe(e){let{components:n,...t}=e;return(0,s.yg)(VZe,(0,p.A)({},FZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}qZe.isMDXComponent=!0;const jZe={toc:[]},HZe="wrapper";function YZe(e){let{components:n,...t}=e;return(0,s.yg)(HZe,(0,p.A)({},jZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}YZe.isMDXComponent=!0;const QZe={toc:[]},$Ze="wrapper";function KZe(e){let{components:n,...t}=e;return(0,s.yg)($Ze,(0,p.A)({},QZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}KZe.isMDXComponent=!0;const JZe={toc:[]},ZZe="wrapper";function e0e(e){let{components:n,...t}=e;return(0,s.yg)(ZZe,(0,p.A)({},JZe,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}e0e.isMDXComponent=!0;const n0e={toc:[]},t0e="wrapper";function o0e(e){let{components:n,...t}=e;return(0,s.yg)(t0e,(0,p.A)({},n0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}o0e.isMDXComponent=!0;const p0e={toc:[]},r0e="wrapper";function s0e(e){let{components:n,...t}=e;return(0,s.yg)(r0e,(0,p.A)({},p0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}s0e.isMDXComponent=!0;const c0e={toc:[]},a0e="wrapper";function i0e(e){let{components:n,...t}=e;return(0,s.yg)(a0e,(0,p.A)({},c0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}i0e.isMDXComponent=!0;const l0e={toc:[]},u0e="wrapper";function m0e(e){let{components:n,...t}=e;return(0,s.yg)(u0e,(0,p.A)({},l0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}m0e.isMDXComponent=!0;const y0e={toc:[]},d0e="wrapper";function h0e(e){let{components:n,...t}=e;return(0,s.yg)(d0e,(0,p.A)({},y0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}h0e.isMDXComponent=!0;const g0e={toc:[]},f0e="wrapper";function D0e(e){let{components:n,...t}=e;return(0,s.yg)(f0e,(0,p.A)({},g0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}D0e.isMDXComponent=!0;const M0e={toc:[]},X0e="wrapper";function _0e(e){let{components:n,...t}=e;return(0,s.yg)(X0e,(0,p.A)({},M0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}_0e.isMDXComponent=!0;const w0e={toc:[]},T0e="wrapper";function C0e(e){let{components:n,...t}=e;return(0,s.yg)(T0e,(0,p.A)({},w0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}C0e.isMDXComponent=!0;const x0e={toc:[]},A0e="wrapper";function v0e(e){let{components:n,...t}=e;return(0,s.yg)(A0e,(0,p.A)({},x0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}v0e.isMDXComponent=!0;const L0e={toc:[]},b0e="wrapper";function N0e(e){let{components:n,...t}=e;return(0,s.yg)(b0e,(0,p.A)({},L0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}N0e.isMDXComponent=!0;const k0e={toc:[]},z0e="wrapper";function P0e(e){let{components:n,...t}=e;return(0,s.yg)(z0e,(0,p.A)({},k0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}P0e.isMDXComponent=!0;const I0e={toc:[]},R0e="wrapper";function W0e(e){let{components:n,...t}=e;return(0,s.yg)(R0e,(0,p.A)({},I0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}W0e.isMDXComponent=!0;const S0e={toc:[]},B0e="wrapper";function E0e(e){let{components:n,...t}=e;return(0,s.yg)(B0e,(0,p.A)({},S0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}E0e.isMDXComponent=!0;const G0e={toc:[]},O0e="wrapper";function U0e(e){let{components:n,...t}=e;return(0,s.yg)(O0e,(0,p.A)({},G0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}U0e.isMDXComponent=!0;const F0e={toc:[]},V0e="wrapper";function q0e(e){let{components:n,...t}=e;return(0,s.yg)(V0e,(0,p.A)({},F0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}q0e.isMDXComponent=!0;const j0e={toc:[]},H0e="wrapper";function Y0e(e){let{components:n,...t}=e;return(0,s.yg)(H0e,(0,p.A)({},j0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Y0e.isMDXComponent=!0;const Q0e={toc:[]},$0e="wrapper";function K0e(e){let{components:n,...t}=e;return(0,s.yg)($0e,(0,p.A)({},Q0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}K0e.isMDXComponent=!0;const J0e={toc:[]},Z0e="wrapper";function e3e(e){let{components:n,...t}=e;return(0,s.yg)(Z0e,(0,p.A)({},J0e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}e3e.isMDXComponent=!0;const n3e={toc:[]},t3e="wrapper";function o3e(e){let{components:n,...t}=e;return(0,s.yg)(t3e,(0,p.A)({},n3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}o3e.isMDXComponent=!0;const p3e={toc:[]},r3e="wrapper";function s3e(e){let{components:n,...t}=e;return(0,s.yg)(r3e,(0,p.A)({},p3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}s3e.isMDXComponent=!0;const c3e={toc:[]},a3e="wrapper";function i3e(e){let{components:n,...t}=e;return(0,s.yg)(a3e,(0,p.A)({},c3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}i3e.isMDXComponent=!0;const l3e={toc:[]},u3e="wrapper";function m3e(e){let{components:n,...t}=e;return(0,s.yg)(u3e,(0,p.A)({},l3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}m3e.isMDXComponent=!0;const y3e={toc:[]},d3e="wrapper";function h3e(e){let{components:n,...t}=e;return(0,s.yg)(d3e,(0,p.A)({},y3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}h3e.isMDXComponent=!0;const g3e={toc:[]},f3e="wrapper";function D3e(e){let{components:n,...t}=e;return(0,s.yg)(f3e,(0,p.A)({},g3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}D3e.isMDXComponent=!0;const M3e={toc:[]},X3e="wrapper";function _3e(e){let{components:n,...t}=e;return(0,s.yg)(X3e,(0,p.A)({},M3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}_3e.isMDXComponent=!0;const w3e={toc:[]},T3e="wrapper";function C3e(e){let{components:n,...t}=e;return(0,s.yg)(T3e,(0,p.A)({},w3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}C3e.isMDXComponent=!0;const x3e={toc:[]},A3e="wrapper";function v3e(e){let{components:n,...t}=e;return(0,s.yg)(A3e,(0,p.A)({},x3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}v3e.isMDXComponent=!0;const L3e={toc:[]},b3e="wrapper";function N3e(e){let{components:n,...t}=e;return(0,s.yg)(b3e,(0,p.A)({},L3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}N3e.isMDXComponent=!0;const k3e={toc:[]},z3e="wrapper";function P3e(e){let{components:n,...t}=e;return(0,s.yg)(z3e,(0,p.A)({},k3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}P3e.isMDXComponent=!0;const I3e={toc:[]},R3e="wrapper";function W3e(e){let{components:n,...t}=e;return(0,s.yg)(R3e,(0,p.A)({},I3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}W3e.isMDXComponent=!0;const S3e={toc:[]},B3e="wrapper";function E3e(e){let{components:n,...t}=e;return(0,s.yg)(B3e,(0,p.A)({},S3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}E3e.isMDXComponent=!0;const G3e={toc:[]},O3e="wrapper";function U3e(e){let{components:n,...t}=e;return(0,s.yg)(O3e,(0,p.A)({},G3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}U3e.isMDXComponent=!0;const F3e={toc:[]},V3e="wrapper";function q3e(e){let{components:n,...t}=e;return(0,s.yg)(V3e,(0,p.A)({},F3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}q3e.isMDXComponent=!0;const j3e={toc:[]},H3e="wrapper";function Y3e(e){let{components:n,...t}=e;return(0,s.yg)(H3e,(0,p.A)({},j3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}Y3e.isMDXComponent=!0;const Q3e={toc:[]},$3e="wrapper";function K3e(e){let{components:n,...t}=e;return(0,s.yg)($3e,(0,p.A)({},Q3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}K3e.isMDXComponent=!0;const J3e={toc:[]},Z3e="wrapper";function e1e(e){let{components:n,...t}=e;return(0,s.yg)(Z3e,(0,p.A)({},J3e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}e1e.isMDXComponent=!0;const n1e={toc:[]},t1e="wrapper";function o1e(e){let{components:n,...t}=e;return(0,s.yg)(t1e,(0,p.A)({},n1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}o1e.isMDXComponent=!0;const p1e={toc:[]},r1e="wrapper";function s1e(e){let{components:n,...t}=e;return(0,s.yg)(r1e,(0,p.A)({},p1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}s1e.isMDXComponent=!0;const c1e={toc:[]},a1e="wrapper";function i1e(e){let{components:n,...t}=e;return(0,s.yg)(a1e,(0,p.A)({},c1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}i1e.isMDXComponent=!0;const l1e={toc:[]},u1e="wrapper";function m1e(e){let{components:n,...t}=e;return(0,s.yg)(u1e,(0,p.A)({},l1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}m1e.isMDXComponent=!0;const y1e={toc:[]},d1e="wrapper";function h1e(e){let{components:n,...t}=e;return(0,s.yg)(d1e,(0,p.A)({},y1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}h1e.isMDXComponent=!0;const g1e={toc:[]},f1e="wrapper";function D1e(e){let{components:n,...t}=e;return(0,s.yg)(f1e,(0,p.A)({},g1e,t,{components:n,mdxType:"MDXLayout"}))}D1e.isMDXComponent=!0;const M1e={toc:[]},X1e="wrapper";function _1e(e){let{components:n,...t}=e;return(0,s.yg)(X1e,(0,p.A)({},M1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}_1e.isMDXComponent=!0;const w1e={toc:[]},T1e="wrapper";function C1e(e){let{components:n,...t}=e;return(0,s.yg)(T1e,(0,p.A)({},w1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}C1e.isMDXComponent=!0;const x1e={toc:[]},A1e="wrapper";function v1e(e){let{components:n,...t}=e;return(0,s.yg)(A1e,(0,p.A)({},x1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}v1e.isMDXComponent=!0;const L1e={toc:[]},b1e="wrapper";function N1e(e){let{components:n,...t}=e;return(0,s.yg)(b1e,(0,p.A)({},L1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}N1e.isMDXComponent=!0;const k1e={toc:[]},z1e="wrapper";function P1e(e){let{components:n,...t}=e;return(0,s.yg)(z1e,(0,p.A)({},k1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}P1e.isMDXComponent=!0;const I1e={toc:[]},R1e="wrapper";function W1e(e){let{components:n,...t}=e;return(0,s.yg)(R1e,(0,p.A)({},I1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}W1e.isMDXComponent=!0;const S1e={toc:[]},B1e="wrapper";function E1e(e){let{components:n,...t}=e;return(0,s.yg)(B1e,(0,p.A)({},S1e,t,{components:n,mdxType:"MDXLayout"}))}E1e.isMDXComponent=!0;const G1e={toc:[]},O1e="wrapper";function U1e(e){let{components:n,...t}=e;return(0,s.yg)(O1e,(0,p.A)({},G1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}U1e.isMDXComponent=!0;const F1e={toc:[]},V1e="wrapper";function q1e(e){let{components:n,...t}=e;return(0,s.yg)(V1e,(0,p.A)({},F1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}q1e.isMDXComponent=!0;const j1e={toc:[]},H1e="wrapper";function Y1e(e){let{components:n,...t}=e;return(0,s.yg)(H1e,(0,p.A)({},j1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Y1e.isMDXComponent=!0;const Q1e={toc:[]},$1e="wrapper";function K1e(e){let{components:n,...t}=e;return(0,s.yg)($1e,(0,p.A)({},Q1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}K1e.isMDXComponent=!0;const J1e={toc:[]},Z1e="wrapper";function e9e(e){let{components:n,...t}=e;return(0,s.yg)(Z1e,(0,p.A)({},J1e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}e9e.isMDXComponent=!0;const n9e={toc:[]},t9e="wrapper";function o9e(e){let{components:n,...t}=e;return(0,s.yg)(t9e,(0,p.A)({},n9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}o9e.isMDXComponent=!0;const p9e={toc:[]},r9e="wrapper";function s9e(e){let{components:n,...t}=e;return(0,s.yg)(r9e,(0,p.A)({},p9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}s9e.isMDXComponent=!0;const c9e={toc:[]},a9e="wrapper";function i9e(e){let{components:n,...t}=e;return(0,s.yg)(a9e,(0,p.A)({},c9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}i9e.isMDXComponent=!0;const l9e={toc:[]},u9e="wrapper";function m9e(e){let{components:n,...t}=e;return(0,s.yg)(u9e,(0,p.A)({},l9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}m9e.isMDXComponent=!0;const y9e={toc:[]},d9e="wrapper";function h9e(e){let{components:n,...t}=e;return(0,s.yg)(d9e,(0,p.A)({},y9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}h9e.isMDXComponent=!0;const g9e={toc:[]},f9e="wrapper";function D9e(e){let{components:n,...t}=e;return(0,s.yg)(f9e,(0,p.A)({},g9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}D9e.isMDXComponent=!0;const M9e={toc:[]},X9e="wrapper";function _9e(e){let{components:n,...t}=e;return(0,s.yg)(X9e,(0,p.A)({},M9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}_9e.isMDXComponent=!0;const w9e={toc:[]},T9e="wrapper";function C9e(e){let{components:n,...t}=e;return(0,s.yg)(T9e,(0,p.A)({},w9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}C9e.isMDXComponent=!0;const x9e={toc:[]},A9e="wrapper";function v9e(e){let{components:n,...t}=e;return(0,s.yg)(A9e,(0,p.A)({},x9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}v9e.isMDXComponent=!0;const L9e={toc:[]},b9e="wrapper";function N9e(e){let{components:n,...t}=e;return(0,s.yg)(b9e,(0,p.A)({},L9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}N9e.isMDXComponent=!0;const k9e={toc:[]},z9e="wrapper";function P9e(e){let{components:n,...t}=e;return(0,s.yg)(z9e,(0,p.A)({},k9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}P9e.isMDXComponent=!0;const I9e={toc:[]},R9e="wrapper";function W9e(e){let{components:n,...t}=e;return(0,s.yg)(R9e,(0,p.A)({},I9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}W9e.isMDXComponent=!0;const S9e={toc:[]},B9e="wrapper";function E9e(e){let{components:n,...t}=e;return(0,s.yg)(B9e,(0,p.A)({},S9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}E9e.isMDXComponent=!0;const G9e={toc:[]},O9e="wrapper";function U9e(e){let{components:n,...t}=e;return(0,s.yg)(O9e,(0,p.A)({},G9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}U9e.isMDXComponent=!0;const F9e={toc:[]},V9e="wrapper";function q9e(e){let{components:n,...t}=e;return(0,s.yg)(V9e,(0,p.A)({},F9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}q9e.isMDXComponent=!0;const j9e={toc:[]},H9e="wrapper";function Y9e(e){let{components:n,...t}=e;return(0,s.yg)(H9e,(0,p.A)({},j9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Y9e.isMDXComponent=!0;const Q9e={toc:[]},$9e="wrapper";function K9e(e){let{components:n,...t}=e;return(0,s.yg)($9e,(0,p.A)({},Q9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}K9e.isMDXComponent=!0;const J9e={toc:[]},Z9e="wrapper";function e2e(e){let{components:n,...t}=e;return(0,s.yg)(Z9e,(0,p.A)({},J9e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}e2e.isMDXComponent=!0;const n2e={toc:[]},t2e="wrapper";function o2e(e){let{components:n,...t}=e;return(0,s.yg)(t2e,(0,p.A)({},n2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}o2e.isMDXComponent=!0;const p2e={toc:[]},r2e="wrapper";function s2e(e){let{components:n,...t}=e;return(0,s.yg)(r2e,(0,p.A)({},p2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}s2e.isMDXComponent=!0;const c2e={toc:[]},a2e="wrapper";function i2e(e){let{components:n,...t}=e;return(0,s.yg)(a2e,(0,p.A)({},c2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}i2e.isMDXComponent=!0;const l2e={toc:[]},u2e="wrapper";function m2e(e){let{components:n,...t}=e;return(0,s.yg)(u2e,(0,p.A)({},l2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}m2e.isMDXComponent=!0;const y2e={toc:[]},d2e="wrapper";function h2e(e){let{components:n,...t}=e;return(0,s.yg)(d2e,(0,p.A)({},y2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}h2e.isMDXComponent=!0;const g2e={toc:[]},f2e="wrapper";function D2e(e){let{components:n,...t}=e;return(0,s.yg)(f2e,(0,p.A)({},g2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}D2e.isMDXComponent=!0;const M2e={toc:[]},X2e="wrapper";function _2e(e){let{components:n,...t}=e;return(0,s.yg)(X2e,(0,p.A)({},M2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}_2e.isMDXComponent=!0;const w2e={toc:[]},T2e="wrapper";function C2e(e){let{components:n,...t}=e;return(0,s.yg)(T2e,(0,p.A)({},w2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}C2e.isMDXComponent=!0;const x2e={toc:[]},A2e="wrapper";function v2e(e){let{components:n,...t}=e;return(0,s.yg)(A2e,(0,p.A)({},x2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}v2e.isMDXComponent=!0;const L2e={toc:[]},b2e="wrapper";function N2e(e){let{components:n,...t}=e;return(0,s.yg)(b2e,(0,p.A)({},L2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}N2e.isMDXComponent=!0;const k2e={toc:[]},z2e="wrapper";function P2e(e){let{components:n,...t}=e;return(0,s.yg)(z2e,(0,p.A)({},k2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}P2e.isMDXComponent=!0;const I2e={toc:[]},R2e="wrapper";function W2e(e){let{components:n,...t}=e;return(0,s.yg)(R2e,(0,p.A)({},I2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}W2e.isMDXComponent=!0;const S2e={toc:[]},B2e="wrapper";function E2e(e){let{components:n,...t}=e;return(0,s.yg)(B2e,(0,p.A)({},S2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}E2e.isMDXComponent=!0;const G2e={toc:[]},O2e="wrapper";function U2e(e){let{components:n,...t}=e;return(0,s.yg)(O2e,(0,p.A)({},G2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}U2e.isMDXComponent=!0;const F2e={toc:[]},V2e="wrapper";function q2e(e){let{components:n,...t}=e;return(0,s.yg)(V2e,(0,p.A)({},F2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}q2e.isMDXComponent=!0;const j2e={toc:[]},H2e="wrapper";function Y2e(e){let{components:n,...t}=e;return(0,s.yg)(H2e,(0,p.A)({},j2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Y2e.isMDXComponent=!0;const Q2e={toc:[]},$2e="wrapper";function K2e(e){let{components:n,...t}=e;return(0,s.yg)($2e,(0,p.A)({},Q2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}K2e.isMDXComponent=!0;const J2e={toc:[]},Z2e="wrapper";function e4e(e){let{components:n,...t}=e;return(0,s.yg)(Z2e,(0,p.A)({},J2e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}e4e.isMDXComponent=!0;const n4e={toc:[]},t4e="wrapper";function o4e(e){let{components:n,...t}=e;return(0,s.yg)(t4e,(0,p.A)({},n4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}o4e.isMDXComponent=!0;const p4e={toc:[]},r4e="wrapper";function s4e(e){let{components:n,...t}=e;return(0,s.yg)(r4e,(0,p.A)({},p4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}s4e.isMDXComponent=!0;const c4e={toc:[]},a4e="wrapper";function i4e(e){let{components:n,...t}=e;return(0,s.yg)(a4e,(0,p.A)({},c4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}i4e.isMDXComponent=!0;const l4e={toc:[]},u4e="wrapper";function m4e(e){let{components:n,...t}=e;return(0,s.yg)(u4e,(0,p.A)({},l4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}m4e.isMDXComponent=!0;const y4e={toc:[]},d4e="wrapper";function h4e(e){let{components:n,...t}=e;return(0,s.yg)(d4e,(0,p.A)({},y4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}h4e.isMDXComponent=!0;const g4e={toc:[]},f4e="wrapper";function D4e(e){let{components:n,...t}=e;return(0,s.yg)(f4e,(0,p.A)({},g4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}D4e.isMDXComponent=!0;const M4e={toc:[]},X4e="wrapper";function _4e(e){let{components:n,...t}=e;return(0,s.yg)(X4e,(0,p.A)({},M4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}_4e.isMDXComponent=!0;const w4e={toc:[]},T4e="wrapper";function C4e(e){let{components:n,...t}=e;return(0,s.yg)(T4e,(0,p.A)({},w4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}C4e.isMDXComponent=!0;const x4e={toc:[]},A4e="wrapper";function v4e(e){let{components:n,...t}=e;return(0,s.yg)(A4e,(0,p.A)({},x4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}v4e.isMDXComponent=!0;const L4e={toc:[]},b4e="wrapper";function N4e(e){let{components:n,...t}=e;return(0,s.yg)(b4e,(0,p.A)({},L4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}N4e.isMDXComponent=!0;const k4e={toc:[]},z4e="wrapper";function P4e(e){let{components:n,...t}=e;return(0,s.yg)(z4e,(0,p.A)({},k4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}P4e.isMDXComponent=!0;const I4e={toc:[]},R4e="wrapper";function W4e(e){let{components:n,...t}=e;return(0,s.yg)(R4e,(0,p.A)({},I4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}W4e.isMDXComponent=!0;const S4e={toc:[]},B4e="wrapper";function E4e(e){let{components:n,...t}=e;return(0,s.yg)(B4e,(0,p.A)({},S4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}E4e.isMDXComponent=!0;const G4e={toc:[]},O4e="wrapper";function U4e(e){let{components:n,...t}=e;return(0,s.yg)(O4e,(0,p.A)({},G4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}U4e.isMDXComponent=!0;const F4e={toc:[]},V4e="wrapper";function q4e(e){let{components:n,...t}=e;return(0,s.yg)(V4e,(0,p.A)({},F4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}q4e.isMDXComponent=!0;const j4e={toc:[]},H4e="wrapper";function Y4e(e){let{components:n,...t}=e;return(0,s.yg)(H4e,(0,p.A)({},j4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Y4e.isMDXComponent=!0;const Q4e={toc:[]},$4e="wrapper";function K4e(e){let{components:n,...t}=e;return(0,s.yg)($4e,(0,p.A)({},Q4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}K4e.isMDXComponent=!0;const J4e={toc:[]},Z4e="wrapper";function e6e(e){let{components:n,...t}=e;return(0,s.yg)(Z4e,(0,p.A)({},J4e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}e6e.isMDXComponent=!0;const n6e={toc:[]},t6e="wrapper";function o6e(e){let{components:n,...t}=e;return(0,s.yg)(t6e,(0,p.A)({},n6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}o6e.isMDXComponent=!0;const p6e={toc:[]},r6e="wrapper";function s6e(e){let{components:n,...t}=e;return(0,s.yg)(r6e,(0,p.A)({},p6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}s6e.isMDXComponent=!0;const c6e={toc:[]},a6e="wrapper";function i6e(e){let{components:n,...t}=e;return(0,s.yg)(a6e,(0,p.A)({},c6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}i6e.isMDXComponent=!0;const l6e={toc:[]},u6e="wrapper";function m6e(e){let{components:n,...t}=e;return(0,s.yg)(u6e,(0,p.A)({},l6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}m6e.isMDXComponent=!0;const y6e={toc:[]},d6e="wrapper";function h6e(e){let{components:n,...t}=e;return(0,s.yg)(d6e,(0,p.A)({},y6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}h6e.isMDXComponent=!0;const g6e={toc:[]},f6e="wrapper";function D6e(e){let{components:n,...t}=e;return(0,s.yg)(f6e,(0,p.A)({},g6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}D6e.isMDXComponent=!0;const M6e={toc:[]},X6e="wrapper";function _6e(e){let{components:n,...t}=e;return(0,s.yg)(X6e,(0,p.A)({},M6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}_6e.isMDXComponent=!0;const w6e={toc:[]},T6e="wrapper";function C6e(e){let{components:n,...t}=e;return(0,s.yg)(T6e,(0,p.A)({},w6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}C6e.isMDXComponent=!0;const x6e={toc:[]},A6e="wrapper";function v6e(e){let{components:n,...t}=e;return(0,s.yg)(A6e,(0,p.A)({},x6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}v6e.isMDXComponent=!0;const L6e={toc:[]},b6e="wrapper";function N6e(e){let{components:n,...t}=e;return(0,s.yg)(b6e,(0,p.A)({},L6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}N6e.isMDXComponent=!0;const k6e={toc:[]},z6e="wrapper";function P6e(e){let{components:n,...t}=e;return(0,s.yg)(z6e,(0,p.A)({},k6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}P6e.isMDXComponent=!0;const I6e={toc:[]},R6e="wrapper";function W6e(e){let{components:n,...t}=e;return(0,s.yg)(R6e,(0,p.A)({},I6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}W6e.isMDXComponent=!0;const S6e={toc:[]},B6e="wrapper";function E6e(e){let{components:n,...t}=e;return(0,s.yg)(B6e,(0,p.A)({},S6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}E6e.isMDXComponent=!0;const G6e={toc:[]},O6e="wrapper";function U6e(e){let{components:n,...t}=e;return(0,s.yg)(O6e,(0,p.A)({},G6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}U6e.isMDXComponent=!0;const F6e={toc:[]},V6e="wrapper";function q6e(e){let{components:n,...t}=e;return(0,s.yg)(V6e,(0,p.A)({},F6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}q6e.isMDXComponent=!0;const j6e={toc:[]},H6e="wrapper";function Y6e(e){let{components:n,...t}=e;return(0,s.yg)(H6e,(0,p.A)({},j6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}Y6e.isMDXComponent=!0;const Q6e={toc:[]},$6e="wrapper";function K6e(e){let{components:n,...t}=e;return(0,s.yg)($6e,(0,p.A)({},Q6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}K6e.isMDXComponent=!0;const J6e={toc:[]},Z6e="wrapper";function e8e(e){let{components:n,...t}=e;return(0,s.yg)(Z6e,(0,p.A)({},J6e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}e8e.isMDXComponent=!0;const n8e={toc:[]},t8e="wrapper";function o8e(e){let{components:n,...t}=e;return(0,s.yg)(t8e,(0,p.A)({},n8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}o8e.isMDXComponent=!0;const p8e={toc:[]},r8e="wrapper";function s8e(e){let{components:n,...t}=e;return(0,s.yg)(r8e,(0,p.A)({},p8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}s8e.isMDXComponent=!0;const c8e={toc:[]},a8e="wrapper";function i8e(e){let{components:n,...t}=e;return(0,s.yg)(a8e,(0,p.A)({},c8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}i8e.isMDXComponent=!0;const l8e={toc:[]},u8e="wrapper";function m8e(e){let{components:n,...t}=e;return(0,s.yg)(u8e,(0,p.A)({},l8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}m8e.isMDXComponent=!0;const y8e={toc:[]},d8e="wrapper";function h8e(e){let{components:n,...t}=e;return(0,s.yg)(d8e,(0,p.A)({},y8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}h8e.isMDXComponent=!0;const g8e={toc:[]},f8e="wrapper";function D8e(e){let{components:n,...t}=e;return(0,s.yg)(f8e,(0,p.A)({},g8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}D8e.isMDXComponent=!0;const M8e={toc:[]},X8e="wrapper";function _8e(e){let{components:n,...t}=e;return(0,s.yg)(X8e,(0,p.A)({},M8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}_8e.isMDXComponent=!0;const w8e={toc:[]},T8e="wrapper";function C8e(e){let{components:n,...t}=e;return(0,s.yg)(T8e,(0,p.A)({},w8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}C8e.isMDXComponent=!0;const x8e={toc:[]},A8e="wrapper";function v8e(e){let{components:n,...t}=e;return(0,s.yg)(A8e,(0,p.A)({},x8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}v8e.isMDXComponent=!0;const L8e={toc:[]},b8e="wrapper";function N8e(e){let{components:n,...t}=e;return(0,s.yg)(b8e,(0,p.A)({},L8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}N8e.isMDXComponent=!0;const k8e={toc:[]},z8e="wrapper";function P8e(e){let{components:n,...t}=e;return(0,s.yg)(z8e,(0,p.A)({},k8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}P8e.isMDXComponent=!0;const I8e={toc:[]},R8e="wrapper";function W8e(e){let{components:n,...t}=e;return(0,s.yg)(R8e,(0,p.A)({},I8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}W8e.isMDXComponent=!0;const S8e={toc:[]},B8e="wrapper";function E8e(e){let{components:n,...t}=e;return(0,s.yg)(B8e,(0,p.A)({},S8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}E8e.isMDXComponent=!0;const G8e={toc:[]},O8e="wrapper";function U8e(e){let{components:n,...t}=e;return(0,s.yg)(O8e,(0,p.A)({},G8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}U8e.isMDXComponent=!0;const F8e={toc:[]},V8e="wrapper";function q8e(e){let{components:n,...t}=e;return(0,s.yg)(V8e,(0,p.A)({},F8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}q8e.isMDXComponent=!0;const j8e={toc:[]},H8e="wrapper";function Y8e(e){let{components:n,...t}=e;return(0,s.yg)(H8e,(0,p.A)({},j8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Y8e.isMDXComponent=!0;const Q8e={toc:[]},$8e="wrapper";function K8e(e){let{components:n,...t}=e;return(0,s.yg)($8e,(0,p.A)({},Q8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}K8e.isMDXComponent=!0;const J8e={toc:[]},Z8e="wrapper";function e5e(e){let{components:n,...t}=e;return(0,s.yg)(Z8e,(0,p.A)({},J8e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}e5e.isMDXComponent=!0;const n5e={toc:[]},t5e="wrapper";function o5e(e){let{components:n,...t}=e;return(0,s.yg)(t5e,(0,p.A)({},n5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}o5e.isMDXComponent=!0;const p5e={toc:[]},r5e="wrapper";function s5e(e){let{components:n,...t}=e;return(0,s.yg)(r5e,(0,p.A)({},p5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}s5e.isMDXComponent=!0;const c5e={toc:[]},a5e="wrapper";function i5e(e){let{components:n,...t}=e;return(0,s.yg)(a5e,(0,p.A)({},c5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}i5e.isMDXComponent=!0;const l5e={toc:[]},u5e="wrapper";function m5e(e){let{components:n,...t}=e;return(0,s.yg)(u5e,(0,p.A)({},l5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}m5e.isMDXComponent=!0;const y5e={toc:[]},d5e="wrapper";function h5e(e){let{components:n,...t}=e;return(0,s.yg)(d5e,(0,p.A)({},y5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}h5e.isMDXComponent=!0;const g5e={toc:[]},f5e="wrapper";function D5e(e){let{components:n,...t}=e;return(0,s.yg)(f5e,(0,p.A)({},g5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}D5e.isMDXComponent=!0;const M5e={toc:[]},X5e="wrapper";function _5e(e){let{components:n,...t}=e;return(0,s.yg)(X5e,(0,p.A)({},M5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}_5e.isMDXComponent=!0;const w5e={toc:[]},T5e="wrapper";function C5e(e){let{components:n,...t}=e;return(0,s.yg)(T5e,(0,p.A)({},w5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}C5e.isMDXComponent=!0;const x5e={toc:[]},A5e="wrapper";function v5e(e){let{components:n,...t}=e;return(0,s.yg)(A5e,(0,p.A)({},x5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}v5e.isMDXComponent=!0;const L5e={toc:[]},b5e="wrapper";function N5e(e){let{components:n,...t}=e;return(0,s.yg)(b5e,(0,p.A)({},L5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}N5e.isMDXComponent=!0;const k5e={toc:[]},z5e="wrapper";function P5e(e){let{components:n,...t}=e;return(0,s.yg)(z5e,(0,p.A)({},k5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}P5e.isMDXComponent=!0;const I5e={toc:[]},R5e="wrapper";function W5e(e){let{components:n,...t}=e;return(0,s.yg)(R5e,(0,p.A)({},I5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}W5e.isMDXComponent=!0;const S5e={toc:[]},B5e="wrapper";function E5e(e){let{components:n,...t}=e;return(0,s.yg)(B5e,(0,p.A)({},S5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}E5e.isMDXComponent=!0;const G5e={toc:[]},O5e="wrapper";function U5e(e){let{components:n,...t}=e;return(0,s.yg)(O5e,(0,p.A)({},G5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}U5e.isMDXComponent=!0;const F5e={toc:[]},V5e="wrapper";function q5e(e){let{components:n,...t}=e;return(0,s.yg)(V5e,(0,p.A)({},F5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}q5e.isMDXComponent=!0;const j5e={toc:[]},H5e="wrapper";function Y5e(e){let{components:n,...t}=e;return(0,s.yg)(H5e,(0,p.A)({},j5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}Y5e.isMDXComponent=!0;const Q5e={toc:[]},$5e="wrapper";function K5e(e){let{components:n,...t}=e;return(0,s.yg)($5e,(0,p.A)({},Q5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}K5e.isMDXComponent=!0;const J5e={toc:[]},Z5e="wrapper";function e7e(e){let{components:n,...t}=e;return(0,s.yg)(Z5e,(0,p.A)({},J5e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}e7e.isMDXComponent=!0;const n7e={toc:[]},t7e="wrapper";function o7e(e){let{components:n,...t}=e;return(0,s.yg)(t7e,(0,p.A)({},n7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}o7e.isMDXComponent=!0;const p7e={toc:[]},r7e="wrapper";function s7e(e){let{components:n,...t}=e;return(0,s.yg)(r7e,(0,p.A)({},p7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}s7e.isMDXComponent=!0;const c7e={toc:[]},a7e="wrapper";function i7e(e){let{components:n,...t}=e;return(0,s.yg)(a7e,(0,p.A)({},c7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}i7e.isMDXComponent=!0;const l7e={toc:[]},u7e="wrapper";function m7e(e){let{components:n,...t}=e;return(0,s.yg)(u7e,(0,p.A)({},l7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}m7e.isMDXComponent=!0;const y7e={toc:[]},d7e="wrapper";function h7e(e){let{components:n,...t}=e;return(0,s.yg)(d7e,(0,p.A)({},y7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}h7e.isMDXComponent=!0;const g7e={toc:[]},f7e="wrapper";function D7e(e){let{components:n,...t}=e;return(0,s.yg)(f7e,(0,p.A)({},g7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}D7e.isMDXComponent=!0;const M7e={toc:[]},X7e="wrapper";function _7e(e){let{components:n,...t}=e;return(0,s.yg)(X7e,(0,p.A)({},M7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}_7e.isMDXComponent=!0;const w7e={toc:[]},T7e="wrapper";function C7e(e){let{components:n,...t}=e;return(0,s.yg)(T7e,(0,p.A)({},w7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}C7e.isMDXComponent=!0;const x7e={toc:[]},A7e="wrapper";function v7e(e){let{components:n,...t}=e;return(0,s.yg)(A7e,(0,p.A)({},x7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}v7e.isMDXComponent=!0;const L7e={toc:[]},b7e="wrapper";function N7e(e){let{components:n,...t}=e;return(0,s.yg)(b7e,(0,p.A)({},L7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}N7e.isMDXComponent=!0;const k7e={toc:[]},z7e="wrapper";function P7e(e){let{components:n,...t}=e;return(0,s.yg)(z7e,(0,p.A)({},k7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}P7e.isMDXComponent=!0;const I7e={toc:[]},R7e="wrapper";function W7e(e){let{components:n,...t}=e;return(0,s.yg)(R7e,(0,p.A)({},I7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}W7e.isMDXComponent=!0;const S7e={toc:[]},B7e="wrapper";function E7e(e){let{components:n,...t}=e;return(0,s.yg)(B7e,(0,p.A)({},S7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}E7e.isMDXComponent=!0;const G7e={toc:[]},O7e="wrapper";function U7e(e){let{components:n,...t}=e;return(0,s.yg)(O7e,(0,p.A)({},G7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}U7e.isMDXComponent=!0;const F7e={toc:[]},V7e="wrapper";function q7e(e){let{components:n,...t}=e;return(0,s.yg)(V7e,(0,p.A)({},F7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}q7e.isMDXComponent=!0;const j7e={toc:[]},H7e="wrapper";function Y7e(e){let{components:n,...t}=e;return(0,s.yg)(H7e,(0,p.A)({},j7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}Y7e.isMDXComponent=!0;const Q7e={toc:[]},$7e="wrapper";function K7e(e){let{components:n,...t}=e;return(0,s.yg)($7e,(0,p.A)({},Q7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}K7e.isMDXComponent=!0;const J7e={toc:[]},Z7e="wrapper";function een(e){let{components:n,...t}=e;return(0,s.yg)(Z7e,(0,p.A)({},J7e,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}een.isMDXComponent=!0;const nen={toc:[]},ten="wrapper";function oen(e){let{components:n,...t}=e;return(0,s.yg)(ten,(0,p.A)({},nen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}oen.isMDXComponent=!0;const pen={toc:[]},ren="wrapper";function sen(e){let{components:n,...t}=e;return(0,s.yg)(ren,(0,p.A)({},pen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}sen.isMDXComponent=!0;const cen={toc:[]},aen="wrapper";function ien(e){let{components:n,...t}=e;return(0,s.yg)(aen,(0,p.A)({},cen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}ien.isMDXComponent=!0;const len={toc:[]},uen="wrapper";function men(e){let{components:n,...t}=e;return(0,s.yg)(uen,(0,p.A)({},len,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}men.isMDXComponent=!0;const yen={toc:[]},den="wrapper";function hen(e){let{components:n,...t}=e;return(0,s.yg)(den,(0,p.A)({},yen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}hen.isMDXComponent=!0;const gen={toc:[]},fen="wrapper";function Den(e){let{components:n,...t}=e;return(0,s.yg)(fen,(0,p.A)({},gen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}Den.isMDXComponent=!0;const Men={toc:[]},Xen="wrapper";function _en(e){let{components:n,...t}=e;return(0,s.yg)(Xen,(0,p.A)({},Men,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}_en.isMDXComponent=!0;const wen={toc:[]},Ten="wrapper";function Cen(e){let{components:n,...t}=e;return(0,s.yg)(Ten,(0,p.A)({},wen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}Cen.isMDXComponent=!0;const xen={toc:[]},Aen="wrapper";function ven(e){let{components:n,...t}=e;return(0,s.yg)(Aen,(0,p.A)({},xen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}ven.isMDXComponent=!0;const Len={toc:[]},ben="wrapper";function Nen(e){let{components:n,...t}=e;return(0,s.yg)(ben,(0,p.A)({},Len,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Nen.isMDXComponent=!0;const ken={toc:[]},zen="wrapper";function Pen(e){let{components:n,...t}=e;return(0,s.yg)(zen,(0,p.A)({},ken,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}Pen.isMDXComponent=!0;const Ien={toc:[]},Ren="wrapper";function Wen(e){let{components:n,...t}=e;return(0,s.yg)(Ren,(0,p.A)({},Ien,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Wen.isMDXComponent=!0;const Sen={toc:[]},Ben="wrapper";function Een(e){let{components:n,...t}=e;return(0,s.yg)(Ben,(0,p.A)({},Sen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Een.isMDXComponent=!0;const Gen={toc:[]},Oen="wrapper";function Uen(e){let{components:n,...t}=e;return(0,s.yg)(Oen,(0,p.A)({},Gen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}Uen.isMDXComponent=!0;const Fen={toc:[]},Ven="wrapper";function qen(e){let{components:n,...t}=e;return(0,s.yg)(Ven,(0,p.A)({},Fen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}qen.isMDXComponent=!0;const jen={toc:[]},Hen="wrapper";function Yen(e){let{components:n,...t}=e;return(0,s.yg)(Hen,(0,p.A)({},jen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Yen.isMDXComponent=!0;const Qen={toc:[]},$en="wrapper";function Ken(e){let{components:n,...t}=e;return(0,s.yg)($en,(0,p.A)({},Qen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Ken.isMDXComponent=!0;const Jen={toc:[]},Zen="wrapper";function enn(e){let{components:n,...t}=e;return(0,s.yg)(Zen,(0,p.A)({},Jen,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}enn.isMDXComponent=!0;const nnn={toc:[]},tnn="wrapper";function onn(e){let{components:n,...t}=e;return(0,s.yg)(tnn,(0,p.A)({},nnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}onn.isMDXComponent=!0;const pnn={toc:[]},rnn="wrapper";function snn(e){let{components:n,...t}=e;return(0,s.yg)(rnn,(0,p.A)({},pnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}snn.isMDXComponent=!0;const cnn={toc:[]},ann="wrapper";function inn(e){let{components:n,...t}=e;return(0,s.yg)(ann,(0,p.A)({},cnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}inn.isMDXComponent=!0;const lnn={toc:[]},unn="wrapper";function mnn(e){let{components:n,...t}=e;return(0,s.yg)(unn,(0,p.A)({},lnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}mnn.isMDXComponent=!0;const ynn={toc:[]},dnn="wrapper";function hnn(e){let{components:n,...t}=e;return(0,s.yg)(dnn,(0,p.A)({},ynn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}hnn.isMDXComponent=!0;const gnn={toc:[]},fnn="wrapper";function Dnn(e){let{components:n,...t}=e;return(0,s.yg)(fnn,(0,p.A)({},gnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Dnn.isMDXComponent=!0;const Mnn={toc:[]},Xnn="wrapper";function _nn(e){let{components:n,...t}=e;return(0,s.yg)(Xnn,(0,p.A)({},Mnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}_nn.isMDXComponent=!0;const wnn={toc:[]},Tnn="wrapper";function Cnn(e){let{components:n,...t}=e;return(0,s.yg)(Tnn,(0,p.A)({},wnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Cnn.isMDXComponent=!0;const xnn={toc:[]},Ann="wrapper";function vnn(e){let{components:n,...t}=e;return(0,s.yg)(Ann,(0,p.A)({},xnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}vnn.isMDXComponent=!0;const Lnn={toc:[]},bnn="wrapper";function Nnn(e){let{components:n,...t}=e;return(0,s.yg)(bnn,(0,p.A)({},Lnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Nnn.isMDXComponent=!0;const knn={toc:[]},znn="wrapper";function Pnn(e){let{components:n,...t}=e;return(0,s.yg)(znn,(0,p.A)({},knn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Pnn.isMDXComponent=!0;const Inn={toc:[]},Rnn="wrapper";function Wnn(e){let{components:n,...t}=e;return(0,s.yg)(Rnn,(0,p.A)({},Inn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}Wnn.isMDXComponent=!0;const Snn={toc:[]},Bnn="wrapper";function Enn(e){let{components:n,...t}=e;return(0,s.yg)(Bnn,(0,p.A)({},Snn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Curve#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Enn.isMDXComponent=!0;const Gnn={toc:[]},Onn="wrapper";function Unn(e){let{components:n,...t}=e;return(0,s.yg)(Onn,(0,p.A)({},Gnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Unn.isMDXComponent=!0;const Fnn={toc:[]},Vnn="wrapper";function qnn(e){let{components:n,...t}=e;return(0,s.yg)(Vnn,(0,p.A)({},Fnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}qnn.isMDXComponent=!0;const jnn={toc:[]},Hnn="wrapper";function Ynn(e){let{components:n,...t}=e;return(0,s.yg)(Hnn,(0,p.A)({},jnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Ynn.isMDXComponent=!0;const Qnn={toc:[]},$nn="wrapper";function Knn(e){let{components:n,...t}=e;return(0,s.yg)($nn,(0,p.A)({},Qnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}Knn.isMDXComponent=!0;const Jnn={toc:[]},Znn="wrapper";function etn(e){let{components:n,...t}=e;return(0,s.yg)(Znn,(0,p.A)({},Jnn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}etn.isMDXComponent=!0;const ntn={toc:[]},ttn="wrapper";function otn(e){let{components:n,...t}=e;return(0,s.yg)(ttn,(0,p.A)({},ntn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}otn.isMDXComponent=!0;const ptn={toc:[]},rtn="wrapper";function stn(e){let{components:n,...t}=e;return(0,s.yg)(rtn,(0,p.A)({},ptn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Grid, makeScene2D} from '@revideo/2d';\nimport {all, createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const grid = createRef<Grid>();\n\n  view.add(\n    <Grid\n      ref={grid}\n      width={'100%'}\n      height={'100%'}\n      stroke={'#666'}\n      start={0}\n      end={1}\n    />,\n  );\n\n  yield* all(\n    grid().end(0.5, 1).to(1, 1).wait(1),\n    grid().start(0.5, 1).to(0, 1).wait(1),\n  );\n});\n")))}stn.isMDXComponent=!0;const ctn={toc:[]},atn="wrapper";function itn(e){let{components:n,...t}=e;return(0,s.yg)(atn,(0,p.A)({},ctn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing a two-dimensional grid."))}itn.isMDXComponent=!0;const ltn={toc:[]},utn="wrapper";function mtn(e){let{components:n,...t}=e;return(0,s.yg)(utn,(0,p.A)({},ltn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}mtn.isMDXComponent=!0;const ytn={toc:[]},dtn="wrapper";function htn(e){let{components:n,...t}=e;return(0,s.yg)(dtn,(0,p.A)({},ytn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}htn.isMDXComponent=!0;const gtn={toc:[]},ftn="wrapper";function Dtn(e){let{components:n,...t}=e;return(0,s.yg)(ftn,(0,p.A)({},gtn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Dtn.isMDXComponent=!0;const Mtn={toc:[]},Xtn="wrapper";function _tn(e){let{components:n,...t}=e;return(0,s.yg)(Xtn,(0,p.A)({},Mtn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}_tn.isMDXComponent=!0;const wtn={toc:[]},Ttn="wrapper";function Ctn(e){let{components:n,...t}=e;return(0,s.yg)(Ttn,(0,p.A)({},wtn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Ctn.isMDXComponent=!0;const xtn={toc:[]},Atn="wrapper";function vtn(e){let{components:n,...t}=e;return(0,s.yg)(Atn,(0,p.A)({},xtn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}vtn.isMDXComponent=!0;const Ltn={toc:[]},btn="wrapper";function Ntn(e){let{components:n,...t}=e;return(0,s.yg)(btn,(0,p.A)({},Ltn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Ntn.isMDXComponent=!0;const ktn={toc:[]},ztn="wrapper";function Ptn(e){let{components:n,...t}=e;return(0,s.yg)(ztn,(0,p.A)({},ktn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Ptn.isMDXComponent=!0;const Itn={toc:[]},Rtn="wrapper";function Wtn(e){let{components:n,...t}=e;return(0,s.yg)(Rtn,(0,p.A)({},Itn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Wtn.isMDXComponent=!0;const Stn={toc:[]},Btn="wrapper";function Etn(e){let{components:n,...t}=e;return(0,s.yg)(Btn,(0,p.A)({},Stn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Etn.isMDXComponent=!0;const Gtn={toc:[]},Otn="wrapper";function Utn(e){let{components:n,...t}=e;return(0,s.yg)(Otn,(0,p.A)({},Gtn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Utn.isMDXComponent=!0;const Ftn={toc:[]},Vtn="wrapper";function qtn(e){let{components:n,...t}=e;return(0,s.yg)(Vtn,(0,p.A)({},Ftn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}qtn.isMDXComponent=!0;const jtn={toc:[]},Htn="wrapper";function Ytn(e){let{components:n,...t}=e;return(0,s.yg)(Htn,(0,p.A)({},jtn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Ytn.isMDXComponent=!0;const Qtn={toc:[]},$tn="wrapper";function Ktn(e){let{components:n,...t}=e;return(0,s.yg)($tn,(0,p.A)({},Qtn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Ktn.isMDXComponent=!0;const Jtn={toc:[]},Ztn="wrapper";function eon(e){let{components:n,...t}=e;return(0,s.yg)(Ztn,(0,p.A)({},Jtn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of each grid line that comes after the given percentage will\nbe made invisible."),(0,s.yg)("p",null,"This property is useful for animating the grid appearing on-screen."))}eon.isMDXComponent=!0;const non={toc:[]},ton="wrapper";function oon(e){let{components:n,...t}=e;return(0,s.yg)(ton,(0,p.A)({},non,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage that should be clipped from the end of each grid line."))}oon.isMDXComponent=!0;const pon={toc:[]},ron="wrapper";function son(e){let{components:n,...t}=e;return(0,s.yg)(ron,(0,p.A)({},pon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}son.isMDXComponent=!0;const con={toc:[]},aon="wrapper";function ion(e){let{components:n,...t}=e;return(0,s.yg)(aon,(0,p.A)({},con,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}ion.isMDXComponent=!0;const lon={toc:[]},uon="wrapper";function mon(e){let{components:n,...t}=e;return(0,s.yg)(uon,(0,p.A)({},lon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}mon.isMDXComponent=!0;const yon={toc:[]},don="wrapper";function hon(e){let{components:n,...t}=e;return(0,s.yg)(don,(0,p.A)({},yon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}hon.isMDXComponent=!0;const gon={toc:[]},fon="wrapper";function Don(e){let{components:n,...t}=e;return(0,s.yg)(fon,(0,p.A)({},gon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Don.isMDXComponent=!0;const Mon={toc:[]},Xon="wrapper";function _on(e){let{components:n,...t}=e;return(0,s.yg)(Xon,(0,p.A)({},Mon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}_on.isMDXComponent=!0;const won={toc:[]},Ton="wrapper";function Con(e){let{components:n,...t}=e;return(0,s.yg)(Ton,(0,p.A)({},won,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}Con.isMDXComponent=!0;const xon={toc:[]},Aon="wrapper";function von(e){let{components:n,...t}=e;return(0,s.yg)(Aon,(0,p.A)({},xon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}von.isMDXComponent=!0;const Lon={toc:[]},bon="wrapper";function Non(e){let{components:n,...t}=e;return(0,s.yg)(bon,(0,p.A)({},Lon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Non.isMDXComponent=!0;const kon={toc:[]},zon="wrapper";function Pon(e){let{components:n,...t}=e;return(0,s.yg)(zon,(0,p.A)({},kon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}Pon.isMDXComponent=!0;const Ion={toc:[]},Ron="wrapper";function Won(e){let{components:n,...t}=e;return(0,s.yg)(Ron,(0,p.A)({},Ion,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Won.isMDXComponent=!0;const Son={toc:[]},Bon="wrapper";function Eon(e){let{components:n,...t}=e;return(0,s.yg)(Bon,(0,p.A)({},Son,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Eon.isMDXComponent=!0;const Gon={toc:[]},Oon="wrapper";function Uon(e){let{components:n,...t}=e;return(0,s.yg)(Oon,(0,p.A)({},Gon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Uon.isMDXComponent=!0;const Fon={toc:[]},Von="wrapper";function qon(e){let{components:n,...t}=e;return(0,s.yg)(Von,(0,p.A)({},Fon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}qon.isMDXComponent=!0;const jon={toc:[]},Hon="wrapper";function Yon(e){let{components:n,...t}=e;return(0,s.yg)(Hon,(0,p.A)({},jon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}Yon.isMDXComponent=!0;const Qon={toc:[]},$on="wrapper";function Kon(e){let{components:n,...t}=e;return(0,s.yg)($on,(0,p.A)({},Qon,t,{components:n,mdxType:"MDXLayout"}))}Kon.isMDXComponent=!0;const Jon={toc:[]},Zon="wrapper";function epn(e){let{components:n,...t}=e;return(0,s.yg)(Zon,(0,p.A)({},Jon,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}epn.isMDXComponent=!0;const npn={toc:[]},tpn="wrapper";function opn(e){let{components:n,...t}=e;return(0,s.yg)(tpn,(0,p.A)({},npn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}opn.isMDXComponent=!0;const ppn={toc:[]},rpn="wrapper";function spn(e){let{components:n,...t}=e;return(0,s.yg)(rpn,(0,p.A)({},ppn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}spn.isMDXComponent=!0;const cpn={toc:[]},apn="wrapper";function ipn(e){let{components:n,...t}=e;return(0,s.yg)(apn,(0,p.A)({},cpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}ipn.isMDXComponent=!0;const lpn={toc:[]},upn="wrapper";function mpn(e){let{components:n,...t}=e;return(0,s.yg)(upn,(0,p.A)({},lpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}mpn.isMDXComponent=!0;const ypn={toc:[]},dpn="wrapper";function hpn(e){let{components:n,...t}=e;return(0,s.yg)(dpn,(0,p.A)({},ypn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The spacing between the grid lines."))}hpn.isMDXComponent=!0;const gpn={toc:[]},fpn="wrapper";function Dpn(e){let{components:n,...t}=e;return(0,s.yg)(fpn,(0,p.A)({},gpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Dpn.isMDXComponent=!0;const Mpn={toc:[]},Xpn="wrapper";function _pn(e){let{components:n,...t}=e;return(0,s.yg)(Xpn,(0,p.A)({},Mpn,t,{components:n,mdxType:"MDXLayout"}))}_pn.isMDXComponent=!0;const wpn={toc:[]},Tpn="wrapper";function Cpn(e){let{components:n,...t}=e;return(0,s.yg)(Tpn,(0,p.A)({},wpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of each grid line that comes before the given percentage will\nbe made invisible."),(0,s.yg)("p",null,"This property is useful for animating the grid appearing on-screen."))}Cpn.isMDXComponent=!0;const xpn={toc:[]},Apn="wrapper";function vpn(e){let{components:n,...t}=e;return(0,s.yg)(Apn,(0,p.A)({},xpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage that should be clipped from the beginning of each grid line."))}vpn.isMDXComponent=!0;const Lpn={toc:[]},bpn="wrapper";function Npn(e){let{components:n,...t}=e;return(0,s.yg)(bpn,(0,p.A)({},Lpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Npn.isMDXComponent=!0;const kpn={toc:[]},zpn="wrapper";function Ppn(e){let{components:n,...t}=e;return(0,s.yg)(zpn,(0,p.A)({},kpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Ppn.isMDXComponent=!0;const Ipn={toc:[]},Rpn="wrapper";function Wpn(e){let{components:n,...t}=e;return(0,s.yg)(Rpn,(0,p.A)({},Ipn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Wpn.isMDXComponent=!0;const Spn={toc:[]},Bpn="wrapper";function Epn(e){let{components:n,...t}=e;return(0,s.yg)(Bpn,(0,p.A)({},Spn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Epn.isMDXComponent=!0;const Gpn={toc:[]},Opn="wrapper";function Upn(e){let{components:n,...t}=e;return(0,s.yg)(Opn,(0,p.A)({},Gpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Upn.isMDXComponent=!0;const Fpn={toc:[]},Vpn="wrapper";function qpn(e){let{components:n,...t}=e;return(0,s.yg)(Vpn,(0,p.A)({},Fpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}qpn.isMDXComponent=!0;const jpn={toc:[]},Hpn="wrapper";function Ypn(e){let{components:n,...t}=e;return(0,s.yg)(Hpn,(0,p.A)({},jpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}Ypn.isMDXComponent=!0;const Qpn={toc:[]},$pn="wrapper";function Kpn(e){let{components:n,...t}=e;return(0,s.yg)($pn,(0,p.A)({},Qpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Kpn.isMDXComponent=!0;const Jpn={toc:[]},Zpn="wrapper";function ern(e){let{components:n,...t}=e;return(0,s.yg)(Zpn,(0,p.A)({},Jpn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}ern.isMDXComponent=!0;const nrn={toc:[]},trn="wrapper";function orn(e){let{components:n,...t}=e;return(0,s.yg)(trn,(0,p.A)({},nrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}orn.isMDXComponent=!0;const prn={toc:[]},rrn="wrapper";function srn(e){let{components:n,...t}=e;return(0,s.yg)(rrn,(0,p.A)({},prn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}srn.isMDXComponent=!0;const crn={toc:[]},arn="wrapper";function irn(e){let{components:n,...t}=e;return(0,s.yg)(arn,(0,p.A)({},crn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}irn.isMDXComponent=!0;const lrn={toc:[]},urn="wrapper";function mrn(e){let{components:n,...t}=e;return(0,s.yg)(urn,(0,p.A)({},lrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}mrn.isMDXComponent=!0;const yrn={toc:[]},drn="wrapper";function hrn(e){let{components:n,...t}=e;return(0,s.yg)(drn,(0,p.A)({},yrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}hrn.isMDXComponent=!0;const grn={toc:[]},frn="wrapper";function Drn(e){let{components:n,...t}=e;return(0,s.yg)(frn,(0,p.A)({},grn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Drn.isMDXComponent=!0;const Mrn={toc:[]},Xrn="wrapper";function _rn(e){let{components:n,...t}=e;return(0,s.yg)(Xrn,(0,p.A)({},Mrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}_rn.isMDXComponent=!0;const wrn={toc:[]},Trn="wrapper";function Crn(e){let{components:n,...t}=e;return(0,s.yg)(Trn,(0,p.A)({},wrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Crn.isMDXComponent=!0;const xrn={toc:[]},Arn="wrapper";function vrn(e){let{components:n,...t}=e;return(0,s.yg)(Arn,(0,p.A)({},xrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}vrn.isMDXComponent=!0;const Lrn={toc:[]},brn="wrapper";function Nrn(e){let{components:n,...t}=e;return(0,s.yg)(brn,(0,p.A)({},Lrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}Nrn.isMDXComponent=!0;const krn={toc:[]},zrn="wrapper";function Prn(e){let{components:n,...t}=e;return(0,s.yg)(zrn,(0,p.A)({},krn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}Prn.isMDXComponent=!0;const Irn={toc:[]},Rrn="wrapper";function Wrn(e){let{components:n,...t}=e;return(0,s.yg)(Rrn,(0,p.A)({},Irn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}Wrn.isMDXComponent=!0;const Srn={toc:[]},Brn="wrapper";function Ern(e){let{components:n,...t}=e;return(0,s.yg)(Brn,(0,p.A)({},Srn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Ern.isMDXComponent=!0;const Grn={toc:[]},Orn="wrapper";function Urn(e){let{components:n,...t}=e;return(0,s.yg)(Orn,(0,p.A)({},Grn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Urn.isMDXComponent=!0;const Frn={toc:[]},Vrn="wrapper";function qrn(e){let{components:n,...t}=e;return(0,s.yg)(Vrn,(0,p.A)({},Frn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}qrn.isMDXComponent=!0;const jrn={toc:[]},Hrn="wrapper";function Yrn(e){let{components:n,...t}=e;return(0,s.yg)(Hrn,(0,p.A)({},jrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Yrn.isMDXComponent=!0;const Qrn={toc:[]},$rn="wrapper";function Krn(e){let{components:n,...t}=e;return(0,s.yg)($rn,(0,p.A)({},Qrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}Krn.isMDXComponent=!0;const Jrn={toc:[]},Zrn="wrapper";function esn(e){let{components:n,...t}=e;return(0,s.yg)(Zrn,(0,p.A)({},Jrn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}esn.isMDXComponent=!0;const nsn={toc:[]},tsn="wrapper";function osn(e){let{components:n,...t}=e;return(0,s.yg)(tsn,(0,p.A)({},nsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}osn.isMDXComponent=!0;const psn={toc:[]},rsn="wrapper";function ssn(e){let{components:n,...t}=e;return(0,s.yg)(rsn,(0,p.A)({},psn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}ssn.isMDXComponent=!0;const csn={toc:[]},asn="wrapper";function isn(e){let{components:n,...t}=e;return(0,s.yg)(asn,(0,p.A)({},csn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}isn.isMDXComponent=!0;const lsn={toc:[]},usn="wrapper";function msn(e){let{components:n,...t}=e;return(0,s.yg)(usn,(0,p.A)({},lsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}msn.isMDXComponent=!0;const ysn={toc:[]},dsn="wrapper";function hsn(e){let{components:n,...t}=e;return(0,s.yg)(dsn,(0,p.A)({},ysn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}hsn.isMDXComponent=!0;const gsn={toc:[]},fsn="wrapper";function Dsn(e){let{components:n,...t}=e;return(0,s.yg)(fsn,(0,p.A)({},gsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Dsn.isMDXComponent=!0;const Msn={toc:[]},Xsn="wrapper";function _sn(e){let{components:n,...t}=e;return(0,s.yg)(Xsn,(0,p.A)({},Msn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}_sn.isMDXComponent=!0;const wsn={toc:[]},Tsn="wrapper";function Csn(e){let{components:n,...t}=e;return(0,s.yg)(Tsn,(0,p.A)({},wsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}Csn.isMDXComponent=!0;const xsn={toc:[]},Asn="wrapper";function vsn(e){let{components:n,...t}=e;return(0,s.yg)(Asn,(0,p.A)({},xsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}vsn.isMDXComponent=!0;const Lsn={toc:[]},bsn="wrapper";function Nsn(e){let{components:n,...t}=e;return(0,s.yg)(bsn,(0,p.A)({},Lsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}Nsn.isMDXComponent=!0;const ksn={toc:[]},zsn="wrapper";function Psn(e){let{components:n,...t}=e;return(0,s.yg)(zsn,(0,p.A)({},ksn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Psn.isMDXComponent=!0;const Isn={toc:[]},Rsn="wrapper";function Wsn(e){let{components:n,...t}=e;return(0,s.yg)(Rsn,(0,p.A)({},Isn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Wsn.isMDXComponent=!0;const Ssn={toc:[]},Bsn="wrapper";function Esn(e){let{components:n,...t}=e;return(0,s.yg)(Bsn,(0,p.A)({},Ssn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Esn.isMDXComponent=!0;const Gsn={toc:[]},Osn="wrapper";function Usn(e){let{components:n,...t}=e;return(0,s.yg)(Osn,(0,p.A)({},Gsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Usn.isMDXComponent=!0;const Fsn={toc:[]},Vsn="wrapper";function qsn(e){let{components:n,...t}=e;return(0,s.yg)(Vsn,(0,p.A)({},Fsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}qsn.isMDXComponent=!0;const jsn={toc:[]},Hsn="wrapper";function Ysn(e){let{components:n,...t}=e;return(0,s.yg)(Hsn,(0,p.A)({},jsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Ysn.isMDXComponent=!0;const Qsn={toc:[]},$sn="wrapper";function Ksn(e){let{components:n,...t}=e;return(0,s.yg)($sn,(0,p.A)({},Qsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Ksn.isMDXComponent=!0;const Jsn={toc:[]},Zsn="wrapper";function ecn(e){let{components:n,...t}=e;return(0,s.yg)(Zsn,(0,p.A)({},Jsn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}ecn.isMDXComponent=!0;const ncn={toc:[]},tcn="wrapper";function ocn(e){let{components:n,...t}=e;return(0,s.yg)(tcn,(0,p.A)({},ncn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}ocn.isMDXComponent=!0;const pcn={toc:[]},rcn="wrapper";function scn(e){let{components:n,...t}=e;return(0,s.yg)(rcn,(0,p.A)({},pcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}scn.isMDXComponent=!0;const ccn={toc:[]},acn="wrapper";function icn(e){let{components:n,...t}=e;return(0,s.yg)(acn,(0,p.A)({},ccn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}icn.isMDXComponent=!0;const lcn={toc:[]},ucn="wrapper";function mcn(e){let{components:n,...t}=e;return(0,s.yg)(ucn,(0,p.A)({},lcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}mcn.isMDXComponent=!0;const ycn={toc:[]},dcn="wrapper";function hcn(e){let{components:n,...t}=e;return(0,s.yg)(dcn,(0,p.A)({},ycn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}hcn.isMDXComponent=!0;const gcn={toc:[]},fcn="wrapper";function Dcn(e){let{components:n,...t}=e;return(0,s.yg)(fcn,(0,p.A)({},gcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Dcn.isMDXComponent=!0;const Mcn={toc:[]},Xcn="wrapper";function _cn(e){let{components:n,...t}=e;return(0,s.yg)(Xcn,(0,p.A)({},Mcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}_cn.isMDXComponent=!0;const wcn={toc:[]},Tcn="wrapper";function Ccn(e){let{components:n,...t}=e;return(0,s.yg)(Tcn,(0,p.A)({},wcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Ccn.isMDXComponent=!0;const xcn={toc:[]},Acn="wrapper";function vcn(e){let{components:n,...t}=e;return(0,s.yg)(Acn,(0,p.A)({},xcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}vcn.isMDXComponent=!0;const Lcn={toc:[]},bcn="wrapper";function Ncn(e){let{components:n,...t}=e;return(0,s.yg)(bcn,(0,p.A)({},Lcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Ncn.isMDXComponent=!0;const kcn={toc:[]},zcn="wrapper";function Pcn(e){let{components:n,...t}=e;return(0,s.yg)(zcn,(0,p.A)({},kcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Pcn.isMDXComponent=!0;const Icn={toc:[]},Rcn="wrapper";function Wcn(e){let{components:n,...t}=e;return(0,s.yg)(Rcn,(0,p.A)({},Icn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}Wcn.isMDXComponent=!0;const Scn={toc:[]},Bcn="wrapper";function Ecn(e){let{components:n,...t}=e;return(0,s.yg)(Bcn,(0,p.A)({},Scn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Ecn.isMDXComponent=!0;const Gcn={toc:[]},Ocn="wrapper";function Ucn(e){let{components:n,...t}=e;return(0,s.yg)(Ocn,(0,p.A)({},Gcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}Ucn.isMDXComponent=!0;const Fcn={toc:[]},Vcn="wrapper";function qcn(e){let{components:n,...t}=e;return(0,s.yg)(Vcn,(0,p.A)({},Fcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}qcn.isMDXComponent=!0;const jcn={toc:[]},Hcn="wrapper";function Ycn(e){let{components:n,...t}=e;return(0,s.yg)(Hcn,(0,p.A)({},jcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}Ycn.isMDXComponent=!0;const Qcn={toc:[]},$cn="wrapper";function Kcn(e){let{components:n,...t}=e;return(0,s.yg)($cn,(0,p.A)({},Qcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Kcn.isMDXComponent=!0;const Jcn={toc:[]},Zcn="wrapper";function ean(e){let{components:n,...t}=e;return(0,s.yg)(Zcn,(0,p.A)({},Jcn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}ean.isMDXComponent=!0;const nan={toc:[]},tan="wrapper";function oan(e){let{components:n,...t}=e;return(0,s.yg)(tan,(0,p.A)({},nan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}oan.isMDXComponent=!0;const pan={toc:[]},ran="wrapper";function san(e){let{components:n,...t}=e;return(0,s.yg)(ran,(0,p.A)({},pan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}san.isMDXComponent=!0;const can={toc:[]},aan="wrapper";function ian(e){let{components:n,...t}=e;return(0,s.yg)(aan,(0,p.A)({},can,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}ian.isMDXComponent=!0;const lan={toc:[]},uan="wrapper";function man(e){let{components:n,...t}=e;return(0,s.yg)(uan,(0,p.A)({},lan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}man.isMDXComponent=!0;const yan={toc:[]},dan="wrapper";function han(e){let{components:n,...t}=e;return(0,s.yg)(dan,(0,p.A)({},yan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}han.isMDXComponent=!0;const gan={toc:[]},fan="wrapper";function Dan(e){let{components:n,...t}=e;return(0,s.yg)(fan,(0,p.A)({},gan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}Dan.isMDXComponent=!0;const Man={toc:[]},Xan="wrapper";function _an(e){let{components:n,...t}=e;return(0,s.yg)(Xan,(0,p.A)({},Man,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}_an.isMDXComponent=!0;const wan={toc:[]},Tan="wrapper";function Can(e){let{components:n,...t}=e;return(0,s.yg)(Tan,(0,p.A)({},wan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}Can.isMDXComponent=!0;const xan={toc:[]},Aan="wrapper";function van(e){let{components:n,...t}=e;return(0,s.yg)(Aan,(0,p.A)({},xan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}van.isMDXComponent=!0;const Lan={toc:[]},ban="wrapper";function Nan(e){let{components:n,...t}=e;return(0,s.yg)(ban,(0,p.A)({},Lan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Nan.isMDXComponent=!0;const kan={toc:[]},zan="wrapper";function Pan(e){let{components:n,...t}=e;return(0,s.yg)(zan,(0,p.A)({},kan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}Pan.isMDXComponent=!0;const Ian={toc:[]},Ran="wrapper";function Wan(e){let{components:n,...t}=e;return(0,s.yg)(Ran,(0,p.A)({},Ian,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Wan.isMDXComponent=!0;const San={toc:[]},Ban="wrapper";function Ean(e){let{components:n,...t}=e;return(0,s.yg)(Ban,(0,p.A)({},San,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}Ean.isMDXComponent=!0;const Gan={toc:[]},Oan="wrapper";function Uan(e){let{components:n,...t}=e;return(0,s.yg)(Oan,(0,p.A)({},Gan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}Uan.isMDXComponent=!0;const Fan={toc:[]},Van="wrapper";function qan(e){let{components:n,...t}=e;return(0,s.yg)(Van,(0,p.A)({},Fan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}qan.isMDXComponent=!0;const jan={toc:[]},Han="wrapper";function Yan(e){let{components:n,...t}=e;return(0,s.yg)(Han,(0,p.A)({},jan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}Yan.isMDXComponent=!0;const Qan={toc:[]},$an="wrapper";function Kan(e){let{components:n,...t}=e;return(0,s.yg)($an,(0,p.A)({},Qan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Kan.isMDXComponent=!0;const Jan={toc:[]},Zan="wrapper";function ein(e){let{components:n,...t}=e;return(0,s.yg)(Zan,(0,p.A)({},Jan,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}ein.isMDXComponent=!0;const nin={toc:[]},tin="wrapper";function oin(e){let{components:n,...t}=e;return(0,s.yg)(tin,(0,p.A)({},nin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}oin.isMDXComponent=!0;const pin={toc:[]},rin="wrapper";function sin(e){let{components:n,...t}=e;return(0,s.yg)(rin,(0,p.A)({},pin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}sin.isMDXComponent=!0;const cin={toc:[]},ain="wrapper";function iin(e){let{components:n,...t}=e;return(0,s.yg)(ain,(0,p.A)({},cin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}iin.isMDXComponent=!0;const lin={toc:[]},uin="wrapper";function min(e){let{components:n,...t}=e;return(0,s.yg)(uin,(0,p.A)({},lin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}min.isMDXComponent=!0;const yin={toc:[]},din="wrapper";function hin(e){let{components:n,...t}=e;return(0,s.yg)(din,(0,p.A)({},yin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}hin.isMDXComponent=!0;const gin={toc:[]},fin="wrapper";function Din(e){let{components:n,...t}=e;return(0,s.yg)(fin,(0,p.A)({},gin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}Din.isMDXComponent=!0;const Min={toc:[]},Xin="wrapper";function _in(e){let{components:n,...t}=e;return(0,s.yg)(Xin,(0,p.A)({},Min,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}_in.isMDXComponent=!0;const win={toc:[]},Tin="wrapper";function Cin(e){let{components:n,...t}=e;return(0,s.yg)(Tin,(0,p.A)({},win,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}Cin.isMDXComponent=!0;const xin={toc:[]},Ain="wrapper";function vin(e){let{components:n,...t}=e;return(0,s.yg)(Ain,(0,p.A)({},xin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}vin.isMDXComponent=!0;const Lin={toc:[]},bin="wrapper";function Nin(e){let{components:n,...t}=e;return(0,s.yg)(bin,(0,p.A)({},Lin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}Nin.isMDXComponent=!0;const kin={toc:[]},zin="wrapper";function Pin(e){let{components:n,...t}=e;return(0,s.yg)(zin,(0,p.A)({},kin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}Pin.isMDXComponent=!0;const Iin={toc:[]},Rin="wrapper";function Win(e){let{components:n,...t}=e;return(0,s.yg)(Rin,(0,p.A)({},Iin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Win.isMDXComponent=!0;const Sin={toc:[]},Bin="wrapper";function Ein(e){let{components:n,...t}=e;return(0,s.yg)(Bin,(0,p.A)({},Sin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}Ein.isMDXComponent=!0;const Gin={toc:[]},Oin="wrapper";function Uin(e){let{components:n,...t}=e;return(0,s.yg)(Oin,(0,p.A)({},Gin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Uin.isMDXComponent=!0;const Fin={toc:[]},Vin="wrapper";function qin(e){let{components:n,...t}=e;return(0,s.yg)(Vin,(0,p.A)({},Fin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}qin.isMDXComponent=!0;const jin={toc:[]},Hin="wrapper";function Yin(e){let{components:n,...t}=e;return(0,s.yg)(Hin,(0,p.A)({},jin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Yin.isMDXComponent=!0;const Qin={toc:[]},$in="wrapper";function Kin(e){let{components:n,...t}=e;return(0,s.yg)($in,(0,p.A)({},Qin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}Kin.isMDXComponent=!0;const Jin={toc:[]},Zin="wrapper";function eln(e){let{components:n,...t}=e;return(0,s.yg)(Zin,(0,p.A)({},Jin,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}eln.isMDXComponent=!0;const nln={toc:[]},tln="wrapper";function oln(e){let{components:n,...t}=e;return(0,s.yg)(tln,(0,p.A)({},nln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}oln.isMDXComponent=!0;const pln={toc:[]},rln="wrapper";function sln(e){let{components:n,...t}=e;return(0,s.yg)(rln,(0,p.A)({},pln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}sln.isMDXComponent=!0;const cln={toc:[]},aln="wrapper";function iln(e){let{components:n,...t}=e;return(0,s.yg)(aln,(0,p.A)({},cln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}iln.isMDXComponent=!0;const lln={toc:[]},uln="wrapper";function mln(e){let{components:n,...t}=e;return(0,s.yg)(uln,(0,p.A)({},lln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}mln.isMDXComponent=!0;const yln={toc:[]},dln="wrapper";function hln(e){let{components:n,...t}=e;return(0,s.yg)(dln,(0,p.A)({},yln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}hln.isMDXComponent=!0;const gln={toc:[]},fln="wrapper";function Dln(e){let{components:n,...t}=e;return(0,s.yg)(fln,(0,p.A)({},gln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}Dln.isMDXComponent=!0;const Mln={toc:[]},Xln="wrapper";function _ln(e){let{components:n,...t}=e;return(0,s.yg)(Xln,(0,p.A)({},Mln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}_ln.isMDXComponent=!0;const wln={toc:[]},Tln="wrapper";function Cln(e){let{components:n,...t}=e;return(0,s.yg)(Tln,(0,p.A)({},wln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}Cln.isMDXComponent=!0;const xln={toc:[]},Aln="wrapper";function vln(e){let{components:n,...t}=e;return(0,s.yg)(Aln,(0,p.A)({},xln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}vln.isMDXComponent=!0;const Lln={toc:[]},bln="wrapper";function Nln(e){let{components:n,...t}=e;return(0,s.yg)(bln,(0,p.A)({},Lln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}Nln.isMDXComponent=!0;const kln={toc:[]},zln="wrapper";function Pln(e){let{components:n,...t}=e;return(0,s.yg)(zln,(0,p.A)({},kln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}Pln.isMDXComponent=!0;const Iln={toc:[]},Rln="wrapper";function Wln(e){let{components:n,...t}=e;return(0,s.yg)(Rln,(0,p.A)({},Iln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Wln.isMDXComponent=!0;const Sln={toc:[]},Bln="wrapper";function Eln(e){let{components:n,...t}=e;return(0,s.yg)(Bln,(0,p.A)({},Sln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Eln.isMDXComponent=!0;const Gln={toc:[]},Oln="wrapper";function Uln(e){let{components:n,...t}=e;return(0,s.yg)(Oln,(0,p.A)({},Gln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Uln.isMDXComponent=!0;const Fln={toc:[]},Vln="wrapper";function qln(e){let{components:n,...t}=e;return(0,s.yg)(Vln,(0,p.A)({},Fln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}qln.isMDXComponent=!0;const jln={toc:[]},Hln="wrapper";function Yln(e){let{components:n,...t}=e;return(0,s.yg)(Hln,(0,p.A)({},jln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Yln.isMDXComponent=!0;const Qln={toc:[]},$ln="wrapper";function Kln(e){let{components:n,...t}=e;return(0,s.yg)($ln,(0,p.A)({},Qln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}Kln.isMDXComponent=!0;const Jln={toc:[]},Zln="wrapper";function eun(e){let{components:n,...t}=e;return(0,s.yg)(Zln,(0,p.A)({},Jln,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}eun.isMDXComponent=!0;const nun={toc:[]},tun="wrapper";function oun(e){let{components:n,...t}=e;return(0,s.yg)(tun,(0,p.A)({},nun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}oun.isMDXComponent=!0;const pun={toc:[]},run="wrapper";function sun(e){let{components:n,...t}=e;return(0,s.yg)(run,(0,p.A)({},pun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}sun.isMDXComponent=!0;const cun={toc:[]},aun="wrapper";function iun(e){let{components:n,...t}=e;return(0,s.yg)(aun,(0,p.A)({},cun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}iun.isMDXComponent=!0;const lun={toc:[]},uun="wrapper";function mun(e){let{components:n,...t}=e;return(0,s.yg)(uun,(0,p.A)({},lun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}mun.isMDXComponent=!0;const yun={toc:[]},dun="wrapper";function hun(e){let{components:n,...t}=e;return(0,s.yg)(dun,(0,p.A)({},yun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}hun.isMDXComponent=!0;const gun={toc:[]},fun="wrapper";function Dun(e){let{components:n,...t}=e;return(0,s.yg)(fun,(0,p.A)({},gun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}Dun.isMDXComponent=!0;const Mun={toc:[]},Xun="wrapper";function _un(e){let{components:n,...t}=e;return(0,s.yg)(Xun,(0,p.A)({},Mun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}_un.isMDXComponent=!0;const wun={toc:[]},Tun="wrapper";function Cun(e){let{components:n,...t}=e;return(0,s.yg)(Tun,(0,p.A)({},wun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Cun.isMDXComponent=!0;const xun={toc:[]},Aun="wrapper";function vun(e){let{components:n,...t}=e;return(0,s.yg)(Aun,(0,p.A)({},xun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}vun.isMDXComponent=!0;const Lun={toc:[]},bun="wrapper";function Nun(e){let{components:n,...t}=e;return(0,s.yg)(bun,(0,p.A)({},Lun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Nun.isMDXComponent=!0;const kun={toc:[]},zun="wrapper";function Pun(e){let{components:n,...t}=e;return(0,s.yg)(zun,(0,p.A)({},kun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Pun.isMDXComponent=!0;const Iun={toc:[]},Run="wrapper";function Wun(e){let{components:n,...t}=e;return(0,s.yg)(Run,(0,p.A)({},Iun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}Wun.isMDXComponent=!0;const Sun={toc:[]},Bun="wrapper";function Eun(e){let{components:n,...t}=e;return(0,s.yg)(Bun,(0,p.A)({},Sun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}Eun.isMDXComponent=!0;const Gun={toc:[]},Oun="wrapper";function Uun(e){let{components:n,...t}=e;return(0,s.yg)(Oun,(0,p.A)({},Gun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Uun.isMDXComponent=!0;const Fun={toc:[]},Vun="wrapper";function qun(e){let{components:n,...t}=e;return(0,s.yg)(Vun,(0,p.A)({},Fun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}qun.isMDXComponent=!0;const jun={toc:[]},Hun="wrapper";function Yun(e){let{components:n,...t}=e;return(0,s.yg)(Hun,(0,p.A)({},jun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Yun.isMDXComponent=!0;const Qun={toc:[]},$un="wrapper";function Kun(e){let{components:n,...t}=e;return(0,s.yg)($un,(0,p.A)({},Qun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Kun.isMDXComponent=!0;const Jun={toc:[]},Zun="wrapper";function emn(e){let{components:n,...t}=e;return(0,s.yg)(Zun,(0,p.A)({},Jun,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}emn.isMDXComponent=!0;const nmn={toc:[]},tmn="wrapper";function omn(e){let{components:n,...t}=e;return(0,s.yg)(tmn,(0,p.A)({},nmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}omn.isMDXComponent=!0;const pmn={toc:[]},rmn="wrapper";function smn(e){let{components:n,...t}=e;return(0,s.yg)(rmn,(0,p.A)({},pmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}smn.isMDXComponent=!0;const cmn={toc:[]},amn="wrapper";function imn(e){let{components:n,...t}=e;return(0,s.yg)(amn,(0,p.A)({},cmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}imn.isMDXComponent=!0;const lmn={toc:[]},umn="wrapper";function mmn(e){let{components:n,...t}=e;return(0,s.yg)(umn,(0,p.A)({},lmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}mmn.isMDXComponent=!0;const ymn={toc:[]},dmn="wrapper";function hmn(e){let{components:n,...t}=e;return(0,s.yg)(dmn,(0,p.A)({},ymn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Grid#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}hmn.isMDXComponent=!0;const gmn={toc:[]},fmn="wrapper";function Dmn(e){let{components:n,...t}=e;return(0,s.yg)(fmn,(0,p.A)({},gmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Dmn.isMDXComponent=!0;const Mmn={toc:[]},Xmn="wrapper";function _mn(e){let{components:n,...t}=e;return(0,s.yg)(Xmn,(0,p.A)({},Mmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}_mn.isMDXComponent=!0;const wmn={toc:[]},Tmn="wrapper";function Cmn(e){let{components:n,...t}=e;return(0,s.yg)(Tmn,(0,p.A)({},wmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Cmn.isMDXComponent=!0;const xmn={toc:[]},Amn="wrapper";function vmn(e){let{components:n,...t}=e;return(0,s.yg)(Amn,(0,p.A)({},xmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}vmn.isMDXComponent=!0;const Lmn={toc:[]},bmn="wrapper";function Nmn(e){let{components:n,...t}=e;return(0,s.yg)(bmn,(0,p.A)({},Lmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Nmn.isMDXComponent=!0;const kmn={toc:[]},zmn="wrapper";function Pmn(e){let{components:n,...t}=e;return(0,s.yg)(zmn,(0,p.A)({},kmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}Pmn.isMDXComponent=!0;const Imn={toc:[]},Rmn="wrapper";function Wmn(e){let{components:n,...t}=e;return(0,s.yg)(Rmn,(0,p.A)({},Imn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An Icon Component that provides easy access to over 150k icons.\nSee ",(0,s.yg)("a",{parentName:"p",href:"https://icones.js.org/collection/all"},"https://icones.js.org/collection/all")," for all available Icons."))}Wmn.isMDXComponent=!0;const Smn={toc:[]},Bmn="wrapper";function Emn(e){let{components:n,...t}=e;return(0,s.yg)(Bmn,(0,p.A)({},Smn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Emn.isMDXComponent=!0;const Gmn={toc:[]},Omn="wrapper";function Umn(e){let{components:n,...t}=e;return(0,s.yg)(Omn,(0,p.A)({},Gmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}Umn.isMDXComponent=!0;const Fmn={toc:[]},Vmn="wrapper";function qmn(e){let{components:n,...t}=e;return(0,s.yg)(Vmn,(0,p.A)({},Fmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}qmn.isMDXComponent=!0;const jmn={toc:[]},Hmn="wrapper";function Ymn(e){let{components:n,...t}=e;return(0,s.yg)(Hmn,(0,p.A)({},jmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}Ymn.isMDXComponent=!0;const Qmn={toc:[]},$mn="wrapper";function Kmn(e){let{components:n,...t}=e;return(0,s.yg)($mn,(0,p.A)({},Qmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Kmn.isMDXComponent=!0;const Jmn={toc:[]},Zmn="wrapper";function eyn(e){let{components:n,...t}=e;return(0,s.yg)(Zmn,(0,p.A)({},Jmn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}eyn.isMDXComponent=!0;const nyn={toc:[]},tyn="wrapper";function oyn(e){let{components:n,...t}=e;return(0,s.yg)(tyn,(0,p.A)({},nyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}oyn.isMDXComponent=!0;const pyn={toc:[]},ryn="wrapper";function syn(e){let{components:n,...t}=e;return(0,s.yg)(ryn,(0,p.A)({},pyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this image."))}syn.isMDXComponent=!0;const cyn={toc:[]},ayn="wrapper";function iyn(e){let{components:n,...t}=e;return(0,s.yg)(ayn,(0,p.A)({},cyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}iyn.isMDXComponent=!0;const lyn={toc:[]},uyn="wrapper";function myn(e){let{components:n,...t}=e;return(0,s.yg)(uyn,(0,p.A)({},lyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}myn.isMDXComponent=!0;const yyn={toc:[]},dyn="wrapper";function hyn(e){let{components:n,...t}=e;return(0,s.yg)(dyn,(0,p.A)({},yyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}hyn.isMDXComponent=!0;const gyn={toc:[]},fyn="wrapper";function Dyn(e){let{components:n,...t}=e;return(0,s.yg)(fyn,(0,p.A)({},gyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Dyn.isMDXComponent=!0;const Myn={toc:[]},Xyn="wrapper";function _yn(e){let{components:n,...t}=e;return(0,s.yg)(Xyn,(0,p.A)({},Myn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}_yn.isMDXComponent=!0;const wyn={toc:[]},Tyn="wrapper";function Cyn(e){let{components:n,...t}=e;return(0,s.yg)(Tyn,(0,p.A)({},wyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Cyn.isMDXComponent=!0;const xyn={toc:[]},Ayn="wrapper";function vyn(e){let{components:n,...t}=e;return(0,s.yg)(Ayn,(0,p.A)({},xyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}vyn.isMDXComponent=!0;const Lyn={toc:[]},byn="wrapper";function Nyn(e){let{components:n,...t}=e;return(0,s.yg)(byn,(0,p.A)({},Lyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Nyn.isMDXComponent=!0;const kyn={toc:[]},zyn="wrapper";function Pyn(e){let{components:n,...t}=e;return(0,s.yg)(zyn,(0,p.A)({},kyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Pyn.isMDXComponent=!0;const Iyn={toc:[]},Ryn="wrapper";function Wyn(e){let{components:n,...t}=e;return(0,s.yg)(Ryn,(0,p.A)({},Iyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Wyn.isMDXComponent=!0;const Syn={toc:[]},Byn="wrapper";function Eyn(e){let{components:n,...t}=e;return(0,s.yg)(Byn,(0,p.A)({},Syn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}Eyn.isMDXComponent=!0;const Gyn={toc:[]},Oyn="wrapper";function Uyn(e){let{components:n,...t}=e;return(0,s.yg)(Oyn,(0,p.A)({},Gyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}Uyn.isMDXComponent=!0;const Fyn={toc:[]},Vyn="wrapper";function qyn(e){let{components:n,...t}=e;return(0,s.yg)(Vyn,(0,p.A)({},Fyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provide the color in one of the following formats:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},"named color like ",(0,s.yg)("inlineCode",{parentName:"li"},"red"),", ",(0,s.yg)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.yg)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.yg)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.yg)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.yg)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.yg)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.yg)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.yg)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}qyn.isMDXComponent=!0;const jyn={toc:[]},Hyn="wrapper";function Yyn(e){let{components:n,...t}=e;return(0,s.yg)(Hyn,(0,p.A)({},jyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"'white'"))}Yyn.isMDXComponent=!0;const Qyn={toc:[]},$yn="wrapper";function Kyn(e){let{components:n,...t}=e;return(0,s.yg)($yn,(0,p.A)({},Qyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The color of the icon"))}Kyn.isMDXComponent=!0;const Jyn={toc:[]},Zyn="wrapper";function edn(e){let{components:n,...t}=e;return(0,s.yg)(Zyn,(0,p.A)({},Jyn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}edn.isMDXComponent=!0;const ndn={toc:[]},tdn="wrapper";function odn(e){let{components:n,...t}=e;return(0,s.yg)(tdn,(0,p.A)({},ndn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}odn.isMDXComponent=!0;const pdn={toc:[]},rdn="wrapper";function sdn(e){let{components:n,...t}=e;return(0,s.yg)(rdn,(0,p.A)({},pdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}sdn.isMDXComponent=!0;const cdn={toc:[]},adn="wrapper";function idn(e){let{components:n,...t}=e;return(0,s.yg)(adn,(0,p.A)({},cdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}idn.isMDXComponent=!0;const ldn={toc:[]},udn="wrapper";function mdn(e){let{components:n,...t}=e;return(0,s.yg)(udn,(0,p.A)({},ldn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}mdn.isMDXComponent=!0;const ydn={toc:[]},ddn="wrapper";function hdn(e){let{components:n,...t}=e;return(0,s.yg)(ddn,(0,p.A)({},ydn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}hdn.isMDXComponent=!0;const gdn={toc:[]},fdn="wrapper";function Ddn(e){let{components:n,...t}=e;return(0,s.yg)(fdn,(0,p.A)({},gdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}Ddn.isMDXComponent=!0;const Mdn={toc:[]},Xdn="wrapper";function _dn(e){let{components:n,...t}=e;return(0,s.yg)(Xdn,(0,p.A)({},Mdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}_dn.isMDXComponent=!0;const wdn={toc:[]},Tdn="wrapper";function Cdn(e){let{components:n,...t}=e;return(0,s.yg)(Tdn,(0,p.A)({},wdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}Cdn.isMDXComponent=!0;const xdn={toc:[]},Adn="wrapper";function vdn(e){let{components:n,...t}=e;return(0,s.yg)(Adn,(0,p.A)({},xdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"You can find identifiers on ",(0,s.yg)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}vdn.isMDXComponent=!0;const Ldn={toc:[]},bdn="wrapper";function Ndn(e){let{components:n,...t}=e;return(0,s.yg)(bdn,(0,p.A)({},Ldn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The identifier of the icon."))}Ndn.isMDXComponent=!0;const kdn={toc:[]},zdn="wrapper";function Pdn(e){let{components:n,...t}=e;return(0,s.yg)(zdn,(0,p.A)({},kdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Pdn.isMDXComponent=!0;const Idn={toc:[]},Rdn="wrapper";function Wdn(e){let{components:n,...t}=e;return(0,s.yg)(Rdn,(0,p.A)({},Idn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Wdn.isMDXComponent=!0;const Sdn={toc:[]},Bdn="wrapper";function Edn(e){let{components:n,...t}=e;return(0,s.yg)(Bdn,(0,p.A)({},Sdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Edn.isMDXComponent=!0;const Gdn={toc:[]},Odn="wrapper";function Udn(e){let{components:n,...t}=e;return(0,s.yg)(Odn,(0,p.A)({},Gdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Udn.isMDXComponent=!0;const Fdn={toc:[]},Vdn="wrapper";function qdn(e){let{components:n,...t}=e;return(0,s.yg)(Vdn,(0,p.A)({},Fdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}qdn.isMDXComponent=!0;const jdn={toc:[]},Hdn="wrapper";function Ydn(e){let{components:n,...t}=e;return(0,s.yg)(Hdn,(0,p.A)({},jdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}Ydn.isMDXComponent=!0;const Qdn={toc:[]},$dn="wrapper";function Kdn(e){let{components:n,...t}=e;return(0,s.yg)($dn,(0,p.A)({},Qdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}Kdn.isMDXComponent=!0;const Jdn={toc:[]},Zdn="wrapper";function ehn(e){let{components:n,...t}=e;return(0,s.yg)(Zdn,(0,p.A)({},Jdn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}ehn.isMDXComponent=!0;const nhn={toc:[]},thn="wrapper";function ohn(e){let{components:n,...t}=e;return(0,s.yg)(thn,(0,p.A)({},nhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}ohn.isMDXComponent=!0;const phn={toc:[]},rhn="wrapper";function shn(e){let{components:n,...t}=e;return(0,s.yg)(rhn,(0,p.A)({},phn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}shn.isMDXComponent=!0;const chn={toc:[]},ahn="wrapper";function ihn(e){let{components:n,...t}=e;return(0,s.yg)(ahn,(0,p.A)({},chn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}ihn.isMDXComponent=!0;const lhn={toc:[]},uhn="wrapper";function mhn(e){let{components:n,...t}=e;return(0,s.yg)(uhn,(0,p.A)({},lhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"One uniform radius:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}mhn.isMDXComponent=!0;const yhn={toc:[]},dhn="wrapper";function hhn(e){let{components:n,...t}=e;return(0,s.yg)(dhn,(0,p.A)({},yhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Individual radii for each corner:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}hhn.isMDXComponent=!0;const ghn={toc:[]},fhn="wrapper";function Dhn(e){let{components:n,...t}=e;return(0,s.yg)(fhn,(0,p.A)({},ghn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}Dhn.isMDXComponent=!0;const Mhn={toc:[]},Xhn="wrapper";function _hn(e){let{components:n,...t}=e;return(0,s.yg)(Xhn,(0,p.A)({},Mhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}_hn.isMDXComponent=!0;const whn={toc:[]},Thn="wrapper";function Chn(e){let{components:n,...t}=e;return(0,s.yg)(Thn,(0,p.A)({},whn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Chn.isMDXComponent=!0;const xhn={toc:[]},Ahn="wrapper";function vhn(e){let{components:n,...t}=e;return(0,s.yg)(Ahn,(0,p.A)({},xhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}vhn.isMDXComponent=!0;const Lhn={toc:[]},bhn="wrapper";function Nhn(e){let{components:n,...t}=e;return(0,s.yg)(bhn,(0,p.A)({},Lhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Nhn.isMDXComponent=!0;const khn={toc:[]},zhn="wrapper";function Phn(e){let{components:n,...t}=e;return(0,s.yg)(zhn,(0,p.A)({},khn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}Phn.isMDXComponent=!0;const Ihn={toc:[]},Rhn="wrapper";function Whn(e){let{components:n,...t}=e;return(0,s.yg)(Rhn,(0,p.A)({},Ihn,t,{components:n,mdxType:"MDXLayout"}))}Whn.isMDXComponent=!0;const Shn={toc:[]},Bhn="wrapper";function Ehn(e){let{components:n,...t}=e;return(0,s.yg)(Bhn,(0,p.A)({},Shn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Ehn.isMDXComponent=!0;const Ghn={toc:[]},Ohn="wrapper";function Uhn(e){let{components:n,...t}=e;return(0,s.yg)(Ohn,(0,p.A)({},Ghn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Uhn.isMDXComponent=!0;const Fhn={toc:[]},Vhn="wrapper";function qhn(e){let{components:n,...t}=e;return(0,s.yg)(Vhn,(0,p.A)({},Fhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}qhn.isMDXComponent=!0;const jhn={toc:[]},Hhn="wrapper";function Yhn(e){let{components:n,...t}=e;return(0,s.yg)(Hhn,(0,p.A)({},jhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Yhn.isMDXComponent=!0;const Qhn={toc:[]},$hn="wrapper";function Khn(e){let{components:n,...t}=e;return(0,s.yg)($hn,(0,p.A)({},Qhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}Khn.isMDXComponent=!0;const Jhn={toc:[]},Zhn="wrapper";function egn(e){let{components:n,...t}=e;return(0,s.yg)(Zhn,(0,p.A)({},Jhn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}egn.isMDXComponent=!0;const ngn={toc:[]},tgn="wrapper";function ogn(e){let{components:n,...t}=e;return(0,s.yg)(tgn,(0,p.A)({},ngn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}ogn.isMDXComponent=!0;const pgn={toc:[]},rgn="wrapper";function sgn(e){let{components:n,...t}=e;return(0,s.yg)(rgn,(0,p.A)({},pgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}sgn.isMDXComponent=!0;const cgn={toc:[]},agn="wrapper";function ign(e){let{components:n,...t}=e;return(0,s.yg)(agn,(0,p.A)({},cgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}ign.isMDXComponent=!0;const lgn={toc:[]},ugn="wrapper";function mgn(e){let{components:n,...t}=e;return(0,s.yg)(ugn,(0,p.A)({},lgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"true"))}mgn.isMDXComponent=!0;const ygn={toc:[]},dgn="wrapper";function hgn(e){let{components:n,...t}=e;return(0,s.yg)(dgn,(0,p.A)({},ygn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the image should be smoothed."))}hgn.isMDXComponent=!0;const ggn={toc:[]},fgn="wrapper";function Dgn(e){let{components:n,...t}=e;return(0,s.yg)(fgn,(0,p.A)({},ggn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Dgn.isMDXComponent=!0;const Mgn={toc:[]},Xgn="wrapper";function _gn(e){let{components:n,...t}=e;return(0,s.yg)(Xgn,(0,p.A)({},Mgn,t,{components:n,mdxType:"MDXLayout"}))}_gn.isMDXComponent=!0;const wgn={toc:[]},Tgn="wrapper";function Cgn(e){let{components:n,...t}=e;return(0,s.yg)(Tgn,(0,p.A)({},wgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Using a local image:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.yg)("p",null,"Loading an image from the internet:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}Cgn.isMDXComponent=!0;const xgn={toc:[]},Agn="wrapper";function vgn(e){let{components:n,...t}=e;return(0,s.yg)(Agn,(0,p.A)({},xgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The source of this image."))}vgn.isMDXComponent=!0;const Lgn={toc:[]},bgn="wrapper";function Ngn(e){let{components:n,...t}=e;return(0,s.yg)(bgn,(0,p.A)({},Lgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Ngn.isMDXComponent=!0;const kgn={toc:[]},zgn="wrapper";function Pgn(e){let{components:n,...t}=e;return(0,s.yg)(zgn,(0,p.A)({},kgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}Pgn.isMDXComponent=!0;const Ign={toc:[]},Rgn="wrapper";function Wgn(e){let{components:n,...t}=e;return(0,s.yg)(Rgn,(0,p.A)({},Ign,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Wgn.isMDXComponent=!0;const Sgn={toc:[]},Bgn="wrapper";function Egn(e){let{components:n,...t}=e;return(0,s.yg)(Bgn,(0,p.A)({},Sgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Egn.isMDXComponent=!0;const Ggn={toc:[]},Ogn="wrapper";function Ugn(e){let{components:n,...t}=e;return(0,s.yg)(Ogn,(0,p.A)({},Ggn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Ugn.isMDXComponent=!0;const Fgn={toc:[]},Vgn="wrapper";function qgn(e){let{components:n,...t}=e;return(0,s.yg)(Vgn,(0,p.A)({},Fgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}qgn.isMDXComponent=!0;const jgn={toc:[]},Hgn="wrapper";function Ygn(e){let{components:n,...t}=e;return(0,s.yg)(Hgn,(0,p.A)({},jgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Ygn.isMDXComponent=!0;const Qgn={toc:[]},$gn="wrapper";function Kgn(e){let{components:n,...t}=e;return(0,s.yg)($gn,(0,p.A)({},Qgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Kgn.isMDXComponent=!0;const Jgn={toc:[]},Zgn="wrapper";function efn(e){let{components:n,...t}=e;return(0,s.yg)(Zgn,(0,p.A)({},Jgn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}efn.isMDXComponent=!0;const nfn={toc:[]},tfn="wrapper";function ofn(e){let{components:n,...t}=e;return(0,s.yg)(tfn,(0,p.A)({},nfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}ofn.isMDXComponent=!0;const pfn={toc:[]},rfn="wrapper";function sfn(e){let{components:n,...t}=e;return(0,s.yg)(rfn,(0,p.A)({},pfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}sfn.isMDXComponent=!0;const cfn={toc:[]},afn="wrapper";function ifn(e){let{components:n,...t}=e;return(0,s.yg)(afn,(0,p.A)({},cfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}ifn.isMDXComponent=!0;const lfn={toc:[]},ufn="wrapper";function mfn(e){let{components:n,...t}=e;return(0,s.yg)(ufn,(0,p.A)({},lfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}mfn.isMDXComponent=!0;const yfn={toc:[]},dfn="wrapper";function hfn(e){let{components:n,...t}=e;return(0,s.yg)(dfn,(0,p.A)({},yfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}hfn.isMDXComponent=!0;const gfn={toc:[]},ffn="wrapper";function Dfn(e){let{components:n,...t}=e;return(0,s.yg)(ffn,(0,p.A)({},gfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}Dfn.isMDXComponent=!0;const Mfn={toc:[]},Xfn="wrapper";function _fn(e){let{components:n,...t}=e;return(0,s.yg)(Xfn,(0,p.A)({},Mfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}_fn.isMDXComponent=!0;const wfn={toc:[]},Tfn="wrapper";function Cfn(e){let{components:n,...t}=e;return(0,s.yg)(Tfn,(0,p.A)({},wfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Cfn.isMDXComponent=!0;const xfn={toc:[]},Afn="wrapper";function vfn(e){let{components:n,...t}=e;return(0,s.yg)(Afn,(0,p.A)({},xfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}vfn.isMDXComponent=!0;const Lfn={toc:[]},bfn="wrapper";function Nfn(e){let{components:n,...t}=e;return(0,s.yg)(bfn,(0,p.A)({},Lfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Nfn.isMDXComponent=!0;const kfn={toc:[]},zfn="wrapper";function Pfn(e){let{components:n,...t}=e;return(0,s.yg)(zfn,(0,p.A)({},kfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}Pfn.isMDXComponent=!0;const Ifn={toc:[]},Rfn="wrapper";function Wfn(e){let{components:n,...t}=e;return(0,s.yg)(Rfn,(0,p.A)({},Ifn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Wfn.isMDXComponent=!0;const Sfn={toc:[]},Bfn="wrapper";function Efn(e){let{components:n,...t}=e;return(0,s.yg)(Bfn,(0,p.A)({},Sfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Efn.isMDXComponent=!0;const Gfn={toc:[]},Ofn="wrapper";function Ufn(e){let{components:n,...t}=e;return(0,s.yg)(Ofn,(0,p.A)({},Gfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}Ufn.isMDXComponent=!0;const Ffn={toc:[]},Vfn="wrapper";function qfn(e){let{components:n,...t}=e;return(0,s.yg)(Vfn,(0,p.A)({},Ffn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}qfn.isMDXComponent=!0;const jfn={toc:[]},Hfn="wrapper";function Yfn(e){let{components:n,...t}=e;return(0,s.yg)(Hfn,(0,p.A)({},jfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Yfn.isMDXComponent=!0;const Qfn={toc:[]},$fn="wrapper";function Kfn(e){let{components:n,...t}=e;return(0,s.yg)($fn,(0,p.A)({},Qfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}Kfn.isMDXComponent=!0;const Jfn={toc:[]},Zfn="wrapper";function eDn(e){let{components:n,...t}=e;return(0,s.yg)(Zfn,(0,p.A)({},Jfn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}eDn.isMDXComponent=!0;const nDn={toc:[]},tDn="wrapper";function oDn(e){let{components:n,...t}=e;return(0,s.yg)(tDn,(0,p.A)({},nDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}oDn.isMDXComponent=!0;const pDn={toc:[]},rDn="wrapper";function sDn(e){let{components:n,...t}=e;return(0,s.yg)(rDn,(0,p.A)({},pDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}sDn.isMDXComponent=!0;const cDn={toc:[]},aDn="wrapper";function iDn(e){let{components:n,...t}=e;return(0,s.yg)(aDn,(0,p.A)({},cDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}iDn.isMDXComponent=!0;const lDn={toc:[]},uDn="wrapper";function mDn(e){let{components:n,...t}=e;return(0,s.yg)(uDn,(0,p.A)({},lDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}mDn.isMDXComponent=!0;const yDn={toc:[]},dDn="wrapper";function hDn(e){let{components:n,...t}=e;return(0,s.yg)(dDn,(0,p.A)({},yDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}hDn.isMDXComponent=!0;const gDn={toc:[]},fDn="wrapper";function DDn(e){let{components:n,...t}=e;return(0,s.yg)(fDn,(0,p.A)({},gDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}DDn.isMDXComponent=!0;const MDn={toc:[]},XDn="wrapper";function _Dn(e){let{components:n,...t}=e;return(0,s.yg)(XDn,(0,p.A)({},MDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}_Dn.isMDXComponent=!0;const wDn={toc:[]},TDn="wrapper";function CDn(e){let{components:n,...t}=e;return(0,s.yg)(TDn,(0,p.A)({},wDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}CDn.isMDXComponent=!0;const xDn={toc:[]},ADn="wrapper";function vDn(e){let{components:n,...t}=e;return(0,s.yg)(ADn,(0,p.A)({},xDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}vDn.isMDXComponent=!0;const LDn={toc:[]},bDn="wrapper";function NDn(e){let{components:n,...t}=e;return(0,s.yg)(bDn,(0,p.A)({},LDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}NDn.isMDXComponent=!0;const kDn={toc:[]},zDn="wrapper";function PDn(e){let{components:n,...t}=e;return(0,s.yg)(zDn,(0,p.A)({},kDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}PDn.isMDXComponent=!0;const IDn={toc:[]},RDn="wrapper";function WDn(e){let{components:n,...t}=e;return(0,s.yg)(RDn,(0,p.A)({},IDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}WDn.isMDXComponent=!0;const SDn={toc:[]},BDn="wrapper";function EDn(e){let{components:n,...t}=e;return(0,s.yg)(BDn,(0,p.A)({},SDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}EDn.isMDXComponent=!0;const GDn={toc:[]},ODn="wrapper";function UDn(e){let{components:n,...t}=e;return(0,s.yg)(ODn,(0,p.A)({},GDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}UDn.isMDXComponent=!0;const FDn={toc:[]},VDn="wrapper";function qDn(e){let{components:n,...t}=e;return(0,s.yg)(VDn,(0,p.A)({},FDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}qDn.isMDXComponent=!0;const jDn={toc:[]},HDn="wrapper";function YDn(e){let{components:n,...t}=e;return(0,s.yg)(HDn,(0,p.A)({},jDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}YDn.isMDXComponent=!0;const QDn={toc:[]},$Dn="wrapper";function KDn(e){let{components:n,...t}=e;return(0,s.yg)($Dn,(0,p.A)({},QDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}KDn.isMDXComponent=!0;const JDn={toc:[]},ZDn="wrapper";function eMn(e){let{components:n,...t}=e;return(0,s.yg)(ZDn,(0,p.A)({},JDn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}eMn.isMDXComponent=!0;const nMn={toc:[]},tMn="wrapper";function oMn(e){let{components:n,...t}=e;return(0,s.yg)(tMn,(0,p.A)({},nMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}oMn.isMDXComponent=!0;const pMn={toc:[]},rMn="wrapper";function sMn(e){let{components:n,...t}=e;return(0,s.yg)(rMn,(0,p.A)({},pMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}sMn.isMDXComponent=!0;const cMn={toc:[]},aMn="wrapper";function iMn(e){let{components:n,...t}=e;return(0,s.yg)(aMn,(0,p.A)({},cMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}iMn.isMDXComponent=!0;const lMn={toc:[]},uMn="wrapper";function mMn(e){let{components:n,...t}=e;return(0,s.yg)(uMn,(0,p.A)({},lMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}mMn.isMDXComponent=!0;const yMn={toc:[]},dMn="wrapper";function hMn(e){let{components:n,...t}=e;return(0,s.yg)(dMn,(0,p.A)({},yMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}hMn.isMDXComponent=!0;const gMn={toc:[]},fMn="wrapper";function DMn(e){let{components:n,...t}=e;return(0,s.yg)(fMn,(0,p.A)({},gMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}DMn.isMDXComponent=!0;const MMn={toc:[]},XMn="wrapper";function _Mn(e){let{components:n,...t}=e;return(0,s.yg)(XMn,(0,p.A)({},MMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}_Mn.isMDXComponent=!0;const wMn={toc:[]},TMn="wrapper";function CMn(e){let{components:n,...t}=e;return(0,s.yg)(TMn,(0,p.A)({},wMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}CMn.isMDXComponent=!0;const xMn={toc:[]},AMn="wrapper";function vMn(e){let{components:n,...t}=e;return(0,s.yg)(AMn,(0,p.A)({},xMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}vMn.isMDXComponent=!0;const LMn={toc:[]},bMn="wrapper";function NMn(e){let{components:n,...t}=e;return(0,s.yg)(bMn,(0,p.A)({},LMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}NMn.isMDXComponent=!0;const kMn={toc:[]},zMn="wrapper";function PMn(e){let{components:n,...t}=e;return(0,s.yg)(zMn,(0,p.A)({},kMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}PMn.isMDXComponent=!0;const IMn={toc:[]},RMn="wrapper";function WMn(e){let{components:n,...t}=e;return(0,s.yg)(RMn,(0,p.A)({},IMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}WMn.isMDXComponent=!0;const SMn={toc:[]},BMn="wrapper";function EMn(e){let{components:n,...t}=e;return(0,s.yg)(BMn,(0,p.A)({},SMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}EMn.isMDXComponent=!0;const GMn={toc:[]},OMn="wrapper";function UMn(e){let{components:n,...t}=e;return(0,s.yg)(OMn,(0,p.A)({},GMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}UMn.isMDXComponent=!0;const FMn={toc:[]},VMn="wrapper";function qMn(e){let{components:n,...t}=e;return(0,s.yg)(VMn,(0,p.A)({},FMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}qMn.isMDXComponent=!0;const jMn={toc:[]},HMn="wrapper";function YMn(e){let{components:n,...t}=e;return(0,s.yg)(HMn,(0,p.A)({},jMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}YMn.isMDXComponent=!0;const QMn={toc:[]},$Mn="wrapper";function KMn(e){let{components:n,...t}=e;return(0,s.yg)($Mn,(0,p.A)({},QMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}KMn.isMDXComponent=!0;const JMn={toc:[]},ZMn="wrapper";function eXn(e){let{components:n,...t}=e;return(0,s.yg)(ZMn,(0,p.A)({},JMn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}eXn.isMDXComponent=!0;const nXn={toc:[]},tXn="wrapper";function oXn(e){let{components:n,...t}=e;return(0,s.yg)(tXn,(0,p.A)({},nXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}oXn.isMDXComponent=!0;const pXn={toc:[]},rXn="wrapper";function sXn(e){let{components:n,...t}=e;return(0,s.yg)(rXn,(0,p.A)({},pXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}sXn.isMDXComponent=!0;const cXn={toc:[]},aXn="wrapper";function iXn(e){let{components:n,...t}=e;return(0,s.yg)(aXn,(0,p.A)({},cXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}iXn.isMDXComponent=!0;const lXn={toc:[]},uXn="wrapper";function mXn(e){let{components:n,...t}=e;return(0,s.yg)(uXn,(0,p.A)({},lXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}mXn.isMDXComponent=!0;const yXn={toc:[]},dXn="wrapper";function hXn(e){let{components:n,...t}=e;return(0,s.yg)(dXn,(0,p.A)({},yXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}hXn.isMDXComponent=!0;const gXn={toc:[]},fXn="wrapper";function DXn(e){let{components:n,...t}=e;return(0,s.yg)(fXn,(0,p.A)({},gXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}DXn.isMDXComponent=!0;const MXn={toc:[]},XXn="wrapper";function _Xn(e){let{components:n,...t}=e;return(0,s.yg)(XXn,(0,p.A)({},MXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}_Xn.isMDXComponent=!0;const wXn={toc:[]},TXn="wrapper";function CXn(e){let{components:n,...t}=e;return(0,s.yg)(TXn,(0,p.A)({},wXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}CXn.isMDXComponent=!0;const xXn={toc:[]},AXn="wrapper";function vXn(e){let{components:n,...t}=e;return(0,s.yg)(AXn,(0,p.A)({},xXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}vXn.isMDXComponent=!0;const LXn={toc:[]},bXn="wrapper";function NXn(e){let{components:n,...t}=e;return(0,s.yg)(bXn,(0,p.A)({},LXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get color of the image at the given position."))}NXn.isMDXComponent=!0;const kXn={toc:[]},zXn="wrapper";function PXn(e){let{components:n,...t}=e;return(0,s.yg)(zXn,(0,p.A)({},kXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position in local space at which to sample the color."))}PXn.isMDXComponent=!0;const IXn={toc:[]},RXn="wrapper";function WXn(e){let{components:n,...t}=e;return(0,s.yg)(RXn,(0,p.A)({},IXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get color of the image at the given pixel."))}WXn.isMDXComponent=!0;const SXn={toc:[]},BXn="wrapper";function EXn(e){let{components:n,...t}=e;return(0,s.yg)(BXn,(0,p.A)({},SXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The pixel's position."))}EXn.isMDXComponent=!0;const GXn={toc:[]},OXn="wrapper";function UXn(e){let{components:n,...t}=e;return(0,s.yg)(OXn,(0,p.A)({},GXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"overrides ",(0,s.yg)("inlineCode",{parentName:"p"},"Image.src")," getter"))}UXn.isMDXComponent=!0;const FXn={toc:[]},VXn="wrapper";function qXn(e){let{components:n,...t}=e;return(0,s.yg)(VXn,(0,p.A)({},FXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}qXn.isMDXComponent=!0;const jXn={toc:[]},HXn="wrapper";function YXn(e){let{components:n,...t}=e;return(0,s.yg)(HXn,(0,p.A)({},jXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}YXn.isMDXComponent=!0;const QXn={toc:[]},$Xn="wrapper";function KXn(e){let{components:n,...t}=e;return(0,s.yg)($Xn,(0,p.A)({},QXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}KXn.isMDXComponent=!0;const JXn={toc:[]},ZXn="wrapper";function e_n(e){let{components:n,...t}=e;return(0,s.yg)(ZXn,(0,p.A)({},JXn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}e_n.isMDXComponent=!0;const n_n={toc:[]},t_n="wrapper";function o_n(e){let{components:n,...t}=e;return(0,s.yg)(t_n,(0,p.A)({},n_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}o_n.isMDXComponent=!0;const p_n={toc:[]},r_n="wrapper";function s_n(e){let{components:n,...t}=e;return(0,s.yg)(r_n,(0,p.A)({},p_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}s_n.isMDXComponent=!0;const c_n={toc:[]},a_n="wrapper";function i_n(e){let{components:n,...t}=e;return(0,s.yg)(a_n,(0,p.A)({},c_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}i_n.isMDXComponent=!0;const l_n={toc:[]},u_n="wrapper";function m_n(e){let{components:n,...t}=e;return(0,s.yg)(u_n,(0,p.A)({},l_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}m_n.isMDXComponent=!0;const y_n={toc:[]},d_n="wrapper";function h_n(e){let{components:n,...t}=e;return(0,s.yg)(d_n,(0,p.A)({},y_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}h_n.isMDXComponent=!0;const g_n={toc:[]},f_n="wrapper";function D_n(e){let{components:n,...t}=e;return(0,s.yg)(f_n,(0,p.A)({},g_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}D_n.isMDXComponent=!0;const M_n={toc:[]},X_n="wrapper";function __n(e){let{components:n,...t}=e;return(0,s.yg)(X_n,(0,p.A)({},M_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}__n.isMDXComponent=!0;const w_n={toc:[]},T_n="wrapper";function C_n(e){let{components:n,...t}=e;return(0,s.yg)(T_n,(0,p.A)({},w_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}C_n.isMDXComponent=!0;const x_n={toc:[]},A_n="wrapper";function v_n(e){let{components:n,...t}=e;return(0,s.yg)(A_n,(0,p.A)({},x_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}v_n.isMDXComponent=!0;const L_n={toc:[]},b_n="wrapper";function N_n(e){let{components:n,...t}=e;return(0,s.yg)(b_n,(0,p.A)({},L_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}N_n.isMDXComponent=!0;const k_n={toc:[]},z_n="wrapper";function P_n(e){let{components:n,...t}=e;return(0,s.yg)(z_n,(0,p.A)({},k_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}P_n.isMDXComponent=!0;const I_n={toc:[]},R_n="wrapper";function W_n(e){let{components:n,...t}=e;return(0,s.yg)(R_n,(0,p.A)({},I_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}W_n.isMDXComponent=!0;const S_n={toc:[]},B_n="wrapper";function E_n(e){let{components:n,...t}=e;return(0,s.yg)(B_n,(0,p.A)({},S_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}E_n.isMDXComponent=!0;const G_n={toc:[]},O_n="wrapper";function U_n(e){let{components:n,...t}=e;return(0,s.yg)(O_n,(0,p.A)({},G_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}U_n.isMDXComponent=!0;const F_n={toc:[]},V_n="wrapper";function q_n(e){let{components:n,...t}=e;return(0,s.yg)(V_n,(0,p.A)({},F_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}q_n.isMDXComponent=!0;const j_n={toc:[]},H_n="wrapper";function Y_n(e){let{components:n,...t}=e;return(0,s.yg)(H_n,(0,p.A)({},j_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}Y_n.isMDXComponent=!0;const Q_n={toc:[]},$_n="wrapper";function K_n(e){let{components:n,...t}=e;return(0,s.yg)($_n,(0,p.A)({},Q_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}K_n.isMDXComponent=!0;const J_n={toc:[]},Z_n="wrapper";function ewn(e){let{components:n,...t}=e;return(0,s.yg)(Z_n,(0,p.A)({},J_n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}ewn.isMDXComponent=!0;const nwn={toc:[]},twn="wrapper";function own(e){let{components:n,...t}=e;return(0,s.yg)(twn,(0,p.A)({},nwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}own.isMDXComponent=!0;const pwn={toc:[]},rwn="wrapper";function swn(e){let{components:n,...t}=e;return(0,s.yg)(rwn,(0,p.A)({},pwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}swn.isMDXComponent=!0;const cwn={toc:[]},awn="wrapper";function iwn(e){let{components:n,...t}=e;return(0,s.yg)(awn,(0,p.A)({},cwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}iwn.isMDXComponent=!0;const lwn={toc:[]},uwn="wrapper";function mwn(e){let{components:n,...t}=e;return(0,s.yg)(uwn,(0,p.A)({},lwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}mwn.isMDXComponent=!0;const ywn={toc:[]},dwn="wrapper";function hwn(e){let{components:n,...t}=e;return(0,s.yg)(dwn,(0,p.A)({},ywn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}hwn.isMDXComponent=!0;const gwn={toc:[]},fwn="wrapper";function Dwn(e){let{components:n,...t}=e;return(0,s.yg)(fwn,(0,p.A)({},gwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Dwn.isMDXComponent=!0;const Mwn={toc:[]},Xwn="wrapper";function _wn(e){let{components:n,...t}=e;return(0,s.yg)(Xwn,(0,p.A)({},Mwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}_wn.isMDXComponent=!0;const wwn={toc:[]},Twn="wrapper";function Cwn(e){let{components:n,...t}=e;return(0,s.yg)(Twn,(0,p.A)({},wwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}Cwn.isMDXComponent=!0;const xwn={toc:[]},Awn="wrapper";function vwn(e){let{components:n,...t}=e;return(0,s.yg)(Awn,(0,p.A)({},xwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}vwn.isMDXComponent=!0;const Lwn={toc:[]},bwn="wrapper";function Nwn(e){let{components:n,...t}=e;return(0,s.yg)(bwn,(0,p.A)({},Lwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}Nwn.isMDXComponent=!0;const kwn={toc:[]},zwn="wrapper";function Pwn(e){let{components:n,...t}=e;return(0,s.yg)(zwn,(0,p.A)({},kwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Pwn.isMDXComponent=!0;const Iwn={toc:[]},Rwn="wrapper";function Wwn(e){let{components:n,...t}=e;return(0,s.yg)(Rwn,(0,p.A)({},Iwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}Wwn.isMDXComponent=!0;const Swn={toc:[]},Bwn="wrapper";function Ewn(e){let{components:n,...t}=e;return(0,s.yg)(Bwn,(0,p.A)({},Swn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}Ewn.isMDXComponent=!0;const Gwn={toc:[]},Own="wrapper";function Uwn(e){let{components:n,...t}=e;return(0,s.yg)(Own,(0,p.A)({},Gwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Uwn.isMDXComponent=!0;const Fwn={toc:[]},Vwn="wrapper";function qwn(e){let{components:n,...t}=e;return(0,s.yg)(Vwn,(0,p.A)({},Fwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}qwn.isMDXComponent=!0;const jwn={toc:[]},Hwn="wrapper";function Ywn(e){let{components:n,...t}=e;return(0,s.yg)(Hwn,(0,p.A)({},jwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Ywn.isMDXComponent=!0;const Qwn={toc:[]},$wn="wrapper";function Kwn(e){let{components:n,...t}=e;return(0,s.yg)($wn,(0,p.A)({},Qwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}Kwn.isMDXComponent=!0;const Jwn={toc:[]},Zwn="wrapper";function eTn(e){let{components:n,...t}=e;return(0,s.yg)(Zwn,(0,p.A)({},Jwn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}eTn.isMDXComponent=!0;const nTn={toc:[]},tTn="wrapper";function oTn(e){let{components:n,...t}=e;return(0,s.yg)(tTn,(0,p.A)({},nTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}oTn.isMDXComponent=!0;const pTn={toc:[]},rTn="wrapper";function sTn(e){let{components:n,...t}=e;return(0,s.yg)(rTn,(0,p.A)({},pTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}sTn.isMDXComponent=!0;const cTn={toc:[]},aTn="wrapper";function iTn(e){let{components:n,...t}=e;return(0,s.yg)(aTn,(0,p.A)({},cTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The natural size of this image."))}iTn.isMDXComponent=!0;const lTn={toc:[]},uTn="wrapper";function mTn(e){let{components:n,...t}=e;return(0,s.yg)(uTn,(0,p.A)({},lTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}mTn.isMDXComponent=!0;const yTn={toc:[]},dTn="wrapper";function hTn(e){let{components:n,...t}=e;return(0,s.yg)(dTn,(0,p.A)({},yTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}hTn.isMDXComponent=!0;const gTn={toc:[]},fTn="wrapper";function DTn(e){let{components:n,...t}=e;return(0,s.yg)(fTn,(0,p.A)({},gTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}DTn.isMDXComponent=!0;const MTn={toc:[]},XTn="wrapper";function _Tn(e){let{components:n,...t}=e;return(0,s.yg)(XTn,(0,p.A)({},MTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}_Tn.isMDXComponent=!0;const wTn={toc:[]},TTn="wrapper";function CTn(e){let{components:n,...t}=e;return(0,s.yg)(TTn,(0,p.A)({},wTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}CTn.isMDXComponent=!0;const xTn={toc:[]},ATn="wrapper";function vTn(e){let{components:n,...t}=e;return(0,s.yg)(ATn,(0,p.A)({},xTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}vTn.isMDXComponent=!0;const LTn={toc:[]},bTn="wrapper";function NTn(e){let{components:n,...t}=e;return(0,s.yg)(bTn,(0,p.A)({},LTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}NTn.isMDXComponent=!0;const kTn={toc:[]},zTn="wrapper";function PTn(e){let{components:n,...t}=e;return(0,s.yg)(zTn,(0,p.A)({},kTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}PTn.isMDXComponent=!0;const ITn={toc:[]},RTn="wrapper";function WTn(e){let{components:n,...t}=e;return(0,s.yg)(RTn,(0,p.A)({},ITn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}WTn.isMDXComponent=!0;const STn={toc:[]},BTn="wrapper";function ETn(e){let{components:n,...t}=e;return(0,s.yg)(BTn,(0,p.A)({},STn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}ETn.isMDXComponent=!0;const GTn={toc:[]},OTn="wrapper";function UTn(e){let{components:n,...t}=e;return(0,s.yg)(OTn,(0,p.A)({},GTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}UTn.isMDXComponent=!0;const FTn={toc:[]},VTn="wrapper";function qTn(e){let{components:n,...t}=e;return(0,s.yg)(VTn,(0,p.A)({},FTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}qTn.isMDXComponent=!0;const jTn={toc:[]},HTn="wrapper";function YTn(e){let{components:n,...t}=e;return(0,s.yg)(HTn,(0,p.A)({},jTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}YTn.isMDXComponent=!0;const QTn={toc:[]},$Tn="wrapper";function KTn(e){let{components:n,...t}=e;return(0,s.yg)($Tn,(0,p.A)({},QTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}KTn.isMDXComponent=!0;const JTn={toc:[]},ZTn="wrapper";function eCn(e){let{components:n,...t}=e;return(0,s.yg)(ZTn,(0,p.A)({},JTn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}eCn.isMDXComponent=!0;const nCn={toc:[]},tCn="wrapper";function oCn(e){let{components:n,...t}=e;return(0,s.yg)(tCn,(0,p.A)({},nCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}oCn.isMDXComponent=!0;const pCn={toc:[]},rCn="wrapper";function sCn(e){let{components:n,...t}=e;return(0,s.yg)(rCn,(0,p.A)({},pCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}sCn.isMDXComponent=!0;const cCn={toc:[]},aCn="wrapper";function iCn(e){let{components:n,...t}=e;return(0,s.yg)(aCn,(0,p.A)({},cCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}iCn.isMDXComponent=!0;const lCn={toc:[]},uCn="wrapper";function mCn(e){let{components:n,...t}=e;return(0,s.yg)(uCn,(0,p.A)({},lCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}mCn.isMDXComponent=!0;const yCn={toc:[]},dCn="wrapper";function hCn(e){let{components:n,...t}=e;return(0,s.yg)(dCn,(0,p.A)({},yCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}hCn.isMDXComponent=!0;const gCn={toc:[]},fCn="wrapper";function DCn(e){let{components:n,...t}=e;return(0,s.yg)(fCn,(0,p.A)({},gCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}DCn.isMDXComponent=!0;const MCn={toc:[]},XCn="wrapper";function _Cn(e){let{components:n,...t}=e;return(0,s.yg)(XCn,(0,p.A)({},MCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}_Cn.isMDXComponent=!0;const wCn={toc:[]},TCn="wrapper";function CCn(e){let{components:n,...t}=e;return(0,s.yg)(TCn,(0,p.A)({},wCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}CCn.isMDXComponent=!0;const xCn={toc:[]},ACn="wrapper";function vCn(e){let{components:n,...t}=e;return(0,s.yg)(ACn,(0,p.A)({},xCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}vCn.isMDXComponent=!0;const LCn={toc:[]},bCn="wrapper";function NCn(e){let{components:n,...t}=e;return(0,s.yg)(bCn,(0,p.A)({},LCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}NCn.isMDXComponent=!0;const kCn={toc:[]},zCn="wrapper";function PCn(e){let{components:n,...t}=e;return(0,s.yg)(zCn,(0,p.A)({},kCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}PCn.isMDXComponent=!0;const ICn={toc:[]},RCn="wrapper";function WCn(e){let{components:n,...t}=e;return(0,s.yg)(RCn,(0,p.A)({},ICn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}WCn.isMDXComponent=!0;const SCn={toc:[]},BCn="wrapper";function ECn(e){let{components:n,...t}=e;return(0,s.yg)(BCn,(0,p.A)({},SCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}ECn.isMDXComponent=!0;const GCn={toc:[]},OCn="wrapper";function UCn(e){let{components:n,...t}=e;return(0,s.yg)(OCn,(0,p.A)({},GCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}UCn.isMDXComponent=!0;const FCn={toc:[]},VCn="wrapper";function qCn(e){let{components:n,...t}=e;return(0,s.yg)(VCn,(0,p.A)({},FCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}qCn.isMDXComponent=!0;const jCn={toc:[]},HCn="wrapper";function YCn(e){let{components:n,...t}=e;return(0,s.yg)(HCn,(0,p.A)({},jCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}YCn.isMDXComponent=!0;const QCn={toc:[]},$Cn="wrapper";function KCn(e){let{components:n,...t}=e;return(0,s.yg)($Cn,(0,p.A)({},QCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}KCn.isMDXComponent=!0;const JCn={toc:[]},ZCn="wrapper";function exn(e){let{components:n,...t}=e;return(0,s.yg)(ZCn,(0,p.A)({},JCn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}exn.isMDXComponent=!0;const nxn={toc:[]},txn="wrapper";function oxn(e){let{components:n,...t}=e;return(0,s.yg)(txn,(0,p.A)({},nxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}oxn.isMDXComponent=!0;const pxn={toc:[]},rxn="wrapper";function sxn(e){let{components:n,...t}=e;return(0,s.yg)(rxn,(0,p.A)({},pxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}sxn.isMDXComponent=!0;const cxn={toc:[]},axn="wrapper";function ixn(e){let{components:n,...t}=e;return(0,s.yg)(axn,(0,p.A)({},cxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}ixn.isMDXComponent=!0;const lxn={toc:[]},uxn="wrapper";function mxn(e){let{components:n,...t}=e;return(0,s.yg)(uxn,(0,p.A)({},lxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}mxn.isMDXComponent=!0;const yxn={toc:[]},dxn="wrapper";function hxn(e){let{components:n,...t}=e;return(0,s.yg)(dxn,(0,p.A)({},yxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}hxn.isMDXComponent=!0;const gxn={toc:[]},fxn="wrapper";function Dxn(e){let{components:n,...t}=e;return(0,s.yg)(fxn,(0,p.A)({},gxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}Dxn.isMDXComponent=!0;const Mxn={toc:[]},Xxn="wrapper";function _xn(e){let{components:n,...t}=e;return(0,s.yg)(Xxn,(0,p.A)({},Mxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"overrides ",(0,s.yg)("inlineCode",{parentName:"p"},"Image.src")," setter to warn the user that the value\nis not used"))}_xn.isMDXComponent=!0;const wxn={toc:[]},Txn="wrapper";function Cxn(e){let{components:n,...t}=e;return(0,s.yg)(Txn,(0,p.A)({},wxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Cxn.isMDXComponent=!0;const xxn={toc:[]},Axn="wrapper";function vxn(e){let{components:n,...t}=e;return(0,s.yg)(Axn,(0,p.A)({},xxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}vxn.isMDXComponent=!0;const Lxn={toc:[]},bxn="wrapper";function Nxn(e){let{components:n,...t}=e;return(0,s.yg)(bxn,(0,p.A)({},Lxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Nxn.isMDXComponent=!0;const kxn={toc:[]},zxn="wrapper";function Pxn(e){let{components:n,...t}=e;return(0,s.yg)(zxn,(0,p.A)({},kxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Pxn.isMDXComponent=!0;const Ixn={toc:[]},Rxn="wrapper";function Wxn(e){let{components:n,...t}=e;return(0,s.yg)(Rxn,(0,p.A)({},Ixn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Wxn.isMDXComponent=!0;const Sxn={toc:[]},Bxn="wrapper";function Exn(e){let{components:n,...t}=e;return(0,s.yg)(Bxn,(0,p.A)({},Sxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Exn.isMDXComponent=!0;const Gxn={toc:[]},Oxn="wrapper";function Uxn(e){let{components:n,...t}=e;return(0,s.yg)(Oxn,(0,p.A)({},Gxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Address to Iconify API for the requested Icon."))}Uxn.isMDXComponent=!0;const Fxn={toc:[]},Vxn="wrapper";function qxn(e){let{components:n,...t}=e;return(0,s.yg)(Vxn,(0,p.A)({},Fxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create the URL that will be used as the Image source"))}qxn.isMDXComponent=!0;const jxn={toc:[]},Hxn="wrapper";function Yxn(e){let{components:n,...t}=e;return(0,s.yg)(Hxn,(0,p.A)({},jxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Yxn.isMDXComponent=!0;const Qxn={toc:[]},$xn="wrapper";function Kxn(e){let{components:n,...t}=e;return(0,s.yg)($xn,(0,p.A)({},Qxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Kxn.isMDXComponent=!0;const Jxn={toc:[]},Zxn="wrapper";function eAn(e){let{components:n,...t}=e;return(0,s.yg)(Zxn,(0,p.A)({},Jxn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}eAn.isMDXComponent=!0;const nAn={toc:[]},tAn="wrapper";function oAn(e){let{components:n,...t}=e;return(0,s.yg)(tAn,(0,p.A)({},nAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Icon#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}oAn.isMDXComponent=!0;const pAn={toc:[]},rAn="wrapper";function sAn(e){let{components:n,...t}=e;return(0,s.yg)(rAn,(0,p.A)({},pAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}sAn.isMDXComponent=!0;const cAn={toc:[]},aAn="wrapper";function iAn(e){let{components:n,...t}=e;return(0,s.yg)(aAn,(0,p.A)({},cAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}iAn.isMDXComponent=!0;const lAn={toc:[]},uAn="wrapper";function mAn(e){let{components:n,...t}=e;return(0,s.yg)(uAn,(0,p.A)({},lAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}mAn.isMDXComponent=!0;const yAn={toc:[]},dAn="wrapper";function hAn(e){let{components:n,...t}=e;return(0,s.yg)(dAn,(0,p.A)({},yAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}hAn.isMDXComponent=!0;const gAn={toc:[]},fAn="wrapper";function DAn(e){let{components:n,...t}=e;return(0,s.yg)(fAn,(0,p.A)({},gAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}DAn.isMDXComponent=!0;const MAn={toc:[]},XAn="wrapper";function _An(e){let{components:n,...t}=e;return(0,s.yg)(XAn,(0,p.A)({},MAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}_An.isMDXComponent=!0;const wAn={toc:[]},TAn="wrapper";function CAn(e){let{components:n,...t}=e;return(0,s.yg)(TAn,(0,p.A)({},wAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@revideo/2d';\nimport {all, waitFor} from '@revideo/core';\nimport {createRef} from '@revideo/core';\nimport {makeScene2D} from '@revideo/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  yield view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}CAn.isMDXComponent=!0;const xAn={toc:[]},AAn="wrapper";function vAn(e){let{components:n,...t}=e;return(0,s.yg)(AAn,(0,p.A)({},xAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for displaying images."))}vAn.isMDXComponent=!0;const LAn={toc:[]},bAn="wrapper";function NAn(e){let{components:n,...t}=e;return(0,s.yg)(bAn,(0,p.A)({},LAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}NAn.isMDXComponent=!0;const kAn={toc:[]},zAn="wrapper";function PAn(e){let{components:n,...t}=e;return(0,s.yg)(zAn,(0,p.A)({},kAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}PAn.isMDXComponent=!0;const IAn={toc:[]},RAn="wrapper";function WAn(e){let{components:n,...t}=e;return(0,s.yg)(RAn,(0,p.A)({},IAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}WAn.isMDXComponent=!0;const SAn={toc:[]},BAn="wrapper";function EAn(e){let{components:n,...t}=e;return(0,s.yg)(BAn,(0,p.A)({},SAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}EAn.isMDXComponent=!0;const GAn={toc:[]},OAn="wrapper";function UAn(e){let{components:n,...t}=e;return(0,s.yg)(OAn,(0,p.A)({},GAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}UAn.isMDXComponent=!0;const FAn={toc:[]},VAn="wrapper";function qAn(e){let{components:n,...t}=e;return(0,s.yg)(VAn,(0,p.A)({},FAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}qAn.isMDXComponent=!0;const jAn={toc:[]},HAn="wrapper";function YAn(e){let{components:n,...t}=e;return(0,s.yg)(HAn,(0,p.A)({},jAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}YAn.isMDXComponent=!0;const QAn={toc:[]},$An="wrapper";function KAn(e){let{components:n,...t}=e;return(0,s.yg)($An,(0,p.A)({},QAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this image."))}KAn.isMDXComponent=!0;const JAn={toc:[]},ZAn="wrapper";function evn(e){let{components:n,...t}=e;return(0,s.yg)(ZAn,(0,p.A)({},JAn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}evn.isMDXComponent=!0;const nvn={toc:[]},tvn="wrapper";function ovn(e){let{components:n,...t}=e;return(0,s.yg)(tvn,(0,p.A)({},nvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}ovn.isMDXComponent=!0;const pvn={toc:[]},rvn="wrapper";function svn(e){let{components:n,...t}=e;return(0,s.yg)(rvn,(0,p.A)({},pvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}svn.isMDXComponent=!0;const cvn={toc:[]},avn="wrapper";function ivn(e){let{components:n,...t}=e;return(0,s.yg)(avn,(0,p.A)({},cvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}ivn.isMDXComponent=!0;const lvn={toc:[]},uvn="wrapper";function mvn(e){let{components:n,...t}=e;return(0,s.yg)(uvn,(0,p.A)({},lvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}mvn.isMDXComponent=!0;const yvn={toc:[]},dvn="wrapper";function hvn(e){let{components:n,...t}=e;return(0,s.yg)(dvn,(0,p.A)({},yvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}hvn.isMDXComponent=!0;const gvn={toc:[]},fvn="wrapper";function Dvn(e){let{components:n,...t}=e;return(0,s.yg)(fvn,(0,p.A)({},gvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Dvn.isMDXComponent=!0;const Mvn={toc:[]},Xvn="wrapper";function _vn(e){let{components:n,...t}=e;return(0,s.yg)(Xvn,(0,p.A)({},Mvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}_vn.isMDXComponent=!0;const wvn={toc:[]},Tvn="wrapper";function Cvn(e){let{components:n,...t}=e;return(0,s.yg)(Tvn,(0,p.A)({},wvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Cvn.isMDXComponent=!0;const xvn={toc:[]},Avn="wrapper";function vvn(e){let{components:n,...t}=e;return(0,s.yg)(Avn,(0,p.A)({},xvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}vvn.isMDXComponent=!0;const Lvn={toc:[]},bvn="wrapper";function Nvn(e){let{components:n,...t}=e;return(0,s.yg)(bvn,(0,p.A)({},Lvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}Nvn.isMDXComponent=!0;const kvn={toc:[]},zvn="wrapper";function Pvn(e){let{components:n,...t}=e;return(0,s.yg)(zvn,(0,p.A)({},kvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}Pvn.isMDXComponent=!0;const Ivn={toc:[]},Rvn="wrapper";function Wvn(e){let{components:n,...t}=e;return(0,s.yg)(Rvn,(0,p.A)({},Ivn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Wvn.isMDXComponent=!0;const Svn={toc:[]},Bvn="wrapper";function Evn(e){let{components:n,...t}=e;return(0,s.yg)(Bvn,(0,p.A)({},Svn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Evn.isMDXComponent=!0;const Gvn={toc:[]},Ovn="wrapper";function Uvn(e){let{components:n,...t}=e;return(0,s.yg)(Ovn,(0,p.A)({},Gvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Uvn.isMDXComponent=!0;const Fvn={toc:[]},Vvn="wrapper";function qvn(e){let{components:n,...t}=e;return(0,s.yg)(Vvn,(0,p.A)({},Fvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}qvn.isMDXComponent=!0;const jvn={toc:[]},Hvn="wrapper";function Yvn(e){let{components:n,...t}=e;return(0,s.yg)(Hvn,(0,p.A)({},jvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}Yvn.isMDXComponent=!0;const Qvn={toc:[]},$vn="wrapper";function Kvn(e){let{components:n,...t}=e;return(0,s.yg)($vn,(0,p.A)({},Qvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Kvn.isMDXComponent=!0;const Jvn={toc:[]},Zvn="wrapper";function eLn(e){let{components:n,...t}=e;return(0,s.yg)(Zvn,(0,p.A)({},Jvn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}eLn.isMDXComponent=!0;const nLn={toc:[]},tLn="wrapper";function oLn(e){let{components:n,...t}=e;return(0,s.yg)(tLn,(0,p.A)({},nLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}oLn.isMDXComponent=!0;const pLn={toc:[]},rLn="wrapper";function sLn(e){let{components:n,...t}=e;return(0,s.yg)(rLn,(0,p.A)({},pLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}sLn.isMDXComponent=!0;const cLn={toc:[]},aLn="wrapper";function iLn(e){let{components:n,...t}=e;return(0,s.yg)(aLn,(0,p.A)({},cLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}iLn.isMDXComponent=!0;const lLn={toc:[]},uLn="wrapper";function mLn(e){let{components:n,...t}=e;return(0,s.yg)(uLn,(0,p.A)({},lLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}mLn.isMDXComponent=!0;const yLn={toc:[]},dLn="wrapper";function hLn(e){let{components:n,...t}=e;return(0,s.yg)(dLn,(0,p.A)({},yLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}hLn.isMDXComponent=!0;const gLn={toc:[]},fLn="wrapper";function DLn(e){let{components:n,...t}=e;return(0,s.yg)(fLn,(0,p.A)({},gLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}DLn.isMDXComponent=!0;const MLn={toc:[]},XLn="wrapper";function _Ln(e){let{components:n,...t}=e;return(0,s.yg)(XLn,(0,p.A)({},MLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}_Ln.isMDXComponent=!0;const wLn={toc:[]},TLn="wrapper";function CLn(e){let{components:n,...t}=e;return(0,s.yg)(TLn,(0,p.A)({},wLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}CLn.isMDXComponent=!0;const xLn={toc:[]},ALn="wrapper";function vLn(e){let{components:n,...t}=e;return(0,s.yg)(ALn,(0,p.A)({},xLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}vLn.isMDXComponent=!0;const LLn={toc:[]},bLn="wrapper";function NLn(e){let{components:n,...t}=e;return(0,s.yg)(bLn,(0,p.A)({},LLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}NLn.isMDXComponent=!0;const kLn={toc:[]},zLn="wrapper";function PLn(e){let{components:n,...t}=e;return(0,s.yg)(zLn,(0,p.A)({},kLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}PLn.isMDXComponent=!0;const ILn={toc:[]},RLn="wrapper";function WLn(e){let{components:n,...t}=e;return(0,s.yg)(RLn,(0,p.A)({},ILn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}WLn.isMDXComponent=!0;const SLn={toc:[]},BLn="wrapper";function ELn(e){let{components:n,...t}=e;return(0,s.yg)(BLn,(0,p.A)({},SLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}ELn.isMDXComponent=!0;const GLn={toc:[]},OLn="wrapper";function ULn(e){let{components:n,...t}=e;return(0,s.yg)(OLn,(0,p.A)({},GLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"One uniform radius:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}ULn.isMDXComponent=!0;const FLn={toc:[]},VLn="wrapper";function qLn(e){let{components:n,...t}=e;return(0,s.yg)(VLn,(0,p.A)({},FLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Individual radii for each corner:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}qLn.isMDXComponent=!0;const jLn={toc:[]},HLn="wrapper";function YLn(e){let{components:n,...t}=e;return(0,s.yg)(HLn,(0,p.A)({},jLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}YLn.isMDXComponent=!0;const QLn={toc:[]},$Ln="wrapper";function KLn(e){let{components:n,...t}=e;return(0,s.yg)($Ln,(0,p.A)({},QLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}KLn.isMDXComponent=!0;const JLn={toc:[]},ZLn="wrapper";function ebn(e){let{components:n,...t}=e;return(0,s.yg)(ZLn,(0,p.A)({},JLn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}ebn.isMDXComponent=!0;const nbn={toc:[]},tbn="wrapper";function obn(e){let{components:n,...t}=e;return(0,s.yg)(tbn,(0,p.A)({},nbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}obn.isMDXComponent=!0;const pbn={toc:[]},rbn="wrapper";function sbn(e){let{components:n,...t}=e;return(0,s.yg)(rbn,(0,p.A)({},pbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}sbn.isMDXComponent=!0;const cbn={toc:[]},abn="wrapper";function ibn(e){let{components:n,...t}=e;return(0,s.yg)(abn,(0,p.A)({},cbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}ibn.isMDXComponent=!0;const lbn={toc:[]},ubn="wrapper";function mbn(e){let{components:n,...t}=e;return(0,s.yg)(ubn,(0,p.A)({},lbn,t,{components:n,mdxType:"MDXLayout"}))}mbn.isMDXComponent=!0;const ybn={toc:[]},dbn="wrapper";function hbn(e){let{components:n,...t}=e;return(0,s.yg)(dbn,(0,p.A)({},ybn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}hbn.isMDXComponent=!0;const gbn={toc:[]},fbn="wrapper";function Dbn(e){let{components:n,...t}=e;return(0,s.yg)(fbn,(0,p.A)({},gbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Dbn.isMDXComponent=!0;const Mbn={toc:[]},Xbn="wrapper";function _bn(e){let{components:n,...t}=e;return(0,s.yg)(Xbn,(0,p.A)({},Mbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}_bn.isMDXComponent=!0;const wbn={toc:[]},Tbn="wrapper";function Cbn(e){let{components:n,...t}=e;return(0,s.yg)(Tbn,(0,p.A)({},wbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Cbn.isMDXComponent=!0;const xbn={toc:[]},Abn="wrapper";function vbn(e){let{components:n,...t}=e;return(0,s.yg)(Abn,(0,p.A)({},xbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}vbn.isMDXComponent=!0;const Lbn={toc:[]},bbn="wrapper";function Nbn(e){let{components:n,...t}=e;return(0,s.yg)(bbn,(0,p.A)({},Lbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Nbn.isMDXComponent=!0;const kbn={toc:[]},zbn="wrapper";function Pbn(e){let{components:n,...t}=e;return(0,s.yg)(zbn,(0,p.A)({},kbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}Pbn.isMDXComponent=!0;const Ibn={toc:[]},Rbn="wrapper";function Wbn(e){let{components:n,...t}=e;return(0,s.yg)(Rbn,(0,p.A)({},Ibn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}Wbn.isMDXComponent=!0;const Sbn={toc:[]},Bbn="wrapper";function Ebn(e){let{components:n,...t}=e;return(0,s.yg)(Bbn,(0,p.A)({},Sbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}Ebn.isMDXComponent=!0;const Gbn={toc:[]},Obn="wrapper";function Ubn(e){let{components:n,...t}=e;return(0,s.yg)(Obn,(0,p.A)({},Gbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"true"))}Ubn.isMDXComponent=!0;const Fbn={toc:[]},Vbn="wrapper";function qbn(e){let{components:n,...t}=e;return(0,s.yg)(Vbn,(0,p.A)({},Fbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the image should be smoothed."))}qbn.isMDXComponent=!0;const jbn={toc:[]},Hbn="wrapper";function Ybn(e){let{components:n,...t}=e;return(0,s.yg)(Hbn,(0,p.A)({},jbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Ybn.isMDXComponent=!0;const Qbn={toc:[]},$bn="wrapper";function Kbn(e){let{components:n,...t}=e;return(0,s.yg)($bn,(0,p.A)({},Qbn,t,{components:n,mdxType:"MDXLayout"}))}Kbn.isMDXComponent=!0;const Jbn={toc:[]},Zbn="wrapper";function eNn(e){let{components:n,...t}=e;return(0,s.yg)(Zbn,(0,p.A)({},Jbn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Using a local image:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.yg)("p",null,"Loading an image from the internet:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}eNn.isMDXComponent=!0;const nNn={toc:[]},tNn="wrapper";function oNn(e){let{components:n,...t}=e;return(0,s.yg)(tNn,(0,p.A)({},nNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The source of this image."))}oNn.isMDXComponent=!0;const pNn={toc:[]},rNn="wrapper";function sNn(e){let{components:n,...t}=e;return(0,s.yg)(rNn,(0,p.A)({},pNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}sNn.isMDXComponent=!0;const cNn={toc:[]},aNn="wrapper";function iNn(e){let{components:n,...t}=e;return(0,s.yg)(aNn,(0,p.A)({},cNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}iNn.isMDXComponent=!0;const lNn={toc:[]},uNn="wrapper";function mNn(e){let{components:n,...t}=e;return(0,s.yg)(uNn,(0,p.A)({},lNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}mNn.isMDXComponent=!0;const yNn={toc:[]},dNn="wrapper";function hNn(e){let{components:n,...t}=e;return(0,s.yg)(dNn,(0,p.A)({},yNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}hNn.isMDXComponent=!0;const gNn={toc:[]},fNn="wrapper";function DNn(e){let{components:n,...t}=e;return(0,s.yg)(fNn,(0,p.A)({},gNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}DNn.isMDXComponent=!0;const MNn={toc:[]},XNn="wrapper";function _Nn(e){let{components:n,...t}=e;return(0,s.yg)(XNn,(0,p.A)({},MNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}_Nn.isMDXComponent=!0;const wNn={toc:[]},TNn="wrapper";function CNn(e){let{components:n,...t}=e;return(0,s.yg)(TNn,(0,p.A)({},wNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}CNn.isMDXComponent=!0;const xNn={toc:[]},ANn="wrapper";function vNn(e){let{components:n,...t}=e;return(0,s.yg)(ANn,(0,p.A)({},xNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}vNn.isMDXComponent=!0;const LNn={toc:[]},bNn="wrapper";function NNn(e){let{components:n,...t}=e;return(0,s.yg)(bNn,(0,p.A)({},LNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}NNn.isMDXComponent=!0;const kNn={toc:[]},zNn="wrapper";function PNn(e){let{components:n,...t}=e;return(0,s.yg)(zNn,(0,p.A)({},kNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}PNn.isMDXComponent=!0;const INn={toc:[]},RNn="wrapper";function WNn(e){let{components:n,...t}=e;return(0,s.yg)(RNn,(0,p.A)({},INn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}WNn.isMDXComponent=!0;const SNn={toc:[]},BNn="wrapper";function ENn(e){let{components:n,...t}=e;return(0,s.yg)(BNn,(0,p.A)({},SNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}ENn.isMDXComponent=!0;const GNn={toc:[]},ONn="wrapper";function UNn(e){let{components:n,...t}=e;return(0,s.yg)(ONn,(0,p.A)({},GNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}UNn.isMDXComponent=!0;const FNn={toc:[]},VNn="wrapper";function qNn(e){let{components:n,...t}=e;return(0,s.yg)(VNn,(0,p.A)({},FNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}qNn.isMDXComponent=!0;const jNn={toc:[]},HNn="wrapper";function YNn(e){let{components:n,...t}=e;return(0,s.yg)(HNn,(0,p.A)({},jNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}YNn.isMDXComponent=!0;const QNn={toc:[]},$Nn="wrapper";function KNn(e){let{components:n,...t}=e;return(0,s.yg)($Nn,(0,p.A)({},QNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}KNn.isMDXComponent=!0;const JNn={toc:[]},ZNn="wrapper";function ekn(e){let{components:n,...t}=e;return(0,s.yg)(ZNn,(0,p.A)({},JNn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}ekn.isMDXComponent=!0;const nkn={toc:[]},tkn="wrapper";function okn(e){let{components:n,...t}=e;return(0,s.yg)(tkn,(0,p.A)({},nkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}okn.isMDXComponent=!0;const pkn={toc:[]},rkn="wrapper";function skn(e){let{components:n,...t}=e;return(0,s.yg)(rkn,(0,p.A)({},pkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}skn.isMDXComponent=!0;const ckn={toc:[]},akn="wrapper";function ikn(e){let{components:n,...t}=e;return(0,s.yg)(akn,(0,p.A)({},ckn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}ikn.isMDXComponent=!0;const lkn={toc:[]},ukn="wrapper";function mkn(e){let{components:n,...t}=e;return(0,s.yg)(ukn,(0,p.A)({},lkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}mkn.isMDXComponent=!0;const ykn={toc:[]},dkn="wrapper";function hkn(e){let{components:n,...t}=e;return(0,s.yg)(dkn,(0,p.A)({},ykn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}hkn.isMDXComponent=!0;const gkn={toc:[]},fkn="wrapper";function Dkn(e){let{components:n,...t}=e;return(0,s.yg)(fkn,(0,p.A)({},gkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}Dkn.isMDXComponent=!0;const Mkn={toc:[]},Xkn="wrapper";function _kn(e){let{components:n,...t}=e;return(0,s.yg)(Xkn,(0,p.A)({},Mkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}_kn.isMDXComponent=!0;const wkn={toc:[]},Tkn="wrapper";function Ckn(e){let{components:n,...t}=e;return(0,s.yg)(Tkn,(0,p.A)({},wkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Ckn.isMDXComponent=!0;const xkn={toc:[]},Akn="wrapper";function vkn(e){let{components:n,...t}=e;return(0,s.yg)(Akn,(0,p.A)({},xkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}vkn.isMDXComponent=!0;const Lkn={toc:[]},bkn="wrapper";function Nkn(e){let{components:n,...t}=e;return(0,s.yg)(bkn,(0,p.A)({},Lkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Nkn.isMDXComponent=!0;const kkn={toc:[]},zkn="wrapper";function Pkn(e){let{components:n,...t}=e;return(0,s.yg)(zkn,(0,p.A)({},kkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Pkn.isMDXComponent=!0;const Ikn={toc:[]},Rkn="wrapper";function Wkn(e){let{components:n,...t}=e;return(0,s.yg)(Rkn,(0,p.A)({},Ikn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}Wkn.isMDXComponent=!0;const Skn={toc:[]},Bkn="wrapper";function Ekn(e){let{components:n,...t}=e;return(0,s.yg)(Bkn,(0,p.A)({},Skn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}Ekn.isMDXComponent=!0;const Gkn={toc:[]},Okn="wrapper";function Ukn(e){let{components:n,...t}=e;return(0,s.yg)(Okn,(0,p.A)({},Gkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}Ukn.isMDXComponent=!0;const Fkn={toc:[]},Vkn="wrapper";function qkn(e){let{components:n,...t}=e;return(0,s.yg)(Vkn,(0,p.A)({},Fkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}qkn.isMDXComponent=!0;const jkn={toc:[]},Hkn="wrapper";function Ykn(e){let{components:n,...t}=e;return(0,s.yg)(Hkn,(0,p.A)({},jkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Ykn.isMDXComponent=!0;const Qkn={toc:[]},$kn="wrapper";function Kkn(e){let{components:n,...t}=e;return(0,s.yg)($kn,(0,p.A)({},Qkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}Kkn.isMDXComponent=!0;const Jkn={toc:[]},Zkn="wrapper";function ezn(e){let{components:n,...t}=e;return(0,s.yg)(Zkn,(0,p.A)({},Jkn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}ezn.isMDXComponent=!0;const nzn={toc:[]},tzn="wrapper";function ozn(e){let{components:n,...t}=e;return(0,s.yg)(tzn,(0,p.A)({},nzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}ozn.isMDXComponent=!0;const pzn={toc:[]},rzn="wrapper";function szn(e){let{components:n,...t}=e;return(0,s.yg)(rzn,(0,p.A)({},pzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}szn.isMDXComponent=!0;const czn={toc:[]},azn="wrapper";function izn(e){let{components:n,...t}=e;return(0,s.yg)(azn,(0,p.A)({},czn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}izn.isMDXComponent=!0;const lzn={toc:[]},uzn="wrapper";function mzn(e){let{components:n,...t}=e;return(0,s.yg)(uzn,(0,p.A)({},lzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}mzn.isMDXComponent=!0;const yzn={toc:[]},dzn="wrapper";function hzn(e){let{components:n,...t}=e;return(0,s.yg)(dzn,(0,p.A)({},yzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}hzn.isMDXComponent=!0;const gzn={toc:[]},fzn="wrapper";function Dzn(e){let{components:n,...t}=e;return(0,s.yg)(fzn,(0,p.A)({},gzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Dzn.isMDXComponent=!0;const Mzn={toc:[]},Xzn="wrapper";function _zn(e){let{components:n,...t}=e;return(0,s.yg)(Xzn,(0,p.A)({},Mzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}_zn.isMDXComponent=!0;const wzn={toc:[]},Tzn="wrapper";function Czn(e){let{components:n,...t}=e;return(0,s.yg)(Tzn,(0,p.A)({},wzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Czn.isMDXComponent=!0;const xzn={toc:[]},Azn="wrapper";function vzn(e){let{components:n,...t}=e;return(0,s.yg)(Azn,(0,p.A)({},xzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}vzn.isMDXComponent=!0;const Lzn={toc:[]},bzn="wrapper";function Nzn(e){let{components:n,...t}=e;return(0,s.yg)(bzn,(0,p.A)({},Lzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}Nzn.isMDXComponent=!0;const kzn={toc:[]},zzn="wrapper";function Pzn(e){let{components:n,...t}=e;return(0,s.yg)(zzn,(0,p.A)({},kzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Pzn.isMDXComponent=!0;const Izn={toc:[]},Rzn="wrapper";function Wzn(e){let{components:n,...t}=e;return(0,s.yg)(Rzn,(0,p.A)({},Izn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}Wzn.isMDXComponent=!0;const Szn={toc:[]},Bzn="wrapper";function Ezn(e){let{components:n,...t}=e;return(0,s.yg)(Bzn,(0,p.A)({},Szn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Ezn.isMDXComponent=!0;const Gzn={toc:[]},Ozn="wrapper";function Uzn(e){let{components:n,...t}=e;return(0,s.yg)(Ozn,(0,p.A)({},Gzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Uzn.isMDXComponent=!0;const Fzn={toc:[]},Vzn="wrapper";function qzn(e){let{components:n,...t}=e;return(0,s.yg)(Vzn,(0,p.A)({},Fzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}qzn.isMDXComponent=!0;const jzn={toc:[]},Hzn="wrapper";function Yzn(e){let{components:n,...t}=e;return(0,s.yg)(Hzn,(0,p.A)({},jzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Yzn.isMDXComponent=!0;const Qzn={toc:[]},$zn="wrapper";function Kzn(e){let{components:n,...t}=e;return(0,s.yg)($zn,(0,p.A)({},Qzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}Kzn.isMDXComponent=!0;const Jzn={toc:[]},Zzn="wrapper";function ePn(e){let{components:n,...t}=e;return(0,s.yg)(Zzn,(0,p.A)({},Jzn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}ePn.isMDXComponent=!0;const nPn={toc:[]},tPn="wrapper";function oPn(e){let{components:n,...t}=e;return(0,s.yg)(tPn,(0,p.A)({},nPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}oPn.isMDXComponent=!0;const pPn={toc:[]},rPn="wrapper";function sPn(e){let{components:n,...t}=e;return(0,s.yg)(rPn,(0,p.A)({},pPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}sPn.isMDXComponent=!0;const cPn={toc:[]},aPn="wrapper";function iPn(e){let{components:n,...t}=e;return(0,s.yg)(aPn,(0,p.A)({},cPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}iPn.isMDXComponent=!0;const lPn={toc:[]},uPn="wrapper";function mPn(e){let{components:n,...t}=e;return(0,s.yg)(uPn,(0,p.A)({},lPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}mPn.isMDXComponent=!0;const yPn={toc:[]},dPn="wrapper";function hPn(e){let{components:n,...t}=e;return(0,s.yg)(dPn,(0,p.A)({},yPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}hPn.isMDXComponent=!0;const gPn={toc:[]},fPn="wrapper";function DPn(e){let{components:n,...t}=e;return(0,s.yg)(fPn,(0,p.A)({},gPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}DPn.isMDXComponent=!0;const MPn={toc:[]},XPn="wrapper";function _Pn(e){let{components:n,...t}=e;return(0,s.yg)(XPn,(0,p.A)({},MPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}_Pn.isMDXComponent=!0;const wPn={toc:[]},TPn="wrapper";function CPn(e){let{components:n,...t}=e;return(0,s.yg)(TPn,(0,p.A)({},wPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}CPn.isMDXComponent=!0;const xPn={toc:[]},APn="wrapper";function vPn(e){let{components:n,...t}=e;return(0,s.yg)(APn,(0,p.A)({},xPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}vPn.isMDXComponent=!0;const LPn={toc:[]},bPn="wrapper";function NPn(e){let{components:n,...t}=e;return(0,s.yg)(bPn,(0,p.A)({},LPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}NPn.isMDXComponent=!0;const kPn={toc:[]},zPn="wrapper";function PPn(e){let{components:n,...t}=e;return(0,s.yg)(zPn,(0,p.A)({},kPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}PPn.isMDXComponent=!0;const IPn={toc:[]},RPn="wrapper";function WPn(e){let{components:n,...t}=e;return(0,s.yg)(RPn,(0,p.A)({},IPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}WPn.isMDXComponent=!0;const SPn={toc:[]},BPn="wrapper";function EPn(e){let{components:n,...t}=e;return(0,s.yg)(BPn,(0,p.A)({},SPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}EPn.isMDXComponent=!0;const GPn={toc:[]},OPn="wrapper";function UPn(e){let{components:n,...t}=e;return(0,s.yg)(OPn,(0,p.A)({},GPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}UPn.isMDXComponent=!0;const FPn={toc:[]},VPn="wrapper";function qPn(e){let{components:n,...t}=e;return(0,s.yg)(VPn,(0,p.A)({},FPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}qPn.isMDXComponent=!0;const jPn={toc:[]},HPn="wrapper";function YPn(e){let{components:n,...t}=e;return(0,s.yg)(HPn,(0,p.A)({},jPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}YPn.isMDXComponent=!0;const QPn={toc:[]},$Pn="wrapper";function KPn(e){let{components:n,...t}=e;return(0,s.yg)($Pn,(0,p.A)({},QPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}KPn.isMDXComponent=!0;const JPn={toc:[]},ZPn="wrapper";function eIn(e){let{components:n,...t}=e;return(0,s.yg)(ZPn,(0,p.A)({},JPn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}eIn.isMDXComponent=!0;const nIn={toc:[]},tIn="wrapper";function oIn(e){let{components:n,...t}=e;return(0,s.yg)(tIn,(0,p.A)({},nIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}oIn.isMDXComponent=!0;const pIn={toc:[]},rIn="wrapper";function sIn(e){let{components:n,...t}=e;return(0,s.yg)(rIn,(0,p.A)({},pIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get color of the image at the given position."))}sIn.isMDXComponent=!0;const cIn={toc:[]},aIn="wrapper";function iIn(e){let{components:n,...t}=e;return(0,s.yg)(aIn,(0,p.A)({},cIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position in local space at which to sample the color."))}iIn.isMDXComponent=!0;const lIn={toc:[]},uIn="wrapper";function mIn(e){let{components:n,...t}=e;return(0,s.yg)(uIn,(0,p.A)({},lIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get color of the image at the given pixel."))}mIn.isMDXComponent=!0;const yIn={toc:[]},dIn="wrapper";function hIn(e){let{components:n,...t}=e;return(0,s.yg)(dIn,(0,p.A)({},yIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The pixel's position."))}hIn.isMDXComponent=!0;const gIn={toc:[]},fIn="wrapper";function DIn(e){let{components:n,...t}=e;return(0,s.yg)(fIn,(0,p.A)({},gIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}DIn.isMDXComponent=!0;const MIn={toc:[]},XIn="wrapper";function _In(e){let{components:n,...t}=e;return(0,s.yg)(XIn,(0,p.A)({},MIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}_In.isMDXComponent=!0;const wIn={toc:[]},TIn="wrapper";function CIn(e){let{components:n,...t}=e;return(0,s.yg)(TIn,(0,p.A)({},wIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}CIn.isMDXComponent=!0;const xIn={toc:[]},AIn="wrapper";function vIn(e){let{components:n,...t}=e;return(0,s.yg)(AIn,(0,p.A)({},xIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}vIn.isMDXComponent=!0;const LIn={toc:[]},bIn="wrapper";function NIn(e){let{components:n,...t}=e;return(0,s.yg)(bIn,(0,p.A)({},LIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}NIn.isMDXComponent=!0;const kIn={toc:[]},zIn="wrapper";function PIn(e){let{components:n,...t}=e;return(0,s.yg)(zIn,(0,p.A)({},kIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}PIn.isMDXComponent=!0;const IIn={toc:[]},RIn="wrapper";function WIn(e){let{components:n,...t}=e;return(0,s.yg)(RIn,(0,p.A)({},IIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}WIn.isMDXComponent=!0;const SIn={toc:[]},BIn="wrapper";function EIn(e){let{components:n,...t}=e;return(0,s.yg)(BIn,(0,p.A)({},SIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}EIn.isMDXComponent=!0;const GIn={toc:[]},OIn="wrapper";function UIn(e){let{components:n,...t}=e;return(0,s.yg)(OIn,(0,p.A)({},GIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}UIn.isMDXComponent=!0;const FIn={toc:[]},VIn="wrapper";function qIn(e){let{components:n,...t}=e;return(0,s.yg)(VIn,(0,p.A)({},FIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}qIn.isMDXComponent=!0;const jIn={toc:[]},HIn="wrapper";function YIn(e){let{components:n,...t}=e;return(0,s.yg)(HIn,(0,p.A)({},jIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}YIn.isMDXComponent=!0;const QIn={toc:[]},$In="wrapper";function KIn(e){let{components:n,...t}=e;return(0,s.yg)($In,(0,p.A)({},QIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}KIn.isMDXComponent=!0;const JIn={toc:[]},ZIn="wrapper";function eRn(e){let{components:n,...t}=e;return(0,s.yg)(ZIn,(0,p.A)({},JIn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}eRn.isMDXComponent=!0;const nRn={toc:[]},tRn="wrapper";function oRn(e){let{components:n,...t}=e;return(0,s.yg)(tRn,(0,p.A)({},nRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}oRn.isMDXComponent=!0;const pRn={toc:[]},rRn="wrapper";function sRn(e){let{components:n,...t}=e;return(0,s.yg)(rRn,(0,p.A)({},pRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}sRn.isMDXComponent=!0;const cRn={toc:[]},aRn="wrapper";function iRn(e){let{components:n,...t}=e;return(0,s.yg)(aRn,(0,p.A)({},cRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}iRn.isMDXComponent=!0;const lRn={toc:[]},uRn="wrapper";function mRn(e){let{components:n,...t}=e;return(0,s.yg)(uRn,(0,p.A)({},lRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}mRn.isMDXComponent=!0;const yRn={toc:[]},dRn="wrapper";function hRn(e){let{components:n,...t}=e;return(0,s.yg)(dRn,(0,p.A)({},yRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}hRn.isMDXComponent=!0;const gRn={toc:[]},fRn="wrapper";function DRn(e){let{components:n,...t}=e;return(0,s.yg)(fRn,(0,p.A)({},gRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}DRn.isMDXComponent=!0;const MRn={toc:[]},XRn="wrapper";function _Rn(e){let{components:n,...t}=e;return(0,s.yg)(XRn,(0,p.A)({},MRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}_Rn.isMDXComponent=!0;const wRn={toc:[]},TRn="wrapper";function CRn(e){let{components:n,...t}=e;return(0,s.yg)(TRn,(0,p.A)({},wRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}CRn.isMDXComponent=!0;const xRn={toc:[]},ARn="wrapper";function vRn(e){let{components:n,...t}=e;return(0,s.yg)(ARn,(0,p.A)({},xRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}vRn.isMDXComponent=!0;const LRn={toc:[]},bRn="wrapper";function NRn(e){let{components:n,...t}=e;return(0,s.yg)(bRn,(0,p.A)({},LRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}NRn.isMDXComponent=!0;const kRn={toc:[]},zRn="wrapper";function PRn(e){let{components:n,...t}=e;return(0,s.yg)(zRn,(0,p.A)({},kRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}PRn.isMDXComponent=!0;const IRn={toc:[]},RRn="wrapper";function WRn(e){let{components:n,...t}=e;return(0,s.yg)(RRn,(0,p.A)({},IRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}WRn.isMDXComponent=!0;const SRn={toc:[]},BRn="wrapper";function ERn(e){let{components:n,...t}=e;return(0,s.yg)(BRn,(0,p.A)({},SRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}ERn.isMDXComponent=!0;const GRn={toc:[]},ORn="wrapper";function URn(e){let{components:n,...t}=e;return(0,s.yg)(ORn,(0,p.A)({},GRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}URn.isMDXComponent=!0;const FRn={toc:[]},VRn="wrapper";function qRn(e){let{components:n,...t}=e;return(0,s.yg)(VRn,(0,p.A)({},FRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}qRn.isMDXComponent=!0;const jRn={toc:[]},HRn="wrapper";function YRn(e){let{components:n,...t}=e;return(0,s.yg)(HRn,(0,p.A)({},jRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}YRn.isMDXComponent=!0;const QRn={toc:[]},$Rn="wrapper";function KRn(e){let{components:n,...t}=e;return(0,s.yg)($Rn,(0,p.A)({},QRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}KRn.isMDXComponent=!0;const JRn={toc:[]},ZRn="wrapper";function eWn(e){let{components:n,...t}=e;return(0,s.yg)(ZRn,(0,p.A)({},JRn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}eWn.isMDXComponent=!0;const nWn={toc:[]},tWn="wrapper";function oWn(e){let{components:n,...t}=e;return(0,s.yg)(tWn,(0,p.A)({},nWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}oWn.isMDXComponent=!0;const pWn={toc:[]},rWn="wrapper";function sWn(e){let{components:n,...t}=e;return(0,s.yg)(rWn,(0,p.A)({},pWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}sWn.isMDXComponent=!0;const cWn={toc:[]},aWn="wrapper";function iWn(e){let{components:n,...t}=e;return(0,s.yg)(aWn,(0,p.A)({},cWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}iWn.isMDXComponent=!0;const lWn={toc:[]},uWn="wrapper";function mWn(e){let{components:n,...t}=e;return(0,s.yg)(uWn,(0,p.A)({},lWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}mWn.isMDXComponent=!0;const yWn={toc:[]},dWn="wrapper";function hWn(e){let{components:n,...t}=e;return(0,s.yg)(dWn,(0,p.A)({},yWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}hWn.isMDXComponent=!0;const gWn={toc:[]},fWn="wrapper";function DWn(e){let{components:n,...t}=e;return(0,s.yg)(fWn,(0,p.A)({},gWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}DWn.isMDXComponent=!0;const MWn={toc:[]},XWn="wrapper";function _Wn(e){let{components:n,...t}=e;return(0,s.yg)(XWn,(0,p.A)({},MWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}_Wn.isMDXComponent=!0;const wWn={toc:[]},TWn="wrapper";function CWn(e){let{components:n,...t}=e;return(0,s.yg)(TWn,(0,p.A)({},wWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}CWn.isMDXComponent=!0;const xWn={toc:[]},AWn="wrapper";function vWn(e){let{components:n,...t}=e;return(0,s.yg)(AWn,(0,p.A)({},xWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}vWn.isMDXComponent=!0;const LWn={toc:[]},bWn="wrapper";function NWn(e){let{components:n,...t}=e;return(0,s.yg)(bWn,(0,p.A)({},LWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}NWn.isMDXComponent=!0;const kWn={toc:[]},zWn="wrapper";function PWn(e){let{components:n,...t}=e;return(0,s.yg)(zWn,(0,p.A)({},kWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}PWn.isMDXComponent=!0;const IWn={toc:[]},RWn="wrapper";function WWn(e){let{components:n,...t}=e;return(0,s.yg)(RWn,(0,p.A)({},IWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The natural size of this image."))}WWn.isMDXComponent=!0;const SWn={toc:[]},BWn="wrapper";function EWn(e){let{components:n,...t}=e;return(0,s.yg)(BWn,(0,p.A)({},SWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}EWn.isMDXComponent=!0;const GWn={toc:[]},OWn="wrapper";function UWn(e){let{components:n,...t}=e;return(0,s.yg)(OWn,(0,p.A)({},GWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}UWn.isMDXComponent=!0;const FWn={toc:[]},VWn="wrapper";function qWn(e){let{components:n,...t}=e;return(0,s.yg)(VWn,(0,p.A)({},FWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}qWn.isMDXComponent=!0;const jWn={toc:[]},HWn="wrapper";function YWn(e){let{components:n,...t}=e;return(0,s.yg)(HWn,(0,p.A)({},jWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}YWn.isMDXComponent=!0;const QWn={toc:[]},$Wn="wrapper";function KWn(e){let{components:n,...t}=e;return(0,s.yg)($Wn,(0,p.A)({},QWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}KWn.isMDXComponent=!0;const JWn={toc:[]},ZWn="wrapper";function eSn(e){let{components:n,...t}=e;return(0,s.yg)(ZWn,(0,p.A)({},JWn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}eSn.isMDXComponent=!0;const nSn={toc:[]},tSn="wrapper";function oSn(e){let{components:n,...t}=e;return(0,s.yg)(tSn,(0,p.A)({},nSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}oSn.isMDXComponent=!0;const pSn={toc:[]},rSn="wrapper";function sSn(e){let{components:n,...t}=e;return(0,s.yg)(rSn,(0,p.A)({},pSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}sSn.isMDXComponent=!0;const cSn={toc:[]},aSn="wrapper";function iSn(e){let{components:n,...t}=e;return(0,s.yg)(aSn,(0,p.A)({},cSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}iSn.isMDXComponent=!0;const lSn={toc:[]},uSn="wrapper";function mSn(e){let{components:n,...t}=e;return(0,s.yg)(uSn,(0,p.A)({},lSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}mSn.isMDXComponent=!0;const ySn={toc:[]},dSn="wrapper";function hSn(e){let{components:n,...t}=e;return(0,s.yg)(dSn,(0,p.A)({},ySn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}hSn.isMDXComponent=!0;const gSn={toc:[]},fSn="wrapper";function DSn(e){let{components:n,...t}=e;return(0,s.yg)(fSn,(0,p.A)({},gSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}DSn.isMDXComponent=!0;const MSn={toc:[]},XSn="wrapper";function _Sn(e){let{components:n,...t}=e;return(0,s.yg)(XSn,(0,p.A)({},MSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}_Sn.isMDXComponent=!0;const wSn={toc:[]},TSn="wrapper";function CSn(e){let{components:n,...t}=e;return(0,s.yg)(TSn,(0,p.A)({},wSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}CSn.isMDXComponent=!0;const xSn={toc:[]},ASn="wrapper";function vSn(e){let{components:n,...t}=e;return(0,s.yg)(ASn,(0,p.A)({},xSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}vSn.isMDXComponent=!0;const LSn={toc:[]},bSn="wrapper";function NSn(e){let{components:n,...t}=e;return(0,s.yg)(bSn,(0,p.A)({},LSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}NSn.isMDXComponent=!0;const kSn={toc:[]},zSn="wrapper";function PSn(e){let{components:n,...t}=e;return(0,s.yg)(zSn,(0,p.A)({},kSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}PSn.isMDXComponent=!0;const ISn={toc:[]},RSn="wrapper";function WSn(e){let{components:n,...t}=e;return(0,s.yg)(RSn,(0,p.A)({},ISn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}WSn.isMDXComponent=!0;const SSn={toc:[]},BSn="wrapper";function ESn(e){let{components:n,...t}=e;return(0,s.yg)(BSn,(0,p.A)({},SSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}ESn.isMDXComponent=!0;const GSn={toc:[]},OSn="wrapper";function USn(e){let{components:n,...t}=e;return(0,s.yg)(OSn,(0,p.A)({},GSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}USn.isMDXComponent=!0;const FSn={toc:[]},VSn="wrapper";function qSn(e){let{components:n,...t}=e;return(0,s.yg)(VSn,(0,p.A)({},FSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}qSn.isMDXComponent=!0;const jSn={toc:[]},HSn="wrapper";function YSn(e){let{components:n,...t}=e;return(0,s.yg)(HSn,(0,p.A)({},jSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}YSn.isMDXComponent=!0;const QSn={toc:[]},$Sn="wrapper";function KSn(e){let{components:n,...t}=e;return(0,s.yg)($Sn,(0,p.A)({},QSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}KSn.isMDXComponent=!0;const JSn={toc:[]},ZSn="wrapper";function eBn(e){let{components:n,...t}=e;return(0,s.yg)(ZSn,(0,p.A)({},JSn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}eBn.isMDXComponent=!0;const nBn={toc:[]},tBn="wrapper";function oBn(e){let{components:n,...t}=e;return(0,s.yg)(tBn,(0,p.A)({},nBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}oBn.isMDXComponent=!0;const pBn={toc:[]},rBn="wrapper";function sBn(e){let{components:n,...t}=e;return(0,s.yg)(rBn,(0,p.A)({},pBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}sBn.isMDXComponent=!0;const cBn={toc:[]},aBn="wrapper";function iBn(e){let{components:n,...t}=e;return(0,s.yg)(aBn,(0,p.A)({},cBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}iBn.isMDXComponent=!0;const lBn={toc:[]},uBn="wrapper";function mBn(e){let{components:n,...t}=e;return(0,s.yg)(uBn,(0,p.A)({},lBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}mBn.isMDXComponent=!0;const yBn={toc:[]},dBn="wrapper";function hBn(e){let{components:n,...t}=e;return(0,s.yg)(dBn,(0,p.A)({},yBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}hBn.isMDXComponent=!0;const gBn={toc:[]},fBn="wrapper";function DBn(e){let{components:n,...t}=e;return(0,s.yg)(fBn,(0,p.A)({},gBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}DBn.isMDXComponent=!0;const MBn={toc:[]},XBn="wrapper";function _Bn(e){let{components:n,...t}=e;return(0,s.yg)(XBn,(0,p.A)({},MBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}_Bn.isMDXComponent=!0;const wBn={toc:[]},TBn="wrapper";function CBn(e){let{components:n,...t}=e;return(0,s.yg)(TBn,(0,p.A)({},wBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}CBn.isMDXComponent=!0;const xBn={toc:[]},ABn="wrapper";function vBn(e){let{components:n,...t}=e;return(0,s.yg)(ABn,(0,p.A)({},xBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}vBn.isMDXComponent=!0;const LBn={toc:[]},bBn="wrapper";function NBn(e){let{components:n,...t}=e;return(0,s.yg)(bBn,(0,p.A)({},LBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}NBn.isMDXComponent=!0;const kBn={toc:[]},zBn="wrapper";function PBn(e){let{components:n,...t}=e;return(0,s.yg)(zBn,(0,p.A)({},kBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}PBn.isMDXComponent=!0;const IBn={toc:[]},RBn="wrapper";function WBn(e){let{components:n,...t}=e;return(0,s.yg)(RBn,(0,p.A)({},IBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}WBn.isMDXComponent=!0;const SBn={toc:[]},BBn="wrapper";function EBn(e){let{components:n,...t}=e;return(0,s.yg)(BBn,(0,p.A)({},SBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}EBn.isMDXComponent=!0;const GBn={toc:[]},OBn="wrapper";function UBn(e){let{components:n,...t}=e;return(0,s.yg)(OBn,(0,p.A)({},GBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}UBn.isMDXComponent=!0;const FBn={toc:[]},VBn="wrapper";function qBn(e){let{components:n,...t}=e;return(0,s.yg)(VBn,(0,p.A)({},FBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}qBn.isMDXComponent=!0;const jBn={toc:[]},HBn="wrapper";function YBn(e){let{components:n,...t}=e;return(0,s.yg)(HBn,(0,p.A)({},jBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}YBn.isMDXComponent=!0;const QBn={toc:[]},$Bn="wrapper";function KBn(e){let{components:n,...t}=e;return(0,s.yg)($Bn,(0,p.A)({},QBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}KBn.isMDXComponent=!0;const JBn={toc:[]},ZBn="wrapper";function eEn(e){let{components:n,...t}=e;return(0,s.yg)(ZBn,(0,p.A)({},JBn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}eEn.isMDXComponent=!0;const nEn={toc:[]},tEn="wrapper";function oEn(e){let{components:n,...t}=e;return(0,s.yg)(tEn,(0,p.A)({},nEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}oEn.isMDXComponent=!0;const pEn={toc:[]},rEn="wrapper";function sEn(e){let{components:n,...t}=e;return(0,s.yg)(rEn,(0,p.A)({},pEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}sEn.isMDXComponent=!0;const cEn={toc:[]},aEn="wrapper";function iEn(e){let{components:n,...t}=e;return(0,s.yg)(aEn,(0,p.A)({},cEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}iEn.isMDXComponent=!0;const lEn={toc:[]},uEn="wrapper";function mEn(e){let{components:n,...t}=e;return(0,s.yg)(uEn,(0,p.A)({},lEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}mEn.isMDXComponent=!0;const yEn={toc:[]},dEn="wrapper";function hEn(e){let{components:n,...t}=e;return(0,s.yg)(dEn,(0,p.A)({},yEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}hEn.isMDXComponent=!0;const gEn={toc:[]},fEn="wrapper";function DEn(e){let{components:n,...t}=e;return(0,s.yg)(fEn,(0,p.A)({},gEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}DEn.isMDXComponent=!0;const MEn={toc:[]},XEn="wrapper";function _En(e){let{components:n,...t}=e;return(0,s.yg)(XEn,(0,p.A)({},MEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}_En.isMDXComponent=!0;const wEn={toc:[]},TEn="wrapper";function CEn(e){let{components:n,...t}=e;return(0,s.yg)(TEn,(0,p.A)({},wEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}CEn.isMDXComponent=!0;const xEn={toc:[]},AEn="wrapper";function vEn(e){let{components:n,...t}=e;return(0,s.yg)(AEn,(0,p.A)({},xEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}vEn.isMDXComponent=!0;const LEn={toc:[]},bEn="wrapper";function NEn(e){let{components:n,...t}=e;return(0,s.yg)(bEn,(0,p.A)({},LEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}NEn.isMDXComponent=!0;const kEn={toc:[]},zEn="wrapper";function PEn(e){let{components:n,...t}=e;return(0,s.yg)(zEn,(0,p.A)({},kEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}PEn.isMDXComponent=!0;const IEn={toc:[]},REn="wrapper";function WEn(e){let{components:n,...t}=e;return(0,s.yg)(REn,(0,p.A)({},IEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}WEn.isMDXComponent=!0;const SEn={toc:[]},BEn="wrapper";function EEn(e){let{components:n,...t}=e;return(0,s.yg)(BEn,(0,p.A)({},SEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}EEn.isMDXComponent=!0;const GEn={toc:[]},OEn="wrapper";function UEn(e){let{components:n,...t}=e;return(0,s.yg)(OEn,(0,p.A)({},GEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node representing a knot of a ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline"},(0,s.yg)("inlineCode",{parentName:"a"},"Spline")),"."))}UEn.isMDXComponent=!0;const FEn={toc:[]},VEn="wrapper";function qEn(e){let{components:n,...t}=e;return(0,s.yg)(VEn,(0,p.A)({},FEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}qEn.isMDXComponent=!0;const jEn={toc:[]},HEn="wrapper";function YEn(e){let{components:n,...t}=e;return(0,s.yg)(HEn,(0,p.A)({},jEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}YEn.isMDXComponent=!0;const QEn={toc:[]},$En="wrapper";function KEn(e){let{components:n,...t}=e;return(0,s.yg)($En,(0,p.A)({},QEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}KEn.isMDXComponent=!0;const JEn={toc:[]},ZEn="wrapper";function eGn(e){let{components:n,...t}=e;return(0,s.yg)(ZEn,(0,p.A)({},JEn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}eGn.isMDXComponent=!0;const nGn={toc:[]},tGn="wrapper";function oGn(e){let{components:n,...t}=e;return(0,s.yg)(tGn,(0,p.A)({},nGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}oGn.isMDXComponent=!0;const pGn={toc:[]},rGn="wrapper";function sGn(e){let{components:n,...t}=e;return(0,s.yg)(rGn,(0,p.A)({},pGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}sGn.isMDXComponent=!0;const cGn={toc:[]},aGn="wrapper";function iGn(e){let{components:n,...t}=e;return(0,s.yg)(aGn,(0,p.A)({},cGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}iGn.isMDXComponent=!0;const lGn={toc:[]},uGn="wrapper";function mGn(e){let{components:n,...t}=e;return(0,s.yg)(uGn,(0,p.A)({},lGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"0"))}mGn.isMDXComponent=!0;const yGn={toc:[]},dGn="wrapper";function hGn(e){let{components:n,...t}=e;return(0,s.yg)(dGn,(0,p.A)({},yGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}hGn.isMDXComponent=!0;const gGn={toc:[]},fGn="wrapper";function DGn(e){let{components:n,...t}=e;return(0,s.yg)(fGn,(0,p.A)({},gGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}DGn.isMDXComponent=!0;const MGn={toc:[]},XGn="wrapper";function _Gn(e){let{components:n,...t}=e;return(0,s.yg)(XGn,(0,p.A)({},MGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}_Gn.isMDXComponent=!0;const wGn={toc:[]},TGn="wrapper";function CGn(e){let{components:n,...t}=e;return(0,s.yg)(TGn,(0,p.A)({},wGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#startHandle"},(0,s.yg)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.yg)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.yg)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.yg)("inlineCode",{parentName:"a"},"auto"))," property."))}CGn.isMDXComponent=!0;const xGn={toc:[]},AGn="wrapper";function vGn(e){let{components:n,...t}=e;return(0,s.yg)(AGn,(0,p.A)({},xGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Mirrored position of the startHandle."))}vGn.isMDXComponent=!0;const LGn={toc:[]},bGn="wrapper";function NGn(e){let{components:n,...t}=e;return(0,s.yg)(bGn,(0,p.A)({},LGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}NGn.isMDXComponent=!0;const kGn={toc:[]},zGn="wrapper";function PGn(e){let{components:n,...t}=e;return(0,s.yg)(zGn,(0,p.A)({},kGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}PGn.isMDXComponent=!0;const IGn={toc:[]},RGn="wrapper";function WGn(e){let{components:n,...t}=e;return(0,s.yg)(RGn,(0,p.A)({},IGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}WGn.isMDXComponent=!0;const SGn={toc:[]},BGn="wrapper";function EGn(e){let{components:n,...t}=e;return(0,s.yg)(BGn,(0,p.A)({},SGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}EGn.isMDXComponent=!0;const GGn={toc:[]},OGn="wrapper";function UGn(e){let{components:n,...t}=e;return(0,s.yg)(OGn,(0,p.A)({},GGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}UGn.isMDXComponent=!0;const FGn={toc:[]},VGn="wrapper";function qGn(e){let{components:n,...t}=e;return(0,s.yg)(VGn,(0,p.A)({},FGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}qGn.isMDXComponent=!0;const jGn={toc:[]},HGn="wrapper";function YGn(e){let{components:n,...t}=e;return(0,s.yg)(HGn,(0,p.A)({},jGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}YGn.isMDXComponent=!0;const QGn={toc:[]},$Gn="wrapper";function KGn(e){let{components:n,...t}=e;return(0,s.yg)($Gn,(0,p.A)({},QGn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}KGn.isMDXComponent=!0;const JGn={toc:[]},ZGn="wrapper";function eOn(e){let{components:n,...t}=e;return(0,s.yg)(ZGn,(0,p.A)({},JGn,t,{components:n,mdxType:"MDXLayout"}))}eOn.isMDXComponent=!0;const nOn={toc:[]},tOn="wrapper";function oOn(e){let{components:n,...t}=e;return(0,s.yg)(tOn,(0,p.A)({},nOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}oOn.isMDXComponent=!0;const pOn={toc:[]},rOn="wrapper";function sOn(e){let{components:n,...t}=e;return(0,s.yg)(rOn,(0,p.A)({},pOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}sOn.isMDXComponent=!0;const cOn={toc:[]},aOn="wrapper";function iOn(e){let{components:n,...t}=e;return(0,s.yg)(aOn,(0,p.A)({},cOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}iOn.isMDXComponent=!0;const lOn={toc:[]},uOn="wrapper";function mOn(e){let{components:n,...t}=e;return(0,s.yg)(uOn,(0,p.A)({},lOn,t,{components:n,mdxType:"MDXLayout"}))}mOn.isMDXComponent=!0;const yOn={toc:[]},dOn="wrapper";function hOn(e){let{components:n,...t}=e;return(0,s.yg)(dOn,(0,p.A)({},yOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#endHandle"},(0,s.yg)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.yg)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.yg)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.yg)("inlineCode",{parentName:"a"},"auto"))," property."))}hOn.isMDXComponent=!0;const gOn={toc:[]},fOn="wrapper";function DOn(e){let{components:n,...t}=e;return(0,s.yg)(fOn,(0,p.A)({},gOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Mirrored position of the endHandle."))}DOn.isMDXComponent=!0;const MOn={toc:[]},XOn="wrapper";function _On(e){let{components:n,...t}=e;return(0,s.yg)(XOn,(0,p.A)({},MOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}_On.isMDXComponent=!0;const wOn={toc:[]},TOn="wrapper";function COn(e){let{components:n,...t}=e;return(0,s.yg)(TOn,(0,p.A)({},wOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}COn.isMDXComponent=!0;const xOn={toc:[]},AOn="wrapper";function vOn(e){let{components:n,...t}=e;return(0,s.yg)(AOn,(0,p.A)({},xOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}vOn.isMDXComponent=!0;const LOn={toc:[]},bOn="wrapper";function NOn(e){let{components:n,...t}=e;return(0,s.yg)(bOn,(0,p.A)({},LOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}NOn.isMDXComponent=!0;const kOn={toc:[]},zOn="wrapper";function POn(e){let{components:n,...t}=e;return(0,s.yg)(zOn,(0,p.A)({},kOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}POn.isMDXComponent=!0;const IOn={toc:[]},ROn="wrapper";function WOn(e){let{components:n,...t}=e;return(0,s.yg)(ROn,(0,p.A)({},IOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}WOn.isMDXComponent=!0;const SOn={toc:[]},BOn="wrapper";function EOn(e){let{components:n,...t}=e;return(0,s.yg)(BOn,(0,p.A)({},SOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}EOn.isMDXComponent=!0;const GOn={toc:[]},OOn="wrapper";function UOn(e){let{components:n,...t}=e;return(0,s.yg)(OOn,(0,p.A)({},GOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}UOn.isMDXComponent=!0;const FOn={toc:[]},VOn="wrapper";function qOn(e){let{components:n,...t}=e;return(0,s.yg)(VOn,(0,p.A)({},FOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}qOn.isMDXComponent=!0;const jOn={toc:[]},HOn="wrapper";function YOn(e){let{components:n,...t}=e;return(0,s.yg)(HOn,(0,p.A)({},jOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}YOn.isMDXComponent=!0;const QOn={toc:[]},$On="wrapper";function KOn(e){let{components:n,...t}=e;return(0,s.yg)($On,(0,p.A)({},QOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}KOn.isMDXComponent=!0;const JOn={toc:[]},ZOn="wrapper";function eUn(e){let{components:n,...t}=e;return(0,s.yg)(ZOn,(0,p.A)({},JOn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}eUn.isMDXComponent=!0;const nUn={toc:[]},tUn="wrapper";function oUn(e){let{components:n,...t}=e;return(0,s.yg)(tUn,(0,p.A)({},nUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}oUn.isMDXComponent=!0;const pUn={toc:[]},rUn="wrapper";function sUn(e){let{components:n,...t}=e;return(0,s.yg)(rUn,(0,p.A)({},pUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}sUn.isMDXComponent=!0;const cUn={toc:[]},aUn="wrapper";function iUn(e){let{components:n,...t}=e;return(0,s.yg)(aUn,(0,p.A)({},cUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}iUn.isMDXComponent=!0;const lUn={toc:[]},uUn="wrapper";function mUn(e){let{components:n,...t}=e;return(0,s.yg)(uUn,(0,p.A)({},lUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}mUn.isMDXComponent=!0;const yUn={toc:[]},dUn="wrapper";function hUn(e){let{components:n,...t}=e;return(0,s.yg)(dUn,(0,p.A)({},yUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}hUn.isMDXComponent=!0;const gUn={toc:[]},fUn="wrapper";function DUn(e){let{components:n,...t}=e;return(0,s.yg)(fUn,(0,p.A)({},gUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}DUn.isMDXComponent=!0;const MUn={toc:[]},XUn="wrapper";function _Un(e){let{components:n,...t}=e;return(0,s.yg)(XUn,(0,p.A)({},MUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}_Un.isMDXComponent=!0;const wUn={toc:[]},TUn="wrapper";function CUn(e){let{components:n,...t}=e;return(0,s.yg)(TUn,(0,p.A)({},wUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}CUn.isMDXComponent=!0;const xUn={toc:[]},AUn="wrapper";function vUn(e){let{components:n,...t}=e;return(0,s.yg)(AUn,(0,p.A)({},xUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}vUn.isMDXComponent=!0;const LUn={toc:[]},bUn="wrapper";function NUn(e){let{components:n,...t}=e;return(0,s.yg)(bUn,(0,p.A)({},LUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}NUn.isMDXComponent=!0;const kUn={toc:[]},zUn="wrapper";function PUn(e){let{components:n,...t}=e;return(0,s.yg)(zUn,(0,p.A)({},kUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}PUn.isMDXComponent=!0;const IUn={toc:[]},RUn="wrapper";function WUn(e){let{components:n,...t}=e;return(0,s.yg)(RUn,(0,p.A)({},IUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}WUn.isMDXComponent=!0;const SUn={toc:[]},BUn="wrapper";function EUn(e){let{components:n,...t}=e;return(0,s.yg)(BUn,(0,p.A)({},SUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}EUn.isMDXComponent=!0;const GUn={toc:[]},OUn="wrapper";function UUn(e){let{components:n,...t}=e;return(0,s.yg)(OUn,(0,p.A)({},GUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}UUn.isMDXComponent=!0;const FUn={toc:[]},VUn="wrapper";function qUn(e){let{components:n,...t}=e;return(0,s.yg)(VUn,(0,p.A)({},FUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}qUn.isMDXComponent=!0;const jUn={toc:[]},HUn="wrapper";function YUn(e){let{components:n,...t}=e;return(0,s.yg)(HUn,(0,p.A)({},jUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}YUn.isMDXComponent=!0;const QUn={toc:[]},$Un="wrapper";function KUn(e){let{components:n,...t}=e;return(0,s.yg)($Un,(0,p.A)({},QUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}KUn.isMDXComponent=!0;const JUn={toc:[]},ZUn="wrapper";function eFn(e){let{components:n,...t}=e;return(0,s.yg)(ZUn,(0,p.A)({},JUn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}eFn.isMDXComponent=!0;const nFn={toc:[]},tFn="wrapper";function oFn(e){let{components:n,...t}=e;return(0,s.yg)(tFn,(0,p.A)({},nFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}oFn.isMDXComponent=!0;const pFn={toc:[]},rFn="wrapper";function sFn(e){let{components:n,...t}=e;return(0,s.yg)(rFn,(0,p.A)({},pFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}sFn.isMDXComponent=!0;const cFn={toc:[]},aFn="wrapper";function iFn(e){let{components:n,...t}=e;return(0,s.yg)(aFn,(0,p.A)({},cFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}iFn.isMDXComponent=!0;const lFn={toc:[]},uFn="wrapper";function mFn(e){let{components:n,...t}=e;return(0,s.yg)(uFn,(0,p.A)({},lFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}mFn.isMDXComponent=!0;const yFn={toc:[]},dFn="wrapper";function hFn(e){let{components:n,...t}=e;return(0,s.yg)(dFn,(0,p.A)({},yFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}hFn.isMDXComponent=!0;const gFn={toc:[]},fFn="wrapper";function DFn(e){let{components:n,...t}=e;return(0,s.yg)(fFn,(0,p.A)({},gFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}DFn.isMDXComponent=!0;const MFn={toc:[]},XFn="wrapper";function _Fn(e){let{components:n,...t}=e;return(0,s.yg)(XFn,(0,p.A)({},MFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}_Fn.isMDXComponent=!0;const wFn={toc:[]},TFn="wrapper";function CFn(e){let{components:n,...t}=e;return(0,s.yg)(TFn,(0,p.A)({},wFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}CFn.isMDXComponent=!0;const xFn={toc:[]},AFn="wrapper";function vFn(e){let{components:n,...t}=e;return(0,s.yg)(AFn,(0,p.A)({},xFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}vFn.isMDXComponent=!0;const LFn={toc:[]},bFn="wrapper";function NFn(e){let{components:n,...t}=e;return(0,s.yg)(bFn,(0,p.A)({},LFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}NFn.isMDXComponent=!0;const kFn={toc:[]},zFn="wrapper";function PFn(e){let{components:n,...t}=e;return(0,s.yg)(zFn,(0,p.A)({},kFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}PFn.isMDXComponent=!0;const IFn={toc:[]},RFn="wrapper";function WFn(e){let{components:n,...t}=e;return(0,s.yg)(RFn,(0,p.A)({},IFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}WFn.isMDXComponent=!0;const SFn={toc:[]},BFn="wrapper";function EFn(e){let{components:n,...t}=e;return(0,s.yg)(BFn,(0,p.A)({},SFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}EFn.isMDXComponent=!0;const GFn={toc:[]},OFn="wrapper";function UFn(e){let{components:n,...t}=e;return(0,s.yg)(OFn,(0,p.A)({},GFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}UFn.isMDXComponent=!0;const FFn={toc:[]},VFn="wrapper";function qFn(e){let{components:n,...t}=e;return(0,s.yg)(VFn,(0,p.A)({},FFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}qFn.isMDXComponent=!0;const jFn={toc:[]},HFn="wrapper";function YFn(e){let{components:n,...t}=e;return(0,s.yg)(HFn,(0,p.A)({},jFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}YFn.isMDXComponent=!0;const QFn={toc:[]},$Fn="wrapper";function KFn(e){let{components:n,...t}=e;return(0,s.yg)($Fn,(0,p.A)({},QFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}KFn.isMDXComponent=!0;const JFn={toc:[]},ZFn="wrapper";function eVn(e){let{components:n,...t}=e;return(0,s.yg)(ZFn,(0,p.A)({},JFn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}eVn.isMDXComponent=!0;const nVn={toc:[]},tVn="wrapper";function oVn(e){let{components:n,...t}=e;return(0,s.yg)(tVn,(0,p.A)({},nVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}oVn.isMDXComponent=!0;const pVn={toc:[]},rVn="wrapper";function sVn(e){let{components:n,...t}=e;return(0,s.yg)(rVn,(0,p.A)({},pVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}sVn.isMDXComponent=!0;const cVn={toc:[]},aVn="wrapper";function iVn(e){let{components:n,...t}=e;return(0,s.yg)(aVn,(0,p.A)({},cVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}iVn.isMDXComponent=!0;const lVn={toc:[]},uVn="wrapper";function mVn(e){let{components:n,...t}=e;return(0,s.yg)(uVn,(0,p.A)({},lVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}mVn.isMDXComponent=!0;const yVn={toc:[]},dVn="wrapper";function hVn(e){let{components:n,...t}=e;return(0,s.yg)(dVn,(0,p.A)({},yVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}hVn.isMDXComponent=!0;const gVn={toc:[]},fVn="wrapper";function DVn(e){let{components:n,...t}=e;return(0,s.yg)(fVn,(0,p.A)({},gVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}DVn.isMDXComponent=!0;const MVn={toc:[]},XVn="wrapper";function _Vn(e){let{components:n,...t}=e;return(0,s.yg)(XVn,(0,p.A)({},MVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}_Vn.isMDXComponent=!0;const wVn={toc:[]},TVn="wrapper";function CVn(e){let{components:n,...t}=e;return(0,s.yg)(TVn,(0,p.A)({},wVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}CVn.isMDXComponent=!0;const xVn={toc:[]},AVn="wrapper";function vVn(e){let{components:n,...t}=e;return(0,s.yg)(AVn,(0,p.A)({},xVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}vVn.isMDXComponent=!0;const LVn={toc:[]},bVn="wrapper";function NVn(e){let{components:n,...t}=e;return(0,s.yg)(bVn,(0,p.A)({},LVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}NVn.isMDXComponent=!0;const kVn={toc:[]},zVn="wrapper";function PVn(e){let{components:n,...t}=e;return(0,s.yg)(zVn,(0,p.A)({},kVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}PVn.isMDXComponent=!0;const IVn={toc:[]},RVn="wrapper";function WVn(e){let{components:n,...t}=e;return(0,s.yg)(RVn,(0,p.A)({},IVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}WVn.isMDXComponent=!0;const SVn={toc:[]},BVn="wrapper";function EVn(e){let{components:n,...t}=e;return(0,s.yg)(BVn,(0,p.A)({},SVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}EVn.isMDXComponent=!0;const GVn={toc:[]},OVn="wrapper";function UVn(e){let{components:n,...t}=e;return(0,s.yg)(OVn,(0,p.A)({},GVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}UVn.isMDXComponent=!0;const FVn={toc:[]},VVn="wrapper";function qVn(e){let{components:n,...t}=e;return(0,s.yg)(VVn,(0,p.A)({},FVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}qVn.isMDXComponent=!0;const jVn={toc:[]},HVn="wrapper";function YVn(e){let{components:n,...t}=e;return(0,s.yg)(HVn,(0,p.A)({},jVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}YVn.isMDXComponent=!0;const QVn={toc:[]},$Vn="wrapper";function KVn(e){let{components:n,...t}=e;return(0,s.yg)($Vn,(0,p.A)({},QVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}KVn.isMDXComponent=!0;const JVn={toc:[]},ZVn="wrapper";function eqn(e){let{components:n,...t}=e;return(0,s.yg)(ZVn,(0,p.A)({},JVn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}eqn.isMDXComponent=!0;const nqn={toc:[]},tqn="wrapper";function oqn(e){let{components:n,...t}=e;return(0,s.yg)(tqn,(0,p.A)({},nqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}oqn.isMDXComponent=!0;const pqn={toc:[]},rqn="wrapper";function sqn(e){let{components:n,...t}=e;return(0,s.yg)(rqn,(0,p.A)({},pqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}sqn.isMDXComponent=!0;const cqn={toc:[]},aqn="wrapper";function iqn(e){let{components:n,...t}=e;return(0,s.yg)(aqn,(0,p.A)({},cqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}iqn.isMDXComponent=!0;const lqn={toc:[]},uqn="wrapper";function mqn(e){let{components:n,...t}=e;return(0,s.yg)(uqn,(0,p.A)({},lqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}mqn.isMDXComponent=!0;const yqn={toc:[]},dqn="wrapper";function hqn(e){let{components:n,...t}=e;return(0,s.yg)(dqn,(0,p.A)({},yqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}hqn.isMDXComponent=!0;const gqn={toc:[]},fqn="wrapper";function Dqn(e){let{components:n,...t}=e;return(0,s.yg)(fqn,(0,p.A)({},gqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Dqn.isMDXComponent=!0;const Mqn={toc:[]},Xqn="wrapper";function _qn(e){let{components:n,...t}=e;return(0,s.yg)(Xqn,(0,p.A)({},Mqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}_qn.isMDXComponent=!0;const wqn={toc:[]},Tqn="wrapper";function Cqn(e){let{components:n,...t}=e;return(0,s.yg)(Tqn,(0,p.A)({},wqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}Cqn.isMDXComponent=!0;const xqn={toc:[]},Aqn="wrapper";function vqn(e){let{components:n,...t}=e;return(0,s.yg)(Aqn,(0,p.A)({},xqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}vqn.isMDXComponent=!0;const Lqn={toc:[]},bqn="wrapper";function Nqn(e){let{components:n,...t}=e;return(0,s.yg)(bqn,(0,p.A)({},Lqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Nqn.isMDXComponent=!0;const kqn={toc:[]},zqn="wrapper";function Pqn(e){let{components:n,...t}=e;return(0,s.yg)(zqn,(0,p.A)({},kqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Pqn.isMDXComponent=!0;const Iqn={toc:[]},Rqn="wrapper";function Wqn(e){let{components:n,...t}=e;return(0,s.yg)(Rqn,(0,p.A)({},Iqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}Wqn.isMDXComponent=!0;const Sqn={toc:[]},Bqn="wrapper";function Eqn(e){let{components:n,...t}=e;return(0,s.yg)(Bqn,(0,p.A)({},Sqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Eqn.isMDXComponent=!0;const Gqn={toc:[]},Oqn="wrapper";function Uqn(e){let{components:n,...t}=e;return(0,s.yg)(Oqn,(0,p.A)({},Gqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}Uqn.isMDXComponent=!0;const Fqn={toc:[]},Vqn="wrapper";function qqn(e){let{components:n,...t}=e;return(0,s.yg)(Vqn,(0,p.A)({},Fqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}qqn.isMDXComponent=!0;const jqn={toc:[]},Hqn="wrapper";function Yqn(e){let{components:n,...t}=e;return(0,s.yg)(Hqn,(0,p.A)({},jqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Yqn.isMDXComponent=!0;const Qqn={toc:[]},$qn="wrapper";function Kqn(e){let{components:n,...t}=e;return(0,s.yg)($qn,(0,p.A)({},Qqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}Kqn.isMDXComponent=!0;const Jqn={toc:[]},Zqn="wrapper";function ejn(e){let{components:n,...t}=e;return(0,s.yg)(Zqn,(0,p.A)({},Jqn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}ejn.isMDXComponent=!0;const njn={toc:[]},tjn="wrapper";function ojn(e){let{components:n,...t}=e;return(0,s.yg)(tjn,(0,p.A)({},njn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}ojn.isMDXComponent=!0;const pjn={toc:[]},rjn="wrapper";function sjn(e){let{components:n,...t}=e;return(0,s.yg)(rjn,(0,p.A)({},pjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}sjn.isMDXComponent=!0;const cjn={toc:[]},ajn="wrapper";function ijn(e){let{components:n,...t}=e;return(0,s.yg)(ajn,(0,p.A)({},cjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}ijn.isMDXComponent=!0;const ljn={toc:[]},ujn="wrapper";function mjn(e){let{components:n,...t}=e;return(0,s.yg)(ujn,(0,p.A)({},ljn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}mjn.isMDXComponent=!0;const yjn={toc:[]},djn="wrapper";function hjn(e){let{components:n,...t}=e;return(0,s.yg)(djn,(0,p.A)({},yjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}hjn.isMDXComponent=!0;const gjn={toc:[]},fjn="wrapper";function Djn(e){let{components:n,...t}=e;return(0,s.yg)(fjn,(0,p.A)({},gjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}Djn.isMDXComponent=!0;const Mjn={toc:[]},Xjn="wrapper";function _jn(e){let{components:n,...t}=e;return(0,s.yg)(Xjn,(0,p.A)({},Mjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}_jn.isMDXComponent=!0;const wjn={toc:[]},Tjn="wrapper";function Cjn(e){let{components:n,...t}=e;return(0,s.yg)(Tjn,(0,p.A)({},wjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}Cjn.isMDXComponent=!0;const xjn={toc:[]},Ajn="wrapper";function vjn(e){let{components:n,...t}=e;return(0,s.yg)(Ajn,(0,p.A)({},xjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}vjn.isMDXComponent=!0;const Ljn={toc:[]},bjn="wrapper";function Njn(e){let{components:n,...t}=e;return(0,s.yg)(bjn,(0,p.A)({},Ljn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}Njn.isMDXComponent=!0;const kjn={toc:[]},zjn="wrapper";function Pjn(e){let{components:n,...t}=e;return(0,s.yg)(zjn,(0,p.A)({},kjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Pjn.isMDXComponent=!0;const Ijn={toc:[]},Rjn="wrapper";function Wjn(e){let{components:n,...t}=e;return(0,s.yg)(Rjn,(0,p.A)({},Ijn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}Wjn.isMDXComponent=!0;const Sjn={toc:[]},Bjn="wrapper";function Ejn(e){let{components:n,...t}=e;return(0,s.yg)(Bjn,(0,p.A)({},Sjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}Ejn.isMDXComponent=!0;const Gjn={toc:[]},Ojn="wrapper";function Ujn(e){let{components:n,...t}=e;return(0,s.yg)(Ojn,(0,p.A)({},Gjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}Ujn.isMDXComponent=!0;const Fjn={toc:[]},Vjn="wrapper";function qjn(e){let{components:n,...t}=e;return(0,s.yg)(Vjn,(0,p.A)({},Fjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}qjn.isMDXComponent=!0;const jjn={toc:[]},Hjn="wrapper";function Yjn(e){let{components:n,...t}=e;return(0,s.yg)(Hjn,(0,p.A)({},jjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Yjn.isMDXComponent=!0;const Qjn={toc:[]},$jn="wrapper";function Kjn(e){let{components:n,...t}=e;return(0,s.yg)($jn,(0,p.A)({},Qjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Kjn.isMDXComponent=!0;const Jjn={toc:[]},Zjn="wrapper";function eHn(e){let{components:n,...t}=e;return(0,s.yg)(Zjn,(0,p.A)({},Jjn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}eHn.isMDXComponent=!0;const nHn={toc:[]},tHn="wrapper";function oHn(e){let{components:n,...t}=e;return(0,s.yg)(tHn,(0,p.A)({},nHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}oHn.isMDXComponent=!0;const pHn={toc:[]},rHn="wrapper";function sHn(e){let{components:n,...t}=e;return(0,s.yg)(rHn,(0,p.A)({},pHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}sHn.isMDXComponent=!0;const cHn={toc:[]},aHn="wrapper";function iHn(e){let{components:n,...t}=e;return(0,s.yg)(aHn,(0,p.A)({},cHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}iHn.isMDXComponent=!0;const lHn={toc:[]},uHn="wrapper";function mHn(e){let{components:n,...t}=e;return(0,s.yg)(uHn,(0,p.A)({},lHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}mHn.isMDXComponent=!0;const yHn={toc:[]},dHn="wrapper";function hHn(e){let{components:n,...t}=e;return(0,s.yg)(dHn,(0,p.A)({},yHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}hHn.isMDXComponent=!0;const gHn={toc:[]},fHn="wrapper";function DHn(e){let{components:n,...t}=e;return(0,s.yg)(fHn,(0,p.A)({},gHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}DHn.isMDXComponent=!0;const MHn={toc:[]},XHn="wrapper";function _Hn(e){let{components:n,...t}=e;return(0,s.yg)(XHn,(0,p.A)({},MHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}_Hn.isMDXComponent=!0;const wHn={toc:[]},THn="wrapper";function CHn(e){let{components:n,...t}=e;return(0,s.yg)(THn,(0,p.A)({},wHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}CHn.isMDXComponent=!0;const xHn={toc:[]},AHn="wrapper";function vHn(e){let{components:n,...t}=e;return(0,s.yg)(AHn,(0,p.A)({},xHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}vHn.isMDXComponent=!0;const LHn={toc:[]},bHn="wrapper";function NHn(e){let{components:n,...t}=e;return(0,s.yg)(bHn,(0,p.A)({},LHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}NHn.isMDXComponent=!0;const kHn={toc:[]},zHn="wrapper";function PHn(e){let{components:n,...t}=e;return(0,s.yg)(zHn,(0,p.A)({},kHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}PHn.isMDXComponent=!0;const IHn={toc:[]},RHn="wrapper";function WHn(e){let{components:n,...t}=e;return(0,s.yg)(RHn,(0,p.A)({},IHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}WHn.isMDXComponent=!0;const SHn={toc:[]},BHn="wrapper";function EHn(e){let{components:n,...t}=e;return(0,s.yg)(BHn,(0,p.A)({},SHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}EHn.isMDXComponent=!0;const GHn={toc:[]},OHn="wrapper";function UHn(e){let{components:n,...t}=e;return(0,s.yg)(OHn,(0,p.A)({},GHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}UHn.isMDXComponent=!0;const FHn={toc:[]},VHn="wrapper";function qHn(e){let{components:n,...t}=e;return(0,s.yg)(VHn,(0,p.A)({},FHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}qHn.isMDXComponent=!0;const jHn={toc:[]},HHn="wrapper";function YHn(e){let{components:n,...t}=e;return(0,s.yg)(HHn,(0,p.A)({},jHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}YHn.isMDXComponent=!0;const QHn={toc:[]},$Hn="wrapper";function KHn(e){let{components:n,...t}=e;return(0,s.yg)($Hn,(0,p.A)({},QHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}KHn.isMDXComponent=!0;const JHn={toc:[]},ZHn="wrapper";function eYn(e){let{components:n,...t}=e;return(0,s.yg)(ZHn,(0,p.A)({},JHn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}eYn.isMDXComponent=!0;const nYn={toc:[]},tYn="wrapper";function oYn(e){let{components:n,...t}=e;return(0,s.yg)(tYn,(0,p.A)({},nYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}oYn.isMDXComponent=!0;const pYn={toc:[]},rYn="wrapper";function sYn(e){let{components:n,...t}=e;return(0,s.yg)(rYn,(0,p.A)({},pYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}sYn.isMDXComponent=!0;const cYn={toc:[]},aYn="wrapper";function iYn(e){let{components:n,...t}=e;return(0,s.yg)(aYn,(0,p.A)({},cYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}iYn.isMDXComponent=!0;const lYn={toc:[]},uYn="wrapper";function mYn(e){let{components:n,...t}=e;return(0,s.yg)(uYn,(0,p.A)({},lYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}mYn.isMDXComponent=!0;const yYn={toc:[]},dYn="wrapper";function hYn(e){let{components:n,...t}=e;return(0,s.yg)(dYn,(0,p.A)({},yYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}hYn.isMDXComponent=!0;const gYn={toc:[]},fYn="wrapper";function DYn(e){let{components:n,...t}=e;return(0,s.yg)(fYn,(0,p.A)({},gYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}DYn.isMDXComponent=!0;const MYn={toc:[]},XYn="wrapper";function _Yn(e){let{components:n,...t}=e;return(0,s.yg)(XYn,(0,p.A)({},MYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}_Yn.isMDXComponent=!0;const wYn={toc:[]},TYn="wrapper";function CYn(e){let{components:n,...t}=e;return(0,s.yg)(TYn,(0,p.A)({},wYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}CYn.isMDXComponent=!0;const xYn={toc:[]},AYn="wrapper";function vYn(e){let{components:n,...t}=e;return(0,s.yg)(AYn,(0,p.A)({},xYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}vYn.isMDXComponent=!0;const LYn={toc:[]},bYn="wrapper";function NYn(e){let{components:n,...t}=e;return(0,s.yg)(bYn,(0,p.A)({},LYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}NYn.isMDXComponent=!0;const kYn={toc:[]},zYn="wrapper";function PYn(e){let{components:n,...t}=e;return(0,s.yg)(zYn,(0,p.A)({},kYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}PYn.isMDXComponent=!0;const IYn={toc:[]},RYn="wrapper";function WYn(e){let{components:n,...t}=e;return(0,s.yg)(RYn,(0,p.A)({},IYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}WYn.isMDXComponent=!0;const SYn={toc:[]},BYn="wrapper";function EYn(e){let{components:n,...t}=e;return(0,s.yg)(BYn,(0,p.A)({},SYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Latex, makeScene2D} from '@revideo/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Latex\n      // Note how this uses \\color to set the color.\n      tex=\"{\\color{white} ax^2+bx+c=0 \\implies x=\\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}}\"\n      width={600} // height and width can calculate based on each other\n    />,\n  );\n});\n")))}EYn.isMDXComponent=!0;const GYn={toc:[]},OYn="wrapper";function UYn(e){let{components:n,...t}=e;return(0,s.yg)(OYn,(0,p.A)({},GYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for rendering equations with LaTeX."))}UYn.isMDXComponent=!0;const FYn={toc:[]},VYn="wrapper";function qYn(e){let{components:n,...t}=e;return(0,s.yg)(VYn,(0,p.A)({},FYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}qYn.isMDXComponent=!0;const jYn={toc:[]},HYn="wrapper";function YYn(e){let{components:n,...t}=e;return(0,s.yg)(HYn,(0,p.A)({},jYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}YYn.isMDXComponent=!0;const QYn={toc:[]},$Yn="wrapper";function KYn(e){let{components:n,...t}=e;return(0,s.yg)($Yn,(0,p.A)({},QYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}KYn.isMDXComponent=!0;const JYn={toc:[]},ZYn="wrapper";function eQn(e){let{components:n,...t}=e;return(0,s.yg)(ZYn,(0,p.A)({},JYn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}eQn.isMDXComponent=!0;const nQn={toc:[]},tQn="wrapper";function oQn(e){let{components:n,...t}=e;return(0,s.yg)(tQn,(0,p.A)({},nQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}oQn.isMDXComponent=!0;const pQn={toc:[]},rQn="wrapper";function sQn(e){let{components:n,...t}=e;return(0,s.yg)(rQn,(0,p.A)({},pQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}sQn.isMDXComponent=!0;const cQn={toc:[]},aQn="wrapper";function iQn(e){let{components:n,...t}=e;return(0,s.yg)(aQn,(0,p.A)({},cQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}iQn.isMDXComponent=!0;const lQn={toc:[]},uQn="wrapper";function mQn(e){let{components:n,...t}=e;return(0,s.yg)(uQn,(0,p.A)({},lQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this image."))}mQn.isMDXComponent=!0;const yQn={toc:[]},dQn="wrapper";function hQn(e){let{components:n,...t}=e;return(0,s.yg)(dQn,(0,p.A)({},yQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}hQn.isMDXComponent=!0;const gQn={toc:[]},fQn="wrapper";function DQn(e){let{components:n,...t}=e;return(0,s.yg)(fQn,(0,p.A)({},gQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}DQn.isMDXComponent=!0;const MQn={toc:[]},XQn="wrapper";function _Qn(e){let{components:n,...t}=e;return(0,s.yg)(XQn,(0,p.A)({},MQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}_Qn.isMDXComponent=!0;const wQn={toc:[]},TQn="wrapper";function CQn(e){let{components:n,...t}=e;return(0,s.yg)(TQn,(0,p.A)({},wQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}CQn.isMDXComponent=!0;const xQn={toc:[]},AQn="wrapper";function vQn(e){let{components:n,...t}=e;return(0,s.yg)(AQn,(0,p.A)({},xQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}vQn.isMDXComponent=!0;const LQn={toc:[]},bQn="wrapper";function NQn(e){let{components:n,...t}=e;return(0,s.yg)(bQn,(0,p.A)({},LQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}NQn.isMDXComponent=!0;const kQn={toc:[]},zQn="wrapper";function PQn(e){let{components:n,...t}=e;return(0,s.yg)(zQn,(0,p.A)({},kQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}PQn.isMDXComponent=!0;const IQn={toc:[]},RQn="wrapper";function WQn(e){let{components:n,...t}=e;return(0,s.yg)(RQn,(0,p.A)({},IQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}WQn.isMDXComponent=!0;const SQn={toc:[]},BQn="wrapper";function EQn(e){let{components:n,...t}=e;return(0,s.yg)(BQn,(0,p.A)({},SQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}EQn.isMDXComponent=!0;const GQn={toc:[]},OQn="wrapper";function UQn(e){let{components:n,...t}=e;return(0,s.yg)(OQn,(0,p.A)({},GQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}UQn.isMDXComponent=!0;const FQn={toc:[]},VQn="wrapper";function qQn(e){let{components:n,...t}=e;return(0,s.yg)(VQn,(0,p.A)({},FQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}qQn.isMDXComponent=!0;const jQn={toc:[]},HQn="wrapper";function YQn(e){let{components:n,...t}=e;return(0,s.yg)(HQn,(0,p.A)({},jQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}YQn.isMDXComponent=!0;const QQn={toc:[]},$Qn="wrapper";function KQn(e){let{components:n,...t}=e;return(0,s.yg)($Qn,(0,p.A)({},QQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}KQn.isMDXComponent=!0;const JQn={toc:[]},ZQn="wrapper";function e$n(e){let{components:n,...t}=e;return(0,s.yg)(ZQn,(0,p.A)({},JQn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}e$n.isMDXComponent=!0;const n$n={toc:[]},t$n="wrapper";function o$n(e){let{components:n,...t}=e;return(0,s.yg)(t$n,(0,p.A)({},n$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}o$n.isMDXComponent=!0;const p$n={toc:[]},r$n="wrapper";function s$n(e){let{components:n,...t}=e;return(0,s.yg)(r$n,(0,p.A)({},p$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}s$n.isMDXComponent=!0;const c$n={toc:[]},a$n="wrapper";function i$n(e){let{components:n,...t}=e;return(0,s.yg)(a$n,(0,p.A)({},c$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}i$n.isMDXComponent=!0;const l$n={toc:[]},u$n="wrapper";function m$n(e){let{components:n,...t}=e;return(0,s.yg)(u$n,(0,p.A)({},l$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}m$n.isMDXComponent=!0;const y$n={toc:[]},d$n="wrapper";function h$n(e){let{components:n,...t}=e;return(0,s.yg)(d$n,(0,p.A)({},y$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}h$n.isMDXComponent=!0;const g$n={toc:[]},f$n="wrapper";function D$n(e){let{components:n,...t}=e;return(0,s.yg)(f$n,(0,p.A)({},g$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}D$n.isMDXComponent=!0;const M$n={toc:[]},X$n="wrapper";function _$n(e){let{components:n,...t}=e;return(0,s.yg)(X$n,(0,p.A)({},M$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}_$n.isMDXComponent=!0;const w$n={toc:[]},T$n="wrapper";function C$n(e){let{components:n,...t}=e;return(0,s.yg)(T$n,(0,p.A)({},w$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}C$n.isMDXComponent=!0;const x$n={toc:[]},A$n="wrapper";function v$n(e){let{components:n,...t}=e;return(0,s.yg)(A$n,(0,p.A)({},x$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}v$n.isMDXComponent=!0;const L$n={toc:[]},b$n="wrapper";function N$n(e){let{components:n,...t}=e;return(0,s.yg)(b$n,(0,p.A)({},L$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}N$n.isMDXComponent=!0;const k$n={toc:[]},z$n="wrapper";function P$n(e){let{components:n,...t}=e;return(0,s.yg)(z$n,(0,p.A)({},k$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}P$n.isMDXComponent=!0;const I$n={toc:[]},R$n="wrapper";function W$n(e){let{components:n,...t}=e;return(0,s.yg)(R$n,(0,p.A)({},I$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}W$n.isMDXComponent=!0;const S$n={toc:[]},B$n="wrapper";function E$n(e){let{components:n,...t}=e;return(0,s.yg)(B$n,(0,p.A)({},S$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}E$n.isMDXComponent=!0;const G$n={toc:[]},O$n="wrapper";function U$n(e){let{components:n,...t}=e;return(0,s.yg)(O$n,(0,p.A)({},G$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}U$n.isMDXComponent=!0;const F$n={toc:[]},V$n="wrapper";function q$n(e){let{components:n,...t}=e;return(0,s.yg)(V$n,(0,p.A)({},F$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}q$n.isMDXComponent=!0;const j$n={toc:[]},H$n="wrapper";function Y$n(e){let{components:n,...t}=e;return(0,s.yg)(H$n,(0,p.A)({},j$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Y$n.isMDXComponent=!0;const Q$n={toc:[]},$$n="wrapper";function K$n(e){let{components:n,...t}=e;return(0,s.yg)($$n,(0,p.A)({},Q$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}K$n.isMDXComponent=!0;const J$n={toc:[]},Z$n="wrapper";function eKn(e){let{components:n,...t}=e;return(0,s.yg)(Z$n,(0,p.A)({},J$n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}eKn.isMDXComponent=!0;const nKn={toc:[]},tKn="wrapper";function oKn(e){let{components:n,...t}=e;return(0,s.yg)(tKn,(0,p.A)({},nKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"One uniform radius:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}oKn.isMDXComponent=!0;const pKn={toc:[]},rKn="wrapper";function sKn(e){let{components:n,...t}=e;return(0,s.yg)(rKn,(0,p.A)({},pKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Individual radii for each corner:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}sKn.isMDXComponent=!0;const cKn={toc:[]},aKn="wrapper";function iKn(e){let{components:n,...t}=e;return(0,s.yg)(aKn,(0,p.A)({},cKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}iKn.isMDXComponent=!0;const lKn={toc:[]},uKn="wrapper";function mKn(e){let{components:n,...t}=e;return(0,s.yg)(uKn,(0,p.A)({},lKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}mKn.isMDXComponent=!0;const yKn={toc:[]},dKn="wrapper";function hKn(e){let{components:n,...t}=e;return(0,s.yg)(dKn,(0,p.A)({},yKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}hKn.isMDXComponent=!0;const gKn={toc:[]},fKn="wrapper";function DKn(e){let{components:n,...t}=e;return(0,s.yg)(fKn,(0,p.A)({},gKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}DKn.isMDXComponent=!0;const MKn={toc:[]},XKn="wrapper";function _Kn(e){let{components:n,...t}=e;return(0,s.yg)(XKn,(0,p.A)({},MKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}_Kn.isMDXComponent=!0;const wKn={toc:[]},TKn="wrapper";function CKn(e){let{components:n,...t}=e;return(0,s.yg)(TKn,(0,p.A)({},wKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}CKn.isMDXComponent=!0;const xKn={toc:[]},AKn="wrapper";function vKn(e){let{components:n,...t}=e;return(0,s.yg)(AKn,(0,p.A)({},xKn,t,{components:n,mdxType:"MDXLayout"}))}vKn.isMDXComponent=!0;const LKn={toc:[]},bKn="wrapper";function NKn(e){let{components:n,...t}=e;return(0,s.yg)(bKn,(0,p.A)({},LKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}NKn.isMDXComponent=!0;const kKn={toc:[]},zKn="wrapper";function PKn(e){let{components:n,...t}=e;return(0,s.yg)(zKn,(0,p.A)({},kKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}PKn.isMDXComponent=!0;const IKn={toc:[]},RKn="wrapper";function WKn(e){let{components:n,...t}=e;return(0,s.yg)(RKn,(0,p.A)({},IKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}WKn.isMDXComponent=!0;const SKn={toc:[]},BKn="wrapper";function EKn(e){let{components:n,...t}=e;return(0,s.yg)(BKn,(0,p.A)({},SKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}EKn.isMDXComponent=!0;const GKn={toc:[]},OKn="wrapper";function UKn(e){let{components:n,...t}=e;return(0,s.yg)(OKn,(0,p.A)({},GKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}UKn.isMDXComponent=!0;const FKn={toc:[]},VKn="wrapper";function qKn(e){let{components:n,...t}=e;return(0,s.yg)(VKn,(0,p.A)({},FKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}qKn.isMDXComponent=!0;const jKn={toc:[]},HKn="wrapper";function YKn(e){let{components:n,...t}=e;return(0,s.yg)(HKn,(0,p.A)({},jKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}YKn.isMDXComponent=!0;const QKn={toc:[]},$Kn="wrapper";function KKn(e){let{components:n,...t}=e;return(0,s.yg)($Kn,(0,p.A)({},QKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}KKn.isMDXComponent=!0;const JKn={toc:[]},ZKn="wrapper";function eJn(e){let{components:n,...t}=e;return(0,s.yg)(ZKn,(0,p.A)({},JKn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}eJn.isMDXComponent=!0;const nJn={toc:[]},tJn="wrapper";function oJn(e){let{components:n,...t}=e;return(0,s.yg)(tJn,(0,p.A)({},nJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"true"))}oJn.isMDXComponent=!0;const pJn={toc:[]},rJn="wrapper";function sJn(e){let{components:n,...t}=e;return(0,s.yg)(rJn,(0,p.A)({},pJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the image should be smoothed."))}sJn.isMDXComponent=!0;const cJn={toc:[]},aJn="wrapper";function iJn(e){let{components:n,...t}=e;return(0,s.yg)(aJn,(0,p.A)({},cJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}iJn.isMDXComponent=!0;const lJn={toc:[]},uJn="wrapper";function mJn(e){let{components:n,...t}=e;return(0,s.yg)(uJn,(0,p.A)({},lJn,t,{components:n,mdxType:"MDXLayout"}))}mJn.isMDXComponent=!0;const yJn={toc:[]},dJn="wrapper";function hJn(e){let{components:n,...t}=e;return(0,s.yg)(dJn,(0,p.A)({},yJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Using a local image:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.yg)("p",null,"Loading an image from the internet:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}hJn.isMDXComponent=!0;const gJn={toc:[]},fJn="wrapper";function DJn(e){let{components:n,...t}=e;return(0,s.yg)(fJn,(0,p.A)({},gJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The source of this image."))}DJn.isMDXComponent=!0;const MJn={toc:[]},XJn="wrapper";function _Jn(e){let{components:n,...t}=e;return(0,s.yg)(XJn,(0,p.A)({},MJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}_Jn.isMDXComponent=!0;const wJn={toc:[]},TJn="wrapper";function CJn(e){let{components:n,...t}=e;return(0,s.yg)(TJn,(0,p.A)({},wJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}CJn.isMDXComponent=!0;const xJn={toc:[]},AJn="wrapper";function vJn(e){let{components:n,...t}=e;return(0,s.yg)(AJn,(0,p.A)({},xJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}vJn.isMDXComponent=!0;const LJn={toc:[]},bJn="wrapper";function NJn(e){let{components:n,...t}=e;return(0,s.yg)(bJn,(0,p.A)({},LJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}NJn.isMDXComponent=!0;const kJn={toc:[]},zJn="wrapper";function PJn(e){let{components:n,...t}=e;return(0,s.yg)(zJn,(0,p.A)({},kJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}PJn.isMDXComponent=!0;const IJn={toc:[]},RJn="wrapper";function WJn(e){let{components:n,...t}=e;return(0,s.yg)(RJn,(0,p.A)({},IJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}WJn.isMDXComponent=!0;const SJn={toc:[]},BJn="wrapper";function EJn(e){let{components:n,...t}=e;return(0,s.yg)(BJn,(0,p.A)({},SJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}EJn.isMDXComponent=!0;const GJn={toc:[]},OJn="wrapper";function UJn(e){let{components:n,...t}=e;return(0,s.yg)(OJn,(0,p.A)({},GJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}UJn.isMDXComponent=!0;const FJn={toc:[]},VJn="wrapper";function qJn(e){let{components:n,...t}=e;return(0,s.yg)(VJn,(0,p.A)({},FJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}qJn.isMDXComponent=!0;const jJn={toc:[]},HJn="wrapper";function YJn(e){let{components:n,...t}=e;return(0,s.yg)(HJn,(0,p.A)({},jJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}YJn.isMDXComponent=!0;const QJn={toc:[]},$Jn="wrapper";function KJn(e){let{components:n,...t}=e;return(0,s.yg)($Jn,(0,p.A)({},QJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}KJn.isMDXComponent=!0;const JJn={toc:[]},ZJn="wrapper";function eZn(e){let{components:n,...t}=e;return(0,s.yg)(ZJn,(0,p.A)({},JJn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}eZn.isMDXComponent=!0;const nZn={toc:[]},tZn="wrapper";function oZn(e){let{components:n,...t}=e;return(0,s.yg)(tZn,(0,p.A)({},nZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}oZn.isMDXComponent=!0;const pZn={toc:[]},rZn="wrapper";function sZn(e){let{components:n,...t}=e;return(0,s.yg)(rZn,(0,p.A)({},pZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}sZn.isMDXComponent=!0;const cZn={toc:[]},aZn="wrapper";function iZn(e){let{components:n,...t}=e;return(0,s.yg)(aZn,(0,p.A)({},cZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}iZn.isMDXComponent=!0;const lZn={toc:[]},uZn="wrapper";function mZn(e){let{components:n,...t}=e;return(0,s.yg)(uZn,(0,p.A)({},lZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}mZn.isMDXComponent=!0;const yZn={toc:[]},dZn="wrapper";function hZn(e){let{components:n,...t}=e;return(0,s.yg)(dZn,(0,p.A)({},yZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}hZn.isMDXComponent=!0;const gZn={toc:[]},fZn="wrapper";function DZn(e){let{components:n,...t}=e;return(0,s.yg)(fZn,(0,p.A)({},gZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}DZn.isMDXComponent=!0;const MZn={toc:[]},XZn="wrapper";function _Zn(e){let{components:n,...t}=e;return(0,s.yg)(XZn,(0,p.A)({},MZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}_Zn.isMDXComponent=!0;const wZn={toc:[]},TZn="wrapper";function CZn(e){let{components:n,...t}=e;return(0,s.yg)(TZn,(0,p.A)({},wZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}CZn.isMDXComponent=!0;const xZn={toc:[]},AZn="wrapper";function vZn(e){let{components:n,...t}=e;return(0,s.yg)(AZn,(0,p.A)({},xZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}vZn.isMDXComponent=!0;const LZn={toc:[]},bZn="wrapper";function NZn(e){let{components:n,...t}=e;return(0,s.yg)(bZn,(0,p.A)({},LZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}NZn.isMDXComponent=!0;const kZn={toc:[]},zZn="wrapper";function PZn(e){let{components:n,...t}=e;return(0,s.yg)(zZn,(0,p.A)({},kZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}PZn.isMDXComponent=!0;const IZn={toc:[]},RZn="wrapper";function WZn(e){let{components:n,...t}=e;return(0,s.yg)(RZn,(0,p.A)({},IZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}WZn.isMDXComponent=!0;const SZn={toc:[]},BZn="wrapper";function EZn(e){let{components:n,...t}=e;return(0,s.yg)(BZn,(0,p.A)({},SZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}EZn.isMDXComponent=!0;const GZn={toc:[]},OZn="wrapper";function UZn(e){let{components:n,...t}=e;return(0,s.yg)(OZn,(0,p.A)({},GZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}UZn.isMDXComponent=!0;const FZn={toc:[]},VZn="wrapper";function qZn(e){let{components:n,...t}=e;return(0,s.yg)(VZn,(0,p.A)({},FZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}qZn.isMDXComponent=!0;const jZn={toc:[]},HZn="wrapper";function YZn(e){let{components:n,...t}=e;return(0,s.yg)(HZn,(0,p.A)({},jZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}YZn.isMDXComponent=!0;const QZn={toc:[]},$Zn="wrapper";function KZn(e){let{components:n,...t}=e;return(0,s.yg)($Zn,(0,p.A)({},QZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}KZn.isMDXComponent=!0;const JZn={toc:[]},ZZn="wrapper";function e0n(e){let{components:n,...t}=e;return(0,s.yg)(ZZn,(0,p.A)({},JZn,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}e0n.isMDXComponent=!0;const n0n={toc:[]},t0n="wrapper";function o0n(e){let{components:n,...t}=e;return(0,s.yg)(t0n,(0,p.A)({},n0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}o0n.isMDXComponent=!0;const p0n={toc:[]},r0n="wrapper";function s0n(e){let{components:n,...t}=e;return(0,s.yg)(r0n,(0,p.A)({},p0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}s0n.isMDXComponent=!0;const c0n={toc:[]},a0n="wrapper";function i0n(e){let{components:n,...t}=e;return(0,s.yg)(a0n,(0,p.A)({},c0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}i0n.isMDXComponent=!0;const l0n={toc:[]},u0n="wrapper";function m0n(e){let{components:n,...t}=e;return(0,s.yg)(u0n,(0,p.A)({},l0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}m0n.isMDXComponent=!0;const y0n={toc:[]},d0n="wrapper";function h0n(e){let{components:n,...t}=e;return(0,s.yg)(d0n,(0,p.A)({},y0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}h0n.isMDXComponent=!0;const g0n={toc:[]},f0n="wrapper";function D0n(e){let{components:n,...t}=e;return(0,s.yg)(f0n,(0,p.A)({},g0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}D0n.isMDXComponent=!0;const M0n={toc:[]},X0n="wrapper";function _0n(e){let{components:n,...t}=e;return(0,s.yg)(X0n,(0,p.A)({},M0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}_0n.isMDXComponent=!0;const w0n={toc:[]},T0n="wrapper";function C0n(e){let{components:n,...t}=e;return(0,s.yg)(T0n,(0,p.A)({},w0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}C0n.isMDXComponent=!0;const x0n={toc:[]},A0n="wrapper";function v0n(e){let{components:n,...t}=e;return(0,s.yg)(A0n,(0,p.A)({},x0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}v0n.isMDXComponent=!0;const L0n={toc:[]},b0n="wrapper";function N0n(e){let{components:n,...t}=e;return(0,s.yg)(b0n,(0,p.A)({},L0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}N0n.isMDXComponent=!0;const k0n={toc:[]},z0n="wrapper";function P0n(e){let{components:n,...t}=e;return(0,s.yg)(z0n,(0,p.A)({},k0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}P0n.isMDXComponent=!0;const I0n={toc:[]},R0n="wrapper";function W0n(e){let{components:n,...t}=e;return(0,s.yg)(R0n,(0,p.A)({},I0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}W0n.isMDXComponent=!0;const S0n={toc:[]},B0n="wrapper";function E0n(e){let{components:n,...t}=e;return(0,s.yg)(B0n,(0,p.A)({},S0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}E0n.isMDXComponent=!0;const G0n={toc:[]},O0n="wrapper";function U0n(e){let{components:n,...t}=e;return(0,s.yg)(O0n,(0,p.A)({},G0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}U0n.isMDXComponent=!0;const F0n={toc:[]},V0n="wrapper";function q0n(e){let{components:n,...t}=e;return(0,s.yg)(V0n,(0,p.A)({},F0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}q0n.isMDXComponent=!0;const j0n={toc:[]},H0n="wrapper";function Y0n(e){let{components:n,...t}=e;return(0,s.yg)(H0n,(0,p.A)({},j0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Y0n.isMDXComponent=!0;const Q0n={toc:[]},$0n="wrapper";function K0n(e){let{components:n,...t}=e;return(0,s.yg)($0n,(0,p.A)({},Q0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}K0n.isMDXComponent=!0;const J0n={toc:[]},Z0n="wrapper";function e3n(e){let{components:n,...t}=e;return(0,s.yg)(Z0n,(0,p.A)({},J0n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}e3n.isMDXComponent=!0;const n3n={toc:[]},t3n="wrapper";function o3n(e){let{components:n,...t}=e;return(0,s.yg)(t3n,(0,p.A)({},n3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}o3n.isMDXComponent=!0;const p3n={toc:[]},r3n="wrapper";function s3n(e){let{components:n,...t}=e;return(0,s.yg)(r3n,(0,p.A)({},p3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}s3n.isMDXComponent=!0;const c3n={toc:[]},a3n="wrapper";function i3n(e){let{components:n,...t}=e;return(0,s.yg)(a3n,(0,p.A)({},c3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}i3n.isMDXComponent=!0;const l3n={toc:[]},u3n="wrapper";function m3n(e){let{components:n,...t}=e;return(0,s.yg)(u3n,(0,p.A)({},l3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}m3n.isMDXComponent=!0;const y3n={toc:[]},d3n="wrapper";function h3n(e){let{components:n,...t}=e;return(0,s.yg)(d3n,(0,p.A)({},y3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}h3n.isMDXComponent=!0;const g3n={toc:[]},f3n="wrapper";function D3n(e){let{components:n,...t}=e;return(0,s.yg)(f3n,(0,p.A)({},g3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}D3n.isMDXComponent=!0;const M3n={toc:[]},X3n="wrapper";function _3n(e){let{components:n,...t}=e;return(0,s.yg)(X3n,(0,p.A)({},M3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}_3n.isMDXComponent=!0;const w3n={toc:[]},T3n="wrapper";function C3n(e){let{components:n,...t}=e;return(0,s.yg)(T3n,(0,p.A)({},w3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}C3n.isMDXComponent=!0;const x3n={toc:[]},A3n="wrapper";function v3n(e){let{components:n,...t}=e;return(0,s.yg)(A3n,(0,p.A)({},x3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}v3n.isMDXComponent=!0;const L3n={toc:[]},b3n="wrapper";function N3n(e){let{components:n,...t}=e;return(0,s.yg)(b3n,(0,p.A)({},L3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}N3n.isMDXComponent=!0;const k3n={toc:[]},z3n="wrapper";function P3n(e){let{components:n,...t}=e;return(0,s.yg)(z3n,(0,p.A)({},k3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}P3n.isMDXComponent=!0;const I3n={toc:[]},R3n="wrapper";function W3n(e){let{components:n,...t}=e;return(0,s.yg)(R3n,(0,p.A)({},I3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}W3n.isMDXComponent=!0;const S3n={toc:[]},B3n="wrapper";function E3n(e){let{components:n,...t}=e;return(0,s.yg)(B3n,(0,p.A)({},S3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}E3n.isMDXComponent=!0;const G3n={toc:[]},O3n="wrapper";function U3n(e){let{components:n,...t}=e;return(0,s.yg)(O3n,(0,p.A)({},G3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}U3n.isMDXComponent=!0;const F3n={toc:[]},V3n="wrapper";function q3n(e){let{components:n,...t}=e;return(0,s.yg)(V3n,(0,p.A)({},F3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}q3n.isMDXComponent=!0;const j3n={toc:[]},H3n="wrapper";function Y3n(e){let{components:n,...t}=e;return(0,s.yg)(H3n,(0,p.A)({},j3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Y3n.isMDXComponent=!0;const Q3n={toc:[]},$3n="wrapper";function K3n(e){let{components:n,...t}=e;return(0,s.yg)($3n,(0,p.A)({},Q3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}K3n.isMDXComponent=!0;const J3n={toc:[]},Z3n="wrapper";function e1n(e){let{components:n,...t}=e;return(0,s.yg)(Z3n,(0,p.A)({},J3n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}e1n.isMDXComponent=!0;const n1n={toc:[]},t1n="wrapper";function o1n(e){let{components:n,...t}=e;return(0,s.yg)(t1n,(0,p.A)({},n1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}o1n.isMDXComponent=!0;const p1n={toc:[]},r1n="wrapper";function s1n(e){let{components:n,...t}=e;return(0,s.yg)(r1n,(0,p.A)({},p1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}s1n.isMDXComponent=!0;const c1n={toc:[]},a1n="wrapper";function i1n(e){let{components:n,...t}=e;return(0,s.yg)(a1n,(0,p.A)({},c1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}i1n.isMDXComponent=!0;const l1n={toc:[]},u1n="wrapper";function m1n(e){let{components:n,...t}=e;return(0,s.yg)(u1n,(0,p.A)({},l1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}m1n.isMDXComponent=!0;const y1n={toc:[]},d1n="wrapper";function h1n(e){let{components:n,...t}=e;return(0,s.yg)(d1n,(0,p.A)({},y1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}h1n.isMDXComponent=!0;const g1n={toc:[]},f1n="wrapper";function D1n(e){let{components:n,...t}=e;return(0,s.yg)(f1n,(0,p.A)({},g1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}D1n.isMDXComponent=!0;const M1n={toc:[]},X1n="wrapper";function _1n(e){let{components:n,...t}=e;return(0,s.yg)(X1n,(0,p.A)({},M1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get color of the image at the given position."))}_1n.isMDXComponent=!0;const w1n={toc:[]},T1n="wrapper";function C1n(e){let{components:n,...t}=e;return(0,s.yg)(T1n,(0,p.A)({},w1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position in local space at which to sample the color."))}C1n.isMDXComponent=!0;const x1n={toc:[]},A1n="wrapper";function v1n(e){let{components:n,...t}=e;return(0,s.yg)(A1n,(0,p.A)({},x1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get color of the image at the given pixel."))}v1n.isMDXComponent=!0;const L1n={toc:[]},b1n="wrapper";function N1n(e){let{components:n,...t}=e;return(0,s.yg)(b1n,(0,p.A)({},L1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The pixel's position."))}N1n.isMDXComponent=!0;const k1n={toc:[]},z1n="wrapper";function P1n(e){let{components:n,...t}=e;return(0,s.yg)(z1n,(0,p.A)({},k1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}P1n.isMDXComponent=!0;const I1n={toc:[]},R1n="wrapper";function W1n(e){let{components:n,...t}=e;return(0,s.yg)(R1n,(0,p.A)({},I1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}W1n.isMDXComponent=!0;const S1n={toc:[]},B1n="wrapper";function E1n(e){let{components:n,...t}=e;return(0,s.yg)(B1n,(0,p.A)({},S1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}E1n.isMDXComponent=!0;const G1n={toc:[]},O1n="wrapper";function U1n(e){let{components:n,...t}=e;return(0,s.yg)(O1n,(0,p.A)({},G1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}U1n.isMDXComponent=!0;const F1n={toc:[]},V1n="wrapper";function q1n(e){let{components:n,...t}=e;return(0,s.yg)(V1n,(0,p.A)({},F1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}q1n.isMDXComponent=!0;const j1n={toc:[]},H1n="wrapper";function Y1n(e){let{components:n,...t}=e;return(0,s.yg)(H1n,(0,p.A)({},j1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}Y1n.isMDXComponent=!0;const Q1n={toc:[]},$1n="wrapper";function K1n(e){let{components:n,...t}=e;return(0,s.yg)($1n,(0,p.A)({},Q1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}K1n.isMDXComponent=!0;const J1n={toc:[]},Z1n="wrapper";function e9n(e){let{components:n,...t}=e;return(0,s.yg)(Z1n,(0,p.A)({},J1n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}e9n.isMDXComponent=!0;const n9n={toc:[]},t9n="wrapper";function o9n(e){let{components:n,...t}=e;return(0,s.yg)(t9n,(0,p.A)({},n9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}o9n.isMDXComponent=!0;const p9n={toc:[]},r9n="wrapper";function s9n(e){let{components:n,...t}=e;return(0,s.yg)(r9n,(0,p.A)({},p9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}s9n.isMDXComponent=!0;const c9n={toc:[]},a9n="wrapper";function i9n(e){let{components:n,...t}=e;return(0,s.yg)(a9n,(0,p.A)({},c9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}i9n.isMDXComponent=!0;const l9n={toc:[]},u9n="wrapper";function m9n(e){let{components:n,...t}=e;return(0,s.yg)(u9n,(0,p.A)({},l9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}m9n.isMDXComponent=!0;const y9n={toc:[]},d9n="wrapper";function h9n(e){let{components:n,...t}=e;return(0,s.yg)(d9n,(0,p.A)({},y9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}h9n.isMDXComponent=!0;const g9n={toc:[]},f9n="wrapper";function D9n(e){let{components:n,...t}=e;return(0,s.yg)(f9n,(0,p.A)({},g9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}D9n.isMDXComponent=!0;const M9n={toc:[]},X9n="wrapper";function _9n(e){let{components:n,...t}=e;return(0,s.yg)(X9n,(0,p.A)({},M9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}_9n.isMDXComponent=!0;const w9n={toc:[]},T9n="wrapper";function C9n(e){let{components:n,...t}=e;return(0,s.yg)(T9n,(0,p.A)({},w9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}C9n.isMDXComponent=!0;const x9n={toc:[]},A9n="wrapper";function v9n(e){let{components:n,...t}=e;return(0,s.yg)(A9n,(0,p.A)({},x9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}v9n.isMDXComponent=!0;const L9n={toc:[]},b9n="wrapper";function N9n(e){let{components:n,...t}=e;return(0,s.yg)(b9n,(0,p.A)({},L9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}N9n.isMDXComponent=!0;const k9n={toc:[]},z9n="wrapper";function P9n(e){let{components:n,...t}=e;return(0,s.yg)(z9n,(0,p.A)({},k9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}P9n.isMDXComponent=!0;const I9n={toc:[]},R9n="wrapper";function W9n(e){let{components:n,...t}=e;return(0,s.yg)(R9n,(0,p.A)({},I9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}W9n.isMDXComponent=!0;const S9n={toc:[]},B9n="wrapper";function E9n(e){let{components:n,...t}=e;return(0,s.yg)(B9n,(0,p.A)({},S9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}E9n.isMDXComponent=!0;const G9n={toc:[]},O9n="wrapper";function U9n(e){let{components:n,...t}=e;return(0,s.yg)(O9n,(0,p.A)({},G9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}U9n.isMDXComponent=!0;const F9n={toc:[]},V9n="wrapper";function q9n(e){let{components:n,...t}=e;return(0,s.yg)(V9n,(0,p.A)({},F9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}q9n.isMDXComponent=!0;const j9n={toc:[]},H9n="wrapper";function Y9n(e){let{components:n,...t}=e;return(0,s.yg)(H9n,(0,p.A)({},j9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Y9n.isMDXComponent=!0;const Q9n={toc:[]},$9n="wrapper";function K9n(e){let{components:n,...t}=e;return(0,s.yg)($9n,(0,p.A)({},Q9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}K9n.isMDXComponent=!0;const J9n={toc:[]},Z9n="wrapper";function e2n(e){let{components:n,...t}=e;return(0,s.yg)(Z9n,(0,p.A)({},J9n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}e2n.isMDXComponent=!0;const n2n={toc:[]},t2n="wrapper";function o2n(e){let{components:n,...t}=e;return(0,s.yg)(t2n,(0,p.A)({},n2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}o2n.isMDXComponent=!0;const p2n={toc:[]},r2n="wrapper";function s2n(e){let{components:n,...t}=e;return(0,s.yg)(r2n,(0,p.A)({},p2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}s2n.isMDXComponent=!0;const c2n={toc:[]},a2n="wrapper";function i2n(e){let{components:n,...t}=e;return(0,s.yg)(a2n,(0,p.A)({},c2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}i2n.isMDXComponent=!0;const l2n={toc:[]},u2n="wrapper";function m2n(e){let{components:n,...t}=e;return(0,s.yg)(u2n,(0,p.A)({},l2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}m2n.isMDXComponent=!0;const y2n={toc:[]},d2n="wrapper";function h2n(e){let{components:n,...t}=e;return(0,s.yg)(d2n,(0,p.A)({},y2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}h2n.isMDXComponent=!0;const g2n={toc:[]},f2n="wrapper";function D2n(e){let{components:n,...t}=e;return(0,s.yg)(f2n,(0,p.A)({},g2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}D2n.isMDXComponent=!0;const M2n={toc:[]},X2n="wrapper";function _2n(e){let{components:n,...t}=e;return(0,s.yg)(X2n,(0,p.A)({},M2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}_2n.isMDXComponent=!0;const w2n={toc:[]},T2n="wrapper";function C2n(e){let{components:n,...t}=e;return(0,s.yg)(T2n,(0,p.A)({},w2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}C2n.isMDXComponent=!0;const x2n={toc:[]},A2n="wrapper";function v2n(e){let{components:n,...t}=e;return(0,s.yg)(A2n,(0,p.A)({},x2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}v2n.isMDXComponent=!0;const L2n={toc:[]},b2n="wrapper";function N2n(e){let{components:n,...t}=e;return(0,s.yg)(b2n,(0,p.A)({},L2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}N2n.isMDXComponent=!0;const k2n={toc:[]},z2n="wrapper";function P2n(e){let{components:n,...t}=e;return(0,s.yg)(z2n,(0,p.A)({},k2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}P2n.isMDXComponent=!0;const I2n={toc:[]},R2n="wrapper";function W2n(e){let{components:n,...t}=e;return(0,s.yg)(R2n,(0,p.A)({},I2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}W2n.isMDXComponent=!0;const S2n={toc:[]},B2n="wrapper";function E2n(e){let{components:n,...t}=e;return(0,s.yg)(B2n,(0,p.A)({},S2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}E2n.isMDXComponent=!0;const G2n={toc:[]},O2n="wrapper";function U2n(e){let{components:n,...t}=e;return(0,s.yg)(O2n,(0,p.A)({},G2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}U2n.isMDXComponent=!0;const F2n={toc:[]},V2n="wrapper";function q2n(e){let{components:n,...t}=e;return(0,s.yg)(V2n,(0,p.A)({},F2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}q2n.isMDXComponent=!0;const j2n={toc:[]},H2n="wrapper";function Y2n(e){let{components:n,...t}=e;return(0,s.yg)(H2n,(0,p.A)({},j2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}Y2n.isMDXComponent=!0;const Q2n={toc:[]},$2n="wrapper";function K2n(e){let{components:n,...t}=e;return(0,s.yg)($2n,(0,p.A)({},Q2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The natural size of this image."))}K2n.isMDXComponent=!0;const J2n={toc:[]},Z2n="wrapper";function e4n(e){let{components:n,...t}=e;return(0,s.yg)(Z2n,(0,p.A)({},J2n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}e4n.isMDXComponent=!0;const n4n={toc:[]},t4n="wrapper";function o4n(e){let{components:n,...t}=e;return(0,s.yg)(t4n,(0,p.A)({},n4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}o4n.isMDXComponent=!0;const p4n={toc:[]},r4n="wrapper";function s4n(e){let{components:n,...t}=e;return(0,s.yg)(r4n,(0,p.A)({},p4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}s4n.isMDXComponent=!0;const c4n={toc:[]},a4n="wrapper";function i4n(e){let{components:n,...t}=e;return(0,s.yg)(a4n,(0,p.A)({},c4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}i4n.isMDXComponent=!0;const l4n={toc:[]},u4n="wrapper";function m4n(e){let{components:n,...t}=e;return(0,s.yg)(u4n,(0,p.A)({},l4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}m4n.isMDXComponent=!0;const y4n={toc:[]},d4n="wrapper";function h4n(e){let{components:n,...t}=e;return(0,s.yg)(d4n,(0,p.A)({},y4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}h4n.isMDXComponent=!0;const g4n={toc:[]},f4n="wrapper";function D4n(e){let{components:n,...t}=e;return(0,s.yg)(f4n,(0,p.A)({},g4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}D4n.isMDXComponent=!0;const M4n={toc:[]},X4n="wrapper";function _4n(e){let{components:n,...t}=e;return(0,s.yg)(X4n,(0,p.A)({},M4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}_4n.isMDXComponent=!0;const w4n={toc:[]},T4n="wrapper";function C4n(e){let{components:n,...t}=e;return(0,s.yg)(T4n,(0,p.A)({},w4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}C4n.isMDXComponent=!0;const x4n={toc:[]},A4n="wrapper";function v4n(e){let{components:n,...t}=e;return(0,s.yg)(A4n,(0,p.A)({},x4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}v4n.isMDXComponent=!0;const L4n={toc:[]},b4n="wrapper";function N4n(e){let{components:n,...t}=e;return(0,s.yg)(b4n,(0,p.A)({},L4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}N4n.isMDXComponent=!0;const k4n={toc:[]},z4n="wrapper";function P4n(e){let{components:n,...t}=e;return(0,s.yg)(z4n,(0,p.A)({},k4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}P4n.isMDXComponent=!0;const I4n={toc:[]},R4n="wrapper";function W4n(e){let{components:n,...t}=e;return(0,s.yg)(R4n,(0,p.A)({},I4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}W4n.isMDXComponent=!0;const S4n={toc:[]},B4n="wrapper";function E4n(e){let{components:n,...t}=e;return(0,s.yg)(B4n,(0,p.A)({},S4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}E4n.isMDXComponent=!0;const G4n={toc:[]},O4n="wrapper";function U4n(e){let{components:n,...t}=e;return(0,s.yg)(O4n,(0,p.A)({},G4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}U4n.isMDXComponent=!0;const F4n={toc:[]},V4n="wrapper";function q4n(e){let{components:n,...t}=e;return(0,s.yg)(V4n,(0,p.A)({},F4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}q4n.isMDXComponent=!0;const j4n={toc:[]},H4n="wrapper";function Y4n(e){let{components:n,...t}=e;return(0,s.yg)(H4n,(0,p.A)({},j4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}Y4n.isMDXComponent=!0;const Q4n={toc:[]},$4n="wrapper";function K4n(e){let{components:n,...t}=e;return(0,s.yg)($4n,(0,p.A)({},Q4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}K4n.isMDXComponent=!0;const J4n={toc:[]},Z4n="wrapper";function e6n(e){let{components:n,...t}=e;return(0,s.yg)(Z4n,(0,p.A)({},J4n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}e6n.isMDXComponent=!0;const n6n={toc:[]},t6n="wrapper";function o6n(e){let{components:n,...t}=e;return(0,s.yg)(t6n,(0,p.A)({},n6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}o6n.isMDXComponent=!0;const p6n={toc:[]},r6n="wrapper";function s6n(e){let{components:n,...t}=e;return(0,s.yg)(r6n,(0,p.A)({},p6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}s6n.isMDXComponent=!0;const c6n={toc:[]},a6n="wrapper";function i6n(e){let{components:n,...t}=e;return(0,s.yg)(a6n,(0,p.A)({},c6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}i6n.isMDXComponent=!0;const l6n={toc:[]},u6n="wrapper";function m6n(e){let{components:n,...t}=e;return(0,s.yg)(u6n,(0,p.A)({},l6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}m6n.isMDXComponent=!0;const y6n={toc:[]},d6n="wrapper";function h6n(e){let{components:n,...t}=e;return(0,s.yg)(d6n,(0,p.A)({},y6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}h6n.isMDXComponent=!0;const g6n={toc:[]},f6n="wrapper";function D6n(e){let{components:n,...t}=e;return(0,s.yg)(f6n,(0,p.A)({},g6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}D6n.isMDXComponent=!0;const M6n={toc:[]},X6n="wrapper";function _6n(e){let{components:n,...t}=e;return(0,s.yg)(X6n,(0,p.A)({},M6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}_6n.isMDXComponent=!0;const w6n={toc:[]},T6n="wrapper";function C6n(e){let{components:n,...t}=e;return(0,s.yg)(T6n,(0,p.A)({},w6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}C6n.isMDXComponent=!0;const x6n={toc:[]},A6n="wrapper";function v6n(e){let{components:n,...t}=e;return(0,s.yg)(A6n,(0,p.A)({},x6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}v6n.isMDXComponent=!0;const L6n={toc:[]},b6n="wrapper";function N6n(e){let{components:n,...t}=e;return(0,s.yg)(b6n,(0,p.A)({},L6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}N6n.isMDXComponent=!0;const k6n={toc:[]},z6n="wrapper";function P6n(e){let{components:n,...t}=e;return(0,s.yg)(z6n,(0,p.A)({},k6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}P6n.isMDXComponent=!0;const I6n={toc:[]},R6n="wrapper";function W6n(e){let{components:n,...t}=e;return(0,s.yg)(R6n,(0,p.A)({},I6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}W6n.isMDXComponent=!0;const S6n={toc:[]},B6n="wrapper";function E6n(e){let{components:n,...t}=e;return(0,s.yg)(B6n,(0,p.A)({},S6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}E6n.isMDXComponent=!0;const G6n={toc:[]},O6n="wrapper";function U6n(e){let{components:n,...t}=e;return(0,s.yg)(O6n,(0,p.A)({},G6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}U6n.isMDXComponent=!0;const F6n={toc:[]},V6n="wrapper";function q6n(e){let{components:n,...t}=e;return(0,s.yg)(V6n,(0,p.A)({},F6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}q6n.isMDXComponent=!0;const j6n={toc:[]},H6n="wrapper";function Y6n(e){let{components:n,...t}=e;return(0,s.yg)(H6n,(0,p.A)({},j6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Y6n.isMDXComponent=!0;const Q6n={toc:[]},$6n="wrapper";function K6n(e){let{components:n,...t}=e;return(0,s.yg)($6n,(0,p.A)({},Q6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}K6n.isMDXComponent=!0;const J6n={toc:[]},Z6n="wrapper";function e8n(e){let{components:n,...t}=e;return(0,s.yg)(Z6n,(0,p.A)({},J6n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}e8n.isMDXComponent=!0;const n8n={toc:[]},t8n="wrapper";function o8n(e){let{components:n,...t}=e;return(0,s.yg)(t8n,(0,p.A)({},n8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}o8n.isMDXComponent=!0;const p8n={toc:[]},r8n="wrapper";function s8n(e){let{components:n,...t}=e;return(0,s.yg)(r8n,(0,p.A)({},p8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}s8n.isMDXComponent=!0;const c8n={toc:[]},a8n="wrapper";function i8n(e){let{components:n,...t}=e;return(0,s.yg)(a8n,(0,p.A)({},c8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}i8n.isMDXComponent=!0;const l8n={toc:[]},u8n="wrapper";function m8n(e){let{components:n,...t}=e;return(0,s.yg)(u8n,(0,p.A)({},l8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}m8n.isMDXComponent=!0;const y8n={toc:[]},d8n="wrapper";function h8n(e){let{components:n,...t}=e;return(0,s.yg)(d8n,(0,p.A)({},y8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}h8n.isMDXComponent=!0;const g8n={toc:[]},f8n="wrapper";function D8n(e){let{components:n,...t}=e;return(0,s.yg)(f8n,(0,p.A)({},g8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}D8n.isMDXComponent=!0;const M8n={toc:[]},X8n="wrapper";function _8n(e){let{components:n,...t}=e;return(0,s.yg)(X8n,(0,p.A)({},M8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}_8n.isMDXComponent=!0;const w8n={toc:[]},T8n="wrapper";function C8n(e){let{components:n,...t}=e;return(0,s.yg)(T8n,(0,p.A)({},w8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}C8n.isMDXComponent=!0;const x8n={toc:[]},A8n="wrapper";function v8n(e){let{components:n,...t}=e;return(0,s.yg)(A8n,(0,p.A)({},x8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}v8n.isMDXComponent=!0;const L8n={toc:[]},b8n="wrapper";function N8n(e){let{components:n,...t}=e;return(0,s.yg)(b8n,(0,p.A)({},L8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}N8n.isMDXComponent=!0;const k8n={toc:[]},z8n="wrapper";function P8n(e){let{components:n,...t}=e;return(0,s.yg)(z8n,(0,p.A)({},k8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}P8n.isMDXComponent=!0;const I8n={toc:[]},R8n="wrapper";function W8n(e){let{components:n,...t}=e;return(0,s.yg)(R8n,(0,p.A)({},I8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Latex#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}W8n.isMDXComponent=!0;const S8n={toc:[]},B8n="wrapper";function E8n(e){let{components:n,...t}=e;return(0,s.yg)(B8n,(0,p.A)({},S8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}E8n.isMDXComponent=!0;const G8n={toc:[]},O8n="wrapper";function U8n(e){let{components:n,...t}=e;return(0,s.yg)(O8n,(0,p.A)({},G8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}U8n.isMDXComponent=!0;const F8n={toc:[]},V8n="wrapper";function q8n(e){let{components:n,...t}=e;return(0,s.yg)(V8n,(0,p.A)({},F8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}q8n.isMDXComponent=!0;const j8n={toc:[]},H8n="wrapper";function Y8n(e){let{components:n,...t}=e;return(0,s.yg)(H8n,(0,p.A)({},j8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}Y8n.isMDXComponent=!0;const Q8n={toc:[]},$8n="wrapper";function K8n(e){let{components:n,...t}=e;return(0,s.yg)($8n,(0,p.A)({},Q8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}K8n.isMDXComponent=!0;const J8n={toc:[]},Z8n="wrapper";function e5n(e){let{components:n,...t}=e;return(0,s.yg)(Z8n,(0,p.A)({},J8n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}e5n.isMDXComponent=!0;const n5n={toc:[]},t5n="wrapper";function o5n(e){let{components:n,...t}=e;return(0,s.yg)(t5n,(0,p.A)({},n5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}o5n.isMDXComponent=!0;const p5n={toc:[]},r5n="wrapper";function s5n(e){let{components:n,...t}=e;return(0,s.yg)(r5n,(0,p.A)({},p5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}s5n.isMDXComponent=!0;const c5n={toc:[]},a5n="wrapper";function i5n(e){let{components:n,...t}=e;return(0,s.yg)(a5n,(0,p.A)({},c5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}i5n.isMDXComponent=!0;const l5n={toc:[]},u5n="wrapper";function m5n(e){let{components:n,...t}=e;return(0,s.yg)(u5n,(0,p.A)({},l5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}m5n.isMDXComponent=!0;const y5n={toc:[]},d5n="wrapper";function h5n(e){let{components:n,...t}=e;return(0,s.yg)(d5n,(0,p.A)({},y5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}h5n.isMDXComponent=!0;const g5n={toc:[]},f5n="wrapper";function D5n(e){let{components:n,...t}=e;return(0,s.yg)(f5n,(0,p.A)({},g5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}D5n.isMDXComponent=!0;const M5n={toc:[]},X5n="wrapper";function _5n(e){let{components:n,...t}=e;return(0,s.yg)(X5n,(0,p.A)({},M5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}_5n.isMDXComponent=!0;const w5n={toc:[]},T5n="wrapper";function C5n(e){let{components:n,...t}=e;return(0,s.yg)(T5n,(0,p.A)({},w5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}C5n.isMDXComponent=!0;const x5n={toc:[]},A5n="wrapper";function v5n(e){let{components:n,...t}=e;return(0,s.yg)(A5n,(0,p.A)({},x5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}v5n.isMDXComponent=!0;const L5n={toc:[]},b5n="wrapper";function N5n(e){let{components:n,...t}=e;return(0,s.yg)(b5n,(0,p.A)({},L5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}N5n.isMDXComponent=!0;const k5n={toc:[]},z5n="wrapper";function P5n(e){let{components:n,...t}=e;return(0,s.yg)(z5n,(0,p.A)({},k5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}P5n.isMDXComponent=!0;const I5n={toc:[]},R5n="wrapper";function W5n(e){let{components:n,...t}=e;return(0,s.yg)(R5n,(0,p.A)({},I5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}W5n.isMDXComponent=!0;const S5n={toc:[]},B5n="wrapper";function E5n(e){let{components:n,...t}=e;return(0,s.yg)(B5n,(0,p.A)({},S5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}E5n.isMDXComponent=!0;const G5n={toc:[]},O5n="wrapper";function U5n(e){let{components:n,...t}=e;return(0,s.yg)(O5n,(0,p.A)({},G5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}U5n.isMDXComponent=!0;const F5n={toc:[]},V5n="wrapper";function q5n(e){let{components:n,...t}=e;return(0,s.yg)(V5n,(0,p.A)({},F5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}q5n.isMDXComponent=!0;const j5n={toc:[]},H5n="wrapper";function Y5n(e){let{components:n,...t}=e;return(0,s.yg)(H5n,(0,p.A)({},j5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Y5n.isMDXComponent=!0;const Q5n={toc:[]},$5n="wrapper";function K5n(e){let{components:n,...t}=e;return(0,s.yg)($5n,(0,p.A)({},Q5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}K5n.isMDXComponent=!0;const J5n={toc:[]},Z5n="wrapper";function e7n(e){let{components:n,...t}=e;return(0,s.yg)(Z5n,(0,p.A)({},J5n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}e7n.isMDXComponent=!0;const n7n={toc:[]},t7n="wrapper";function o7n(e){let{components:n,...t}=e;return(0,s.yg)(t7n,(0,p.A)({},n7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}o7n.isMDXComponent=!0;const p7n={toc:[]},r7n="wrapper";function s7n(e){let{components:n,...t}=e;return(0,s.yg)(r7n,(0,p.A)({},p7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}s7n.isMDXComponent=!0;const c7n={toc:[]},a7n="wrapper";function i7n(e){let{components:n,...t}=e;return(0,s.yg)(a7n,(0,p.A)({},c7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}i7n.isMDXComponent=!0;const l7n={toc:[]},u7n="wrapper";function m7n(e){let{components:n,...t}=e;return(0,s.yg)(u7n,(0,p.A)({},l7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}m7n.isMDXComponent=!0;const y7n={toc:[]},d7n="wrapper";function h7n(e){let{components:n,...t}=e;return(0,s.yg)(d7n,(0,p.A)({},y7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}h7n.isMDXComponent=!0;const g7n={toc:[]},f7n="wrapper";function D7n(e){let{components:n,...t}=e;return(0,s.yg)(f7n,(0,p.A)({},g7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}D7n.isMDXComponent=!0;const M7n={toc:[]},X7n="wrapper";function _7n(e){let{components:n,...t}=e;return(0,s.yg)(X7n,(0,p.A)({},M7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}_7n.isMDXComponent=!0;const w7n={toc:[]},T7n="wrapper";function C7n(e){let{components:n,...t}=e;return(0,s.yg)(T7n,(0,p.A)({},w7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}C7n.isMDXComponent=!0;const x7n={toc:[]},A7n="wrapper";function v7n(e){let{components:n,...t}=e;return(0,s.yg)(A7n,(0,p.A)({},x7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}v7n.isMDXComponent=!0;const L7n={toc:[]},b7n="wrapper";function N7n(e){let{components:n,...t}=e;return(0,s.yg)(b7n,(0,p.A)({},L7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}N7n.isMDXComponent=!0;const k7n={toc:[]},z7n="wrapper";function P7n(e){let{components:n,...t}=e;return(0,s.yg)(z7n,(0,p.A)({},k7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}P7n.isMDXComponent=!0;const I7n={toc:[]},R7n="wrapper";function W7n(e){let{components:n,...t}=e;return(0,s.yg)(R7n,(0,p.A)({},I7n,t,{components:n,mdxType:"MDXLayout"}))}W7n.isMDXComponent=!0;const S7n={toc:[]},B7n="wrapper";function E7n(e){let{components:n,...t}=e;return(0,s.yg)(B7n,(0,p.A)({},S7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}E7n.isMDXComponent=!0;const G7n={toc:[]},O7n="wrapper";function U7n(e){let{components:n,...t}=e;return(0,s.yg)(O7n,(0,p.A)({},G7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}U7n.isMDXComponent=!0;const F7n={toc:[]},V7n="wrapper";function q7n(e){let{components:n,...t}=e;return(0,s.yg)(V7n,(0,p.A)({},F7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}q7n.isMDXComponent=!0;const j7n={toc:[]},H7n="wrapper";function Y7n(e){let{components:n,...t}=e;return(0,s.yg)(H7n,(0,p.A)({},j7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Y7n.isMDXComponent=!0;const Q7n={toc:[]},$7n="wrapper";function K7n(e){let{components:n,...t}=e;return(0,s.yg)($7n,(0,p.A)({},Q7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}K7n.isMDXComponent=!0;const J7n={toc:[]},Z7n="wrapper";function eet(e){let{components:n,...t}=e;return(0,s.yg)(Z7n,(0,p.A)({},J7n,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}eet.isMDXComponent=!0;const net={toc:[]},tet="wrapper";function oet(e){let{components:n,...t}=e;return(0,s.yg)(tet,(0,p.A)({},net,t,{components:n,mdxType:"MDXLayout"}))}oet.isMDXComponent=!0;const pet={toc:[]},ret="wrapper";function set(e){let{components:n,...t}=e;return(0,s.yg)(ret,(0,p.A)({},pet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}set.isMDXComponent=!0;const cet={toc:[]},aet="wrapper";function iet(e){let{components:n,...t}=e;return(0,s.yg)(aet,(0,p.A)({},cet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}iet.isMDXComponent=!0;const uet={toc:[]},met="wrapper";function yet(e){let{components:n,...t}=e;return(0,s.yg)(met,(0,p.A)({},uet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}yet.isMDXComponent=!0;const det={toc:[]},het="wrapper";function get(e){let{components:n,...t}=e;return(0,s.yg)(het,(0,p.A)({},det,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}get.isMDXComponent=!0;const fet={toc:[]},Det="wrapper";function Met(e){let{components:n,...t}=e;return(0,s.yg)(Det,(0,p.A)({},fet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Met.isMDXComponent=!0;const Xet={toc:[]},_et="wrapper";function wet(e){let{components:n,...t}=e;return(0,s.yg)(_et,(0,p.A)({},Xet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}wet.isMDXComponent=!0;const Tet={toc:[]},Cet="wrapper";function xet(e){let{components:n,...t}=e;return(0,s.yg)(Cet,(0,p.A)({},Tet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}xet.isMDXComponent=!0;const Aet={toc:[]},vet="wrapper";function Let(e){let{components:n,...t}=e;return(0,s.yg)(vet,(0,p.A)({},Aet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Let.isMDXComponent=!0;const bet={toc:[]},Net="wrapper";function ket(e){let{components:n,...t}=e;return(0,s.yg)(Net,(0,p.A)({},bet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}ket.isMDXComponent=!0;const zet={toc:[]},Pet="wrapper";function Iet(e){let{components:n,...t}=e;return(0,s.yg)(Pet,(0,p.A)({},zet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}Iet.isMDXComponent=!0;const Ret={toc:[]},Wet="wrapper";function Set(e){let{components:n,...t}=e;return(0,s.yg)(Wet,(0,p.A)({},Ret,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Set.isMDXComponent=!0;const Bet={toc:[]},Eet="wrapper";function Get(e){let{components:n,...t}=e;return(0,s.yg)(Eet,(0,p.A)({},Bet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}Get.isMDXComponent=!0;const Oet={toc:[]},Uet="wrapper";function Fet(e){let{components:n,...t}=e;return(0,s.yg)(Uet,(0,p.A)({},Oet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Fet.isMDXComponent=!0;const Vet={toc:[]},qet="wrapper";function jet(e){let{components:n,...t}=e;return(0,s.yg)(qet,(0,p.A)({},Vet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}jet.isMDXComponent=!0;const Het={toc:[]},Yet="wrapper";function Qet(e){let{components:n,...t}=e;return(0,s.yg)(Yet,(0,p.A)({},Het,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Qet.isMDXComponent=!0;const $et={toc:[]},Ket="wrapper";function Jet(e){let{components:n,...t}=e;return(0,s.yg)(Ket,(0,p.A)({},$et,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Jet.isMDXComponent=!0;const Zet={toc:[]},ent="wrapper";function nnt(e){let{components:n,...t}=e;return(0,s.yg)(ent,(0,p.A)({},Zet,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}nnt.isMDXComponent=!0;const tnt={toc:[]},ont="wrapper";function pnt(e){let{components:n,...t}=e;return(0,s.yg)(ont,(0,p.A)({},tnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}pnt.isMDXComponent=!0;const rnt={toc:[]},snt="wrapper";function cnt(e){let{components:n,...t}=e;return(0,s.yg)(snt,(0,p.A)({},rnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}cnt.isMDXComponent=!0;const ant={toc:[]},int="wrapper";function lnt(e){let{components:n,...t}=e;return(0,s.yg)(int,(0,p.A)({},ant,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}lnt.isMDXComponent=!0;const unt={toc:[]},mnt="wrapper";function ynt(e){let{components:n,...t}=e;return(0,s.yg)(mnt,(0,p.A)({},unt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}ynt.isMDXComponent=!0;const dnt={toc:[]},hnt="wrapper";function gnt(e){let{components:n,...t}=e;return(0,s.yg)(hnt,(0,p.A)({},dnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}gnt.isMDXComponent=!0;const fnt={toc:[]},Dnt="wrapper";function Mnt(e){let{components:n,...t}=e;return(0,s.yg)(Dnt,(0,p.A)({},fnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Mnt.isMDXComponent=!0;const Xnt={toc:[]},_nt="wrapper";function wnt(e){let{components:n,...t}=e;return(0,s.yg)(_nt,(0,p.A)({},Xnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}wnt.isMDXComponent=!0;const Tnt={toc:[]},Cnt="wrapper";function xnt(e){let{components:n,...t}=e;return(0,s.yg)(Cnt,(0,p.A)({},Tnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}xnt.isMDXComponent=!0;const Ant={toc:[]},vnt="wrapper";function Lnt(e){let{components:n,...t}=e;return(0,s.yg)(vnt,(0,p.A)({},Ant,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}Lnt.isMDXComponent=!0;const bnt={toc:[]},Nnt="wrapper";function knt(e){let{components:n,...t}=e;return(0,s.yg)(Nnt,(0,p.A)({},bnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}knt.isMDXComponent=!0;const znt={toc:[]},Pnt="wrapper";function Int(e){let{components:n,...t}=e;return(0,s.yg)(Pnt,(0,p.A)({},znt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}Int.isMDXComponent=!0;const Rnt={toc:[]},Wnt="wrapper";function Snt(e){let{components:n,...t}=e;return(0,s.yg)(Wnt,(0,p.A)({},Rnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Snt.isMDXComponent=!0;const Bnt={toc:[]},Ent="wrapper";function Gnt(e){let{components:n,...t}=e;return(0,s.yg)(Ent,(0,p.A)({},Bnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}Gnt.isMDXComponent=!0;const Ont={toc:[]},Unt="wrapper";function Fnt(e){let{components:n,...t}=e;return(0,s.yg)(Unt,(0,p.A)({},Ont,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Fnt.isMDXComponent=!0;const Vnt={toc:[]},qnt="wrapper";function jnt(e){let{components:n,...t}=e;return(0,s.yg)(qnt,(0,p.A)({},Vnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}jnt.isMDXComponent=!0;const Hnt={toc:[]},Ynt="wrapper";function Qnt(e){let{components:n,...t}=e;return(0,s.yg)(Ynt,(0,p.A)({},Hnt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Qnt.isMDXComponent=!0;const $nt={toc:[]},Knt="wrapper";function Jnt(e){let{components:n,...t}=e;return(0,s.yg)(Knt,(0,p.A)({},$nt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Jnt.isMDXComponent=!0;const Znt={toc:[]},ett="wrapper";function ntt(e){let{components:n,...t}=e;return(0,s.yg)(ett,(0,p.A)({},Znt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}ntt.isMDXComponent=!0;const ttt={toc:[]},ott="wrapper";function ptt(e){let{components:n,...t}=e;return(0,s.yg)(ott,(0,p.A)({},ttt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}ptt.isMDXComponent=!0;const rtt={toc:[]},stt="wrapper";function ctt(e){let{components:n,...t}=e;return(0,s.yg)(stt,(0,p.A)({},rtt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}ctt.isMDXComponent=!0;const att={toc:[]},itt="wrapper";function ltt(e){let{components:n,...t}=e;return(0,s.yg)(itt,(0,p.A)({},att,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}ltt.isMDXComponent=!0;const utt={toc:[]},mtt="wrapper";function ytt(e){let{components:n,...t}=e;return(0,s.yg)(mtt,(0,p.A)({},utt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}ytt.isMDXComponent=!0;const dtt={toc:[]},htt="wrapper";function gtt(e){let{components:n,...t}=e;return(0,s.yg)(htt,(0,p.A)({},dtt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}gtt.isMDXComponent=!0;const ftt={toc:[]},Dtt="wrapper";function Mtt(e){let{components:n,...t}=e;return(0,s.yg)(Dtt,(0,p.A)({},ftt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Mtt.isMDXComponent=!0;const Xtt={toc:[]},_tt="wrapper";function wtt(e){let{components:n,...t}=e;return(0,s.yg)(_tt,(0,p.A)({},Xtt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}wtt.isMDXComponent=!0;const Ttt={toc:[]},Ctt="wrapper";function xtt(e){let{components:n,...t}=e;return(0,s.yg)(Ctt,(0,p.A)({},Ttt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}xtt.isMDXComponent=!0;const Att={toc:[]},vtt="wrapper";function Ltt(e){let{components:n,...t}=e;return(0,s.yg)(vtt,(0,p.A)({},Att,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Ltt.isMDXComponent=!0;const btt={toc:[]},Ntt="wrapper";function ktt(e){let{components:n,...t}=e;return(0,s.yg)(Ntt,(0,p.A)({},btt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}ktt.isMDXComponent=!0;const ztt={toc:[]},Ptt="wrapper";function Itt(e){let{components:n,...t}=e;return(0,s.yg)(Ptt,(0,p.A)({},ztt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Itt.isMDXComponent=!0;const Rtt={toc:[]},Wtt="wrapper";function Stt(e){let{components:n,...t}=e;return(0,s.yg)(Wtt,(0,p.A)({},Rtt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Stt.isMDXComponent=!0;const Btt={toc:[]},Ett="wrapper";function Gtt(e){let{components:n,...t}=e;return(0,s.yg)(Ett,(0,p.A)({},Btt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Gtt.isMDXComponent=!0;const Ott={toc:[]},Utt="wrapper";function Ftt(e){let{components:n,...t}=e;return(0,s.yg)(Utt,(0,p.A)({},Ott,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Ftt.isMDXComponent=!0;const Vtt={toc:[]},qtt="wrapper";function jtt(e){let{components:n,...t}=e;return(0,s.yg)(qtt,(0,p.A)({},Vtt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}jtt.isMDXComponent=!0;const Htt={toc:[]},Ytt="wrapper";function Qtt(e){let{components:n,...t}=e;return(0,s.yg)(Ytt,(0,p.A)({},Htt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Qtt.isMDXComponent=!0;const $tt={toc:[]},Ktt="wrapper";function Jtt(e){let{components:n,...t}=e;return(0,s.yg)(Ktt,(0,p.A)({},$tt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Jtt.isMDXComponent=!0;const Ztt={toc:[]},eot="wrapper";function not(e){let{components:n,...t}=e;return(0,s.yg)(eot,(0,p.A)({},Ztt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}not.isMDXComponent=!0;const tot={toc:[]},oot="wrapper";function pot(e){let{components:n,...t}=e;return(0,s.yg)(oot,(0,p.A)({},tot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}pot.isMDXComponent=!0;const rot={toc:[]},sot="wrapper";function cot(e){let{components:n,...t}=e;return(0,s.yg)(sot,(0,p.A)({},rot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}cot.isMDXComponent=!0;const aot={toc:[]},iot="wrapper";function lot(e){let{components:n,...t}=e;return(0,s.yg)(iot,(0,p.A)({},aot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}lot.isMDXComponent=!0;const uot={toc:[]},mot="wrapper";function yot(e){let{components:n,...t}=e;return(0,s.yg)(mot,(0,p.A)({},uot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}yot.isMDXComponent=!0;const dot={toc:[]},hot="wrapper";function got(e){let{components:n,...t}=e;return(0,s.yg)(hot,(0,p.A)({},dot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}got.isMDXComponent=!0;const fot={toc:[]},Dot="wrapper";function Mot(e){let{components:n,...t}=e;return(0,s.yg)(Dot,(0,p.A)({},fot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}Mot.isMDXComponent=!0;const Xot={toc:[]},_ot="wrapper";function wot(e){let{components:n,...t}=e;return(0,s.yg)(_ot,(0,p.A)({},Xot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}wot.isMDXComponent=!0;const Tot={toc:[]},Cot="wrapper";function xot(e){let{components:n,...t}=e;return(0,s.yg)(Cot,(0,p.A)({},Tot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}xot.isMDXComponent=!0;const Aot={toc:[]},vot="wrapper";function Lot(e){let{components:n,...t}=e;return(0,s.yg)(vot,(0,p.A)({},Aot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Lot.isMDXComponent=!0;const bot={toc:[]},Not="wrapper";function kot(e){let{components:n,...t}=e;return(0,s.yg)(Not,(0,p.A)({},bot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}kot.isMDXComponent=!0;const zot={toc:[]},Pot="wrapper";function Iot(e){let{components:n,...t}=e;return(0,s.yg)(Pot,(0,p.A)({},zot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}Iot.isMDXComponent=!0;const Rot={toc:[]},Wot="wrapper";function Sot(e){let{components:n,...t}=e;return(0,s.yg)(Wot,(0,p.A)({},Rot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}Sot.isMDXComponent=!0;const Bot={toc:[]},Eot="wrapper";function Got(e){let{components:n,...t}=e;return(0,s.yg)(Eot,(0,p.A)({},Bot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}Got.isMDXComponent=!0;const Oot={toc:[]},Uot="wrapper";function Fot(e){let{components:n,...t}=e;return(0,s.yg)(Uot,(0,p.A)({},Oot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}Fot.isMDXComponent=!0;const Vot={toc:[]},qot="wrapper";function jot(e){let{components:n,...t}=e;return(0,s.yg)(qot,(0,p.A)({},Vot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}jot.isMDXComponent=!0;const Hot={toc:[]},Yot="wrapper";function Qot(e){let{components:n,...t}=e;return(0,s.yg)(Yot,(0,p.A)({},Hot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}Qot.isMDXComponent=!0;const $ot={toc:[]},Kot="wrapper";function Jot(e){let{components:n,...t}=e;return(0,s.yg)(Kot,(0,p.A)({},$ot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Jot.isMDXComponent=!0;const Zot={toc:[]},ept="wrapper";function npt(e){let{components:n,...t}=e;return(0,s.yg)(ept,(0,p.A)({},Zot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}npt.isMDXComponent=!0;const tpt={toc:[]},opt="wrapper";function ppt(e){let{components:n,...t}=e;return(0,s.yg)(opt,(0,p.A)({},tpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}ppt.isMDXComponent=!0;const rpt={toc:[]},spt="wrapper";function cpt(e){let{components:n,...t}=e;return(0,s.yg)(spt,(0,p.A)({},rpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}cpt.isMDXComponent=!0;const apt={toc:[]},ipt="wrapper";function lpt(e){let{components:n,...t}=e;return(0,s.yg)(ipt,(0,p.A)({},apt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}lpt.isMDXComponent=!0;const upt={toc:[]},mpt="wrapper";function ypt(e){let{components:n,...t}=e;return(0,s.yg)(mpt,(0,p.A)({},upt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}ypt.isMDXComponent=!0;const dpt={toc:[]},hpt="wrapper";function gpt(e){let{components:n,...t}=e;return(0,s.yg)(hpt,(0,p.A)({},dpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}gpt.isMDXComponent=!0;const fpt={toc:[]},Dpt="wrapper";function Mpt(e){let{components:n,...t}=e;return(0,s.yg)(Dpt,(0,p.A)({},fpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}Mpt.isMDXComponent=!0;const Xpt={toc:[]},_pt="wrapper";function wpt(e){let{components:n,...t}=e;return(0,s.yg)(_pt,(0,p.A)({},Xpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}wpt.isMDXComponent=!0;const Tpt={toc:[]},Cpt="wrapper";function xpt(e){let{components:n,...t}=e;return(0,s.yg)(Cpt,(0,p.A)({},Tpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}xpt.isMDXComponent=!0;const Apt={toc:[]},vpt="wrapper";function Lpt(e){let{components:n,...t}=e;return(0,s.yg)(vpt,(0,p.A)({},Apt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Lpt.isMDXComponent=!0;const bpt={toc:[]},Npt="wrapper";function kpt(e){let{components:n,...t}=e;return(0,s.yg)(Npt,(0,p.A)({},bpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}kpt.isMDXComponent=!0;const zpt={toc:[]},Ppt="wrapper";function Ipt(e){let{components:n,...t}=e;return(0,s.yg)(Ppt,(0,p.A)({},zpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Ipt.isMDXComponent=!0;const Rpt={toc:[]},Wpt="wrapper";function Spt(e){let{components:n,...t}=e;return(0,s.yg)(Wpt,(0,p.A)({},Rpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}Spt.isMDXComponent=!0;const Bpt={toc:[]},Ept="wrapper";function Gpt(e){let{components:n,...t}=e;return(0,s.yg)(Ept,(0,p.A)({},Bpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Gpt.isMDXComponent=!0;const Opt={toc:[]},Upt="wrapper";function Fpt(e){let{components:n,...t}=e;return(0,s.yg)(Upt,(0,p.A)({},Opt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Fpt.isMDXComponent=!0;const Vpt={toc:[]},qpt="wrapper";function jpt(e){let{components:n,...t}=e;return(0,s.yg)(qpt,(0,p.A)({},Vpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}jpt.isMDXComponent=!0;const Hpt={toc:[]},Ypt="wrapper";function Qpt(e){let{components:n,...t}=e;return(0,s.yg)(Ypt,(0,p.A)({},Hpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}Qpt.isMDXComponent=!0;const $pt={toc:[]},Kpt="wrapper";function Jpt(e){let{components:n,...t}=e;return(0,s.yg)(Kpt,(0,p.A)({},$pt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Jpt.isMDXComponent=!0;const Zpt={toc:[]},ert="wrapper";function nrt(e){let{components:n,...t}=e;return(0,s.yg)(ert,(0,p.A)({},Zpt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}nrt.isMDXComponent=!0;const trt={toc:[]},ort="wrapper";function prt(e){let{components:n,...t}=e;return(0,s.yg)(ort,(0,p.A)({},trt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}prt.isMDXComponent=!0;const rrt={toc:[]},srt="wrapper";function crt(e){let{components:n,...t}=e;return(0,s.yg)(srt,(0,p.A)({},rrt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}crt.isMDXComponent=!0;const art={toc:[]},irt="wrapper";function lrt(e){let{components:n,...t}=e;return(0,s.yg)(irt,(0,p.A)({},art,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}lrt.isMDXComponent=!0;const urt={toc:[]},mrt="wrapper";function yrt(e){let{components:n,...t}=e;return(0,s.yg)(mrt,(0,p.A)({},urt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}yrt.isMDXComponent=!0;const drt={toc:[]},hrt="wrapper";function grt(e){let{components:n,...t}=e;return(0,s.yg)(hrt,(0,p.A)({},drt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}grt.isMDXComponent=!0;const frt={toc:[]},Drt="wrapper";function Mrt(e){let{components:n,...t}=e;return(0,s.yg)(Drt,(0,p.A)({},frt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Mrt.isMDXComponent=!0;const Xrt={toc:[]},_rt="wrapper";function wrt(e){let{components:n,...t}=e;return(0,s.yg)(_rt,(0,p.A)({},Xrt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}wrt.isMDXComponent=!0;const Trt={toc:[]},Crt="wrapper";function xrt(e){let{components:n,...t}=e;return(0,s.yg)(Crt,(0,p.A)({},Trt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}xrt.isMDXComponent=!0;const Art={toc:[]},vrt="wrapper";function Lrt(e){let{components:n,...t}=e;return(0,s.yg)(vrt,(0,p.A)({},Art,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}Lrt.isMDXComponent=!0;const brt={toc:[]},Nrt="wrapper";function krt(e){let{components:n,...t}=e;return(0,s.yg)(Nrt,(0,p.A)({},brt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}krt.isMDXComponent=!0;const zrt={toc:[]},Prt="wrapper";function Irt(e){let{components:n,...t}=e;return(0,s.yg)(Prt,(0,p.A)({},zrt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Irt.isMDXComponent=!0;const Rrt={toc:[]},Wrt="wrapper";function Srt(e){let{components:n,...t}=e;return(0,s.yg)(Wrt,(0,p.A)({},Rrt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}Srt.isMDXComponent=!0;const Brt={toc:[]},Ert="wrapper";function Grt(e){let{components:n,...t}=e;return(0,s.yg)(Ert,(0,p.A)({},Brt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}Grt.isMDXComponent=!0;const Ort={toc:[]},Urt="wrapper";function Frt(e){let{components:n,...t}=e;return(0,s.yg)(Urt,(0,p.A)({},Ort,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}Frt.isMDXComponent=!0;const Vrt={toc:[]},qrt="wrapper";function jrt(e){let{components:n,...t}=e;return(0,s.yg)(qrt,(0,p.A)({},Vrt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}jrt.isMDXComponent=!0;const Hrt={toc:[]},Yrt="wrapper";function Qrt(e){let{components:n,...t}=e;return(0,s.yg)(Yrt,(0,p.A)({},Hrt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}Qrt.isMDXComponent=!0;const $rt={toc:[]},Krt="wrapper";function Jrt(e){let{components:n,...t}=e;return(0,s.yg)(Krt,(0,p.A)({},$rt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Jrt.isMDXComponent=!0;const Zrt={toc:[]},est="wrapper";function nst(e){let{components:n,...t}=e;return(0,s.yg)(est,(0,p.A)({},Zrt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}nst.isMDXComponent=!0;const tst={toc:[]},ost="wrapper";function pst(e){let{components:n,...t}=e;return(0,s.yg)(ost,(0,p.A)({},tst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}pst.isMDXComponent=!0;const rst={toc:[]},sst="wrapper";function cst(e){let{components:n,...t}=e;return(0,s.yg)(sst,(0,p.A)({},rst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}cst.isMDXComponent=!0;const ast={toc:[]},ist="wrapper";function lst(e){let{components:n,...t}=e;return(0,s.yg)(ist,(0,p.A)({},ast,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}lst.isMDXComponent=!0;const ust={toc:[]},mst="wrapper";function yst(e){let{components:n,...t}=e;return(0,s.yg)(mst,(0,p.A)({},ust,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}yst.isMDXComponent=!0;const dst={toc:[]},hst="wrapper";function gst(e){let{components:n,...t}=e;return(0,s.yg)(hst,(0,p.A)({},dst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}gst.isMDXComponent=!0;const fst={toc:[]},Dst="wrapper";function Mst(e){let{components:n,...t}=e;return(0,s.yg)(Dst,(0,p.A)({},fst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Mst.isMDXComponent=!0;const Xst={toc:[]},_st="wrapper";function wst(e){let{components:n,...t}=e;return(0,s.yg)(_st,(0,p.A)({},Xst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}wst.isMDXComponent=!0;const Tst={toc:[]},Cst="wrapper";function xst(e){let{components:n,...t}=e;return(0,s.yg)(Cst,(0,p.A)({},Tst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}xst.isMDXComponent=!0;const Ast={toc:[]},vst="wrapper";function Lst(e){let{components:n,...t}=e;return(0,s.yg)(vst,(0,p.A)({},Ast,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}Lst.isMDXComponent=!0;const bst={toc:[]},Nst="wrapper";function kst(e){let{components:n,...t}=e;return(0,s.yg)(Nst,(0,p.A)({},bst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}kst.isMDXComponent=!0;const zst={toc:[]},Pst="wrapper";function Ist(e){let{components:n,...t}=e;return(0,s.yg)(Pst,(0,p.A)({},zst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Ist.isMDXComponent=!0;const Rst={toc:[]},Wst="wrapper";function Sst(e){let{components:n,...t}=e;return(0,s.yg)(Wst,(0,p.A)({},Rst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Sst.isMDXComponent=!0;const Bst={toc:[]},Est="wrapper";function Gst(e){let{components:n,...t}=e;return(0,s.yg)(Est,(0,p.A)({},Bst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}Gst.isMDXComponent=!0;const Ost={toc:[]},Ust="wrapper";function Fst(e){let{components:n,...t}=e;return(0,s.yg)(Ust,(0,p.A)({},Ost,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Fst.isMDXComponent=!0;const Vst={toc:[]},qst="wrapper";function jst(e){let{components:n,...t}=e;return(0,s.yg)(qst,(0,p.A)({},Vst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}jst.isMDXComponent=!0;const Hst={toc:[]},Yst="wrapper";function Qst(e){let{components:n,...t}=e;return(0,s.yg)(Yst,(0,p.A)({},Hst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}Qst.isMDXComponent=!0;const $st={toc:[]},Kst="wrapper";function Jst(e){let{components:n,...t}=e;return(0,s.yg)(Kst,(0,p.A)({},$st,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Jst.isMDXComponent=!0;const Zst={toc:[]},ect="wrapper";function nct(e){let{components:n,...t}=e;return(0,s.yg)(ect,(0,p.A)({},Zst,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}nct.isMDXComponent=!0;const tct={toc:[]},oct="wrapper";function pct(e){let{components:n,...t}=e;return(0,s.yg)(oct,(0,p.A)({},tct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}pct.isMDXComponent=!0;const rct={toc:[]},sct="wrapper";function cct(e){let{components:n,...t}=e;return(0,s.yg)(sct,(0,p.A)({},rct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}cct.isMDXComponent=!0;const act={toc:[]},ict="wrapper";function lct(e){let{components:n,...t}=e;return(0,s.yg)(ict,(0,p.A)({},act,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}lct.isMDXComponent=!0;const uct={toc:[]},mct="wrapper";function yct(e){let{components:n,...t}=e;return(0,s.yg)(mct,(0,p.A)({},uct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}yct.isMDXComponent=!0;const dct={toc:[]},hct="wrapper";function gct(e){let{components:n,...t}=e;return(0,s.yg)(hct,(0,p.A)({},dct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}gct.isMDXComponent=!0;const fct={toc:[]},Dct="wrapper";function Mct(e){let{components:n,...t}=e;return(0,s.yg)(Dct,(0,p.A)({},fct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Mct.isMDXComponent=!0;const Xct={toc:[]},_ct="wrapper";function wct(e){let{components:n,...t}=e;return(0,s.yg)(_ct,(0,p.A)({},Xct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}wct.isMDXComponent=!0;const Tct={toc:[]},Cct="wrapper";function xct(e){let{components:n,...t}=e;return(0,s.yg)(Cct,(0,p.A)({},Tct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}xct.isMDXComponent=!0;const Act={toc:[]},vct="wrapper";function Lct(e){let{components:n,...t}=e;return(0,s.yg)(vct,(0,p.A)({},Act,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Lct.isMDXComponent=!0;const bct={toc:[]},Nct="wrapper";function kct(e){let{components:n,...t}=e;return(0,s.yg)(Nct,(0,p.A)({},bct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}kct.isMDXComponent=!0;const zct={toc:[]},Pct="wrapper";function Ict(e){let{components:n,...t}=e;return(0,s.yg)(Pct,(0,p.A)({},zct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Ict.isMDXComponent=!0;const Rct={toc:[]},Wct="wrapper";function Sct(e){let{components:n,...t}=e;return(0,s.yg)(Wct,(0,p.A)({},Rct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Sct.isMDXComponent=!0;const Bct={toc:[]},Ect="wrapper";function Gct(e){let{components:n,...t}=e;return(0,s.yg)(Ect,(0,p.A)({},Bct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Gct.isMDXComponent=!0;const Oct={toc:[]},Uct="wrapper";function Fct(e){let{components:n,...t}=e;return(0,s.yg)(Uct,(0,p.A)({},Oct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}Fct.isMDXComponent=!0;const Vct={toc:[]},qct="wrapper";function jct(e){let{components:n,...t}=e;return(0,s.yg)(qct,(0,p.A)({},Vct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Layout#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}jct.isMDXComponent=!0;const Hct={toc:[]},Yct="wrapper";function Qct(e){let{components:n,...t}=e;return(0,s.yg)(Yct,(0,p.A)({},Hct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Qct.isMDXComponent=!0;const $ct={toc:[]},Kct="wrapper";function Jct(e){let{components:n,...t}=e;return(0,s.yg)(Kct,(0,p.A)({},$ct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Jct.isMDXComponent=!0;const Zct={toc:[]},eat="wrapper";function nat(e){let{components:n,...t}=e;return(0,s.yg)(eat,(0,p.A)({},Zct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}nat.isMDXComponent=!0;const tat={toc:[]},oat="wrapper";function pat(e){let{components:n,...t}=e;return(0,s.yg)(oat,(0,p.A)({},tat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}pat.isMDXComponent=!0;const rat={toc:[]},sat="wrapper";function cat(e){let{components:n,...t}=e;return(0,s.yg)(sat,(0,p.A)({},rat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}cat.isMDXComponent=!0;const aat={toc:[]},iat="wrapper";function lat(e){let{components:n,...t}=e;return(0,s.yg)(iat,(0,p.A)({},aat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}lat.isMDXComponent=!0;const uat={toc:[]},mat="wrapper";function yat(e){let{components:n,...t}=e;return(0,s.yg)(mat,(0,p.A)({},uat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This node can be used to render any polygonal shape defined by a set of\npoints."))}yat.isMDXComponent=!0;const dat={toc:[]},hat="wrapper";function gat(e){let{components:n,...t}=e;return(0,s.yg)(hat,(0,p.A)({},dat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Simple line\nimport {makeScene2D, Line} from '@revideo/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Line\n      points={[\n        [150, 50],\n        [0, -50],\n        [-150, 50],\n      ]}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      radius={40}\n      startArrow\n    />,\n  );\n});\n\n// snippet Polygon\nimport {makeScene2D, Line} from '@revideo/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Line\n      points={[\n        [-200, 70],\n        [150, 70],\n        [100, -70],\n        [-100, -70],\n      ]}\n      fill={'lightseagreen'}\n      closed\n    />,\n  );\n});\n\n// snippet Using signals\nimport {makeScene2D, Line} from '@revideo/2d';\nimport {createSignal} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const tip = createSignal(-150);\n  view.add(\n    <Line\n      points={[\n        [-150, 70],\n        [150, 70],\n        // this point is dynamically calculated based on the signal:\n        () => [tip(), -70],\n      ]}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      closed\n    />,\n  );\n\n  yield* tip(150, 1).back(1);\n});\n\n// snippet Tweening points\nimport {makeScene2D, Line} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const line = createRef<Line>();\n  view.add(\n    <Line\n      ref={line}\n      points={[\n        [-150, 70],\n        [150, 70],\n        [0, -70],\n      ]}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      radius={20}\n      closed\n    />,\n  );\n\n  yield* line()\n    .points(\n      [\n        [-150, 0],\n        [0, 100],\n        [150, 0],\n        [150, -70],\n        [-150, -70],\n      ],\n      2,\n    )\n    .back(2);\n});\n")))}gat.isMDXComponent=!0;const fat={toc:[]},Dat="wrapper";function Mat(e){let{components:n,...t}=e;return(0,s.yg)(Dat,(0,p.A)({},fat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing lines and polygons."))}Mat.isMDXComponent=!0;const Xat={toc:[]},_at="wrapper";function wat(e){let{components:n,...t}=e;return(0,s.yg)(_at,(0,p.A)({},Xat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}wat.isMDXComponent=!0;const Tat={toc:[]},Cat="wrapper";function xat(e){let{components:n,...t}=e;return(0,s.yg)(Cat,(0,p.A)({},Tat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}xat.isMDXComponent=!0;const Aat={toc:[]},vat="wrapper";function Lat(e){let{components:n,...t}=e;return(0,s.yg)(vat,(0,p.A)({},Aat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Lat.isMDXComponent=!0;const bat={toc:[]},Nat="wrapper";function kat(e){let{components:n,...t}=e;return(0,s.yg)(Nat,(0,p.A)({},bat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}kat.isMDXComponent=!0;const zat={toc:[]},Pat="wrapper";function Iat(e){let{components:n,...t}=e;return(0,s.yg)(Pat,(0,p.A)({},zat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Iat.isMDXComponent=!0;const Rat={toc:[]},Wat="wrapper";function Sat(e){let{components:n,...t}=e;return(0,s.yg)(Wat,(0,p.A)({},Rat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}Sat.isMDXComponent=!0;const Bat={toc:[]},Eat="wrapper";function Gat(e){let{components:n,...t}=e;return(0,s.yg)(Eat,(0,p.A)({},Bat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Gat.isMDXComponent=!0;const Oat={toc:[]},Uat="wrapper";function Fat(e){let{components:n,...t}=e;return(0,s.yg)(Uat,(0,p.A)({},Oat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}Fat.isMDXComponent=!0;const Vat={toc:[]},qat="wrapper";function jat(e){let{components:n,...t}=e;return(0,s.yg)(qat,(0,p.A)({},Vat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}jat.isMDXComponent=!0;const Hat={toc:[]},Yat="wrapper";function Qat(e){let{components:n,...t}=e;return(0,s.yg)(Yat,(0,p.A)({},Hat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Qat.isMDXComponent=!0;const $at={toc:[]},Kat="wrapper";function Jat(e){let{components:n,...t}=e;return(0,s.yg)(Kat,(0,p.A)({},$at,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Jat.isMDXComponent=!0;const Zat={toc:[]},eit="wrapper";function nit(e){let{components:n,...t}=e;return(0,s.yg)(eit,(0,p.A)({},Zat,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}nit.isMDXComponent=!0;const tit={toc:[]},oit="wrapper";function pit(e){let{components:n,...t}=e;return(0,s.yg)(oit,(0,p.A)({},tit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}pit.isMDXComponent=!0;const rit={toc:[]},sit="wrapper";function cit(e){let{components:n,...t}=e;return(0,s.yg)(sit,(0,p.A)({},rit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}cit.isMDXComponent=!0;const ait={toc:[]},iit="wrapper";function lit(e){let{components:n,...t}=e;return(0,s.yg)(iit,(0,p.A)({},ait,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}lit.isMDXComponent=!0;const uit={toc:[]},mit="wrapper";function yit(e){let{components:n,...t}=e;return(0,s.yg)(mit,(0,p.A)({},uit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}yit.isMDXComponent=!0;const dit={toc:[]},hit="wrapper";function git(e){let{components:n,...t}=e;return(0,s.yg)(hit,(0,p.A)({},dit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}git.isMDXComponent=!0;const fit={toc:[]},Dit="wrapper";function Mit(e){let{components:n,...t}=e;return(0,s.yg)(Dit,(0,p.A)({},fit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}Mit.isMDXComponent=!0;const Xit={toc:[]},_it="wrapper";function wit(e){let{components:n,...t}=e;return(0,s.yg)(_it,(0,p.A)({},Xit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}wit.isMDXComponent=!0;const Tit={toc:[]},Cit="wrapper";function xit(e){let{components:n,...t}=e;return(0,s.yg)(Cit,(0,p.A)({},Tit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}xit.isMDXComponent=!0;const Ait={toc:[]},vit="wrapper";function Lit(e){let{components:n,...t}=e;return(0,s.yg)(vit,(0,p.A)({},Ait,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Lit.isMDXComponent=!0;const bit={toc:[]},Nit="wrapper";function kit(e){let{components:n,...t}=e;return(0,s.yg)(Nit,(0,p.A)({},bit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}kit.isMDXComponent=!0;const zit={toc:[]},Pit="wrapper";function Iit(e){let{components:n,...t}=e;return(0,s.yg)(Pit,(0,p.A)({},zit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Iit.isMDXComponent=!0;const Rit={toc:[]},Wit="wrapper";function Sit(e){let{components:n,...t}=e;return(0,s.yg)(Wit,(0,p.A)({},Rit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}Sit.isMDXComponent=!0;const Bit={toc:[]},Eit="wrapper";function Git(e){let{components:n,...t}=e;return(0,s.yg)(Eit,(0,p.A)({},Bit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Git.isMDXComponent=!0;const Oit={toc:[]},Uit="wrapper";function Fit(e){let{components:n,...t}=e;return(0,s.yg)(Uit,(0,p.A)({},Oit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Fit.isMDXComponent=!0;const Vit={toc:[]},qit="wrapper";function jit(e){let{components:n,...t}=e;return(0,s.yg)(qit,(0,p.A)({},Vit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}jit.isMDXComponent=!0;const Hit={toc:[]},Yit="wrapper";function Qit(e){let{components:n,...t}=e;return(0,s.yg)(Yit,(0,p.A)({},Hit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Qit.isMDXComponent=!0;const $it={toc:[]},Kit="wrapper";function Jit(e){let{components:n,...t}=e;return(0,s.yg)(Kit,(0,p.A)({},$it,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Jit.isMDXComponent=!0;const Zit={toc:[]},elt="wrapper";function nlt(e){let{components:n,...t}=e;return(0,s.yg)(elt,(0,p.A)({},Zit,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}nlt.isMDXComponent=!0;const tlt={toc:[]},olt="wrapper";function plt(e){let{components:n,...t}=e;return(0,s.yg)(olt,(0,p.A)({},tlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}plt.isMDXComponent=!0;const rlt={toc:[]},slt="wrapper";function clt(e){let{components:n,...t}=e;return(0,s.yg)(slt,(0,p.A)({},rlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}clt.isMDXComponent=!0;const alt={toc:[]},ilt="wrapper";function llt(e){let{components:n,...t}=e;return(0,s.yg)(ilt,(0,p.A)({},alt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set to ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", the Line will use the positions of its children as\npoints."))}llt.isMDXComponent=!0;const ult={toc:[]},mlt="wrapper";function ylt(e){let{components:n,...t}=e;return(0,s.yg)(mlt,(0,p.A)({},ult,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The points of the line."))}ylt.isMDXComponent=!0;const dlt={toc:[]},hlt="wrapper";function glt(e){let{components:n,...t}=e;return(0,s.yg)(hlt,(0,p.A)({},dlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}glt.isMDXComponent=!0;const flt={toc:[]},Dlt="wrapper";function Mlt(e){let{components:n,...t}=e;return(0,s.yg)(Dlt,(0,p.A)({},flt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}Mlt.isMDXComponent=!0;const Xlt={toc:[]},_lt="wrapper";function wlt(e){let{components:n,...t}=e;return(0,s.yg)(_lt,(0,p.A)({},Xlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The radius of the line's corners."))}wlt.isMDXComponent=!0;const Tlt={toc:[]},Clt="wrapper";function xlt(e){let{components:n,...t}=e;return(0,s.yg)(Clt,(0,p.A)({},Tlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}xlt.isMDXComponent=!0;const Alt={toc:[]},vlt="wrapper";function Llt(e){let{components:n,...t}=e;return(0,s.yg)(vlt,(0,p.A)({},Alt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Llt.isMDXComponent=!0;const blt={toc:[]},Nlt="wrapper";function klt(e){let{components:n,...t}=e;return(0,s.yg)(Nlt,(0,p.A)({},blt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}klt.isMDXComponent=!0;const zlt={toc:[]},Plt="wrapper";function Ilt(e){let{components:n,...t}=e;return(0,s.yg)(Plt,(0,p.A)({},zlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Ilt.isMDXComponent=!0;const Rlt={toc:[]},Wlt="wrapper";function Slt(e){let{components:n,...t}=e;return(0,s.yg)(Wlt,(0,p.A)({},Rlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}Slt.isMDXComponent=!0;const Blt={toc:[]},Elt="wrapper";function Glt(e){let{components:n,...t}=e;return(0,s.yg)(Elt,(0,p.A)({},Blt,t,{components:n,mdxType:"MDXLayout"}))}Glt.isMDXComponent=!0;const Olt={toc:[]},Ult="wrapper";function Flt(e){let{components:n,...t}=e;return(0,s.yg)(Ult,(0,p.A)({},Olt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Flt.isMDXComponent=!0;const Vlt={toc:[]},qlt="wrapper";function jlt(e){let{components:n,...t}=e;return(0,s.yg)(qlt,(0,p.A)({},Vlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}jlt.isMDXComponent=!0;const Hlt={toc:[]},Ylt="wrapper";function Qlt(e){let{components:n,...t}=e;return(0,s.yg)(Ylt,(0,p.A)({},Hlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}Qlt.isMDXComponent=!0;const $lt={toc:[]},Klt="wrapper";function Jlt(e){let{components:n,...t}=e;return(0,s.yg)(Klt,(0,p.A)({},$lt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Jlt.isMDXComponent=!0;const Zlt={toc:[]},eut="wrapper";function nut(e){let{components:n,...t}=e;return(0,s.yg)(eut,(0,p.A)({},Zlt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}nut.isMDXComponent=!0;const tut={toc:[]},out="wrapper";function put(e){let{components:n,...t}=e;return(0,s.yg)(out,(0,p.A)({},tut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}put.isMDXComponent=!0;const rut={toc:[]},sut="wrapper";function cut(e){let{components:n,...t}=e;return(0,s.yg)(sut,(0,p.A)({},rut,t,{components:n,mdxType:"MDXLayout"}))}cut.isMDXComponent=!0;const aut={toc:[]},iut="wrapper";function lut(e){let{components:n,...t}=e;return(0,s.yg)(iut,(0,p.A)({},aut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}lut.isMDXComponent=!0;const uut={toc:[]},mut="wrapper";function yut(e){let{components:n,...t}=e;return(0,s.yg)(mut,(0,p.A)({},uut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}yut.isMDXComponent=!0;const dut={toc:[]},hut="wrapper";function gut(e){let{components:n,...t}=e;return(0,s.yg)(hut,(0,p.A)({},dut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}gut.isMDXComponent=!0;const fut={toc:[]},Dut="wrapper";function Mut(e){let{components:n,...t}=e;return(0,s.yg)(Dut,(0,p.A)({},fut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Mut.isMDXComponent=!0;const Xut={toc:[]},_ut="wrapper";function wut(e){let{components:n,...t}=e;return(0,s.yg)(_ut,(0,p.A)({},Xut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}wut.isMDXComponent=!0;const Tut={toc:[]},Cut="wrapper";function xut(e){let{components:n,...t}=e;return(0,s.yg)(Cut,(0,p.A)({},Tut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}xut.isMDXComponent=!0;const Aut={toc:[]},vut="wrapper";function Lut(e){let{components:n,...t}=e;return(0,s.yg)(vut,(0,p.A)({},Aut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Lut.isMDXComponent=!0;const but={toc:[]},Nut="wrapper";function kut(e){let{components:n,...t}=e;return(0,s.yg)(Nut,(0,p.A)({},but,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}kut.isMDXComponent=!0;const zut={toc:[]},Put="wrapper";function Iut(e){let{components:n,...t}=e;return(0,s.yg)(Put,(0,p.A)({},zut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Iut.isMDXComponent=!0;const Rut={toc:[]},Wut="wrapper";function Sut(e){let{components:n,...t}=e;return(0,s.yg)(Wut,(0,p.A)({},Rut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Sut.isMDXComponent=!0;const But={toc:[]},Eut="wrapper";function Gut(e){let{components:n,...t}=e;return(0,s.yg)(Eut,(0,p.A)({},But,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Gut.isMDXComponent=!0;const Out={toc:[]},Uut="wrapper";function Fut(e){let{components:n,...t}=e;return(0,s.yg)(Uut,(0,p.A)({},Out,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Fut.isMDXComponent=!0;const Vut={toc:[]},qut="wrapper";function jut(e){let{components:n,...t}=e;return(0,s.yg)(qut,(0,p.A)({},Vut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}jut.isMDXComponent=!0;const Hut={toc:[]},Yut="wrapper";function Qut(e){let{components:n,...t}=e;return(0,s.yg)(Yut,(0,p.A)({},Hut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Qut.isMDXComponent=!0;const $ut={toc:[]},Kut="wrapper";function Jut(e){let{components:n,...t}=e;return(0,s.yg)(Kut,(0,p.A)({},$ut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}Jut.isMDXComponent=!0;const Zut={toc:[]},emt="wrapper";function nmt(e){let{components:n,...t}=e;return(0,s.yg)(emt,(0,p.A)({},Zut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}nmt.isMDXComponent=!0;const tmt={toc:[]},omt="wrapper";function pmt(e){let{components:n,...t}=e;return(0,s.yg)(omt,(0,p.A)({},tmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}pmt.isMDXComponent=!0;const rmt={toc:[]},smt="wrapper";function cmt(e){let{components:n,...t}=e;return(0,s.yg)(smt,(0,p.A)({},rmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}cmt.isMDXComponent=!0;const amt={toc:[]},imt="wrapper";function lmt(e){let{components:n,...t}=e;return(0,s.yg)(imt,(0,p.A)({},amt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}lmt.isMDXComponent=!0;const umt={toc:[]},mmt="wrapper";function ymt(e){let{components:n,...t}=e;return(0,s.yg)(mmt,(0,p.A)({},umt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}ymt.isMDXComponent=!0;const dmt={toc:[]},hmt="wrapper";function gmt(e){let{components:n,...t}=e;return(0,s.yg)(hmt,(0,p.A)({},dmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}gmt.isMDXComponent=!0;const fmt={toc:[]},Dmt="wrapper";function Mmt(e){let{components:n,...t}=e;return(0,s.yg)(Dmt,(0,p.A)({},fmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Mmt.isMDXComponent=!0;const Xmt={toc:[]},_mt="wrapper";function wmt(e){let{components:n,...t}=e;return(0,s.yg)(_mt,(0,p.A)({},Xmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}wmt.isMDXComponent=!0;const Tmt={toc:[]},Cmt="wrapper";function xmt(e){let{components:n,...t}=e;return(0,s.yg)(Cmt,(0,p.A)({},Tmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}xmt.isMDXComponent=!0;const Amt={toc:[]},vmt="wrapper";function Lmt(e){let{components:n,...t}=e;return(0,s.yg)(vmt,(0,p.A)({},Amt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Lmt.isMDXComponent=!0;const bmt={toc:[]},Nmt="wrapper";function kmt(e){let{components:n,...t}=e;return(0,s.yg)(Nmt,(0,p.A)({},bmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}kmt.isMDXComponent=!0;const zmt={toc:[]},Pmt="wrapper";function Imt(e){let{components:n,...t}=e;return(0,s.yg)(Pmt,(0,p.A)({},zmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Imt.isMDXComponent=!0;const Rmt={toc:[]},Wmt="wrapper";function Smt(e){let{components:n,...t}=e;return(0,s.yg)(Wmt,(0,p.A)({},Rmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Smt.isMDXComponent=!0;const Bmt={toc:[]},Emt="wrapper";function Gmt(e){let{components:n,...t}=e;return(0,s.yg)(Emt,(0,p.A)({},Bmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}Gmt.isMDXComponent=!0;const Omt={toc:[]},Umt="wrapper";function Fmt(e){let{components:n,...t}=e;return(0,s.yg)(Umt,(0,p.A)({},Omt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}Fmt.isMDXComponent=!0;const Vmt={toc:[]},qmt="wrapper";function jmt(e){let{components:n,...t}=e;return(0,s.yg)(qmt,(0,p.A)({},Vmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}jmt.isMDXComponent=!0;const Hmt={toc:[]},Ymt="wrapper";function Qmt(e){let{components:n,...t}=e;return(0,s.yg)(Ymt,(0,p.A)({},Hmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Qmt.isMDXComponent=!0;const $mt={toc:[]},Kmt="wrapper";function Jmt(e){let{components:n,...t}=e;return(0,s.yg)(Kmt,(0,p.A)({},$mt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Jmt.isMDXComponent=!0;const Zmt={toc:[]},eyt="wrapper";function nyt(e){let{components:n,...t}=e;return(0,s.yg)(eyt,(0,p.A)({},Zmt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}nyt.isMDXComponent=!0;const tyt={toc:[]},oyt="wrapper";function pyt(e){let{components:n,...t}=e;return(0,s.yg)(oyt,(0,p.A)({},tyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}pyt.isMDXComponent=!0;const ryt={toc:[]},syt="wrapper";function cyt(e){let{components:n,...t}=e;return(0,s.yg)(syt,(0,p.A)({},ryt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}cyt.isMDXComponent=!0;const ayt={toc:[]},iyt="wrapper";function lyt(e){let{components:n,...t}=e;return(0,s.yg)(iyt,(0,p.A)({},ayt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}lyt.isMDXComponent=!0;const uyt={toc:[]},myt="wrapper";function yyt(e){let{components:n,...t}=e;return(0,s.yg)(myt,(0,p.A)({},uyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}yyt.isMDXComponent=!0;const dyt={toc:[]},hyt="wrapper";function gyt(e){let{components:n,...t}=e;return(0,s.yg)(hyt,(0,p.A)({},dyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}gyt.isMDXComponent=!0;const fyt={toc:[]},Dyt="wrapper";function Myt(e){let{components:n,...t}=e;return(0,s.yg)(Dyt,(0,p.A)({},fyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}Myt.isMDXComponent=!0;const Xyt={toc:[]},_yt="wrapper";function wyt(e){let{components:n,...t}=e;return(0,s.yg)(_yt,(0,p.A)({},Xyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}wyt.isMDXComponent=!0;const Tyt={toc:[]},Cyt="wrapper";function xyt(e){let{components:n,...t}=e;return(0,s.yg)(Cyt,(0,p.A)({},Tyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}xyt.isMDXComponent=!0;const Ayt={toc:[]},vyt="wrapper";function Lyt(e){let{components:n,...t}=e;return(0,s.yg)(vyt,(0,p.A)({},Ayt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Lyt.isMDXComponent=!0;const byt={toc:[]},Nyt="wrapper";function kyt(e){let{components:n,...t}=e;return(0,s.yg)(Nyt,(0,p.A)({},byt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}kyt.isMDXComponent=!0;const zyt={toc:[]},Pyt="wrapper";function Iyt(e){let{components:n,...t}=e;return(0,s.yg)(Pyt,(0,p.A)({},zyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}Iyt.isMDXComponent=!0;const Ryt={toc:[]},Wyt="wrapper";function Syt(e){let{components:n,...t}=e;return(0,s.yg)(Wyt,(0,p.A)({},Ryt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Syt.isMDXComponent=!0;const Byt={toc:[]},Eyt="wrapper";function Gyt(e){let{components:n,...t}=e;return(0,s.yg)(Eyt,(0,p.A)({},Byt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}Gyt.isMDXComponent=!0;const Oyt={toc:[]},Uyt="wrapper";function Fyt(e){let{components:n,...t}=e;return(0,s.yg)(Uyt,(0,p.A)({},Oyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Fyt.isMDXComponent=!0;const Vyt={toc:[]},qyt="wrapper";function jyt(e){let{components:n,...t}=e;return(0,s.yg)(qyt,(0,p.A)({},Vyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}jyt.isMDXComponent=!0;const Hyt={toc:[]},Yyt="wrapper";function Qyt(e){let{components:n,...t}=e;return(0,s.yg)(Yyt,(0,p.A)({},Hyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}Qyt.isMDXComponent=!0;const $yt={toc:[]},Kyt="wrapper";function Jyt(e){let{components:n,...t}=e;return(0,s.yg)(Kyt,(0,p.A)({},$yt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Jyt.isMDXComponent=!0;const Zyt={toc:[]},edt="wrapper";function ndt(e){let{components:n,...t}=e;return(0,s.yg)(edt,(0,p.A)({},Zyt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}ndt.isMDXComponent=!0;const tdt={toc:[]},odt="wrapper";function pdt(e){let{components:n,...t}=e;return(0,s.yg)(odt,(0,p.A)({},tdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}pdt.isMDXComponent=!0;const rdt={toc:[]},sdt="wrapper";function cdt(e){let{components:n,...t}=e;return(0,s.yg)(sdt,(0,p.A)({},rdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}cdt.isMDXComponent=!0;const adt={toc:[]},idt="wrapper";function ldt(e){let{components:n,...t}=e;return(0,s.yg)(idt,(0,p.A)({},adt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}ldt.isMDXComponent=!0;const udt={toc:[]},mdt="wrapper";function ydt(e){let{components:n,...t}=e;return(0,s.yg)(mdt,(0,p.A)({},udt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}ydt.isMDXComponent=!0;const ddt={toc:[]},hdt="wrapper";function gdt(e){let{components:n,...t}=e;return(0,s.yg)(hdt,(0,p.A)({},ddt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}gdt.isMDXComponent=!0;const fdt={toc:[]},Ddt="wrapper";function Mdt(e){let{components:n,...t}=e;return(0,s.yg)(Ddt,(0,p.A)({},fdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Mdt.isMDXComponent=!0;const Xdt={toc:[]},_dt="wrapper";function wdt(e){let{components:n,...t}=e;return(0,s.yg)(_dt,(0,p.A)({},Xdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}wdt.isMDXComponent=!0;const Tdt={toc:[]},Cdt="wrapper";function xdt(e){let{components:n,...t}=e;return(0,s.yg)(Cdt,(0,p.A)({},Tdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}xdt.isMDXComponent=!0;const Adt={toc:[]},vdt="wrapper";function Ldt(e){let{components:n,...t}=e;return(0,s.yg)(vdt,(0,p.A)({},Adt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Ldt.isMDXComponent=!0;const bdt={toc:[]},Ndt="wrapper";function kdt(e){let{components:n,...t}=e;return(0,s.yg)(Ndt,(0,p.A)({},bdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}kdt.isMDXComponent=!0;const zdt={toc:[]},Pdt="wrapper";function Idt(e){let{components:n,...t}=e;return(0,s.yg)(Pdt,(0,p.A)({},zdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Idt.isMDXComponent=!0;const Rdt={toc:[]},Wdt="wrapper";function Sdt(e){let{components:n,...t}=e;return(0,s.yg)(Wdt,(0,p.A)({},Rdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Sdt.isMDXComponent=!0;const Bdt={toc:[]},Edt="wrapper";function Gdt(e){let{components:n,...t}=e;return(0,s.yg)(Edt,(0,p.A)({},Bdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Gdt.isMDXComponent=!0;const Odt={toc:[]},Udt="wrapper";function Fdt(e){let{components:n,...t}=e;return(0,s.yg)(Udt,(0,p.A)({},Odt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Fdt.isMDXComponent=!0;const Vdt={toc:[]},qdt="wrapper";function jdt(e){let{components:n,...t}=e;return(0,s.yg)(qdt,(0,p.A)({},Vdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}jdt.isMDXComponent=!0;const Hdt={toc:[]},Ydt="wrapper";function Qdt(e){let{components:n,...t}=e;return(0,s.yg)(Ydt,(0,p.A)({},Hdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Qdt.isMDXComponent=!0;const $dt={toc:[]},Kdt="wrapper";function Jdt(e){let{components:n,...t}=e;return(0,s.yg)(Kdt,(0,p.A)({},$dt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Jdt.isMDXComponent=!0;const Zdt={toc:[]},eht="wrapper";function nht(e){let{components:n,...t}=e;return(0,s.yg)(eht,(0,p.A)({},Zdt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}nht.isMDXComponent=!0;const tht={toc:[]},oht="wrapper";function pht(e){let{components:n,...t}=e;return(0,s.yg)(oht,(0,p.A)({},tht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}pht.isMDXComponent=!0;const rht={toc:[]},sht="wrapper";function cht(e){let{components:n,...t}=e;return(0,s.yg)(sht,(0,p.A)({},rht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}cht.isMDXComponent=!0;const aht={toc:[]},iht="wrapper";function lht(e){let{components:n,...t}=e;return(0,s.yg)(iht,(0,p.A)({},aht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}lht.isMDXComponent=!0;const uht={toc:[]},mht="wrapper";function yht(e){let{components:n,...t}=e;return(0,s.yg)(mht,(0,p.A)({},uht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}yht.isMDXComponent=!0;const dht={toc:[]},hht="wrapper";function ght(e){let{components:n,...t}=e;return(0,s.yg)(hht,(0,p.A)({},dht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}ght.isMDXComponent=!0;const fht={toc:[]},Dht="wrapper";function Mht(e){let{components:n,...t}=e;return(0,s.yg)(Dht,(0,p.A)({},fht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}Mht.isMDXComponent=!0;const Xht={toc:[]},_ht="wrapper";function wht(e){let{components:n,...t}=e;return(0,s.yg)(_ht,(0,p.A)({},Xht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}wht.isMDXComponent=!0;const Tht={toc:[]},Cht="wrapper";function xht(e){let{components:n,...t}=e;return(0,s.yg)(Cht,(0,p.A)({},Tht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}xht.isMDXComponent=!0;const Aht={toc:[]},vht="wrapper";function Lht(e){let{components:n,...t}=e;return(0,s.yg)(vht,(0,p.A)({},Aht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}Lht.isMDXComponent=!0;const bht={toc:[]},Nht="wrapper";function kht(e){let{components:n,...t}=e;return(0,s.yg)(Nht,(0,p.A)({},bht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}kht.isMDXComponent=!0;const zht={toc:[]},Pht="wrapper";function Iht(e){let{components:n,...t}=e;return(0,s.yg)(Pht,(0,p.A)({},zht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}Iht.isMDXComponent=!0;const Rht={toc:[]},Wht="wrapper";function Sht(e){let{components:n,...t}=e;return(0,s.yg)(Wht,(0,p.A)({},Rht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}Sht.isMDXComponent=!0;const Bht={toc:[]},Eht="wrapper";function Ght(e){let{components:n,...t}=e;return(0,s.yg)(Eht,(0,p.A)({},Bht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Ght.isMDXComponent=!0;const Oht={toc:[]},Uht="wrapper";function Fht(e){let{components:n,...t}=e;return(0,s.yg)(Uht,(0,p.A)({},Oht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}Fht.isMDXComponent=!0;const Vht={toc:[]},qht="wrapper";function jht(e){let{components:n,...t}=e;return(0,s.yg)(qht,(0,p.A)({},Vht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}jht.isMDXComponent=!0;const Hht={toc:[]},Yht="wrapper";function Qht(e){let{components:n,...t}=e;return(0,s.yg)(Yht,(0,p.A)({},Hht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}Qht.isMDXComponent=!0;const $ht={toc:[]},Kht="wrapper";function Jht(e){let{components:n,...t}=e;return(0,s.yg)(Kht,(0,p.A)({},$ht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Jht.isMDXComponent=!0;const Zht={toc:[]},egt="wrapper";function ngt(e){let{components:n,...t}=e;return(0,s.yg)(egt,(0,p.A)({},Zht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}ngt.isMDXComponent=!0;const tgt={toc:[]},ogt="wrapper";function pgt(e){let{components:n,...t}=e;return(0,s.yg)(ogt,(0,p.A)({},tgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}pgt.isMDXComponent=!0;const rgt={toc:[]},sgt="wrapper";function cgt(e){let{components:n,...t}=e;return(0,s.yg)(sgt,(0,p.A)({},rgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}cgt.isMDXComponent=!0;const agt={toc:[]},igt="wrapper";function lgt(e){let{components:n,...t}=e;return(0,s.yg)(igt,(0,p.A)({},agt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}lgt.isMDXComponent=!0;const ugt={toc:[]},mgt="wrapper";function ygt(e){let{components:n,...t}=e;return(0,s.yg)(mgt,(0,p.A)({},ugt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}ygt.isMDXComponent=!0;const dgt={toc:[]},hgt="wrapper";function ggt(e){let{components:n,...t}=e;return(0,s.yg)(hgt,(0,p.A)({},dgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}ggt.isMDXComponent=!0;const fgt={toc:[]},Dgt="wrapper";function Mgt(e){let{components:n,...t}=e;return(0,s.yg)(Dgt,(0,p.A)({},fgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}Mgt.isMDXComponent=!0;const Xgt={toc:[]},_gt="wrapper";function wgt(e){let{components:n,...t}=e;return(0,s.yg)(_gt,(0,p.A)({},Xgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}wgt.isMDXComponent=!0;const Tgt={toc:[]},Cgt="wrapper";function xgt(e){let{components:n,...t}=e;return(0,s.yg)(Cgt,(0,p.A)({},Tgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}xgt.isMDXComponent=!0;const Agt={toc:[]},vgt="wrapper";function Lgt(e){let{components:n,...t}=e;return(0,s.yg)(vgt,(0,p.A)({},Agt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Lgt.isMDXComponent=!0;const bgt={toc:[]},Ngt="wrapper";function kgt(e){let{components:n,...t}=e;return(0,s.yg)(Ngt,(0,p.A)({},bgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}kgt.isMDXComponent=!0;const zgt={toc:[]},Pgt="wrapper";function Igt(e){let{components:n,...t}=e;return(0,s.yg)(Pgt,(0,p.A)({},zgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Igt.isMDXComponent=!0;const Rgt={toc:[]},Wgt="wrapper";function Sgt(e){let{components:n,...t}=e;return(0,s.yg)(Wgt,(0,p.A)({},Rgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Sgt.isMDXComponent=!0;const Bgt={toc:[]},Egt="wrapper";function Ggt(e){let{components:n,...t}=e;return(0,s.yg)(Egt,(0,p.A)({},Bgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Ggt.isMDXComponent=!0;const Ogt={toc:[]},Ugt="wrapper";function Fgt(e){let{components:n,...t}=e;return(0,s.yg)(Ugt,(0,p.A)({},Ogt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}Fgt.isMDXComponent=!0;const Vgt={toc:[]},qgt="wrapper";function jgt(e){let{components:n,...t}=e;return(0,s.yg)(qgt,(0,p.A)({},Vgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}jgt.isMDXComponent=!0;const Hgt={toc:[]},Ygt="wrapper";function Qgt(e){let{components:n,...t}=e;return(0,s.yg)(Ygt,(0,p.A)({},Hgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}Qgt.isMDXComponent=!0;const $gt={toc:[]},Kgt="wrapper";function Jgt(e){let{components:n,...t}=e;return(0,s.yg)(Kgt,(0,p.A)({},$gt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Jgt.isMDXComponent=!0;const Zgt={toc:[]},eft="wrapper";function nft(e){let{components:n,...t}=e;return(0,s.yg)(eft,(0,p.A)({},Zgt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}nft.isMDXComponent=!0;const tft={toc:[]},oft="wrapper";function pft(e){let{components:n,...t}=e;return(0,s.yg)(oft,(0,p.A)({},tft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}pft.isMDXComponent=!0;const rft={toc:[]},sft="wrapper";function cft(e){let{components:n,...t}=e;return(0,s.yg)(sft,(0,p.A)({},rft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}cft.isMDXComponent=!0;const aft={toc:[]},ift="wrapper";function lft(e){let{components:n,...t}=e;return(0,s.yg)(ift,(0,p.A)({},aft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}lft.isMDXComponent=!0;const uft={toc:[]},mft="wrapper";function yft(e){let{components:n,...t}=e;return(0,s.yg)(mft,(0,p.A)({},uft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}yft.isMDXComponent=!0;const dft={toc:[]},hft="wrapper";function gft(e){let{components:n,...t}=e;return(0,s.yg)(hft,(0,p.A)({},dft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}gft.isMDXComponent=!0;const fft={toc:[]},Dft="wrapper";function Mft(e){let{components:n,...t}=e;return(0,s.yg)(Dft,(0,p.A)({},fft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Mft.isMDXComponent=!0;const Xft={toc:[]},_ft="wrapper";function wft(e){let{components:n,...t}=e;return(0,s.yg)(_ft,(0,p.A)({},Xft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}wft.isMDXComponent=!0;const Tft={toc:[]},Cft="wrapper";function xft(e){let{components:n,...t}=e;return(0,s.yg)(Cft,(0,p.A)({},Tft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}xft.isMDXComponent=!0;const Aft={toc:[]},vft="wrapper";function Lft(e){let{components:n,...t}=e;return(0,s.yg)(vft,(0,p.A)({},Aft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}Lft.isMDXComponent=!0;const bft={toc:[]},Nft="wrapper";function kft(e){let{components:n,...t}=e;return(0,s.yg)(Nft,(0,p.A)({},bft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}kft.isMDXComponent=!0;const zft={toc:[]},Pft="wrapper";function Ift(e){let{components:n,...t}=e;return(0,s.yg)(Pft,(0,p.A)({},zft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Ift.isMDXComponent=!0;const Rft={toc:[]},Wft="wrapper";function Sft(e){let{components:n,...t}=e;return(0,s.yg)(Wft,(0,p.A)({},Rft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}Sft.isMDXComponent=!0;const Bft={toc:[]},Eft="wrapper";function Gft(e){let{components:n,...t}=e;return(0,s.yg)(Eft,(0,p.A)({},Bft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}Gft.isMDXComponent=!0;const Oft={toc:[]},Uft="wrapper";function Fft(e){let{components:n,...t}=e;return(0,s.yg)(Uft,(0,p.A)({},Oft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}Fft.isMDXComponent=!0;const Vft={toc:[]},qft="wrapper";function jft(e){let{components:n,...t}=e;return(0,s.yg)(qft,(0,p.A)({},Vft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}jft.isMDXComponent=!0;const Hft={toc:[]},Yft="wrapper";function Qft(e){let{components:n,...t}=e;return(0,s.yg)(Yft,(0,p.A)({},Hft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}Qft.isMDXComponent=!0;const $ft={toc:[]},Kft="wrapper";function Jft(e){let{components:n,...t}=e;return(0,s.yg)(Kft,(0,p.A)({},$ft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}Jft.isMDXComponent=!0;const Zft={toc:[]},eDt="wrapper";function nDt(e){let{components:n,...t}=e;return(0,s.yg)(eDt,(0,p.A)({},Zft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}nDt.isMDXComponent=!0;const tDt={toc:[]},oDt="wrapper";function pDt(e){let{components:n,...t}=e;return(0,s.yg)(oDt,(0,p.A)({},tDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}pDt.isMDXComponent=!0;const rDt={toc:[]},sDt="wrapper";function cDt(e){let{components:n,...t}=e;return(0,s.yg)(sDt,(0,p.A)({},rDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}cDt.isMDXComponent=!0;const aDt={toc:[]},iDt="wrapper";function lDt(e){let{components:n,...t}=e;return(0,s.yg)(iDt,(0,p.A)({},aDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}lDt.isMDXComponent=!0;const uDt={toc:[]},mDt="wrapper";function yDt(e){let{components:n,...t}=e;return(0,s.yg)(mDt,(0,p.A)({},uDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}yDt.isMDXComponent=!0;const dDt={toc:[]},hDt="wrapper";function gDt(e){let{components:n,...t}=e;return(0,s.yg)(hDt,(0,p.A)({},dDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}gDt.isMDXComponent=!0;const fDt={toc:[]},DDt="wrapper";function MDt(e){let{components:n,...t}=e;return(0,s.yg)(DDt,(0,p.A)({},fDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}MDt.isMDXComponent=!0;const XDt={toc:[]},_Dt="wrapper";function wDt(e){let{components:n,...t}=e;return(0,s.yg)(_Dt,(0,p.A)({},XDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}wDt.isMDXComponent=!0;const TDt={toc:[]},CDt="wrapper";function xDt(e){let{components:n,...t}=e;return(0,s.yg)(CDt,(0,p.A)({},TDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}xDt.isMDXComponent=!0;const ADt={toc:[]},vDt="wrapper";function LDt(e){let{components:n,...t}=e;return(0,s.yg)(vDt,(0,p.A)({},ADt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}LDt.isMDXComponent=!0;const bDt={toc:[]},NDt="wrapper";function kDt(e){let{components:n,...t}=e;return(0,s.yg)(NDt,(0,p.A)({},bDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}kDt.isMDXComponent=!0;const zDt={toc:[]},PDt="wrapper";function IDt(e){let{components:n,...t}=e;return(0,s.yg)(PDt,(0,p.A)({},zDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}IDt.isMDXComponent=!0;const RDt={toc:[]},WDt="wrapper";function SDt(e){let{components:n,...t}=e;return(0,s.yg)(WDt,(0,p.A)({},RDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}SDt.isMDXComponent=!0;const BDt={toc:[]},EDt="wrapper";function GDt(e){let{components:n,...t}=e;return(0,s.yg)(EDt,(0,p.A)({},BDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}GDt.isMDXComponent=!0;const ODt={toc:[]},UDt="wrapper";function FDt(e){let{components:n,...t}=e;return(0,s.yg)(UDt,(0,p.A)({},ODt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}FDt.isMDXComponent=!0;const VDt={toc:[]},qDt="wrapper";function jDt(e){let{components:n,...t}=e;return(0,s.yg)(qDt,(0,p.A)({},VDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}jDt.isMDXComponent=!0;const HDt={toc:[]},YDt="wrapper";function QDt(e){let{components:n,...t}=e;return(0,s.yg)(YDt,(0,p.A)({},HDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}QDt.isMDXComponent=!0;const $Dt={toc:[]},KDt="wrapper";function JDt(e){let{components:n,...t}=e;return(0,s.yg)(KDt,(0,p.A)({},$Dt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}JDt.isMDXComponent=!0;const ZDt={toc:[]},eMt="wrapper";function nMt(e){let{components:n,...t}=e;return(0,s.yg)(eMt,(0,p.A)({},ZDt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}nMt.isMDXComponent=!0;const tMt={toc:[]},oMt="wrapper";function pMt(e){let{components:n,...t}=e;return(0,s.yg)(oMt,(0,p.A)({},tMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}pMt.isMDXComponent=!0;const rMt={toc:[]},sMt="wrapper";function cMt(e){let{components:n,...t}=e;return(0,s.yg)(sMt,(0,p.A)({},rMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}cMt.isMDXComponent=!0;const aMt={toc:[]},iMt="wrapper";function lMt(e){let{components:n,...t}=e;return(0,s.yg)(iMt,(0,p.A)({},aMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}lMt.isMDXComponent=!0;const uMt={toc:[]},mMt="wrapper";function yMt(e){let{components:n,...t}=e;return(0,s.yg)(mMt,(0,p.A)({},uMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}yMt.isMDXComponent=!0;const dMt={toc:[]},hMt="wrapper";function gMt(e){let{components:n,...t}=e;return(0,s.yg)(hMt,(0,p.A)({},dMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}gMt.isMDXComponent=!0;const fMt={toc:[]},DMt="wrapper";function MMt(e){let{components:n,...t}=e;return(0,s.yg)(DMt,(0,p.A)({},fMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}MMt.isMDXComponent=!0;const XMt={toc:[]},_Mt="wrapper";function wMt(e){let{components:n,...t}=e;return(0,s.yg)(_Mt,(0,p.A)({},XMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}wMt.isMDXComponent=!0;const TMt={toc:[]},CMt="wrapper";function xMt(e){let{components:n,...t}=e;return(0,s.yg)(CMt,(0,p.A)({},TMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}xMt.isMDXComponent=!0;const AMt={toc:[]},vMt="wrapper";function LMt(e){let{components:n,...t}=e;return(0,s.yg)(vMt,(0,p.A)({},AMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}LMt.isMDXComponent=!0;const bMt={toc:[]},NMt="wrapper";function kMt(e){let{components:n,...t}=e;return(0,s.yg)(NMt,(0,p.A)({},bMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}kMt.isMDXComponent=!0;const zMt={toc:[]},PMt="wrapper";function IMt(e){let{components:n,...t}=e;return(0,s.yg)(PMt,(0,p.A)({},zMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}IMt.isMDXComponent=!0;const RMt={toc:[]},WMt="wrapper";function SMt(e){let{components:n,...t}=e;return(0,s.yg)(WMt,(0,p.A)({},RMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}SMt.isMDXComponent=!0;const BMt={toc:[]},EMt="wrapper";function GMt(e){let{components:n,...t}=e;return(0,s.yg)(EMt,(0,p.A)({},BMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}GMt.isMDXComponent=!0;const OMt={toc:[]},UMt="wrapper";function FMt(e){let{components:n,...t}=e;return(0,s.yg)(UMt,(0,p.A)({},OMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}FMt.isMDXComponent=!0;const VMt={toc:[]},qMt="wrapper";function jMt(e){let{components:n,...t}=e;return(0,s.yg)(qMt,(0,p.A)({},VMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}jMt.isMDXComponent=!0;const HMt={toc:[]},YMt="wrapper";function QMt(e){let{components:n,...t}=e;return(0,s.yg)(YMt,(0,p.A)({},HMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}QMt.isMDXComponent=!0;const $Mt={toc:[]},KMt="wrapper";function JMt(e){let{components:n,...t}=e;return(0,s.yg)(KMt,(0,p.A)({},$Mt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}JMt.isMDXComponent=!0;const ZMt={toc:[]},eXt="wrapper";function nXt(e){let{components:n,...t}=e;return(0,s.yg)(eXt,(0,p.A)({},ZMt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}nXt.isMDXComponent=!0;const tXt={toc:[]},oXt="wrapper";function pXt(e){let{components:n,...t}=e;return(0,s.yg)(oXt,(0,p.A)({},tXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}pXt.isMDXComponent=!0;const rXt={toc:[]},sXt="wrapper";function cXt(e){let{components:n,...t}=e;return(0,s.yg)(sXt,(0,p.A)({},rXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Line#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}cXt.isMDXComponent=!0;const aXt={toc:[]},iXt="wrapper";function lXt(e){let{components:n,...t}=e;return(0,s.yg)(iXt,(0,p.A)({},aXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}lXt.isMDXComponent=!0;const uXt={toc:[]},mXt="wrapper";function yXt(e){let{components:n,...t}=e;return(0,s.yg)(mXt,(0,p.A)({},uXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}yXt.isMDXComponent=!0;const dXt={toc:[]},hXt="wrapper";function gXt(e){let{components:n,...t}=e;return(0,s.yg)(hXt,(0,p.A)({},dXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}gXt.isMDXComponent=!0;const fXt={toc:[]},DXt="wrapper";function MXt(e){let{components:n,...t}=e;return(0,s.yg)(DXt,(0,p.A)({},fXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}MXt.isMDXComponent=!0;const XXt={toc:[]},_Xt="wrapper";function wXt(e){let{components:n,...t}=e;return(0,s.yg)(_Xt,(0,p.A)({},XXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}wXt.isMDXComponent=!0;const TXt={toc:[]},CXt="wrapper";function xXt(e){let{components:n,...t}=e;return(0,s.yg)(CXt,(0,p.A)({},TXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}xXt.isMDXComponent=!0;const AXt={toc:[]},vXt="wrapper";function LXt(e){let{components:n,...t}=e;return(0,s.yg)(vXt,(0,p.A)({},AXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}LXt.isMDXComponent=!0;const bXt={toc:[]},NXt="wrapper";function kXt(e){let{components:n,...t}=e;return(0,s.yg)(NXt,(0,p.A)({},bXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}kXt.isMDXComponent=!0;const zXt={toc:[]},PXt="wrapper";function IXt(e){let{components:n,...t}=e;return(0,s.yg)(PXt,(0,p.A)({},zXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}IXt.isMDXComponent=!0;const RXt={toc:[]},WXt="wrapper";function SXt(e){let{components:n,...t}=e;return(0,s.yg)(WXt,(0,p.A)({},RXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}SXt.isMDXComponent=!0;const BXt={toc:[]},EXt="wrapper";function GXt(e){let{components:n,...t}=e;return(0,s.yg)(EXt,(0,p.A)({},BXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}GXt.isMDXComponent=!0;const OXt={toc:[]},UXt="wrapper";function FXt(e){let{components:n,...t}=e;return(0,s.yg)(UXt,(0,p.A)({},OXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}FXt.isMDXComponent=!0;const VXt={toc:[]},qXt="wrapper";function jXt(e){let{components:n,...t}=e;return(0,s.yg)(qXt,(0,p.A)({},VXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}jXt.isMDXComponent=!0;const HXt={toc:[]},YXt="wrapper";function QXt(e){let{components:n,...t}=e;return(0,s.yg)(YXt,(0,p.A)({},HXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}QXt.isMDXComponent=!0;const $Xt={toc:[]},KXt="wrapper";function JXt(e){let{components:n,...t}=e;return(0,s.yg)(KXt,(0,p.A)({},$Xt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}JXt.isMDXComponent=!0;const ZXt={toc:[]},e_t="wrapper";function n_t(e){let{components:n,...t}=e;return(0,s.yg)(e_t,(0,p.A)({},ZXt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}n_t.isMDXComponent=!0;const t_t={toc:[]},o_t="wrapper";function p_t(e){let{components:n,...t}=e;return(0,s.yg)(o_t,(0,p.A)({},t_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}p_t.isMDXComponent=!0;const r_t={toc:[]},s_t="wrapper";function c_t(e){let{components:n,...t}=e;return(0,s.yg)(s_t,(0,p.A)({},r_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}c_t.isMDXComponent=!0;const a_t={toc:[]},i_t="wrapper";function l_t(e){let{components:n,...t}=e;return(0,s.yg)(i_t,(0,p.A)({},a_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}l_t.isMDXComponent=!0;const u_t={toc:[]},m_t="wrapper";function y_t(e){let{components:n,...t}=e;return(0,s.yg)(m_t,(0,p.A)({},u_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}y_t.isMDXComponent=!0;const d_t={toc:[]},h_t="wrapper";function g_t(e){let{components:n,...t}=e;return(0,s.yg)(h_t,(0,p.A)({},d_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}g_t.isMDXComponent=!0;const f_t={toc:[]},D_t="wrapper";function M_t(e){let{components:n,...t}=e;return(0,s.yg)(D_t,(0,p.A)({},f_t,t,{components:n,mdxType:"MDXLayout"}))}M_t.isMDXComponent=!0;const X_t={toc:[]},__t="wrapper";function w_t(e){let{components:n,...t}=e;return(0,s.yg)(__t,(0,p.A)({},X_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}w_t.isMDXComponent=!0;const T_t={toc:[]},C_t="wrapper";function x_t(e){let{components:n,...t}=e;return(0,s.yg)(C_t,(0,p.A)({},T_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}x_t.isMDXComponent=!0;const A_t={toc:[]},v_t="wrapper";function L_t(e){let{components:n,...t}=e;return(0,s.yg)(v_t,(0,p.A)({},A_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}L_t.isMDXComponent=!0;const b_t={toc:[]},N_t="wrapper";function k_t(e){let{components:n,...t}=e;return(0,s.yg)(N_t,(0,p.A)({},b_t,t,{components:n,mdxType:"MDXLayout"}))}k_t.isMDXComponent=!0;const z_t={toc:[]},P_t="wrapper";function I_t(e){let{components:n,...t}=e;return(0,s.yg)(P_t,(0,p.A)({},z_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}I_t.isMDXComponent=!0;const R_t={toc:[]},W_t="wrapper";function S_t(e){let{components:n,...t}=e;return(0,s.yg)(W_t,(0,p.A)({},R_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}S_t.isMDXComponent=!0;const B_t={toc:[]},E_t="wrapper";function G_t(e){let{components:n,...t}=e;return(0,s.yg)(E_t,(0,p.A)({},B_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}G_t.isMDXComponent=!0;const O_t={toc:[]},U_t="wrapper";function F_t(e){let{components:n,...t}=e;return(0,s.yg)(U_t,(0,p.A)({},O_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}F_t.isMDXComponent=!0;const V_t={toc:[]},q_t="wrapper";function j_t(e){let{components:n,...t}=e;return(0,s.yg)(q_t,(0,p.A)({},V_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}j_t.isMDXComponent=!0;const H_t={toc:[]},Y_t="wrapper";function Q_t(e){let{components:n,...t}=e;return(0,s.yg)(Y_t,(0,p.A)({},H_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}Q_t.isMDXComponent=!0;const $_t={toc:[]},K_t="wrapper";function J_t(e){let{components:n,...t}=e;return(0,s.yg)(K_t,(0,p.A)({},$_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}J_t.isMDXComponent=!0;const Z_t={toc:[]},ewt="wrapper";function nwt(e){let{components:n,...t}=e;return(0,s.yg)(ewt,(0,p.A)({},Z_t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}nwt.isMDXComponent=!0;const twt={toc:[]},owt="wrapper";function pwt(e){let{components:n,...t}=e;return(0,s.yg)(owt,(0,p.A)({},twt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}pwt.isMDXComponent=!0;const rwt={toc:[]},swt="wrapper";function cwt(e){let{components:n,...t}=e;return(0,s.yg)(swt,(0,p.A)({},rwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}cwt.isMDXComponent=!0;const awt={toc:[]},iwt="wrapper";function lwt(e){let{components:n,...t}=e;return(0,s.yg)(iwt,(0,p.A)({},awt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}lwt.isMDXComponent=!0;const uwt={toc:[]},mwt="wrapper";function ywt(e){let{components:n,...t}=e;return(0,s.yg)(mwt,(0,p.A)({},uwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}ywt.isMDXComponent=!0;const dwt={toc:[]},hwt="wrapper";function gwt(e){let{components:n,...t}=e;return(0,s.yg)(hwt,(0,p.A)({},dwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}gwt.isMDXComponent=!0;const fwt={toc:[]},Dwt="wrapper";function Mwt(e){let{components:n,...t}=e;return(0,s.yg)(Dwt,(0,p.A)({},fwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}Mwt.isMDXComponent=!0;const Xwt={toc:[]},_wt="wrapper";function wwt(e){let{components:n,...t}=e;return(0,s.yg)(_wt,(0,p.A)({},Xwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}wwt.isMDXComponent=!0;const Twt={toc:[]},Cwt="wrapper";function xwt(e){let{components:n,...t}=e;return(0,s.yg)(Cwt,(0,p.A)({},Twt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}xwt.isMDXComponent=!0;const Awt={toc:[]},vwt="wrapper";function Lwt(e){let{components:n,...t}=e;return(0,s.yg)(vwt,(0,p.A)({},Awt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Lwt.isMDXComponent=!0;const bwt={toc:[]},Nwt="wrapper";function kwt(e){let{components:n,...t}=e;return(0,s.yg)(Nwt,(0,p.A)({},bwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}kwt.isMDXComponent=!0;const zwt={toc:[]},Pwt="wrapper";function Iwt(e){let{components:n,...t}=e;return(0,s.yg)(Pwt,(0,p.A)({},zwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Iwt.isMDXComponent=!0;const Rwt={toc:[]},Wwt="wrapper";function Swt(e){let{components:n,...t}=e;return(0,s.yg)(Wwt,(0,p.A)({},Rwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}Swt.isMDXComponent=!0;const Bwt={toc:[]},Ewt="wrapper";function Gwt(e){let{components:n,...t}=e;return(0,s.yg)(Ewt,(0,p.A)({},Bwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Gwt.isMDXComponent=!0;const Owt={toc:[]},Uwt="wrapper";function Fwt(e){let{components:n,...t}=e;return(0,s.yg)(Uwt,(0,p.A)({},Owt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}Fwt.isMDXComponent=!0;const Vwt={toc:[]},qwt="wrapper";function jwt(e){let{components:n,...t}=e;return(0,s.yg)(qwt,(0,p.A)({},Vwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}jwt.isMDXComponent=!0;const Hwt={toc:[]},Ywt="wrapper";function Qwt(e){let{components:n,...t}=e;return(0,s.yg)(Ywt,(0,p.A)({},Hwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}Qwt.isMDXComponent=!0;const $wt={toc:[]},Kwt="wrapper";function Jwt(e){let{components:n,...t}=e;return(0,s.yg)(Kwt,(0,p.A)({},$wt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Jwt.isMDXComponent=!0;const Zwt={toc:[]},eTt="wrapper";function nTt(e){let{components:n,...t}=e;return(0,s.yg)(eTt,(0,p.A)({},Zwt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}nTt.isMDXComponent=!0;const tTt={toc:[]},oTt="wrapper";function pTt(e){let{components:n,...t}=e;return(0,s.yg)(oTt,(0,p.A)({},tTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}pTt.isMDXComponent=!0;const rTt={toc:[]},sTt="wrapper";function cTt(e){let{components:n,...t}=e;return(0,s.yg)(sTt,(0,p.A)({},rTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}cTt.isMDXComponent=!0;const aTt={toc:[]},iTt="wrapper";function lTt(e){let{components:n,...t}=e;return(0,s.yg)(iTt,(0,p.A)({},aTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}lTt.isMDXComponent=!0;const uTt={toc:[]},mTt="wrapper";function yTt(e){let{components:n,...t}=e;return(0,s.yg)(mTt,(0,p.A)({},uTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}yTt.isMDXComponent=!0;const dTt={toc:[]},hTt="wrapper";function gTt(e){let{components:n,...t}=e;return(0,s.yg)(hTt,(0,p.A)({},dTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}gTt.isMDXComponent=!0;const fTt={toc:[]},DTt="wrapper";function MTt(e){let{components:n,...t}=e;return(0,s.yg)(DTt,(0,p.A)({},fTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}MTt.isMDXComponent=!0;const XTt={toc:[]},_Tt="wrapper";function wTt(e){let{components:n,...t}=e;return(0,s.yg)(_Tt,(0,p.A)({},XTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}wTt.isMDXComponent=!0;const TTt={toc:[]},CTt="wrapper";function xTt(e){let{components:n,...t}=e;return(0,s.yg)(CTt,(0,p.A)({},TTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}xTt.isMDXComponent=!0;const ATt={toc:[]},vTt="wrapper";function LTt(e){let{components:n,...t}=e;return(0,s.yg)(vTt,(0,p.A)({},ATt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}LTt.isMDXComponent=!0;const bTt={toc:[]},NTt="wrapper";function kTt(e){let{components:n,...t}=e;return(0,s.yg)(NTt,(0,p.A)({},bTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}kTt.isMDXComponent=!0;const zTt={toc:[]},PTt="wrapper";function ITt(e){let{components:n,...t}=e;return(0,s.yg)(PTt,(0,p.A)({},zTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}ITt.isMDXComponent=!0;const RTt={toc:[]},WTt="wrapper";function STt(e){let{components:n,...t}=e;return(0,s.yg)(WTt,(0,p.A)({},RTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}STt.isMDXComponent=!0;const BTt={toc:[]},ETt="wrapper";function GTt(e){let{components:n,...t}=e;return(0,s.yg)(ETt,(0,p.A)({},BTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}GTt.isMDXComponent=!0;const OTt={toc:[]},UTt="wrapper";function FTt(e){let{components:n,...t}=e;return(0,s.yg)(UTt,(0,p.A)({},OTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}FTt.isMDXComponent=!0;const VTt={toc:[]},qTt="wrapper";function jTt(e){let{components:n,...t}=e;return(0,s.yg)(qTt,(0,p.A)({},VTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}jTt.isMDXComponent=!0;const HTt={toc:[]},YTt="wrapper";function QTt(e){let{components:n,...t}=e;return(0,s.yg)(YTt,(0,p.A)({},HTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}QTt.isMDXComponent=!0;const $Tt={toc:[]},KTt="wrapper";function JTt(e){let{components:n,...t}=e;return(0,s.yg)(KTt,(0,p.A)({},$Tt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}JTt.isMDXComponent=!0;const ZTt={toc:[]},eCt="wrapper";function nCt(e){let{components:n,...t}=e;return(0,s.yg)(eCt,(0,p.A)({},ZTt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}nCt.isMDXComponent=!0;const tCt={toc:[]},oCt="wrapper";function pCt(e){let{components:n,...t}=e;return(0,s.yg)(oCt,(0,p.A)({},tCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}pCt.isMDXComponent=!0;const rCt={toc:[]},sCt="wrapper";function cCt(e){let{components:n,...t}=e;return(0,s.yg)(sCt,(0,p.A)({},rCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}cCt.isMDXComponent=!0;const aCt={toc:[]},iCt="wrapper";function lCt(e){let{components:n,...t}=e;return(0,s.yg)(iCt,(0,p.A)({},aCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}lCt.isMDXComponent=!0;const uCt={toc:[]},mCt="wrapper";function yCt(e){let{components:n,...t}=e;return(0,s.yg)(mCt,(0,p.A)({},uCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}yCt.isMDXComponent=!0;const dCt={toc:[]},hCt="wrapper";function gCt(e){let{components:n,...t}=e;return(0,s.yg)(hCt,(0,p.A)({},dCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}gCt.isMDXComponent=!0;const fCt={toc:[]},DCt="wrapper";function MCt(e){let{components:n,...t}=e;return(0,s.yg)(DCt,(0,p.A)({},fCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}MCt.isMDXComponent=!0;const XCt={toc:[]},_Ct="wrapper";function wCt(e){let{components:n,...t}=e;return(0,s.yg)(_Ct,(0,p.A)({},XCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}wCt.isMDXComponent=!0;const TCt={toc:[]},CCt="wrapper";function xCt(e){let{components:n,...t}=e;return(0,s.yg)(CCt,(0,p.A)({},TCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}xCt.isMDXComponent=!0;const ACt={toc:[]},vCt="wrapper";function LCt(e){let{components:n,...t}=e;return(0,s.yg)(vCt,(0,p.A)({},ACt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}LCt.isMDXComponent=!0;const bCt={toc:[]},NCt="wrapper";function kCt(e){let{components:n,...t}=e;return(0,s.yg)(NCt,(0,p.A)({},bCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}kCt.isMDXComponent=!0;const zCt={toc:[]},PCt="wrapper";function ICt(e){let{components:n,...t}=e;return(0,s.yg)(PCt,(0,p.A)({},zCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}ICt.isMDXComponent=!0;const RCt={toc:[]},WCt="wrapper";function SCt(e){let{components:n,...t}=e;return(0,s.yg)(WCt,(0,p.A)({},RCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}SCt.isMDXComponent=!0;const BCt={toc:[]},ECt="wrapper";function GCt(e){let{components:n,...t}=e;return(0,s.yg)(ECt,(0,p.A)({},BCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}GCt.isMDXComponent=!0;const OCt={toc:[]},UCt="wrapper";function FCt(e){let{components:n,...t}=e;return(0,s.yg)(UCt,(0,p.A)({},OCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}FCt.isMDXComponent=!0;const VCt={toc:[]},qCt="wrapper";function jCt(e){let{components:n,...t}=e;return(0,s.yg)(qCt,(0,p.A)({},VCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}jCt.isMDXComponent=!0;const HCt={toc:[]},YCt="wrapper";function QCt(e){let{components:n,...t}=e;return(0,s.yg)(YCt,(0,p.A)({},HCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}QCt.isMDXComponent=!0;const $Ct={toc:[]},KCt="wrapper";function JCt(e){let{components:n,...t}=e;return(0,s.yg)(KCt,(0,p.A)({},$Ct,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}JCt.isMDXComponent=!0;const ZCt={toc:[]},ext="wrapper";function nxt(e){let{components:n,...t}=e;return(0,s.yg)(ext,(0,p.A)({},ZCt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}nxt.isMDXComponent=!0;const txt={toc:[]},oxt="wrapper";function pxt(e){let{components:n,...t}=e;return(0,s.yg)(oxt,(0,p.A)({},txt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}pxt.isMDXComponent=!0;const rxt={toc:[]},sxt="wrapper";function cxt(e){let{components:n,...t}=e;return(0,s.yg)(sxt,(0,p.A)({},rxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}cxt.isMDXComponent=!0;const axt={toc:[]},ixt="wrapper";function lxt(e){let{components:n,...t}=e;return(0,s.yg)(ixt,(0,p.A)({},axt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}lxt.isMDXComponent=!0;const uxt={toc:[]},mxt="wrapper";function yxt(e){let{components:n,...t}=e;return(0,s.yg)(mxt,(0,p.A)({},uxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}yxt.isMDXComponent=!0;const dxt={toc:[]},hxt="wrapper";function gxt(e){let{components:n,...t}=e;return(0,s.yg)(hxt,(0,p.A)({},dxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}gxt.isMDXComponent=!0;const fxt={toc:[]},Dxt="wrapper";function Mxt(e){let{components:n,...t}=e;return(0,s.yg)(Dxt,(0,p.A)({},fxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Mxt.isMDXComponent=!0;const Xxt={toc:[]},_xt="wrapper";function wxt(e){let{components:n,...t}=e;return(0,s.yg)(_xt,(0,p.A)({},Xxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}wxt.isMDXComponent=!0;const Txt={toc:[]},Cxt="wrapper";function xxt(e){let{components:n,...t}=e;return(0,s.yg)(Cxt,(0,p.A)({},Txt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}xxt.isMDXComponent=!0;const Axt={toc:[]},vxt="wrapper";function Lxt(e){let{components:n,...t}=e;return(0,s.yg)(vxt,(0,p.A)({},Axt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Lxt.isMDXComponent=!0;const bxt={toc:[]},Nxt="wrapper";function kxt(e){let{components:n,...t}=e;return(0,s.yg)(Nxt,(0,p.A)({},bxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}kxt.isMDXComponent=!0;const zxt={toc:[]},Pxt="wrapper";function Ixt(e){let{components:n,...t}=e;return(0,s.yg)(Pxt,(0,p.A)({},zxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}Ixt.isMDXComponent=!0;const Rxt={toc:[]},Wxt="wrapper";function Sxt(e){let{components:n,...t}=e;return(0,s.yg)(Wxt,(0,p.A)({},Rxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Sxt.isMDXComponent=!0;const Bxt={toc:[]},Ext="wrapper";function Gxt(e){let{components:n,...t}=e;return(0,s.yg)(Ext,(0,p.A)({},Bxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Gxt.isMDXComponent=!0;const Oxt={toc:[]},Uxt="wrapper";function Fxt(e){let{components:n,...t}=e;return(0,s.yg)(Uxt,(0,p.A)({},Oxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Fxt.isMDXComponent=!0;const Vxt={toc:[]},qxt="wrapper";function jxt(e){let{components:n,...t}=e;return(0,s.yg)(qxt,(0,p.A)({},Vxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}jxt.isMDXComponent=!0;const Hxt={toc:[]},Yxt="wrapper";function Qxt(e){let{components:n,...t}=e;return(0,s.yg)(Yxt,(0,p.A)({},Hxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Qxt.isMDXComponent=!0;const $xt={toc:[]},Kxt="wrapper";function Jxt(e){let{components:n,...t}=e;return(0,s.yg)(Kxt,(0,p.A)({},$xt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}Jxt.isMDXComponent=!0;const Zxt={toc:[]},eAt="wrapper";function nAt(e){let{components:n,...t}=e;return(0,s.yg)(eAt,(0,p.A)({},Zxt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}nAt.isMDXComponent=!0;const tAt={toc:[]},oAt="wrapper";function pAt(e){let{components:n,...t}=e;return(0,s.yg)(oAt,(0,p.A)({},tAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}pAt.isMDXComponent=!0;const rAt={toc:[]},sAt="wrapper";function cAt(e){let{components:n,...t}=e;return(0,s.yg)(sAt,(0,p.A)({},rAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}cAt.isMDXComponent=!0;const aAt={toc:[]},iAt="wrapper";function lAt(e){let{components:n,...t}=e;return(0,s.yg)(iAt,(0,p.A)({},aAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}lAt.isMDXComponent=!0;const uAt={toc:[]},mAt="wrapper";function yAt(e){let{components:n,...t}=e;return(0,s.yg)(mAt,(0,p.A)({},uAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}yAt.isMDXComponent=!0;const dAt={toc:[]},hAt="wrapper";function gAt(e){let{components:n,...t}=e;return(0,s.yg)(hAt,(0,p.A)({},dAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}gAt.isMDXComponent=!0;const fAt={toc:[]},DAt="wrapper";function MAt(e){let{components:n,...t}=e;return(0,s.yg)(DAt,(0,p.A)({},fAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}MAt.isMDXComponent=!0;const XAt={toc:[]},_At="wrapper";function wAt(e){let{components:n,...t}=e;return(0,s.yg)(_At,(0,p.A)({},XAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}wAt.isMDXComponent=!0;const TAt={toc:[]},CAt="wrapper";function xAt(e){let{components:n,...t}=e;return(0,s.yg)(CAt,(0,p.A)({},TAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}xAt.isMDXComponent=!0;const AAt={toc:[]},vAt="wrapper";function LAt(e){let{components:n,...t}=e;return(0,s.yg)(vAt,(0,p.A)({},AAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}LAt.isMDXComponent=!0;const bAt={toc:[]},NAt="wrapper";function kAt(e){let{components:n,...t}=e;return(0,s.yg)(NAt,(0,p.A)({},bAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}kAt.isMDXComponent=!0;const zAt={toc:[]},PAt="wrapper";function IAt(e){let{components:n,...t}=e;return(0,s.yg)(PAt,(0,p.A)({},zAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}IAt.isMDXComponent=!0;const RAt={toc:[]},WAt="wrapper";function SAt(e){let{components:n,...t}=e;return(0,s.yg)(WAt,(0,p.A)({},RAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}SAt.isMDXComponent=!0;const BAt={toc:[]},EAt="wrapper";function GAt(e){let{components:n,...t}=e;return(0,s.yg)(EAt,(0,p.A)({},BAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}GAt.isMDXComponent=!0;const OAt={toc:[]},UAt="wrapper";function FAt(e){let{components:n,...t}=e;return(0,s.yg)(UAt,(0,p.A)({},OAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}FAt.isMDXComponent=!0;const VAt={toc:[]},qAt="wrapper";function jAt(e){let{components:n,...t}=e;return(0,s.yg)(qAt,(0,p.A)({},VAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}jAt.isMDXComponent=!0;const HAt={toc:[]},YAt="wrapper";function QAt(e){let{components:n,...t}=e;return(0,s.yg)(YAt,(0,p.A)({},HAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}QAt.isMDXComponent=!0;const $At={toc:[]},KAt="wrapper";function JAt(e){let{components:n,...t}=e;return(0,s.yg)(KAt,(0,p.A)({},$At,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}JAt.isMDXComponent=!0;const ZAt={toc:[]},evt="wrapper";function nvt(e){let{components:n,...t}=e;return(0,s.yg)(evt,(0,p.A)({},ZAt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}nvt.isMDXComponent=!0;const tvt={toc:[]},ovt="wrapper";function pvt(e){let{components:n,...t}=e;return(0,s.yg)(ovt,(0,p.A)({},tvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}pvt.isMDXComponent=!0;const rvt={toc:[]},svt="wrapper";function cvt(e){let{components:n,...t}=e;return(0,s.yg)(svt,(0,p.A)({},rvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}cvt.isMDXComponent=!0;const avt={toc:[]},ivt="wrapper";function lvt(e){let{components:n,...t}=e;return(0,s.yg)(ivt,(0,p.A)({},avt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}lvt.isMDXComponent=!0;const uvt={toc:[]},mvt="wrapper";function yvt(e){let{components:n,...t}=e;return(0,s.yg)(mvt,(0,p.A)({},uvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}yvt.isMDXComponent=!0;const dvt={toc:[]},hvt="wrapper";function gvt(e){let{components:n,...t}=e;return(0,s.yg)(hvt,(0,p.A)({},dvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}gvt.isMDXComponent=!0;const fvt={toc:[]},Dvt="wrapper";function Mvt(e){let{components:n,...t}=e;return(0,s.yg)(Dvt,(0,p.A)({},fvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Mvt.isMDXComponent=!0;const Xvt={toc:[]},_vt="wrapper";function wvt(e){let{components:n,...t}=e;return(0,s.yg)(_vt,(0,p.A)({},Xvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}wvt.isMDXComponent=!0;const Tvt={toc:[]},Cvt="wrapper";function xvt(e){let{components:n,...t}=e;return(0,s.yg)(Cvt,(0,p.A)({},Tvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}xvt.isMDXComponent=!0;const Avt={toc:[]},vvt="wrapper";function Lvt(e){let{components:n,...t}=e;return(0,s.yg)(vvt,(0,p.A)({},Avt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Lvt.isMDXComponent=!0;const bvt={toc:[]},Nvt="wrapper";function kvt(e){let{components:n,...t}=e;return(0,s.yg)(Nvt,(0,p.A)({},bvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}kvt.isMDXComponent=!0;const zvt={toc:[]},Pvt="wrapper";function Ivt(e){let{components:n,...t}=e;return(0,s.yg)(Pvt,(0,p.A)({},zvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}Ivt.isMDXComponent=!0;const Rvt={toc:[]},Wvt="wrapper";function Svt(e){let{components:n,...t}=e;return(0,s.yg)(Wvt,(0,p.A)({},Rvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Svt.isMDXComponent=!0;const Bvt={toc:[]},Evt="wrapper";function Gvt(e){let{components:n,...t}=e;return(0,s.yg)(Evt,(0,p.A)({},Bvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Gvt.isMDXComponent=!0;const Ovt={toc:[]},Uvt="wrapper";function Fvt(e){let{components:n,...t}=e;return(0,s.yg)(Uvt,(0,p.A)({},Ovt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Fvt.isMDXComponent=!0;const Vvt={toc:[]},qvt="wrapper";function jvt(e){let{components:n,...t}=e;return(0,s.yg)(qvt,(0,p.A)({},Vvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}jvt.isMDXComponent=!0;const Hvt={toc:[]},Yvt="wrapper";function Qvt(e){let{components:n,...t}=e;return(0,s.yg)(Yvt,(0,p.A)({},Hvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Qvt.isMDXComponent=!0;const $vt={toc:[]},Kvt="wrapper";function Jvt(e){let{components:n,...t}=e;return(0,s.yg)(Kvt,(0,p.A)({},$vt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}Jvt.isMDXComponent=!0;const Zvt={toc:[]},eLt="wrapper";function nLt(e){let{components:n,...t}=e;return(0,s.yg)(eLt,(0,p.A)({},Zvt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}nLt.isMDXComponent=!0;const tLt={toc:[]},oLt="wrapper";function pLt(e){let{components:n,...t}=e;return(0,s.yg)(oLt,(0,p.A)({},tLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}pLt.isMDXComponent=!0;const rLt={toc:[]},sLt="wrapper";function cLt(e){let{components:n,...t}=e;return(0,s.yg)(sLt,(0,p.A)({},rLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}cLt.isMDXComponent=!0;const aLt={toc:[]},iLt="wrapper";function lLt(e){let{components:n,...t}=e;return(0,s.yg)(iLt,(0,p.A)({},aLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}lLt.isMDXComponent=!0;const uLt={toc:[]},mLt="wrapper";function yLt(e){let{components:n,...t}=e;return(0,s.yg)(mLt,(0,p.A)({},uLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}yLt.isMDXComponent=!0;const dLt={toc:[]},hLt="wrapper";function gLt(e){let{components:n,...t}=e;return(0,s.yg)(hLt,(0,p.A)({},dLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}gLt.isMDXComponent=!0;const fLt={toc:[]},DLt="wrapper";function MLt(e){let{components:n,...t}=e;return(0,s.yg)(DLt,(0,p.A)({},fLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}MLt.isMDXComponent=!0;const XLt={toc:[]},_Lt="wrapper";function wLt(e){let{components:n,...t}=e;return(0,s.yg)(_Lt,(0,p.A)({},XLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}wLt.isMDXComponent=!0;const TLt={toc:[]},CLt="wrapper";function xLt(e){let{components:n,...t}=e;return(0,s.yg)(CLt,(0,p.A)({},TLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}xLt.isMDXComponent=!0;const ALt={toc:[]},vLt="wrapper";function LLt(e){let{components:n,...t}=e;return(0,s.yg)(vLt,(0,p.A)({},ALt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Node#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}LLt.isMDXComponent=!0;const bLt={toc:[]},NLt="wrapper";function kLt(e){let{components:n,...t}=e;return(0,s.yg)(NLt,(0,p.A)({},bLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}kLt.isMDXComponent=!0;const zLt={toc:[]},PLt="wrapper";function ILt(e){let{components:n,...t}=e;return(0,s.yg)(PLt,(0,p.A)({},zLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}ILt.isMDXComponent=!0;const RLt={toc:[]},WLt="wrapper";function SLt(e){let{components:n,...t}=e;return(0,s.yg)(WLt,(0,p.A)({},RLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}SLt.isMDXComponent=!0;const BLt={toc:[]},ELt="wrapper";function GLt(e){let{components:n,...t}=e;return(0,s.yg)(ELt,(0,p.A)({},BLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}GLt.isMDXComponent=!0;const OLt={toc:[]},ULt="wrapper";function FLt(e){let{components:n,...t}=e;return(0,s.yg)(ULt,(0,p.A)({},OLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}FLt.isMDXComponent=!0;const VLt={toc:[]},qLt="wrapper";function jLt(e){let{components:n,...t}=e;return(0,s.yg)(qLt,(0,p.A)({},VLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}jLt.isMDXComponent=!0;const HLt={toc:[]},YLt="wrapper";function QLt(e){let{components:n,...t}=e;return(0,s.yg)(YLt,(0,p.A)({},HLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}QLt.isMDXComponent=!0;const $Lt={toc:[]},KLt="wrapper";function JLt(e){let{components:n,...t}=e;return(0,s.yg)(KLt,(0,p.A)({},$Lt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}JLt.isMDXComponent=!0;const ZLt={toc:[]},ebt="wrapper";function nbt(e){let{components:n,...t}=e;return(0,s.yg)(ebt,(0,p.A)({},ZLt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}nbt.isMDXComponent=!0;const tbt={toc:[]},obt="wrapper";function pbt(e){let{components:n,...t}=e;return(0,s.yg)(obt,(0,p.A)({},tbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}pbt.isMDXComponent=!0;const rbt={toc:[]},sbt="wrapper";function cbt(e){let{components:n,...t}=e;return(0,s.yg)(sbt,(0,p.A)({},rbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}cbt.isMDXComponent=!0;const abt={toc:[]},ibt="wrapper";function lbt(e){let{components:n,...t}=e;return(0,s.yg)(ibt,(0,p.A)({},abt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}lbt.isMDXComponent=!0;const ubt={toc:[]},mbt="wrapper";function ybt(e){let{components:n,...t}=e;return(0,s.yg)(mbt,(0,p.A)({},ubt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}ybt.isMDXComponent=!0;const dbt={toc:[]},hbt="wrapper";function gbt(e){let{components:n,...t}=e;return(0,s.yg)(hbt,(0,p.A)({},dbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}gbt.isMDXComponent=!0;const fbt={toc:[]},Dbt="wrapper";function Mbt(e){let{components:n,...t}=e;return(0,s.yg)(Dbt,(0,p.A)({},fbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Mbt.isMDXComponent=!0;const Xbt={toc:[]},_bt="wrapper";function wbt(e){let{components:n,...t}=e;return(0,s.yg)(_bt,(0,p.A)({},Xbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}wbt.isMDXComponent=!0;const Tbt={toc:[]},Cbt="wrapper";function xbt(e){let{components:n,...t}=e;return(0,s.yg)(Cbt,(0,p.A)({},Tbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}xbt.isMDXComponent=!0;const Abt={toc:[]},vbt="wrapper";function Lbt(e){let{components:n,...t}=e;return(0,s.yg)(vbt,(0,p.A)({},Abt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Lbt.isMDXComponent=!0;const bbt={toc:[]},Nbt="wrapper";function kbt(e){let{components:n,...t}=e;return(0,s.yg)(Nbt,(0,p.A)({},bbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}kbt.isMDXComponent=!0;const zbt={toc:[]},Pbt="wrapper";function Ibt(e){let{components:n,...t}=e;return(0,s.yg)(Pbt,(0,p.A)({},zbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Ibt.isMDXComponent=!0;const Rbt={toc:[]},Wbt="wrapper";function Sbt(e){let{components:n,...t}=e;return(0,s.yg)(Wbt,(0,p.A)({},Rbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Sbt.isMDXComponent=!0;const Bbt={toc:[]},Ebt="wrapper";function Gbt(e){let{components:n,...t}=e;return(0,s.yg)(Ebt,(0,p.A)({},Bbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Gbt.isMDXComponent=!0;const Obt={toc:[]},Ubt="wrapper";function Fbt(e){let{components:n,...t}=e;return(0,s.yg)(Ubt,(0,p.A)({},Obt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}Fbt.isMDXComponent=!0;const Vbt={toc:[]},qbt="wrapper";function jbt(e){let{components:n,...t}=e;return(0,s.yg)(qbt,(0,p.A)({},Vbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}jbt.isMDXComponent=!0;const Hbt={toc:[]},Ybt="wrapper";function Qbt(e){let{components:n,...t}=e;return(0,s.yg)(Ybt,(0,p.A)({},Hbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Qbt.isMDXComponent=!0;const $bt={toc:[]},Kbt="wrapper";function Jbt(e){let{components:n,...t}=e;return(0,s.yg)(Kbt,(0,p.A)({},$bt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}Jbt.isMDXComponent=!0;const Zbt={toc:[]},eNt="wrapper";function nNt(e){let{components:n,...t}=e;return(0,s.yg)(eNt,(0,p.A)({},Zbt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}nNt.isMDXComponent=!0;const tNt={toc:[]},oNt="wrapper";function pNt(e){let{components:n,...t}=e;return(0,s.yg)(oNt,(0,p.A)({},tNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}pNt.isMDXComponent=!0;const rNt={toc:[]},sNt="wrapper";function cNt(e){let{components:n,...t}=e;return(0,s.yg)(sNt,(0,p.A)({},rNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}cNt.isMDXComponent=!0;const aNt={toc:[]},iNt="wrapper";function lNt(e){let{components:n,...t}=e;return(0,s.yg)(iNt,(0,p.A)({},aNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}lNt.isMDXComponent=!0;const uNt={toc:[]},mNt="wrapper";function yNt(e){let{components:n,...t}=e;return(0,s.yg)(mNt,(0,p.A)({},uNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}yNt.isMDXComponent=!0;const dNt={toc:[]},hNt="wrapper";function gNt(e){let{components:n,...t}=e;return(0,s.yg)(hNt,(0,p.A)({},dNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}gNt.isMDXComponent=!0;const fNt={toc:[]},DNt="wrapper";function MNt(e){let{components:n,...t}=e;return(0,s.yg)(DNt,(0,p.A)({},fNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}MNt.isMDXComponent=!0;const XNt={toc:[]},_Nt="wrapper";function wNt(e){let{components:n,...t}=e;return(0,s.yg)(_Nt,(0,p.A)({},XNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}wNt.isMDXComponent=!0;const TNt={toc:[]},CNt="wrapper";function xNt(e){let{components:n,...t}=e;return(0,s.yg)(CNt,(0,p.A)({},TNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}xNt.isMDXComponent=!0;const ANt={toc:[]},vNt="wrapper";function LNt(e){let{components:n,...t}=e;return(0,s.yg)(vNt,(0,p.A)({},ANt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}LNt.isMDXComponent=!0;const bNt={toc:[]},NNt="wrapper";function kNt(e){let{components:n,...t}=e;return(0,s.yg)(NNt,(0,p.A)({},bNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}kNt.isMDXComponent=!0;const zNt={toc:[]},PNt="wrapper";function INt(e){let{components:n,...t}=e;return(0,s.yg)(PNt,(0,p.A)({},zNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}INt.isMDXComponent=!0;const RNt={toc:[]},WNt="wrapper";function SNt(e){let{components:n,...t}=e;return(0,s.yg)(WNt,(0,p.A)({},RNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}SNt.isMDXComponent=!0;const BNt={toc:[]},ENt="wrapper";function GNt(e){let{components:n,...t}=e;return(0,s.yg)(ENt,(0,p.A)({},BNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}GNt.isMDXComponent=!0;const ONt={toc:[]},UNt="wrapper";function FNt(e){let{components:n,...t}=e;return(0,s.yg)(UNt,(0,p.A)({},ONt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}FNt.isMDXComponent=!0;const VNt={toc:[]},qNt="wrapper";function jNt(e){let{components:n,...t}=e;return(0,s.yg)(qNt,(0,p.A)({},VNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}jNt.isMDXComponent=!0;const HNt={toc:[]},YNt="wrapper";function QNt(e){let{components:n,...t}=e;return(0,s.yg)(YNt,(0,p.A)({},HNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}QNt.isMDXComponent=!0;const $Nt={toc:[]},KNt="wrapper";function JNt(e){let{components:n,...t}=e;return(0,s.yg)(KNt,(0,p.A)({},$Nt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}JNt.isMDXComponent=!0;const ZNt={toc:[]},ekt="wrapper";function nkt(e){let{components:n,...t}=e;return(0,s.yg)(ekt,(0,p.A)({},ZNt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}nkt.isMDXComponent=!0;const tkt={toc:[]},okt="wrapper";function pkt(e){let{components:n,...t}=e;return(0,s.yg)(okt,(0,p.A)({},tkt,t,{components:n,mdxType:"MDXLayout"}))}pkt.isMDXComponent=!0;const rkt={toc:[]},skt="wrapper";function ckt(e){let{components:n,...t}=e;return(0,s.yg)(skt,(0,p.A)({},rkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}ckt.isMDXComponent=!0;const akt={toc:[]},ikt="wrapper";function lkt(e){let{components:n,...t}=e;return(0,s.yg)(ikt,(0,p.A)({},akt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}lkt.isMDXComponent=!0;const ukt={toc:[]},mkt="wrapper";function ykt(e){let{components:n,...t}=e;return(0,s.yg)(mkt,(0,p.A)({},ukt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}ykt.isMDXComponent=!0;const dkt={toc:[]},hkt="wrapper";function gkt(e){let{components:n,...t}=e;return(0,s.yg)(hkt,(0,p.A)({},dkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}gkt.isMDXComponent=!0;const fkt={toc:[]},Dkt="wrapper";function Mkt(e){let{components:n,...t}=e;return(0,s.yg)(Dkt,(0,p.A)({},fkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}Mkt.isMDXComponent=!0;const Xkt={toc:[]},_kt="wrapper";function wkt(e){let{components:n,...t}=e;return(0,s.yg)(_kt,(0,p.A)({},Xkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}wkt.isMDXComponent=!0;const Tkt={toc:[]},Ckt="wrapper";function xkt(e){let{components:n,...t}=e;return(0,s.yg)(Ckt,(0,p.A)({},Tkt,t,{components:n,mdxType:"MDXLayout"}))}xkt.isMDXComponent=!0;const Akt={toc:[]},vkt="wrapper";function Lkt(e){let{components:n,...t}=e;return(0,s.yg)(vkt,(0,p.A)({},Akt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Lkt.isMDXComponent=!0;const bkt={toc:[]},Nkt="wrapper";function kkt(e){let{components:n,...t}=e;return(0,s.yg)(Nkt,(0,p.A)({},bkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}kkt.isMDXComponent=!0;const zkt={toc:[]},Pkt="wrapper";function Ikt(e){let{components:n,...t}=e;return(0,s.yg)(Pkt,(0,p.A)({},zkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Ikt.isMDXComponent=!0;const Rkt={toc:[]},Wkt="wrapper";function Skt(e){let{components:n,...t}=e;return(0,s.yg)(Wkt,(0,p.A)({},Rkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Skt.isMDXComponent=!0;const Bkt={toc:[]},Ekt="wrapper";function Gkt(e){let{components:n,...t}=e;return(0,s.yg)(Ekt,(0,p.A)({},Bkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Gkt.isMDXComponent=!0;const Okt={toc:[]},Ukt="wrapper";function Fkt(e){let{components:n,...t}=e;return(0,s.yg)(Ukt,(0,p.A)({},Okt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}Fkt.isMDXComponent=!0;const Vkt={toc:[]},qkt="wrapper";function jkt(e){let{components:n,...t}=e;return(0,s.yg)(qkt,(0,p.A)({},Vkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}jkt.isMDXComponent=!0;const Hkt={toc:[]},Ykt="wrapper";function Qkt(e){let{components:n,...t}=e;return(0,s.yg)(Ykt,(0,p.A)({},Hkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Qkt.isMDXComponent=!0;const $kt={toc:[]},Kkt="wrapper";function Jkt(e){let{components:n,...t}=e;return(0,s.yg)(Kkt,(0,p.A)({},$kt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Jkt.isMDXComponent=!0;const Zkt={toc:[]},ezt="wrapper";function nzt(e){let{components:n,...t}=e;return(0,s.yg)(ezt,(0,p.A)({},Zkt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}nzt.isMDXComponent=!0;const tzt={toc:[]},ozt="wrapper";function pzt(e){let{components:n,...t}=e;return(0,s.yg)(ozt,(0,p.A)({},tzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}pzt.isMDXComponent=!0;const rzt={toc:[]},szt="wrapper";function czt(e){let{components:n,...t}=e;return(0,s.yg)(szt,(0,p.A)({},rzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}czt.isMDXComponent=!0;const azt={toc:[]},izt="wrapper";function lzt(e){let{components:n,...t}=e;return(0,s.yg)(izt,(0,p.A)({},azt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}lzt.isMDXComponent=!0;const uzt={toc:[]},mzt="wrapper";function yzt(e){let{components:n,...t}=e;return(0,s.yg)(mzt,(0,p.A)({},uzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}yzt.isMDXComponent=!0;const dzt={toc:[]},hzt="wrapper";function gzt(e){let{components:n,...t}=e;return(0,s.yg)(hzt,(0,p.A)({},dzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}gzt.isMDXComponent=!0;const fzt={toc:[]},Dzt="wrapper";function Mzt(e){let{components:n,...t}=e;return(0,s.yg)(Dzt,(0,p.A)({},fzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}Mzt.isMDXComponent=!0;const Xzt={toc:[]},_zt="wrapper";function wzt(e){let{components:n,...t}=e;return(0,s.yg)(_zt,(0,p.A)({},Xzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}wzt.isMDXComponent=!0;const Tzt={toc:[]},Czt="wrapper";function xzt(e){let{components:n,...t}=e;return(0,s.yg)(Czt,(0,p.A)({},Tzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}xzt.isMDXComponent=!0;const Azt={toc:[]},vzt="wrapper";function Lzt(e){let{components:n,...t}=e;return(0,s.yg)(vzt,(0,p.A)({},Azt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Lzt.isMDXComponent=!0;const bzt={toc:[]},Nzt="wrapper";function kzt(e){let{components:n,...t}=e;return(0,s.yg)(Nzt,(0,p.A)({},bzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}kzt.isMDXComponent=!0;const zzt={toc:[]},Pzt="wrapper";function Izt(e){let{components:n,...t}=e;return(0,s.yg)(Pzt,(0,p.A)({},zzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Izt.isMDXComponent=!0;const Rzt={toc:[]},Wzt="wrapper";function Szt(e){let{components:n,...t}=e;return(0,s.yg)(Wzt,(0,p.A)({},Rzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Szt.isMDXComponent=!0;const Bzt={toc:[]},Ezt="wrapper";function Gzt(e){let{components:n,...t}=e;return(0,s.yg)(Ezt,(0,p.A)({},Bzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}Gzt.isMDXComponent=!0;const Ozt={toc:[]},Uzt="wrapper";function Fzt(e){let{components:n,...t}=e;return(0,s.yg)(Uzt,(0,p.A)({},Ozt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}Fzt.isMDXComponent=!0;const Vzt={toc:[]},qzt="wrapper";function jzt(e){let{components:n,...t}=e;return(0,s.yg)(qzt,(0,p.A)({},Vzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}jzt.isMDXComponent=!0;const Hzt={toc:[]},Yzt="wrapper";function Qzt(e){let{components:n,...t}=e;return(0,s.yg)(Yzt,(0,p.A)({},Hzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}Qzt.isMDXComponent=!0;const $zt={toc:[]},Kzt="wrapper";function Jzt(e){let{components:n,...t}=e;return(0,s.yg)(Kzt,(0,p.A)({},$zt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Jzt.isMDXComponent=!0;const Zzt={toc:[]},ePt="wrapper";function nPt(e){let{components:n,...t}=e;return(0,s.yg)(ePt,(0,p.A)({},Zzt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}nPt.isMDXComponent=!0;const tPt={toc:[]},oPt="wrapper";function pPt(e){let{components:n,...t}=e;return(0,s.yg)(oPt,(0,p.A)({},tPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}pPt.isMDXComponent=!0;const rPt={toc:[]},sPt="wrapper";function cPt(e){let{components:n,...t}=e;return(0,s.yg)(sPt,(0,p.A)({},rPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}cPt.isMDXComponent=!0;const aPt={toc:[]},iPt="wrapper";function lPt(e){let{components:n,...t}=e;return(0,s.yg)(iPt,(0,p.A)({},aPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}lPt.isMDXComponent=!0;const uPt={toc:[]},mPt="wrapper";function yPt(e){let{components:n,...t}=e;return(0,s.yg)(mPt,(0,p.A)({},uPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}yPt.isMDXComponent=!0;const dPt={toc:[]},hPt="wrapper";function gPt(e){let{components:n,...t}=e;return(0,s.yg)(hPt,(0,p.A)({},dPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}gPt.isMDXComponent=!0;const fPt={toc:[]},DPt="wrapper";function MPt(e){let{components:n,...t}=e;return(0,s.yg)(DPt,(0,p.A)({},fPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}MPt.isMDXComponent=!0;const XPt={toc:[]},_Pt="wrapper";function wPt(e){let{components:n,...t}=e;return(0,s.yg)(_Pt,(0,p.A)({},XPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}wPt.isMDXComponent=!0;const TPt={toc:[]},CPt="wrapper";function xPt(e){let{components:n,...t}=e;return(0,s.yg)(CPt,(0,p.A)({},TPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}xPt.isMDXComponent=!0;const APt={toc:[]},vPt="wrapper";function LPt(e){let{components:n,...t}=e;return(0,s.yg)(vPt,(0,p.A)({},APt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}LPt.isMDXComponent=!0;const bPt={toc:[]},NPt="wrapper";function kPt(e){let{components:n,...t}=e;return(0,s.yg)(NPt,(0,p.A)({},bPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}kPt.isMDXComponent=!0;const zPt={toc:[]},PPt="wrapper";function IPt(e){let{components:n,...t}=e;return(0,s.yg)(PPt,(0,p.A)({},zPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}IPt.isMDXComponent=!0;const RPt={toc:[]},WPt="wrapper";function SPt(e){let{components:n,...t}=e;return(0,s.yg)(WPt,(0,p.A)({},RPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}SPt.isMDXComponent=!0;const BPt={toc:[]},EPt="wrapper";function GPt(e){let{components:n,...t}=e;return(0,s.yg)(EPt,(0,p.A)({},BPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}GPt.isMDXComponent=!0;const OPt={toc:[]},UPt="wrapper";function FPt(e){let{components:n,...t}=e;return(0,s.yg)(UPt,(0,p.A)({},OPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}FPt.isMDXComponent=!0;const VPt={toc:[]},qPt="wrapper";function jPt(e){let{components:n,...t}=e;return(0,s.yg)(qPt,(0,p.A)({},VPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}jPt.isMDXComponent=!0;const HPt={toc:[]},YPt="wrapper";function QPt(e){let{components:n,...t}=e;return(0,s.yg)(YPt,(0,p.A)({},HPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}QPt.isMDXComponent=!0;const $Pt={toc:[]},KPt="wrapper";function JPt(e){let{components:n,...t}=e;return(0,s.yg)(KPt,(0,p.A)({},$Pt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}JPt.isMDXComponent=!0;const ZPt={toc:[]},eIt="wrapper";function nIt(e){let{components:n,...t}=e;return(0,s.yg)(eIt,(0,p.A)({},ZPt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}nIt.isMDXComponent=!0;const tIt={toc:[]},oIt="wrapper";function pIt(e){let{components:n,...t}=e;return(0,s.yg)(oIt,(0,p.A)({},tIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}pIt.isMDXComponent=!0;const rIt={toc:[]},sIt="wrapper";function cIt(e){let{components:n,...t}=e;return(0,s.yg)(sIt,(0,p.A)({},rIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}cIt.isMDXComponent=!0;const aIt={toc:[]},iIt="wrapper";function lIt(e){let{components:n,...t}=e;return(0,s.yg)(iIt,(0,p.A)({},aIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}lIt.isMDXComponent=!0;const uIt={toc:[]},mIt="wrapper";function yIt(e){let{components:n,...t}=e;return(0,s.yg)(mIt,(0,p.A)({},uIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}yIt.isMDXComponent=!0;const dIt={toc:[]},hIt="wrapper";function gIt(e){let{components:n,...t}=e;return(0,s.yg)(hIt,(0,p.A)({},dIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}gIt.isMDXComponent=!0;const fIt={toc:[]},DIt="wrapper";function MIt(e){let{components:n,...t}=e;return(0,s.yg)(DIt,(0,p.A)({},fIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}MIt.isMDXComponent=!0;const XIt={toc:[]},_It="wrapper";function wIt(e){let{components:n,...t}=e;return(0,s.yg)(_It,(0,p.A)({},XIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}wIt.isMDXComponent=!0;const TIt={toc:[]},CIt="wrapper";function xIt(e){let{components:n,...t}=e;return(0,s.yg)(CIt,(0,p.A)({},TIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}xIt.isMDXComponent=!0;const AIt={toc:[]},vIt="wrapper";function LIt(e){let{components:n,...t}=e;return(0,s.yg)(vIt,(0,p.A)({},AIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}LIt.isMDXComponent=!0;const bIt={toc:[]},NIt="wrapper";function kIt(e){let{components:n,...t}=e;return(0,s.yg)(NIt,(0,p.A)({},bIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}kIt.isMDXComponent=!0;const zIt={toc:[]},PIt="wrapper";function IIt(e){let{components:n,...t}=e;return(0,s.yg)(PIt,(0,p.A)({},zIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}IIt.isMDXComponent=!0;const RIt={toc:[]},WIt="wrapper";function SIt(e){let{components:n,...t}=e;return(0,s.yg)(WIt,(0,p.A)({},RIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}SIt.isMDXComponent=!0;const BIt={toc:[]},EIt="wrapper";function GIt(e){let{components:n,...t}=e;return(0,s.yg)(EIt,(0,p.A)({},BIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}GIt.isMDXComponent=!0;const OIt={toc:[]},UIt="wrapper";function FIt(e){let{components:n,...t}=e;return(0,s.yg)(UIt,(0,p.A)({},OIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}FIt.isMDXComponent=!0;const VIt={toc:[]},qIt="wrapper";function jIt(e){let{components:n,...t}=e;return(0,s.yg)(qIt,(0,p.A)({},VIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}jIt.isMDXComponent=!0;const HIt={toc:[]},YIt="wrapper";function QIt(e){let{components:n,...t}=e;return(0,s.yg)(YIt,(0,p.A)({},HIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}QIt.isMDXComponent=!0;const $It={toc:[]},KIt="wrapper";function JIt(e){let{components:n,...t}=e;return(0,s.yg)(KIt,(0,p.A)({},$It,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}JIt.isMDXComponent=!0;const ZIt={toc:[]},eRt="wrapper";function nRt(e){let{components:n,...t}=e;return(0,s.yg)(eRt,(0,p.A)({},ZIt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}nRt.isMDXComponent=!0;const tRt={toc:[]},oRt="wrapper";function pRt(e){let{components:n,...t}=e;return(0,s.yg)(oRt,(0,p.A)({},tRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}pRt.isMDXComponent=!0;const rRt={toc:[]},sRt="wrapper";function cRt(e){let{components:n,...t}=e;return(0,s.yg)(sRt,(0,p.A)({},rRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}cRt.isMDXComponent=!0;const aRt={toc:[]},iRt="wrapper";function lRt(e){let{components:n,...t}=e;return(0,s.yg)(iRt,(0,p.A)({},aRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}lRt.isMDXComponent=!0;const uRt={toc:[]},mRt="wrapper";function yRt(e){let{components:n,...t}=e;return(0,s.yg)(mRt,(0,p.A)({},uRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}yRt.isMDXComponent=!0;const dRt={toc:[]},hRt="wrapper";function gRt(e){let{components:n,...t}=e;return(0,s.yg)(hRt,(0,p.A)({},dRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}gRt.isMDXComponent=!0;const fRt={toc:[]},DRt="wrapper";function MRt(e){let{components:n,...t}=e;return(0,s.yg)(DRt,(0,p.A)({},fRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}MRt.isMDXComponent=!0;const XRt={toc:[]},_Rt="wrapper";function wRt(e){let{components:n,...t}=e;return(0,s.yg)(_Rt,(0,p.A)({},XRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}wRt.isMDXComponent=!0;const TRt={toc:[]},CRt="wrapper";function xRt(e){let{components:n,...t}=e;return(0,s.yg)(CRt,(0,p.A)({},TRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}xRt.isMDXComponent=!0;const ARt={toc:[]},vRt="wrapper";function LRt(e){let{components:n,...t}=e;return(0,s.yg)(vRt,(0,p.A)({},ARt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}LRt.isMDXComponent=!0;const bRt={toc:[]},NRt="wrapper";function kRt(e){let{components:n,...t}=e;return(0,s.yg)(NRt,(0,p.A)({},bRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}kRt.isMDXComponent=!0;const zRt={toc:[]},PRt="wrapper";function IRt(e){let{components:n,...t}=e;return(0,s.yg)(PRt,(0,p.A)({},zRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}IRt.isMDXComponent=!0;const RRt={toc:[]},WRt="wrapper";function SRt(e){let{components:n,...t}=e;return(0,s.yg)(WRt,(0,p.A)({},RRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}SRt.isMDXComponent=!0;const BRt={toc:[]},ERt="wrapper";function GRt(e){let{components:n,...t}=e;return(0,s.yg)(ERt,(0,p.A)({},BRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}GRt.isMDXComponent=!0;const ORt={toc:[]},URt="wrapper";function FRt(e){let{components:n,...t}=e;return(0,s.yg)(URt,(0,p.A)({},ORt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}FRt.isMDXComponent=!0;const VRt={toc:[]},qRt="wrapper";function jRt(e){let{components:n,...t}=e;return(0,s.yg)(qRt,(0,p.A)({},VRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}jRt.isMDXComponent=!0;const HRt={toc:[]},YRt="wrapper";function QRt(e){let{components:n,...t}=e;return(0,s.yg)(YRt,(0,p.A)({},HRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}QRt.isMDXComponent=!0;const $Rt={toc:[]},KRt="wrapper";function JRt(e){let{components:n,...t}=e;return(0,s.yg)(KRt,(0,p.A)({},$Rt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}JRt.isMDXComponent=!0;const ZRt={toc:[]},eWt="wrapper";function nWt(e){let{components:n,...t}=e;return(0,s.yg)(eWt,(0,p.A)({},ZRt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}nWt.isMDXComponent=!0;const tWt={toc:[]},oWt="wrapper";function pWt(e){let{components:n,...t}=e;return(0,s.yg)(oWt,(0,p.A)({},tWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}pWt.isMDXComponent=!0;const rWt={toc:[]},sWt="wrapper";function cWt(e){let{components:n,...t}=e;return(0,s.yg)(sWt,(0,p.A)({},rWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}cWt.isMDXComponent=!0;const aWt={toc:[]},iWt="wrapper";function lWt(e){let{components:n,...t}=e;return(0,s.yg)(iWt,(0,p.A)({},aWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}lWt.isMDXComponent=!0;const uWt={toc:[]},mWt="wrapper";function yWt(e){let{components:n,...t}=e;return(0,s.yg)(mWt,(0,p.A)({},uWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}yWt.isMDXComponent=!0;const dWt={toc:[]},hWt="wrapper";function gWt(e){let{components:n,...t}=e;return(0,s.yg)(hWt,(0,p.A)({},dWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}gWt.isMDXComponent=!0;const fWt={toc:[]},DWt="wrapper";function MWt(e){let{components:n,...t}=e;return(0,s.yg)(DWt,(0,p.A)({},fWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}MWt.isMDXComponent=!0;const XWt={toc:[]},_Wt="wrapper";function wWt(e){let{components:n,...t}=e;return(0,s.yg)(_Wt,(0,p.A)({},XWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}wWt.isMDXComponent=!0;const TWt={toc:[]},CWt="wrapper";function xWt(e){let{components:n,...t}=e;return(0,s.yg)(CWt,(0,p.A)({},TWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}xWt.isMDXComponent=!0;const AWt={toc:[]},vWt="wrapper";function LWt(e){let{components:n,...t}=e;return(0,s.yg)(vWt,(0,p.A)({},AWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}LWt.isMDXComponent=!0;const bWt={toc:[]},NWt="wrapper";function kWt(e){let{components:n,...t}=e;return(0,s.yg)(NWt,(0,p.A)({},bWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}kWt.isMDXComponent=!0;const zWt={toc:[]},PWt="wrapper";function IWt(e){let{components:n,...t}=e;return(0,s.yg)(PWt,(0,p.A)({},zWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}IWt.isMDXComponent=!0;const RWt={toc:[]},WWt="wrapper";function SWt(e){let{components:n,...t}=e;return(0,s.yg)(WWt,(0,p.A)({},RWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}SWt.isMDXComponent=!0;const BWt={toc:[]},EWt="wrapper";function GWt(e){let{components:n,...t}=e;return(0,s.yg)(EWt,(0,p.A)({},BWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}GWt.isMDXComponent=!0;const OWt={toc:[]},UWt="wrapper";function FWt(e){let{components:n,...t}=e;return(0,s.yg)(UWt,(0,p.A)({},OWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}FWt.isMDXComponent=!0;const VWt={toc:[]},qWt="wrapper";function jWt(e){let{components:n,...t}=e;return(0,s.yg)(qWt,(0,p.A)({},VWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}jWt.isMDXComponent=!0;const HWt={toc:[]},YWt="wrapper";function QWt(e){let{components:n,...t}=e;return(0,s.yg)(YWt,(0,p.A)({},HWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}QWt.isMDXComponent=!0;const $Wt={toc:[]},KWt="wrapper";function JWt(e){let{components:n,...t}=e;return(0,s.yg)(KWt,(0,p.A)({},$Wt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}JWt.isMDXComponent=!0;const ZWt={toc:[]},eSt="wrapper";function nSt(e){let{components:n,...t}=e;return(0,s.yg)(eSt,(0,p.A)({},ZWt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}nSt.isMDXComponent=!0;const tSt={toc:[]},oSt="wrapper";function pSt(e){let{components:n,...t}=e;return(0,s.yg)(oSt,(0,p.A)({},tSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}pSt.isMDXComponent=!0;const rSt={toc:[]},sSt="wrapper";function cSt(e){let{components:n,...t}=e;return(0,s.yg)(sSt,(0,p.A)({},rSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}cSt.isMDXComponent=!0;const aSt={toc:[]},iSt="wrapper";function lSt(e){let{components:n,...t}=e;return(0,s.yg)(iSt,(0,p.A)({},aSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}lSt.isMDXComponent=!0;const uSt={toc:[]},mSt="wrapper";function ySt(e){let{components:n,...t}=e;return(0,s.yg)(mSt,(0,p.A)({},uSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}ySt.isMDXComponent=!0;const dSt={toc:[]},hSt="wrapper";function gSt(e){let{components:n,...t}=e;return(0,s.yg)(hSt,(0,p.A)({},dSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}gSt.isMDXComponent=!0;const fSt={toc:[]},DSt="wrapper";function MSt(e){let{components:n,...t}=e;return(0,s.yg)(DSt,(0,p.A)({},fSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}MSt.isMDXComponent=!0;const XSt={toc:[]},_St="wrapper";function wSt(e){let{components:n,...t}=e;return(0,s.yg)(_St,(0,p.A)({},XSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}wSt.isMDXComponent=!0;const TSt={toc:[]},CSt="wrapper";function xSt(e){let{components:n,...t}=e;return(0,s.yg)(CSt,(0,p.A)({},TSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}xSt.isMDXComponent=!0;const ASt={toc:[]},vSt="wrapper";function LSt(e){let{components:n,...t}=e;return(0,s.yg)(vSt,(0,p.A)({},ASt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}LSt.isMDXComponent=!0;const bSt={toc:[]},NSt="wrapper";function kSt(e){let{components:n,...t}=e;return(0,s.yg)(NSt,(0,p.A)({},bSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}kSt.isMDXComponent=!0;const zSt={toc:[]},PSt="wrapper";function ISt(e){let{components:n,...t}=e;return(0,s.yg)(PSt,(0,p.A)({},zSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}ISt.isMDXComponent=!0;const RSt={toc:[]},WSt="wrapper";function SSt(e){let{components:n,...t}=e;return(0,s.yg)(WSt,(0,p.A)({},RSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}SSt.isMDXComponent=!0;const BSt={toc:[]},ESt="wrapper";function GSt(e){let{components:n,...t}=e;return(0,s.yg)(ESt,(0,p.A)({},BSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}GSt.isMDXComponent=!0;const OSt={toc:[]},USt="wrapper";function FSt(e){let{components:n,...t}=e;return(0,s.yg)(USt,(0,p.A)({},OSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}FSt.isMDXComponent=!0;const VSt={toc:[]},qSt="wrapper";function jSt(e){let{components:n,...t}=e;return(0,s.yg)(qSt,(0,p.A)({},VSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}jSt.isMDXComponent=!0;const HSt={toc:[]},YSt="wrapper";function QSt(e){let{components:n,...t}=e;return(0,s.yg)(YSt,(0,p.A)({},HSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}QSt.isMDXComponent=!0;const $St={toc:[]},KSt="wrapper";function JSt(e){let{components:n,...t}=e;return(0,s.yg)(KSt,(0,p.A)({},$St,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}JSt.isMDXComponent=!0;const ZSt={toc:[]},eBt="wrapper";function nBt(e){let{components:n,...t}=e;return(0,s.yg)(eBt,(0,p.A)({},ZSt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}nBt.isMDXComponent=!0;const tBt={toc:[]},oBt="wrapper";function pBt(e){let{components:n,...t}=e;return(0,s.yg)(oBt,(0,p.A)({},tBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}pBt.isMDXComponent=!0;const rBt={toc:[]},sBt="wrapper";function cBt(e){let{components:n,...t}=e;return(0,s.yg)(sBt,(0,p.A)({},rBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}cBt.isMDXComponent=!0;const aBt={toc:[]},iBt="wrapper";function lBt(e){let{components:n,...t}=e;return(0,s.yg)(iBt,(0,p.A)({},aBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}lBt.isMDXComponent=!0;const uBt={toc:[]},mBt="wrapper";function yBt(e){let{components:n,...t}=e;return(0,s.yg)(mBt,(0,p.A)({},uBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}yBt.isMDXComponent=!0;const dBt={toc:[]},hBt="wrapper";function gBt(e){let{components:n,...t}=e;return(0,s.yg)(hBt,(0,p.A)({},dBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}gBt.isMDXComponent=!0;const fBt={toc:[]},DBt="wrapper";function MBt(e){let{components:n,...t}=e;return(0,s.yg)(DBt,(0,p.A)({},fBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}MBt.isMDXComponent=!0;const XBt={toc:[]},_Bt="wrapper";function wBt(e){let{components:n,...t}=e;return(0,s.yg)(_Bt,(0,p.A)({},XBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}wBt.isMDXComponent=!0;const TBt={toc:[]},CBt="wrapper";function xBt(e){let{components:n,...t}=e;return(0,s.yg)(CBt,(0,p.A)({},TBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}xBt.isMDXComponent=!0;const ABt={toc:[]},vBt="wrapper";function LBt(e){let{components:n,...t}=e;return(0,s.yg)(vBt,(0,p.A)({},ABt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}LBt.isMDXComponent=!0;const bBt={toc:[]},NBt="wrapper";function kBt(e){let{components:n,...t}=e;return(0,s.yg)(NBt,(0,p.A)({},bBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}kBt.isMDXComponent=!0;const zBt={toc:[]},PBt="wrapper";function IBt(e){let{components:n,...t}=e;return(0,s.yg)(PBt,(0,p.A)({},zBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}IBt.isMDXComponent=!0;const RBt={toc:[]},WBt="wrapper";function SBt(e){let{components:n,...t}=e;return(0,s.yg)(WBt,(0,p.A)({},RBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}SBt.isMDXComponent=!0;const BBt={toc:[]},EBt="wrapper";function GBt(e){let{components:n,...t}=e;return(0,s.yg)(EBt,(0,p.A)({},BBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}GBt.isMDXComponent=!0;const OBt={toc:[]},UBt="wrapper";function FBt(e){let{components:n,...t}=e;return(0,s.yg)(UBt,(0,p.A)({},OBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}FBt.isMDXComponent=!0;const VBt={toc:[]},qBt="wrapper";function jBt(e){let{components:n,...t}=e;return(0,s.yg)(qBt,(0,p.A)({},VBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}jBt.isMDXComponent=!0;const HBt={toc:[]},YBt="wrapper";function QBt(e){let{components:n,...t}=e;return(0,s.yg)(YBt,(0,p.A)({},HBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}QBt.isMDXComponent=!0;const $Bt={toc:[]},KBt="wrapper";function JBt(e){let{components:n,...t}=e;return(0,s.yg)(KBt,(0,p.A)({},$Bt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}JBt.isMDXComponent=!0;const ZBt={toc:[]},eEt="wrapper";function nEt(e){let{components:n,...t}=e;return(0,s.yg)(eEt,(0,p.A)({},ZBt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}nEt.isMDXComponent=!0;const tEt={toc:[]},oEt="wrapper";function pEt(e){let{components:n,...t}=e;return(0,s.yg)(oEt,(0,p.A)({},tEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}pEt.isMDXComponent=!0;const rEt={toc:[]},sEt="wrapper";function cEt(e){let{components:n,...t}=e;return(0,s.yg)(sEt,(0,p.A)({},rEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}cEt.isMDXComponent=!0;const aEt={toc:[]},iEt="wrapper";function lEt(e){let{components:n,...t}=e;return(0,s.yg)(iEt,(0,p.A)({},aEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}lEt.isMDXComponent=!0;const uEt={toc:[]},mEt="wrapper";function yEt(e){let{components:n,...t}=e;return(0,s.yg)(mEt,(0,p.A)({},uEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}yEt.isMDXComponent=!0;const dEt={toc:[]},hEt="wrapper";function gEt(e){let{components:n,...t}=e;return(0,s.yg)(hEt,(0,p.A)({},dEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}gEt.isMDXComponent=!0;const fEt={toc:[]},DEt="wrapper";function MEt(e){let{components:n,...t}=e;return(0,s.yg)(DEt,(0,p.A)({},fEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}MEt.isMDXComponent=!0;const XEt={toc:[]},_Et="wrapper";function wEt(e){let{components:n,...t}=e;return(0,s.yg)(_Et,(0,p.A)({},XEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}wEt.isMDXComponent=!0;const TEt={toc:[]},CEt="wrapper";function xEt(e){let{components:n,...t}=e;return(0,s.yg)(CEt,(0,p.A)({},TEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}xEt.isMDXComponent=!0;const AEt={toc:[]},vEt="wrapper";function LEt(e){let{components:n,...t}=e;return(0,s.yg)(vEt,(0,p.A)({},AEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}LEt.isMDXComponent=!0;const bEt={toc:[]},NEt="wrapper";function kEt(e){let{components:n,...t}=e;return(0,s.yg)(NEt,(0,p.A)({},bEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}kEt.isMDXComponent=!0;const zEt={toc:[]},PEt="wrapper";function IEt(e){let{components:n,...t}=e;return(0,s.yg)(PEt,(0,p.A)({},zEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}IEt.isMDXComponent=!0;const REt={toc:[]},WEt="wrapper";function SEt(e){let{components:n,...t}=e;return(0,s.yg)(WEt,(0,p.A)({},REt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}SEt.isMDXComponent=!0;const BEt={toc:[]},EEt="wrapper";function GEt(e){let{components:n,...t}=e;return(0,s.yg)(EEt,(0,p.A)({},BEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}GEt.isMDXComponent=!0;const OEt={toc:[]},UEt="wrapper";function FEt(e){let{components:n,...t}=e;return(0,s.yg)(UEt,(0,p.A)({},OEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}FEt.isMDXComponent=!0;const VEt={toc:[]},qEt="wrapper";function jEt(e){let{components:n,...t}=e;return(0,s.yg)(qEt,(0,p.A)({},VEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}jEt.isMDXComponent=!0;const HEt={toc:[]},YEt="wrapper";function QEt(e){let{components:n,...t}=e;return(0,s.yg)(YEt,(0,p.A)({},HEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}QEt.isMDXComponent=!0;const $Et={toc:[]},KEt="wrapper";function JEt(e){let{components:n,...t}=e;return(0,s.yg)(KEt,(0,p.A)({},$Et,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}JEt.isMDXComponent=!0;const ZEt={toc:[]},eGt="wrapper";function nGt(e){let{components:n,...t}=e;return(0,s.yg)(eGt,(0,p.A)({},ZEt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}nGt.isMDXComponent=!0;const tGt={toc:[]},oGt="wrapper";function pGt(e){let{components:n,...t}=e;return(0,s.yg)(oGt,(0,p.A)({},tGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}pGt.isMDXComponent=!0;const rGt={toc:[]},sGt="wrapper";function cGt(e){let{components:n,...t}=e;return(0,s.yg)(sGt,(0,p.A)({},rGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}cGt.isMDXComponent=!0;const aGt={toc:[]},iGt="wrapper";function lGt(e){let{components:n,...t}=e;return(0,s.yg)(iGt,(0,p.A)({},aGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}lGt.isMDXComponent=!0;const uGt={toc:[]},mGt="wrapper";function yGt(e){let{components:n,...t}=e;return(0,s.yg)(mGt,(0,p.A)({},uGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}yGt.isMDXComponent=!0;const dGt={toc:[]},hGt="wrapper";function gGt(e){let{components:n,...t}=e;return(0,s.yg)(hGt,(0,p.A)({},dGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}gGt.isMDXComponent=!0;const fGt={toc:[]},DGt="wrapper";function MGt(e){let{components:n,...t}=e;return(0,s.yg)(DGt,(0,p.A)({},fGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}MGt.isMDXComponent=!0;const XGt={toc:[]},_Gt="wrapper";function wGt(e){let{components:n,...t}=e;return(0,s.yg)(_Gt,(0,p.A)({},XGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}wGt.isMDXComponent=!0;const TGt={toc:[]},CGt="wrapper";function xGt(e){let{components:n,...t}=e;return(0,s.yg)(CGt,(0,p.A)({},TGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Path#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}xGt.isMDXComponent=!0;const AGt={toc:[]},vGt="wrapper";function LGt(e){let{components:n,...t}=e;return(0,s.yg)(vGt,(0,p.A)({},AGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}LGt.isMDXComponent=!0;const bGt={toc:[]},NGt="wrapper";function kGt(e){let{components:n,...t}=e;return(0,s.yg)(NGt,(0,p.A)({},bGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}kGt.isMDXComponent=!0;const zGt={toc:[]},PGt="wrapper";function IGt(e){let{components:n,...t}=e;return(0,s.yg)(PGt,(0,p.A)({},zGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}IGt.isMDXComponent=!0;const RGt={toc:[]},WGt="wrapper";function SGt(e){let{components:n,...t}=e;return(0,s.yg)(WGt,(0,p.A)({},RGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}SGt.isMDXComponent=!0;const BGt={toc:[]},EGt="wrapper";function GGt(e){let{components:n,...t}=e;return(0,s.yg)(EGt,(0,p.A)({},BGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}GGt.isMDXComponent=!0;const OGt={toc:[]},UGt="wrapper";function FGt(e){let{components:n,...t}=e;return(0,s.yg)(UGt,(0,p.A)({},OGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}FGt.isMDXComponent=!0;const VGt={toc:[]},qGt="wrapper";function jGt(e){let{components:n,...t}=e;return(0,s.yg)(qGt,(0,p.A)({},VGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This node can be used to render shapes such as: triangle, pentagon,\nhexagon and more."),(0,s.yg)("p",null,"Note that the polygon is inscribed in a circle defined by the height\nand width. If height and width are unequal, the polygon is inscribed\nin the resulting ellipse."),(0,s.yg)("p",null,"Since the polygon is inscribed in the circle, the actual displayed\nheight and width may differ somewhat from the bounding rectangle. This\nwill be particularly noticeable if the number of sides is low, e.g. for a\ntriangle."))}jGt.isMDXComponent=!0;const HGt={toc:[]},YGt="wrapper";function QGt(e){let{components:n,...t}=e;return(0,s.yg)(YGt,(0,p.A)({},HGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Polygon\nimport {makeScene2D, Polygon} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Polygon>();\n  view.add(\n    <Polygon\n      ref={ref}\n      sides={6}\n      size={160}\n      fill={'lightseagreen'}\n    />\n  );\n\n  yield* ref().sides(3, 2).to(6, 2);\n});\n\n// snippet Pentagon outline\nimport {makeScene2D, Polygon} from '@revideo/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Polygon\n      sides={5}\n      size={160}\n      radius={30}\n      stroke={'lightblue'}\n      lineWidth={8}\n    />\n  );\n});\n")))}QGt.isMDXComponent=!0;const $Gt={toc:[]},KGt="wrapper";function JGt(e){let{components:n,...t}=e;return(0,s.yg)(KGt,(0,p.A)({},$Gt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing regular polygons."))}JGt.isMDXComponent=!0;const ZGt={toc:[]},eOt="wrapper";function nOt(e){let{components:n,...t}=e;return(0,s.yg)(eOt,(0,p.A)({},ZGt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}nOt.isMDXComponent=!0;const tOt={toc:[]},oOt="wrapper";function pOt(e){let{components:n,...t}=e;return(0,s.yg)(oOt,(0,p.A)({},tOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}pOt.isMDXComponent=!0;const rOt={toc:[]},sOt="wrapper";function cOt(e){let{components:n,...t}=e;return(0,s.yg)(sOt,(0,p.A)({},rOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}cOt.isMDXComponent=!0;const aOt={toc:[]},iOt="wrapper";function lOt(e){let{components:n,...t}=e;return(0,s.yg)(iOt,(0,p.A)({},aOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}lOt.isMDXComponent=!0;const uOt={toc:[]},mOt="wrapper";function yOt(e){let{components:n,...t}=e;return(0,s.yg)(mOt,(0,p.A)({},uOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}yOt.isMDXComponent=!0;const dOt={toc:[]},hOt="wrapper";function gOt(e){let{components:n,...t}=e;return(0,s.yg)(hOt,(0,p.A)({},dOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}gOt.isMDXComponent=!0;const fOt={toc:[]},DOt="wrapper";function MOt(e){let{components:n,...t}=e;return(0,s.yg)(DOt,(0,p.A)({},fOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}MOt.isMDXComponent=!0;const XOt={toc:[]},_Ot="wrapper";function wOt(e){let{components:n,...t}=e;return(0,s.yg)(_Ot,(0,p.A)({},XOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}wOt.isMDXComponent=!0;const TOt={toc:[]},COt="wrapper";function xOt(e){let{components:n,...t}=e;return(0,s.yg)(COt,(0,p.A)({},TOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}xOt.isMDXComponent=!0;const AOt={toc:[]},vOt="wrapper";function LOt(e){let{components:n,...t}=e;return(0,s.yg)(vOt,(0,p.A)({},AOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}LOt.isMDXComponent=!0;const bOt={toc:[]},NOt="wrapper";function kOt(e){let{components:n,...t}=e;return(0,s.yg)(NOt,(0,p.A)({},bOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}kOt.isMDXComponent=!0;const zOt={toc:[]},POt="wrapper";function IOt(e){let{components:n,...t}=e;return(0,s.yg)(POt,(0,p.A)({},zOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}IOt.isMDXComponent=!0;const ROt={toc:[]},WOt="wrapper";function SOt(e){let{components:n,...t}=e;return(0,s.yg)(WOt,(0,p.A)({},ROt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}SOt.isMDXComponent=!0;const BOt={toc:[]},EOt="wrapper";function GOt(e){let{components:n,...t}=e;return(0,s.yg)(EOt,(0,p.A)({},BOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}GOt.isMDXComponent=!0;const OOt={toc:[]},UOt="wrapper";function FOt(e){let{components:n,...t}=e;return(0,s.yg)(UOt,(0,p.A)({},OOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}FOt.isMDXComponent=!0;const VOt={toc:[]},qOt="wrapper";function jOt(e){let{components:n,...t}=e;return(0,s.yg)(qOt,(0,p.A)({},VOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}jOt.isMDXComponent=!0;const HOt={toc:[]},YOt="wrapper";function QOt(e){let{components:n,...t}=e;return(0,s.yg)(YOt,(0,p.A)({},HOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}QOt.isMDXComponent=!0;const $Ot={toc:[]},KOt="wrapper";function JOt(e){let{components:n,...t}=e;return(0,s.yg)(KOt,(0,p.A)({},$Ot,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}JOt.isMDXComponent=!0;const ZOt={toc:[]},eUt="wrapper";function nUt(e){let{components:n,...t}=e;return(0,s.yg)(eUt,(0,p.A)({},ZOt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}nUt.isMDXComponent=!0;const tUt={toc:[]},oUt="wrapper";function pUt(e){let{components:n,...t}=e;return(0,s.yg)(oUt,(0,p.A)({},tUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}pUt.isMDXComponent=!0;const rUt={toc:[]},sUt="wrapper";function cUt(e){let{components:n,...t}=e;return(0,s.yg)(sUt,(0,p.A)({},rUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}cUt.isMDXComponent=!0;const aUt={toc:[]},iUt="wrapper";function lUt(e){let{components:n,...t}=e;return(0,s.yg)(iUt,(0,p.A)({},aUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}lUt.isMDXComponent=!0;const uUt={toc:[]},mUt="wrapper";function yUt(e){let{components:n,...t}=e;return(0,s.yg)(mUt,(0,p.A)({},uUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}yUt.isMDXComponent=!0;const dUt={toc:[]},hUt="wrapper";function gUt(e){let{components:n,...t}=e;return(0,s.yg)(hUt,(0,p.A)({},dUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}gUt.isMDXComponent=!0;const fUt={toc:[]},DUt="wrapper";function MUt(e){let{components:n,...t}=e;return(0,s.yg)(DUt,(0,p.A)({},fUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}MUt.isMDXComponent=!0;const XUt={toc:[]},_Ut="wrapper";function wUt(e){let{components:n,...t}=e;return(0,s.yg)(_Ut,(0,p.A)({},XUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}wUt.isMDXComponent=!0;const TUt={toc:[]},CUt="wrapper";function xUt(e){let{components:n,...t}=e;return(0,s.yg)(CUt,(0,p.A)({},TUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}xUt.isMDXComponent=!0;const AUt={toc:[]},vUt="wrapper";function LUt(e){let{components:n,...t}=e;return(0,s.yg)(vUt,(0,p.A)({},AUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}LUt.isMDXComponent=!0;const bUt={toc:[]},NUt="wrapper";function kUt(e){let{components:n,...t}=e;return(0,s.yg)(NUt,(0,p.A)({},bUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}kUt.isMDXComponent=!0;const zUt={toc:[]},PUt="wrapper";function IUt(e){let{components:n,...t}=e;return(0,s.yg)(PUt,(0,p.A)({},zUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}IUt.isMDXComponent=!0;const RUt={toc:[]},WUt="wrapper";function SUt(e){let{components:n,...t}=e;return(0,s.yg)(WUt,(0,p.A)({},RUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}SUt.isMDXComponent=!0;const BUt={toc:[]},EUt="wrapper";function GUt(e){let{components:n,...t}=e;return(0,s.yg)(EUt,(0,p.A)({},BUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}GUt.isMDXComponent=!0;const OUt={toc:[]},UUt="wrapper";function FUt(e){let{components:n,...t}=e;return(0,s.yg)(UUt,(0,p.A)({},OUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}FUt.isMDXComponent=!0;const VUt={toc:[]},qUt="wrapper";function jUt(e){let{components:n,...t}=e;return(0,s.yg)(qUt,(0,p.A)({},VUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}jUt.isMDXComponent=!0;const HUt={toc:[]},YUt="wrapper";function QUt(e){let{components:n,...t}=e;return(0,s.yg)(YUt,(0,p.A)({},HUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  radius={30}\n  size={320}\n  sides={3}\n  stroke={'#fff'}\n  lineWidth={8}\n/>\n")))}QUt.isMDXComponent=!0;const $Ut={toc:[]},KUt="wrapper";function JUt(e){let{components:n,...t}=e;return(0,s.yg)(KUt,(0,p.A)({},$Ut,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The radius of the polygon's corners."))}JUt.isMDXComponent=!0;const ZUt={toc:[]},eFt="wrapper";function nFt(e){let{components:n,...t}=e;return(0,s.yg)(eFt,(0,p.A)({},ZUt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}nFt.isMDXComponent=!0;const tFt={toc:[]},oFt="wrapper";function pFt(e){let{components:n,...t}=e;return(0,s.yg)(oFt,(0,p.A)({},tFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}pFt.isMDXComponent=!0;const rFt={toc:[]},sFt="wrapper";function cFt(e){let{components:n,...t}=e;return(0,s.yg)(sFt,(0,p.A)({},rFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}cFt.isMDXComponent=!0;const aFt={toc:[]},iFt="wrapper";function lFt(e){let{components:n,...t}=e;return(0,s.yg)(iFt,(0,p.A)({},aFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}lFt.isMDXComponent=!0;const uFt={toc:[]},mFt="wrapper";function yFt(e){let{components:n,...t}=e;return(0,s.yg)(mFt,(0,p.A)({},uFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}yFt.isMDXComponent=!0;const dFt={toc:[]},hFt="wrapper";function gFt(e){let{components:n,...t}=e;return(0,s.yg)(hFt,(0,p.A)({},dFt,t,{components:n,mdxType:"MDXLayout"}))}gFt.isMDXComponent=!0;const fFt={toc:[]},DFt="wrapper";function MFt(e){let{components:n,...t}=e;return(0,s.yg)(DFt,(0,p.A)({},fFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"For example, a value of 6 creates a hexagon."))}MFt.isMDXComponent=!0;const XFt={toc:[]},_Ft="wrapper";function wFt(e){let{components:n,...t}=e;return(0,s.yg)(_Ft,(0,p.A)({},XFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  size={320}\n  sides={7}\n  stroke={'#fff'}\n  lineWidth={8}\n  fill={'lightseagreen'}\n/>\n")))}wFt.isMDXComponent=!0;const TFt={toc:[]},CFt="wrapper";function xFt(e){let{components:n,...t}=e;return(0,s.yg)(CFt,(0,p.A)({},TFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The number of sides of the polygon."))}xFt.isMDXComponent=!0;const AFt={toc:[]},vFt="wrapper";function LFt(e){let{components:n,...t}=e;return(0,s.yg)(vFt,(0,p.A)({},AFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}LFt.isMDXComponent=!0;const bFt={toc:[]},NFt="wrapper";function kFt(e){let{components:n,...t}=e;return(0,s.yg)(NFt,(0,p.A)({},bFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}kFt.isMDXComponent=!0;const zFt={toc:[]},PFt="wrapper";function IFt(e){let{components:n,...t}=e;return(0,s.yg)(PFt,(0,p.A)({},zFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}IFt.isMDXComponent=!0;const RFt={toc:[]},WFt="wrapper";function SFt(e){let{components:n,...t}=e;return(0,s.yg)(WFt,(0,p.A)({},RFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}SFt.isMDXComponent=!0;const BFt={toc:[]},EFt="wrapper";function GFt(e){let{components:n,...t}=e;return(0,s.yg)(EFt,(0,p.A)({},BFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}GFt.isMDXComponent=!0;const OFt={toc:[]},UFt="wrapper";function FFt(e){let{components:n,...t}=e;return(0,s.yg)(UFt,(0,p.A)({},OFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}FFt.isMDXComponent=!0;const VFt={toc:[]},qFt="wrapper";function jFt(e){let{components:n,...t}=e;return(0,s.yg)(qFt,(0,p.A)({},VFt,t,{components:n,mdxType:"MDXLayout"}))}jFt.isMDXComponent=!0;const HFt={toc:[]},YFt="wrapper";function QFt(e){let{components:n,...t}=e;return(0,s.yg)(YFt,(0,p.A)({},HFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}QFt.isMDXComponent=!0;const $Ft={toc:[]},KFt="wrapper";function JFt(e){let{components:n,...t}=e;return(0,s.yg)(KFt,(0,p.A)({},$Ft,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}JFt.isMDXComponent=!0;const ZFt={toc:[]},eVt="wrapper";function nVt(e){let{components:n,...t}=e;return(0,s.yg)(eVt,(0,p.A)({},ZFt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}nVt.isMDXComponent=!0;const tVt={toc:[]},oVt="wrapper";function pVt(e){let{components:n,...t}=e;return(0,s.yg)(oVt,(0,p.A)({},tVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}pVt.isMDXComponent=!0;const rVt={toc:[]},sVt="wrapper";function cVt(e){let{components:n,...t}=e;return(0,s.yg)(sVt,(0,p.A)({},rVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}cVt.isMDXComponent=!0;const aVt={toc:[]},iVt="wrapper";function lVt(e){let{components:n,...t}=e;return(0,s.yg)(iVt,(0,p.A)({},aVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}lVt.isMDXComponent=!0;const uVt={toc:[]},mVt="wrapper";function yVt(e){let{components:n,...t}=e;return(0,s.yg)(mVt,(0,p.A)({},uVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}yVt.isMDXComponent=!0;const dVt={toc:[]},hVt="wrapper";function gVt(e){let{components:n,...t}=e;return(0,s.yg)(hVt,(0,p.A)({},dVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}gVt.isMDXComponent=!0;const fVt={toc:[]},DVt="wrapper";function MVt(e){let{components:n,...t}=e;return(0,s.yg)(DVt,(0,p.A)({},fVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}MVt.isMDXComponent=!0;const XVt={toc:[]},_Vt="wrapper";function wVt(e){let{components:n,...t}=e;return(0,s.yg)(_Vt,(0,p.A)({},XVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}wVt.isMDXComponent=!0;const TVt={toc:[]},CVt="wrapper";function xVt(e){let{components:n,...t}=e;return(0,s.yg)(CVt,(0,p.A)({},TVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}xVt.isMDXComponent=!0;const AVt={toc:[]},vVt="wrapper";function LVt(e){let{components:n,...t}=e;return(0,s.yg)(vVt,(0,p.A)({},AVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}LVt.isMDXComponent=!0;const bVt={toc:[]},NVt="wrapper";function kVt(e){let{components:n,...t}=e;return(0,s.yg)(NVt,(0,p.A)({},bVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}kVt.isMDXComponent=!0;const zVt={toc:[]},PVt="wrapper";function IVt(e){let{components:n,...t}=e;return(0,s.yg)(PVt,(0,p.A)({},zVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}IVt.isMDXComponent=!0;const RVt={toc:[]},WVt="wrapper";function SVt(e){let{components:n,...t}=e;return(0,s.yg)(WVt,(0,p.A)({},RVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}SVt.isMDXComponent=!0;const BVt={toc:[]},EVt="wrapper";function GVt(e){let{components:n,...t}=e;return(0,s.yg)(EVt,(0,p.A)({},BVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}GVt.isMDXComponent=!0;const OVt={toc:[]},UVt="wrapper";function FVt(e){let{components:n,...t}=e;return(0,s.yg)(UVt,(0,p.A)({},OVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}FVt.isMDXComponent=!0;const VVt={toc:[]},qVt="wrapper";function jVt(e){let{components:n,...t}=e;return(0,s.yg)(qVt,(0,p.A)({},VVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}jVt.isMDXComponent=!0;const HVt={toc:[]},YVt="wrapper";function QVt(e){let{components:n,...t}=e;return(0,s.yg)(YVt,(0,p.A)({},HVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}QVt.isMDXComponent=!0;const $Vt={toc:[]},KVt="wrapper";function JVt(e){let{components:n,...t}=e;return(0,s.yg)(KVt,(0,p.A)({},$Vt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}JVt.isMDXComponent=!0;const ZVt={toc:[]},eqt="wrapper";function nqt(e){let{components:n,...t}=e;return(0,s.yg)(eqt,(0,p.A)({},ZVt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}nqt.isMDXComponent=!0;const tqt={toc:[]},oqt="wrapper";function pqt(e){let{components:n,...t}=e;return(0,s.yg)(oqt,(0,p.A)({},tqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}pqt.isMDXComponent=!0;const rqt={toc:[]},sqt="wrapper";function cqt(e){let{components:n,...t}=e;return(0,s.yg)(sqt,(0,p.A)({},rqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}cqt.isMDXComponent=!0;const aqt={toc:[]},iqt="wrapper";function lqt(e){let{components:n,...t}=e;return(0,s.yg)(iqt,(0,p.A)({},aqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}lqt.isMDXComponent=!0;const uqt={toc:[]},mqt="wrapper";function yqt(e){let{components:n,...t}=e;return(0,s.yg)(mqt,(0,p.A)({},uqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}yqt.isMDXComponent=!0;const dqt={toc:[]},hqt="wrapper";function gqt(e){let{components:n,...t}=e;return(0,s.yg)(hqt,(0,p.A)({},dqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}gqt.isMDXComponent=!0;const fqt={toc:[]},Dqt="wrapper";function Mqt(e){let{components:n,...t}=e;return(0,s.yg)(Dqt,(0,p.A)({},fqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Mqt.isMDXComponent=!0;const Xqt={toc:[]},_qt="wrapper";function wqt(e){let{components:n,...t}=e;return(0,s.yg)(_qt,(0,p.A)({},Xqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}wqt.isMDXComponent=!0;const Tqt={toc:[]},Cqt="wrapper";function xqt(e){let{components:n,...t}=e;return(0,s.yg)(Cqt,(0,p.A)({},Tqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}xqt.isMDXComponent=!0;const Aqt={toc:[]},vqt="wrapper";function Lqt(e){let{components:n,...t}=e;return(0,s.yg)(vqt,(0,p.A)({},Aqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}Lqt.isMDXComponent=!0;const bqt={toc:[]},Nqt="wrapper";function kqt(e){let{components:n,...t}=e;return(0,s.yg)(Nqt,(0,p.A)({},bqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}kqt.isMDXComponent=!0;const zqt={toc:[]},Pqt="wrapper";function Iqt(e){let{components:n,...t}=e;return(0,s.yg)(Pqt,(0,p.A)({},zqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Iqt.isMDXComponent=!0;const Rqt={toc:[]},Wqt="wrapper";function Sqt(e){let{components:n,...t}=e;return(0,s.yg)(Wqt,(0,p.A)({},Rqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Sqt.isMDXComponent=!0;const Bqt={toc:[]},Eqt="wrapper";function Gqt(e){let{components:n,...t}=e;return(0,s.yg)(Eqt,(0,p.A)({},Bqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}Gqt.isMDXComponent=!0;const Oqt={toc:[]},Uqt="wrapper";function Fqt(e){let{components:n,...t}=e;return(0,s.yg)(Uqt,(0,p.A)({},Oqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Fqt.isMDXComponent=!0;const Vqt={toc:[]},qqt="wrapper";function jqt(e){let{components:n,...t}=e;return(0,s.yg)(qqt,(0,p.A)({},Vqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}jqt.isMDXComponent=!0;const Hqt={toc:[]},Yqt="wrapper";function Qqt(e){let{components:n,...t}=e;return(0,s.yg)(Yqt,(0,p.A)({},Hqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Qqt.isMDXComponent=!0;const $qt={toc:[]},Kqt="wrapper";function Jqt(e){let{components:n,...t}=e;return(0,s.yg)(Kqt,(0,p.A)({},$qt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}Jqt.isMDXComponent=!0;const Zqt={toc:[]},ejt="wrapper";function njt(e){let{components:n,...t}=e;return(0,s.yg)(ejt,(0,p.A)({},Zqt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}njt.isMDXComponent=!0;const tjt={toc:[]},ojt="wrapper";function pjt(e){let{components:n,...t}=e;return(0,s.yg)(ojt,(0,p.A)({},tjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}pjt.isMDXComponent=!0;const rjt={toc:[]},sjt="wrapper";function cjt(e){let{components:n,...t}=e;return(0,s.yg)(sjt,(0,p.A)({},rjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}cjt.isMDXComponent=!0;const ajt={toc:[]},ijt="wrapper";function ljt(e){let{components:n,...t}=e;return(0,s.yg)(ijt,(0,p.A)({},ajt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}ljt.isMDXComponent=!0;const ujt={toc:[]},mjt="wrapper";function yjt(e){let{components:n,...t}=e;return(0,s.yg)(mjt,(0,p.A)({},ujt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}yjt.isMDXComponent=!0;const djt={toc:[]},hjt="wrapper";function gjt(e){let{components:n,...t}=e;return(0,s.yg)(hjt,(0,p.A)({},djt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}gjt.isMDXComponent=!0;const fjt={toc:[]},Djt="wrapper";function Mjt(e){let{components:n,...t}=e;return(0,s.yg)(Djt,(0,p.A)({},fjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}Mjt.isMDXComponent=!0;const Xjt={toc:[]},_jt="wrapper";function wjt(e){let{components:n,...t}=e;return(0,s.yg)(_jt,(0,p.A)({},Xjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}wjt.isMDXComponent=!0;const Tjt={toc:[]},Cjt="wrapper";function xjt(e){let{components:n,...t}=e;return(0,s.yg)(Cjt,(0,p.A)({},Tjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}xjt.isMDXComponent=!0;const Ajt={toc:[]},vjt="wrapper";function Ljt(e){let{components:n,...t}=e;return(0,s.yg)(vjt,(0,p.A)({},Ajt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Ljt.isMDXComponent=!0;const bjt={toc:[]},Njt="wrapper";function kjt(e){let{components:n,...t}=e;return(0,s.yg)(Njt,(0,p.A)({},bjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}kjt.isMDXComponent=!0;const zjt={toc:[]},Pjt="wrapper";function Ijt(e){let{components:n,...t}=e;return(0,s.yg)(Pjt,(0,p.A)({},zjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}Ijt.isMDXComponent=!0;const Rjt={toc:[]},Wjt="wrapper";function Sjt(e){let{components:n,...t}=e;return(0,s.yg)(Wjt,(0,p.A)({},Rjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Sjt.isMDXComponent=!0;const Bjt={toc:[]},Ejt="wrapper";function Gjt(e){let{components:n,...t}=e;return(0,s.yg)(Ejt,(0,p.A)({},Bjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}Gjt.isMDXComponent=!0;const Ojt={toc:[]},Ujt="wrapper";function Fjt(e){let{components:n,...t}=e;return(0,s.yg)(Ujt,(0,p.A)({},Ojt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Fjt.isMDXComponent=!0;const Vjt={toc:[]},qjt="wrapper";function jjt(e){let{components:n,...t}=e;return(0,s.yg)(qjt,(0,p.A)({},Vjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}jjt.isMDXComponent=!0;const Hjt={toc:[]},Yjt="wrapper";function Qjt(e){let{components:n,...t}=e;return(0,s.yg)(Yjt,(0,p.A)({},Hjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Qjt.isMDXComponent=!0;const $jt={toc:[]},Kjt="wrapper";function Jjt(e){let{components:n,...t}=e;return(0,s.yg)(Kjt,(0,p.A)({},$jt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Jjt.isMDXComponent=!0;const Zjt={toc:[]},eHt="wrapper";function nHt(e){let{components:n,...t}=e;return(0,s.yg)(eHt,(0,p.A)({},Zjt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}nHt.isMDXComponent=!0;const tHt={toc:[]},oHt="wrapper";function pHt(e){let{components:n,...t}=e;return(0,s.yg)(oHt,(0,p.A)({},tHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}pHt.isMDXComponent=!0;const rHt={toc:[]},sHt="wrapper";function cHt(e){let{components:n,...t}=e;return(0,s.yg)(sHt,(0,p.A)({},rHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}cHt.isMDXComponent=!0;const aHt={toc:[]},iHt="wrapper";function lHt(e){let{components:n,...t}=e;return(0,s.yg)(iHt,(0,p.A)({},aHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}lHt.isMDXComponent=!0;const uHt={toc:[]},mHt="wrapper";function yHt(e){let{components:n,...t}=e;return(0,s.yg)(mHt,(0,p.A)({},uHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}yHt.isMDXComponent=!0;const dHt={toc:[]},hHt="wrapper";function gHt(e){let{components:n,...t}=e;return(0,s.yg)(hHt,(0,p.A)({},dHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}gHt.isMDXComponent=!0;const fHt={toc:[]},DHt="wrapper";function MHt(e){let{components:n,...t}=e;return(0,s.yg)(DHt,(0,p.A)({},fHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}MHt.isMDXComponent=!0;const XHt={toc:[]},_Ht="wrapper";function wHt(e){let{components:n,...t}=e;return(0,s.yg)(_Ht,(0,p.A)({},XHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}wHt.isMDXComponent=!0;const THt={toc:[]},CHt="wrapper";function xHt(e){let{components:n,...t}=e;return(0,s.yg)(CHt,(0,p.A)({},THt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}xHt.isMDXComponent=!0;const AHt={toc:[]},vHt="wrapper";function LHt(e){let{components:n,...t}=e;return(0,s.yg)(vHt,(0,p.A)({},AHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}LHt.isMDXComponent=!0;const bHt={toc:[]},NHt="wrapper";function kHt(e){let{components:n,...t}=e;return(0,s.yg)(NHt,(0,p.A)({},bHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}kHt.isMDXComponent=!0;const zHt={toc:[]},PHt="wrapper";function IHt(e){let{components:n,...t}=e;return(0,s.yg)(PHt,(0,p.A)({},zHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}IHt.isMDXComponent=!0;const RHt={toc:[]},WHt="wrapper";function SHt(e){let{components:n,...t}=e;return(0,s.yg)(WHt,(0,p.A)({},RHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}SHt.isMDXComponent=!0;const BHt={toc:[]},EHt="wrapper";function GHt(e){let{components:n,...t}=e;return(0,s.yg)(EHt,(0,p.A)({},BHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}GHt.isMDXComponent=!0;const OHt={toc:[]},UHt="wrapper";function FHt(e){let{components:n,...t}=e;return(0,s.yg)(UHt,(0,p.A)({},OHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}FHt.isMDXComponent=!0;const VHt={toc:[]},qHt="wrapper";function jHt(e){let{components:n,...t}=e;return(0,s.yg)(qHt,(0,p.A)({},VHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}jHt.isMDXComponent=!0;const HHt={toc:[]},YHt="wrapper";function QHt(e){let{components:n,...t}=e;return(0,s.yg)(YHt,(0,p.A)({},HHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}QHt.isMDXComponent=!0;const $Ht={toc:[]},KHt="wrapper";function JHt(e){let{components:n,...t}=e;return(0,s.yg)(KHt,(0,p.A)({},$Ht,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}JHt.isMDXComponent=!0;const ZHt={toc:[]},eYt="wrapper";function nYt(e){let{components:n,...t}=e;return(0,s.yg)(eYt,(0,p.A)({},ZHt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}nYt.isMDXComponent=!0;const tYt={toc:[]},oYt="wrapper";function pYt(e){let{components:n,...t}=e;return(0,s.yg)(oYt,(0,p.A)({},tYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}pYt.isMDXComponent=!0;const rYt={toc:[]},sYt="wrapper";function cYt(e){let{components:n,...t}=e;return(0,s.yg)(sYt,(0,p.A)({},rYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}cYt.isMDXComponent=!0;const aYt={toc:[]},iYt="wrapper";function lYt(e){let{components:n,...t}=e;return(0,s.yg)(iYt,(0,p.A)({},aYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}lYt.isMDXComponent=!0;const uYt={toc:[]},mYt="wrapper";function yYt(e){let{components:n,...t}=e;return(0,s.yg)(mYt,(0,p.A)({},uYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}yYt.isMDXComponent=!0;const dYt={toc:[]},hYt="wrapper";function gYt(e){let{components:n,...t}=e;return(0,s.yg)(hYt,(0,p.A)({},dYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}gYt.isMDXComponent=!0;const fYt={toc:[]},DYt="wrapper";function MYt(e){let{components:n,...t}=e;return(0,s.yg)(DYt,(0,p.A)({},fYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}MYt.isMDXComponent=!0;const XYt={toc:[]},_Yt="wrapper";function wYt(e){let{components:n,...t}=e;return(0,s.yg)(_Yt,(0,p.A)({},XYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}wYt.isMDXComponent=!0;const TYt={toc:[]},CYt="wrapper";function xYt(e){let{components:n,...t}=e;return(0,s.yg)(CYt,(0,p.A)({},TYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}xYt.isMDXComponent=!0;const AYt={toc:[]},vYt="wrapper";function LYt(e){let{components:n,...t}=e;return(0,s.yg)(vYt,(0,p.A)({},AYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}LYt.isMDXComponent=!0;const bYt={toc:[]},NYt="wrapper";function kYt(e){let{components:n,...t}=e;return(0,s.yg)(NYt,(0,p.A)({},bYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}kYt.isMDXComponent=!0;const zYt={toc:[]},PYt="wrapper";function IYt(e){let{components:n,...t}=e;return(0,s.yg)(PYt,(0,p.A)({},zYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}IYt.isMDXComponent=!0;const RYt={toc:[]},WYt="wrapper";function SYt(e){let{components:n,...t}=e;return(0,s.yg)(WYt,(0,p.A)({},RYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}SYt.isMDXComponent=!0;const BYt={toc:[]},EYt="wrapper";function GYt(e){let{components:n,...t}=e;return(0,s.yg)(EYt,(0,p.A)({},BYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}GYt.isMDXComponent=!0;const OYt={toc:[]},UYt="wrapper";function FYt(e){let{components:n,...t}=e;return(0,s.yg)(UYt,(0,p.A)({},OYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}FYt.isMDXComponent=!0;const VYt={toc:[]},qYt="wrapper";function jYt(e){let{components:n,...t}=e;return(0,s.yg)(qYt,(0,p.A)({},VYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}jYt.isMDXComponent=!0;const HYt={toc:[]},YYt="wrapper";function QYt(e){let{components:n,...t}=e;return(0,s.yg)(YYt,(0,p.A)({},HYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}QYt.isMDXComponent=!0;const $Yt={toc:[]},KYt="wrapper";function JYt(e){let{components:n,...t}=e;return(0,s.yg)(KYt,(0,p.A)({},$Yt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}JYt.isMDXComponent=!0;const ZYt={toc:[]},eQt="wrapper";function nQt(e){let{components:n,...t}=e;return(0,s.yg)(eQt,(0,p.A)({},ZYt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}nQt.isMDXComponent=!0;const tQt={toc:[]},oQt="wrapper";function pQt(e){let{components:n,...t}=e;return(0,s.yg)(oQt,(0,p.A)({},tQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}pQt.isMDXComponent=!0;const rQt={toc:[]},sQt="wrapper";function cQt(e){let{components:n,...t}=e;return(0,s.yg)(sQt,(0,p.A)({},rQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}cQt.isMDXComponent=!0;const aQt={toc:[]},iQt="wrapper";function lQt(e){let{components:n,...t}=e;return(0,s.yg)(iQt,(0,p.A)({},aQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}lQt.isMDXComponent=!0;const uQt={toc:[]},mQt="wrapper";function yQt(e){let{components:n,...t}=e;return(0,s.yg)(mQt,(0,p.A)({},uQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}yQt.isMDXComponent=!0;const dQt={toc:[]},hQt="wrapper";function gQt(e){let{components:n,...t}=e;return(0,s.yg)(hQt,(0,p.A)({},dQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}gQt.isMDXComponent=!0;const fQt={toc:[]},DQt="wrapper";function MQt(e){let{components:n,...t}=e;return(0,s.yg)(DQt,(0,p.A)({},fQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}MQt.isMDXComponent=!0;const XQt={toc:[]},_Qt="wrapper";function wQt(e){let{components:n,...t}=e;return(0,s.yg)(_Qt,(0,p.A)({},XQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}wQt.isMDXComponent=!0;const TQt={toc:[]},CQt="wrapper";function xQt(e){let{components:n,...t}=e;return(0,s.yg)(CQt,(0,p.A)({},TQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}xQt.isMDXComponent=!0;const AQt={toc:[]},vQt="wrapper";function LQt(e){let{components:n,...t}=e;return(0,s.yg)(vQt,(0,p.A)({},AQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}LQt.isMDXComponent=!0;const bQt={toc:[]},NQt="wrapper";function kQt(e){let{components:n,...t}=e;return(0,s.yg)(NQt,(0,p.A)({},bQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}kQt.isMDXComponent=!0;const zQt={toc:[]},PQt="wrapper";function IQt(e){let{components:n,...t}=e;return(0,s.yg)(PQt,(0,p.A)({},zQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}IQt.isMDXComponent=!0;const RQt={toc:[]},WQt="wrapper";function SQt(e){let{components:n,...t}=e;return(0,s.yg)(WQt,(0,p.A)({},RQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}SQt.isMDXComponent=!0;const BQt={toc:[]},EQt="wrapper";function GQt(e){let{components:n,...t}=e;return(0,s.yg)(EQt,(0,p.A)({},BQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}GQt.isMDXComponent=!0;const OQt={toc:[]},UQt="wrapper";function FQt(e){let{components:n,...t}=e;return(0,s.yg)(UQt,(0,p.A)({},OQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}FQt.isMDXComponent=!0;const VQt={toc:[]},qQt="wrapper";function jQt(e){let{components:n,...t}=e;return(0,s.yg)(qQt,(0,p.A)({},VQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}jQt.isMDXComponent=!0;const HQt={toc:[]},YQt="wrapper";function QQt(e){let{components:n,...t}=e;return(0,s.yg)(YQt,(0,p.A)({},HQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}QQt.isMDXComponent=!0;const $Qt={toc:[]},KQt="wrapper";function JQt(e){let{components:n,...t}=e;return(0,s.yg)(KQt,(0,p.A)({},$Qt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}JQt.isMDXComponent=!0;const ZQt={toc:[]},e$t="wrapper";function n$t(e){let{components:n,...t}=e;return(0,s.yg)(e$t,(0,p.A)({},ZQt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}n$t.isMDXComponent=!0;const t$t={toc:[]},o$t="wrapper";function p$t(e){let{components:n,...t}=e;return(0,s.yg)(o$t,(0,p.A)({},t$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}p$t.isMDXComponent=!0;const r$t={toc:[]},s$t="wrapper";function c$t(e){let{components:n,...t}=e;return(0,s.yg)(s$t,(0,p.A)({},r$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}c$t.isMDXComponent=!0;const a$t={toc:[]},i$t="wrapper";function l$t(e){let{components:n,...t}=e;return(0,s.yg)(i$t,(0,p.A)({},a$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}l$t.isMDXComponent=!0;const u$t={toc:[]},m$t="wrapper";function y$t(e){let{components:n,...t}=e;return(0,s.yg)(m$t,(0,p.A)({},u$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}y$t.isMDXComponent=!0;const d$t={toc:[]},h$t="wrapper";function g$t(e){let{components:n,...t}=e;return(0,s.yg)(h$t,(0,p.A)({},d$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}g$t.isMDXComponent=!0;const f$t={toc:[]},D$t="wrapper";function M$t(e){let{components:n,...t}=e;return(0,s.yg)(D$t,(0,p.A)({},f$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}M$t.isMDXComponent=!0;const X$t={toc:[]},_$t="wrapper";function w$t(e){let{components:n,...t}=e;return(0,s.yg)(_$t,(0,p.A)({},X$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}w$t.isMDXComponent=!0;const T$t={toc:[]},C$t="wrapper";function x$t(e){let{components:n,...t}=e;return(0,s.yg)(C$t,(0,p.A)({},T$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}x$t.isMDXComponent=!0;const A$t={toc:[]},v$t="wrapper";function L$t(e){let{components:n,...t}=e;return(0,s.yg)(v$t,(0,p.A)({},A$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}L$t.isMDXComponent=!0;const b$t={toc:[]},N$t="wrapper";function k$t(e){let{components:n,...t}=e;return(0,s.yg)(N$t,(0,p.A)({},b$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}k$t.isMDXComponent=!0;const z$t={toc:[]},P$t="wrapper";function I$t(e){let{components:n,...t}=e;return(0,s.yg)(P$t,(0,p.A)({},z$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}I$t.isMDXComponent=!0;const R$t={toc:[]},W$t="wrapper";function S$t(e){let{components:n,...t}=e;return(0,s.yg)(W$t,(0,p.A)({},R$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}S$t.isMDXComponent=!0;const B$t={toc:[]},E$t="wrapper";function G$t(e){let{components:n,...t}=e;return(0,s.yg)(E$t,(0,p.A)({},B$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}G$t.isMDXComponent=!0;const O$t={toc:[]},U$t="wrapper";function F$t(e){let{components:n,...t}=e;return(0,s.yg)(U$t,(0,p.A)({},O$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}F$t.isMDXComponent=!0;const V$t={toc:[]},q$t="wrapper";function j$t(e){let{components:n,...t}=e;return(0,s.yg)(q$t,(0,p.A)({},V$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}j$t.isMDXComponent=!0;const H$t={toc:[]},Y$t="wrapper";function Q$t(e){let{components:n,...t}=e;return(0,s.yg)(Y$t,(0,p.A)({},H$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}Q$t.isMDXComponent=!0;const $$t={toc:[]},K$t="wrapper";function J$t(e){let{components:n,...t}=e;return(0,s.yg)(K$t,(0,p.A)({},$$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}J$t.isMDXComponent=!0;const Z$t={toc:[]},eKt="wrapper";function nKt(e){let{components:n,...t}=e;return(0,s.yg)(eKt,(0,p.A)({},Z$t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}nKt.isMDXComponent=!0;const tKt={toc:[]},oKt="wrapper";function pKt(e){let{components:n,...t}=e;return(0,s.yg)(oKt,(0,p.A)({},tKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}pKt.isMDXComponent=!0;const rKt={toc:[]},sKt="wrapper";function cKt(e){let{components:n,...t}=e;return(0,s.yg)(sKt,(0,p.A)({},rKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}cKt.isMDXComponent=!0;const aKt={toc:[]},iKt="wrapper";function lKt(e){let{components:n,...t}=e;return(0,s.yg)(iKt,(0,p.A)({},aKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}lKt.isMDXComponent=!0;const uKt={toc:[]},mKt="wrapper";function yKt(e){let{components:n,...t}=e;return(0,s.yg)(mKt,(0,p.A)({},uKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}yKt.isMDXComponent=!0;const dKt={toc:[]},hKt="wrapper";function gKt(e){let{components:n,...t}=e;return(0,s.yg)(hKt,(0,p.A)({},dKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}gKt.isMDXComponent=!0;const fKt={toc:[]},DKt="wrapper";function MKt(e){let{components:n,...t}=e;return(0,s.yg)(DKt,(0,p.A)({},fKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}MKt.isMDXComponent=!0;const XKt={toc:[]},_Kt="wrapper";function wKt(e){let{components:n,...t}=e;return(0,s.yg)(_Kt,(0,p.A)({},XKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}wKt.isMDXComponent=!0;const TKt={toc:[]},CKt="wrapper";function xKt(e){let{components:n,...t}=e;return(0,s.yg)(CKt,(0,p.A)({},TKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}xKt.isMDXComponent=!0;const AKt={toc:[]},vKt="wrapper";function LKt(e){let{components:n,...t}=e;return(0,s.yg)(vKt,(0,p.A)({},AKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}LKt.isMDXComponent=!0;const bKt={toc:[]},NKt="wrapper";function kKt(e){let{components:n,...t}=e;return(0,s.yg)(NKt,(0,p.A)({},bKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}kKt.isMDXComponent=!0;const zKt={toc:[]},PKt="wrapper";function IKt(e){let{components:n,...t}=e;return(0,s.yg)(PKt,(0,p.A)({},zKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}IKt.isMDXComponent=!0;const RKt={toc:[]},WKt="wrapper";function SKt(e){let{components:n,...t}=e;return(0,s.yg)(WKt,(0,p.A)({},RKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}SKt.isMDXComponent=!0;const BKt={toc:[]},EKt="wrapper";function GKt(e){let{components:n,...t}=e;return(0,s.yg)(EKt,(0,p.A)({},BKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}GKt.isMDXComponent=!0;const OKt={toc:[]},UKt="wrapper";function FKt(e){let{components:n,...t}=e;return(0,s.yg)(UKt,(0,p.A)({},OKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}FKt.isMDXComponent=!0;const VKt={toc:[]},qKt="wrapper";function jKt(e){let{components:n,...t}=e;return(0,s.yg)(qKt,(0,p.A)({},VKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}jKt.isMDXComponent=!0;const HKt={toc:[]},YKt="wrapper";function QKt(e){let{components:n,...t}=e;return(0,s.yg)(YKt,(0,p.A)({},HKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}QKt.isMDXComponent=!0;const $Kt={toc:[]},KKt="wrapper";function JKt(e){let{components:n,...t}=e;return(0,s.yg)(KKt,(0,p.A)({},$Kt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}JKt.isMDXComponent=!0;const ZKt={toc:[]},eJt="wrapper";function nJt(e){let{components:n,...t}=e;return(0,s.yg)(eJt,(0,p.A)({},ZKt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}nJt.isMDXComponent=!0;const tJt={toc:[]},oJt="wrapper";function pJt(e){let{components:n,...t}=e;return(0,s.yg)(oJt,(0,p.A)({},tJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}pJt.isMDXComponent=!0;const rJt={toc:[]},sJt="wrapper";function cJt(e){let{components:n,...t}=e;return(0,s.yg)(sJt,(0,p.A)({},rJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}cJt.isMDXComponent=!0;const aJt={toc:[]},iJt="wrapper";function lJt(e){let{components:n,...t}=e;return(0,s.yg)(iJt,(0,p.A)({},aJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}lJt.isMDXComponent=!0;const uJt={toc:[]},mJt="wrapper";function yJt(e){let{components:n,...t}=e;return(0,s.yg)(mJt,(0,p.A)({},uJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}yJt.isMDXComponent=!0;const dJt={toc:[]},hJt="wrapper";function gJt(e){let{components:n,...t}=e;return(0,s.yg)(hJt,(0,p.A)({},dJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}gJt.isMDXComponent=!0;const fJt={toc:[]},DJt="wrapper";function MJt(e){let{components:n,...t}=e;return(0,s.yg)(DJt,(0,p.A)({},fJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}MJt.isMDXComponent=!0;const XJt={toc:[]},_Jt="wrapper";function wJt(e){let{components:n,...t}=e;return(0,s.yg)(_Jt,(0,p.A)({},XJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}wJt.isMDXComponent=!0;const TJt={toc:[]},CJt="wrapper";function xJt(e){let{components:n,...t}=e;return(0,s.yg)(CJt,(0,p.A)({},TJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}xJt.isMDXComponent=!0;const AJt={toc:[]},vJt="wrapper";function LJt(e){let{components:n,...t}=e;return(0,s.yg)(vJt,(0,p.A)({},AJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}LJt.isMDXComponent=!0;const bJt={toc:[]},NJt="wrapper";function kJt(e){let{components:n,...t}=e;return(0,s.yg)(NJt,(0,p.A)({},bJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}kJt.isMDXComponent=!0;const zJt={toc:[]},PJt="wrapper";function IJt(e){let{components:n,...t}=e;return(0,s.yg)(PJt,(0,p.A)({},zJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}IJt.isMDXComponent=!0;const RJt={toc:[]},WJt="wrapper";function SJt(e){let{components:n,...t}=e;return(0,s.yg)(WJt,(0,p.A)({},RJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}SJt.isMDXComponent=!0;const BJt={toc:[]},EJt="wrapper";function GJt(e){let{components:n,...t}=e;return(0,s.yg)(EJt,(0,p.A)({},BJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}GJt.isMDXComponent=!0;const OJt={toc:[]},UJt="wrapper";function FJt(e){let{components:n,...t}=e;return(0,s.yg)(UJt,(0,p.A)({},OJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}FJt.isMDXComponent=!0;const VJt={toc:[]},qJt="wrapper";function jJt(e){let{components:n,...t}=e;return(0,s.yg)(qJt,(0,p.A)({},VJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Polygon#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}jJt.isMDXComponent=!0;const HJt={toc:[]},YJt="wrapper";function QJt(e){let{components:n,...t}=e;return(0,s.yg)(YJt,(0,p.A)({},HJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}QJt.isMDXComponent=!0;const $Jt={toc:[]},KJt="wrapper";function JJt(e){let{components:n,...t}=e;return(0,s.yg)(KJt,(0,p.A)({},$Jt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}JJt.isMDXComponent=!0;const ZJt={toc:[]},eZt="wrapper";function nZt(e){let{components:n,...t}=e;return(0,s.yg)(eZt,(0,p.A)({},ZJt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}nZt.isMDXComponent=!0;const tZt={toc:[]},oZt="wrapper";function pZt(e){let{components:n,...t}=e;return(0,s.yg)(oZt,(0,p.A)({},tZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}pZt.isMDXComponent=!0;const rZt={toc:[]},sZt="wrapper";function cZt(e){let{components:n,...t}=e;return(0,s.yg)(sZt,(0,p.A)({},rZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}cZt.isMDXComponent=!0;const aZt={toc:[]},iZt="wrapper";function lZt(e){let{components:n,...t}=e;return(0,s.yg)(iZt,(0,p.A)({},aZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}lZt.isMDXComponent=!0;const uZt={toc:[]},mZt="wrapper";function yZt(e){let{components:n,...t}=e;return(0,s.yg)(mZt,(0,p.A)({},uZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, QuadBezier} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<QuadBezier>();\n\n  view.add(\n    <QuadBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, 0]}\n      p1={[0, -200]}\n      p2={[200, 0]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}yZt.isMDXComponent=!0;const dZt={toc:[]},hZt="wrapper";function gZt(e){let{components:n,...t}=e;return(0,s.yg)(hZt,(0,p.A)({},dZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing a quadratic B\xe9zier curve."))}gZt.isMDXComponent=!0;const fZt={toc:[]},DZt="wrapper";function MZt(e){let{components:n,...t}=e;return(0,s.yg)(DZt,(0,p.A)({},fZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}MZt.isMDXComponent=!0;const XZt={toc:[]},_Zt="wrapper";function wZt(e){let{components:n,...t}=e;return(0,s.yg)(_Zt,(0,p.A)({},XZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}wZt.isMDXComponent=!0;const TZt={toc:[]},CZt="wrapper";function xZt(e){let{components:n,...t}=e;return(0,s.yg)(CZt,(0,p.A)({},TZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}xZt.isMDXComponent=!0;const AZt={toc:[]},vZt="wrapper";function LZt(e){let{components:n,...t}=e;return(0,s.yg)(vZt,(0,p.A)({},AZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}LZt.isMDXComponent=!0;const bZt={toc:[]},NZt="wrapper";function kZt(e){let{components:n,...t}=e;return(0,s.yg)(NZt,(0,p.A)({},bZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}kZt.isMDXComponent=!0;const zZt={toc:[]},PZt="wrapper";function IZt(e){let{components:n,...t}=e;return(0,s.yg)(PZt,(0,p.A)({},zZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}IZt.isMDXComponent=!0;const RZt={toc:[]},WZt="wrapper";function SZt(e){let{components:n,...t}=e;return(0,s.yg)(WZt,(0,p.A)({},RZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}SZt.isMDXComponent=!0;const BZt={toc:[]},EZt="wrapper";function GZt(e){let{components:n,...t}=e;return(0,s.yg)(EZt,(0,p.A)({},BZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}GZt.isMDXComponent=!0;const OZt={toc:[]},UZt="wrapper";function FZt(e){let{components:n,...t}=e;return(0,s.yg)(UZt,(0,p.A)({},OZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}FZt.isMDXComponent=!0;const VZt={toc:[]},qZt="wrapper";function jZt(e){let{components:n,...t}=e;return(0,s.yg)(qZt,(0,p.A)({},VZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}jZt.isMDXComponent=!0;const HZt={toc:[]},YZt="wrapper";function QZt(e){let{components:n,...t}=e;return(0,s.yg)(YZt,(0,p.A)({},HZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}QZt.isMDXComponent=!0;const $Zt={toc:[]},KZt="wrapper";function JZt(e){let{components:n,...t}=e;return(0,s.yg)(KZt,(0,p.A)({},$Zt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}JZt.isMDXComponent=!0;const ZZt={toc:[]},e0t="wrapper";function n0t(e){let{components:n,...t}=e;return(0,s.yg)(e0t,(0,p.A)({},ZZt,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}n0t.isMDXComponent=!0;const t0t={toc:[]},o0t="wrapper";function p0t(e){let{components:n,...t}=e;return(0,s.yg)(o0t,(0,p.A)({},t0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}p0t.isMDXComponent=!0;const r0t={toc:[]},s0t="wrapper";function c0t(e){let{components:n,...t}=e;return(0,s.yg)(s0t,(0,p.A)({},r0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}c0t.isMDXComponent=!0;const a0t={toc:[]},i0t="wrapper";function l0t(e){let{components:n,...t}=e;return(0,s.yg)(i0t,(0,p.A)({},a0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}l0t.isMDXComponent=!0;const u0t={toc:[]},m0t="wrapper";function y0t(e){let{components:n,...t}=e;return(0,s.yg)(m0t,(0,p.A)({},u0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}y0t.isMDXComponent=!0;const d0t={toc:[]},h0t="wrapper";function g0t(e){let{components:n,...t}=e;return(0,s.yg)(h0t,(0,p.A)({},d0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}g0t.isMDXComponent=!0;const f0t={toc:[]},D0t="wrapper";function M0t(e){let{components:n,...t}=e;return(0,s.yg)(D0t,(0,p.A)({},f0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}M0t.isMDXComponent=!0;const X0t={toc:[]},_0t="wrapper";function w0t(e){let{components:n,...t}=e;return(0,s.yg)(_0t,(0,p.A)({},X0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}w0t.isMDXComponent=!0;const T0t={toc:[]},C0t="wrapper";function x0t(e){let{components:n,...t}=e;return(0,s.yg)(C0t,(0,p.A)({},T0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}x0t.isMDXComponent=!0;const A0t={toc:[]},v0t="wrapper";function L0t(e){let{components:n,...t}=e;return(0,s.yg)(v0t,(0,p.A)({},A0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}L0t.isMDXComponent=!0;const b0t={toc:[]},N0t="wrapper";function k0t(e){let{components:n,...t}=e;return(0,s.yg)(N0t,(0,p.A)({},b0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}k0t.isMDXComponent=!0;const z0t={toc:[]},P0t="wrapper";function I0t(e){let{components:n,...t}=e;return(0,s.yg)(P0t,(0,p.A)({},z0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}I0t.isMDXComponent=!0;const R0t={toc:[]},W0t="wrapper";function S0t(e){let{components:n,...t}=e;return(0,s.yg)(W0t,(0,p.A)({},R0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}S0t.isMDXComponent=!0;const B0t={toc:[]},E0t="wrapper";function G0t(e){let{components:n,...t}=e;return(0,s.yg)(E0t,(0,p.A)({},B0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}G0t.isMDXComponent=!0;const O0t={toc:[]},U0t="wrapper";function F0t(e){let{components:n,...t}=e;return(0,s.yg)(U0t,(0,p.A)({},O0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}F0t.isMDXComponent=!0;const V0t={toc:[]},q0t="wrapper";function j0t(e){let{components:n,...t}=e;return(0,s.yg)(q0t,(0,p.A)({},V0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}j0t.isMDXComponent=!0;const H0t={toc:[]},Y0t="wrapper";function Q0t(e){let{components:n,...t}=e;return(0,s.yg)(Y0t,(0,p.A)({},H0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Q0t.isMDXComponent=!0;const $0t={toc:[]},K0t="wrapper";function J0t(e){let{components:n,...t}=e;return(0,s.yg)(K0t,(0,p.A)({},$0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}J0t.isMDXComponent=!0;const Z0t={toc:[]},e3t="wrapper";function n3t(e){let{components:n,...t}=e;return(0,s.yg)(e3t,(0,p.A)({},Z0t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}n3t.isMDXComponent=!0;const t3t={toc:[]},o3t="wrapper";function p3t(e){let{components:n,...t}=e;return(0,s.yg)(o3t,(0,p.A)({},t3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}p3t.isMDXComponent=!0;const r3t={toc:[]},s3t="wrapper";function c3t(e){let{components:n,...t}=e;return(0,s.yg)(s3t,(0,p.A)({},r3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The start point of the B\xe9zier curve."))}c3t.isMDXComponent=!0;const a3t={toc:[]},i3t="wrapper";function l3t(e){let{components:n,...t}=e;return(0,s.yg)(i3t,(0,p.A)({},a3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The control point of the B\xe9zier curve."))}l3t.isMDXComponent=!0;const u3t={toc:[]},m3t="wrapper";function y3t(e){let{components:n,...t}=e;return(0,s.yg)(m3t,(0,p.A)({},u3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The end point of the B\xe9zier curve."))}y3t.isMDXComponent=!0;const d3t={toc:[]},h3t="wrapper";function g3t(e){let{components:n,...t}=e;return(0,s.yg)(h3t,(0,p.A)({},d3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}g3t.isMDXComponent=!0;const f3t={toc:[]},D3t="wrapper";function M3t(e){let{components:n,...t}=e;return(0,s.yg)(D3t,(0,p.A)({},f3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}M3t.isMDXComponent=!0;const X3t={toc:[]},_3t="wrapper";function w3t(e){let{components:n,...t}=e;return(0,s.yg)(_3t,(0,p.A)({},X3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}w3t.isMDXComponent=!0;const T3t={toc:[]},C3t="wrapper";function x3t(e){let{components:n,...t}=e;return(0,s.yg)(C3t,(0,p.A)({},T3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}x3t.isMDXComponent=!0;const A3t={toc:[]},v3t="wrapper";function L3t(e){let{components:n,...t}=e;return(0,s.yg)(v3t,(0,p.A)({},A3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}L3t.isMDXComponent=!0;const b3t={toc:[]},N3t="wrapper";function k3t(e){let{components:n,...t}=e;return(0,s.yg)(N3t,(0,p.A)({},b3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}k3t.isMDXComponent=!0;const z3t={toc:[]},P3t="wrapper";function I3t(e){let{components:n,...t}=e;return(0,s.yg)(P3t,(0,p.A)({},z3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}I3t.isMDXComponent=!0;const R3t={toc:[]},W3t="wrapper";function S3t(e){let{components:n,...t}=e;return(0,s.yg)(W3t,(0,p.A)({},R3t,t,{components:n,mdxType:"MDXLayout"}))}S3t.isMDXComponent=!0;const B3t={toc:[]},E3t="wrapper";function G3t(e){let{components:n,...t}=e;return(0,s.yg)(E3t,(0,p.A)({},B3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}G3t.isMDXComponent=!0;const O3t={toc:[]},U3t="wrapper";function F3t(e){let{components:n,...t}=e;return(0,s.yg)(U3t,(0,p.A)({},O3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}F3t.isMDXComponent=!0;const V3t={toc:[]},q3t="wrapper";function j3t(e){let{components:n,...t}=e;return(0,s.yg)(q3t,(0,p.A)({},V3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}j3t.isMDXComponent=!0;const H3t={toc:[]},Y3t="wrapper";function Q3t(e){let{components:n,...t}=e;return(0,s.yg)(Y3t,(0,p.A)({},H3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Q3t.isMDXComponent=!0;const $3t={toc:[]},K3t="wrapper";function J3t(e){let{components:n,...t}=e;return(0,s.yg)(K3t,(0,p.A)({},$3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}J3t.isMDXComponent=!0;const Z3t={toc:[]},e1t="wrapper";function n1t(e){let{components:n,...t}=e;return(0,s.yg)(e1t,(0,p.A)({},Z3t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}n1t.isMDXComponent=!0;const t1t={toc:[]},o1t="wrapper";function p1t(e){let{components:n,...t}=e;return(0,s.yg)(o1t,(0,p.A)({},t1t,t,{components:n,mdxType:"MDXLayout"}))}p1t.isMDXComponent=!0;const r1t={toc:[]},s1t="wrapper";function c1t(e){let{components:n,...t}=e;return(0,s.yg)(s1t,(0,p.A)({},r1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}c1t.isMDXComponent=!0;const a1t={toc:[]},i1t="wrapper";function l1t(e){let{components:n,...t}=e;return(0,s.yg)(i1t,(0,p.A)({},a1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}l1t.isMDXComponent=!0;const u1t={toc:[]},m1t="wrapper";function y1t(e){let{components:n,...t}=e;return(0,s.yg)(m1t,(0,p.A)({},u1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}y1t.isMDXComponent=!0;const d1t={toc:[]},h1t="wrapper";function g1t(e){let{components:n,...t}=e;return(0,s.yg)(h1t,(0,p.A)({},d1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}g1t.isMDXComponent=!0;const f1t={toc:[]},D1t="wrapper";function M1t(e){let{components:n,...t}=e;return(0,s.yg)(D1t,(0,p.A)({},f1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}M1t.isMDXComponent=!0;const X1t={toc:[]},_1t="wrapper";function w1t(e){let{components:n,...t}=e;return(0,s.yg)(_1t,(0,p.A)({},X1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}w1t.isMDXComponent=!0;const T1t={toc:[]},C1t="wrapper";function x1t(e){let{components:n,...t}=e;return(0,s.yg)(C1t,(0,p.A)({},T1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}x1t.isMDXComponent=!0;const A1t={toc:[]},v1t="wrapper";function L1t(e){let{components:n,...t}=e;return(0,s.yg)(v1t,(0,p.A)({},A1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}L1t.isMDXComponent=!0;const b1t={toc:[]},N1t="wrapper";function k1t(e){let{components:n,...t}=e;return(0,s.yg)(N1t,(0,p.A)({},b1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}k1t.isMDXComponent=!0;const z1t={toc:[]},P1t="wrapper";function I1t(e){let{components:n,...t}=e;return(0,s.yg)(P1t,(0,p.A)({},z1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}I1t.isMDXComponent=!0;const R1t={toc:[]},W1t="wrapper";function S1t(e){let{components:n,...t}=e;return(0,s.yg)(W1t,(0,p.A)({},R1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}S1t.isMDXComponent=!0;const B1t={toc:[]},E1t="wrapper";function G1t(e){let{components:n,...t}=e;return(0,s.yg)(E1t,(0,p.A)({},B1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}G1t.isMDXComponent=!0;const O1t={toc:[]},U1t="wrapper";function F1t(e){let{components:n,...t}=e;return(0,s.yg)(U1t,(0,p.A)({},O1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}F1t.isMDXComponent=!0;const V1t={toc:[]},q1t="wrapper";function j1t(e){let{components:n,...t}=e;return(0,s.yg)(q1t,(0,p.A)({},V1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}j1t.isMDXComponent=!0;const H1t={toc:[]},Y1t="wrapper";function Q1t(e){let{components:n,...t}=e;return(0,s.yg)(Y1t,(0,p.A)({},H1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}Q1t.isMDXComponent=!0;const $1t={toc:[]},K1t="wrapper";function J1t(e){let{components:n,...t}=e;return(0,s.yg)(K1t,(0,p.A)({},$1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}J1t.isMDXComponent=!0;const Z1t={toc:[]},e9t="wrapper";function n9t(e){let{components:n,...t}=e;return(0,s.yg)(e9t,(0,p.A)({},Z1t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}n9t.isMDXComponent=!0;const t9t={toc:[]},o9t="wrapper";function p9t(e){let{components:n,...t}=e;return(0,s.yg)(o9t,(0,p.A)({},t9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}p9t.isMDXComponent=!0;const r9t={toc:[]},s9t="wrapper";function c9t(e){let{components:n,...t}=e;return(0,s.yg)(s9t,(0,p.A)({},r9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}c9t.isMDXComponent=!0;const a9t={toc:[]},i9t="wrapper";function l9t(e){let{components:n,...t}=e;return(0,s.yg)(i9t,(0,p.A)({},a9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}l9t.isMDXComponent=!0;const u9t={toc:[]},m9t="wrapper";function y9t(e){let{components:n,...t}=e;return(0,s.yg)(m9t,(0,p.A)({},u9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}y9t.isMDXComponent=!0;const d9t={toc:[]},h9t="wrapper";function g9t(e){let{components:n,...t}=e;return(0,s.yg)(h9t,(0,p.A)({},d9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}g9t.isMDXComponent=!0;const f9t={toc:[]},D9t="wrapper";function M9t(e){let{components:n,...t}=e;return(0,s.yg)(D9t,(0,p.A)({},f9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}M9t.isMDXComponent=!0;const X9t={toc:[]},_9t="wrapper";function w9t(e){let{components:n,...t}=e;return(0,s.yg)(_9t,(0,p.A)({},X9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}w9t.isMDXComponent=!0;const T9t={toc:[]},C9t="wrapper";function x9t(e){let{components:n,...t}=e;return(0,s.yg)(C9t,(0,p.A)({},T9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}x9t.isMDXComponent=!0;const A9t={toc:[]},v9t="wrapper";function L9t(e){let{components:n,...t}=e;return(0,s.yg)(v9t,(0,p.A)({},A9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}L9t.isMDXComponent=!0;const b9t={toc:[]},N9t="wrapper";function k9t(e){let{components:n,...t}=e;return(0,s.yg)(N9t,(0,p.A)({},b9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}k9t.isMDXComponent=!0;const z9t={toc:[]},P9t="wrapper";function I9t(e){let{components:n,...t}=e;return(0,s.yg)(P9t,(0,p.A)({},z9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}I9t.isMDXComponent=!0;const R9t={toc:[]},W9t="wrapper";function S9t(e){let{components:n,...t}=e;return(0,s.yg)(W9t,(0,p.A)({},R9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}S9t.isMDXComponent=!0;const B9t={toc:[]},E9t="wrapper";function G9t(e){let{components:n,...t}=e;return(0,s.yg)(E9t,(0,p.A)({},B9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}G9t.isMDXComponent=!0;const O9t={toc:[]},U9t="wrapper";function F9t(e){let{components:n,...t}=e;return(0,s.yg)(U9t,(0,p.A)({},O9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}F9t.isMDXComponent=!0;const V9t={toc:[]},q9t="wrapper";function j9t(e){let{components:n,...t}=e;return(0,s.yg)(q9t,(0,p.A)({},V9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}j9t.isMDXComponent=!0;const H9t={toc:[]},Y9t="wrapper";function Q9t(e){let{components:n,...t}=e;return(0,s.yg)(Y9t,(0,p.A)({},H9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Q9t.isMDXComponent=!0;const $9t={toc:[]},K9t="wrapper";function J9t(e){let{components:n,...t}=e;return(0,s.yg)(K9t,(0,p.A)({},$9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}J9t.isMDXComponent=!0;const Z9t={toc:[]},e2t="wrapper";function n2t(e){let{components:n,...t}=e;return(0,s.yg)(e2t,(0,p.A)({},Z9t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}n2t.isMDXComponent=!0;const t2t={toc:[]},o2t="wrapper";function p2t(e){let{components:n,...t}=e;return(0,s.yg)(o2t,(0,p.A)({},t2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}p2t.isMDXComponent=!0;const r2t={toc:[]},s2t="wrapper";function c2t(e){let{components:n,...t}=e;return(0,s.yg)(s2t,(0,p.A)({},r2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}c2t.isMDXComponent=!0;const a2t={toc:[]},i2t="wrapper";function l2t(e){let{components:n,...t}=e;return(0,s.yg)(i2t,(0,p.A)({},a2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}l2t.isMDXComponent=!0;const u2t={toc:[]},m2t="wrapper";function y2t(e){let{components:n,...t}=e;return(0,s.yg)(m2t,(0,p.A)({},u2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}y2t.isMDXComponent=!0;const d2t={toc:[]},h2t="wrapper";function g2t(e){let{components:n,...t}=e;return(0,s.yg)(h2t,(0,p.A)({},d2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}g2t.isMDXComponent=!0;const f2t={toc:[]},D2t="wrapper";function M2t(e){let{components:n,...t}=e;return(0,s.yg)(D2t,(0,p.A)({},f2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}M2t.isMDXComponent=!0;const X2t={toc:[]},_2t="wrapper";function w2t(e){let{components:n,...t}=e;return(0,s.yg)(_2t,(0,p.A)({},X2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}w2t.isMDXComponent=!0;const T2t={toc:[]},C2t="wrapper";function x2t(e){let{components:n,...t}=e;return(0,s.yg)(C2t,(0,p.A)({},T2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}x2t.isMDXComponent=!0;const A2t={toc:[]},v2t="wrapper";function L2t(e){let{components:n,...t}=e;return(0,s.yg)(v2t,(0,p.A)({},A2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}L2t.isMDXComponent=!0;const b2t={toc:[]},N2t="wrapper";function k2t(e){let{components:n,...t}=e;return(0,s.yg)(N2t,(0,p.A)({},b2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}k2t.isMDXComponent=!0;const z2t={toc:[]},P2t="wrapper";function I2t(e){let{components:n,...t}=e;return(0,s.yg)(P2t,(0,p.A)({},z2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}I2t.isMDXComponent=!0;const R2t={toc:[]},W2t="wrapper";function S2t(e){let{components:n,...t}=e;return(0,s.yg)(W2t,(0,p.A)({},R2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}S2t.isMDXComponent=!0;const B2t={toc:[]},E2t="wrapper";function G2t(e){let{components:n,...t}=e;return(0,s.yg)(E2t,(0,p.A)({},B2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}G2t.isMDXComponent=!0;const O2t={toc:[]},U2t="wrapper";function F2t(e){let{components:n,...t}=e;return(0,s.yg)(U2t,(0,p.A)({},O2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}F2t.isMDXComponent=!0;const V2t={toc:[]},q2t="wrapper";function j2t(e){let{components:n,...t}=e;return(0,s.yg)(q2t,(0,p.A)({},V2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}j2t.isMDXComponent=!0;const H2t={toc:[]},Y2t="wrapper";function Q2t(e){let{components:n,...t}=e;return(0,s.yg)(Y2t,(0,p.A)({},H2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Q2t.isMDXComponent=!0;const $2t={toc:[]},K2t="wrapper";function J2t(e){let{components:n,...t}=e;return(0,s.yg)(K2t,(0,p.A)({},$2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}J2t.isMDXComponent=!0;const Z2t={toc:[]},e4t="wrapper";function n4t(e){let{components:n,...t}=e;return(0,s.yg)(e4t,(0,p.A)({},Z2t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}n4t.isMDXComponent=!0;const t4t={toc:[]},o4t="wrapper";function p4t(e){let{components:n,...t}=e;return(0,s.yg)(o4t,(0,p.A)({},t4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}p4t.isMDXComponent=!0;const r4t={toc:[]},s4t="wrapper";function c4t(e){let{components:n,...t}=e;return(0,s.yg)(s4t,(0,p.A)({},r4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}c4t.isMDXComponent=!0;const a4t={toc:[]},i4t="wrapper";function l4t(e){let{components:n,...t}=e;return(0,s.yg)(i4t,(0,p.A)({},a4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}l4t.isMDXComponent=!0;const u4t={toc:[]},m4t="wrapper";function y4t(e){let{components:n,...t}=e;return(0,s.yg)(m4t,(0,p.A)({},u4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}y4t.isMDXComponent=!0;const d4t={toc:[]},h4t="wrapper";function g4t(e){let{components:n,...t}=e;return(0,s.yg)(h4t,(0,p.A)({},d4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}g4t.isMDXComponent=!0;const f4t={toc:[]},D4t="wrapper";function M4t(e){let{components:n,...t}=e;return(0,s.yg)(D4t,(0,p.A)({},f4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}M4t.isMDXComponent=!0;const X4t={toc:[]},_4t="wrapper";function w4t(e){let{components:n,...t}=e;return(0,s.yg)(_4t,(0,p.A)({},X4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}w4t.isMDXComponent=!0;const T4t={toc:[]},C4t="wrapper";function x4t(e){let{components:n,...t}=e;return(0,s.yg)(C4t,(0,p.A)({},T4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}x4t.isMDXComponent=!0;const A4t={toc:[]},v4t="wrapper";function L4t(e){let{components:n,...t}=e;return(0,s.yg)(v4t,(0,p.A)({},A4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}L4t.isMDXComponent=!0;const b4t={toc:[]},N4t="wrapper";function k4t(e){let{components:n,...t}=e;return(0,s.yg)(N4t,(0,p.A)({},b4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}k4t.isMDXComponent=!0;const z4t={toc:[]},P4t="wrapper";function I4t(e){let{components:n,...t}=e;return(0,s.yg)(P4t,(0,p.A)({},z4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}I4t.isMDXComponent=!0;const R4t={toc:[]},W4t="wrapper";function S4t(e){let{components:n,...t}=e;return(0,s.yg)(W4t,(0,p.A)({},R4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}S4t.isMDXComponent=!0;const B4t={toc:[]},E4t="wrapper";function G4t(e){let{components:n,...t}=e;return(0,s.yg)(E4t,(0,p.A)({},B4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}G4t.isMDXComponent=!0;const O4t={toc:[]},U4t="wrapper";function F4t(e){let{components:n,...t}=e;return(0,s.yg)(U4t,(0,p.A)({},O4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}F4t.isMDXComponent=!0;const V4t={toc:[]},q4t="wrapper";function j4t(e){let{components:n,...t}=e;return(0,s.yg)(q4t,(0,p.A)({},V4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}j4t.isMDXComponent=!0;const H4t={toc:[]},Y4t="wrapper";function Q4t(e){let{components:n,...t}=e;return(0,s.yg)(Y4t,(0,p.A)({},H4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Q4t.isMDXComponent=!0;const $4t={toc:[]},K4t="wrapper";function J4t(e){let{components:n,...t}=e;return(0,s.yg)(K4t,(0,p.A)({},$4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}J4t.isMDXComponent=!0;const Z4t={toc:[]},e6t="wrapper";function n6t(e){let{components:n,...t}=e;return(0,s.yg)(e6t,(0,p.A)({},Z4t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}n6t.isMDXComponent=!0;const t6t={toc:[]},o6t="wrapper";function p6t(e){let{components:n,...t}=e;return(0,s.yg)(o6t,(0,p.A)({},t6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}p6t.isMDXComponent=!0;const r6t={toc:[]},s6t="wrapper";function c6t(e){let{components:n,...t}=e;return(0,s.yg)(s6t,(0,p.A)({},r6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}c6t.isMDXComponent=!0;const a6t={toc:[]},i6t="wrapper";function l6t(e){let{components:n,...t}=e;return(0,s.yg)(i6t,(0,p.A)({},a6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}l6t.isMDXComponent=!0;const u6t={toc:[]},m6t="wrapper";function y6t(e){let{components:n,...t}=e;return(0,s.yg)(m6t,(0,p.A)({},u6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}y6t.isMDXComponent=!0;const d6t={toc:[]},h6t="wrapper";function g6t(e){let{components:n,...t}=e;return(0,s.yg)(h6t,(0,p.A)({},d6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}g6t.isMDXComponent=!0;const f6t={toc:[]},D6t="wrapper";function M6t(e){let{components:n,...t}=e;return(0,s.yg)(D6t,(0,p.A)({},f6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}M6t.isMDXComponent=!0;const X6t={toc:[]},_6t="wrapper";function w6t(e){let{components:n,...t}=e;return(0,s.yg)(_6t,(0,p.A)({},X6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}w6t.isMDXComponent=!0;const T6t={toc:[]},C6t="wrapper";function x6t(e){let{components:n,...t}=e;return(0,s.yg)(C6t,(0,p.A)({},T6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}x6t.isMDXComponent=!0;const A6t={toc:[]},v6t="wrapper";function L6t(e){let{components:n,...t}=e;return(0,s.yg)(v6t,(0,p.A)({},A6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}L6t.isMDXComponent=!0;const b6t={toc:[]},N6t="wrapper";function k6t(e){let{components:n,...t}=e;return(0,s.yg)(N6t,(0,p.A)({},b6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}k6t.isMDXComponent=!0;const z6t={toc:[]},P6t="wrapper";function I6t(e){let{components:n,...t}=e;return(0,s.yg)(P6t,(0,p.A)({},z6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}I6t.isMDXComponent=!0;const R6t={toc:[]},W6t="wrapper";function S6t(e){let{components:n,...t}=e;return(0,s.yg)(W6t,(0,p.A)({},R6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}S6t.isMDXComponent=!0;const B6t={toc:[]},E6t="wrapper";function G6t(e){let{components:n,...t}=e;return(0,s.yg)(E6t,(0,p.A)({},B6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}G6t.isMDXComponent=!0;const O6t={toc:[]},U6t="wrapper";function F6t(e){let{components:n,...t}=e;return(0,s.yg)(U6t,(0,p.A)({},O6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}F6t.isMDXComponent=!0;const V6t={toc:[]},q6t="wrapper";function j6t(e){let{components:n,...t}=e;return(0,s.yg)(q6t,(0,p.A)({},V6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}j6t.isMDXComponent=!0;const H6t={toc:[]},Y6t="wrapper";function Q6t(e){let{components:n,...t}=e;return(0,s.yg)(Y6t,(0,p.A)({},H6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Q6t.isMDXComponent=!0;const $6t={toc:[]},K6t="wrapper";function J6t(e){let{components:n,...t}=e;return(0,s.yg)(K6t,(0,p.A)({},$6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}J6t.isMDXComponent=!0;const Z6t={toc:[]},e8t="wrapper";function n8t(e){let{components:n,...t}=e;return(0,s.yg)(e8t,(0,p.A)({},Z6t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}n8t.isMDXComponent=!0;const t8t={toc:[]},o8t="wrapper";function p8t(e){let{components:n,...t}=e;return(0,s.yg)(o8t,(0,p.A)({},t8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}p8t.isMDXComponent=!0;const r8t={toc:[]},s8t="wrapper";function c8t(e){let{components:n,...t}=e;return(0,s.yg)(s8t,(0,p.A)({},r8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}c8t.isMDXComponent=!0;const a8t={toc:[]},i8t="wrapper";function l8t(e){let{components:n,...t}=e;return(0,s.yg)(i8t,(0,p.A)({},a8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}l8t.isMDXComponent=!0;const u8t={toc:[]},m8t="wrapper";function y8t(e){let{components:n,...t}=e;return(0,s.yg)(m8t,(0,p.A)({},u8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}y8t.isMDXComponent=!0;const d8t={toc:[]},h8t="wrapper";function g8t(e){let{components:n,...t}=e;return(0,s.yg)(h8t,(0,p.A)({},d8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}g8t.isMDXComponent=!0;const f8t={toc:[]},D8t="wrapper";function M8t(e){let{components:n,...t}=e;return(0,s.yg)(D8t,(0,p.A)({},f8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}M8t.isMDXComponent=!0;const X8t={toc:[]},_8t="wrapper";function w8t(e){let{components:n,...t}=e;return(0,s.yg)(_8t,(0,p.A)({},X8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}w8t.isMDXComponent=!0;const T8t={toc:[]},C8t="wrapper";function x8t(e){let{components:n,...t}=e;return(0,s.yg)(C8t,(0,p.A)({},T8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}x8t.isMDXComponent=!0;const A8t={toc:[]},v8t="wrapper";function L8t(e){let{components:n,...t}=e;return(0,s.yg)(v8t,(0,p.A)({},A8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}L8t.isMDXComponent=!0;const b8t={toc:[]},N8t="wrapper";function k8t(e){let{components:n,...t}=e;return(0,s.yg)(N8t,(0,p.A)({},b8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}k8t.isMDXComponent=!0;const z8t={toc:[]},P8t="wrapper";function I8t(e){let{components:n,...t}=e;return(0,s.yg)(P8t,(0,p.A)({},z8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}I8t.isMDXComponent=!0;const R8t={toc:[]},W8t="wrapper";function S8t(e){let{components:n,...t}=e;return(0,s.yg)(W8t,(0,p.A)({},R8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}S8t.isMDXComponent=!0;const B8t={toc:[]},E8t="wrapper";function G8t(e){let{components:n,...t}=e;return(0,s.yg)(E8t,(0,p.A)({},B8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}G8t.isMDXComponent=!0;const O8t={toc:[]},U8t="wrapper";function F8t(e){let{components:n,...t}=e;return(0,s.yg)(U8t,(0,p.A)({},O8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}F8t.isMDXComponent=!0;const V8t={toc:[]},q8t="wrapper";function j8t(e){let{components:n,...t}=e;return(0,s.yg)(q8t,(0,p.A)({},V8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}j8t.isMDXComponent=!0;const H8t={toc:[]},Y8t="wrapper";function Q8t(e){let{components:n,...t}=e;return(0,s.yg)(Y8t,(0,p.A)({},H8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Q8t.isMDXComponent=!0;const $8t={toc:[]},K8t="wrapper";function J8t(e){let{components:n,...t}=e;return(0,s.yg)(K8t,(0,p.A)({},$8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}J8t.isMDXComponent=!0;const Z8t={toc:[]},e5t="wrapper";function n5t(e){let{components:n,...t}=e;return(0,s.yg)(e5t,(0,p.A)({},Z8t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}n5t.isMDXComponent=!0;const t5t={toc:[]},o5t="wrapper";function p5t(e){let{components:n,...t}=e;return(0,s.yg)(o5t,(0,p.A)({},t5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}p5t.isMDXComponent=!0;const r5t={toc:[]},s5t="wrapper";function c5t(e){let{components:n,...t}=e;return(0,s.yg)(s5t,(0,p.A)({},r5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}c5t.isMDXComponent=!0;const a5t={toc:[]},i5t="wrapper";function l5t(e){let{components:n,...t}=e;return(0,s.yg)(i5t,(0,p.A)({},a5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}l5t.isMDXComponent=!0;const u5t={toc:[]},m5t="wrapper";function y5t(e){let{components:n,...t}=e;return(0,s.yg)(m5t,(0,p.A)({},u5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}y5t.isMDXComponent=!0;const d5t={toc:[]},h5t="wrapper";function g5t(e){let{components:n,...t}=e;return(0,s.yg)(h5t,(0,p.A)({},d5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}g5t.isMDXComponent=!0;const f5t={toc:[]},D5t="wrapper";function M5t(e){let{components:n,...t}=e;return(0,s.yg)(D5t,(0,p.A)({},f5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}M5t.isMDXComponent=!0;const X5t={toc:[]},_5t="wrapper";function w5t(e){let{components:n,...t}=e;return(0,s.yg)(_5t,(0,p.A)({},X5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}w5t.isMDXComponent=!0;const T5t={toc:[]},C5t="wrapper";function x5t(e){let{components:n,...t}=e;return(0,s.yg)(C5t,(0,p.A)({},T5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}x5t.isMDXComponent=!0;const A5t={toc:[]},v5t="wrapper";function L5t(e){let{components:n,...t}=e;return(0,s.yg)(v5t,(0,p.A)({},A5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}L5t.isMDXComponent=!0;const b5t={toc:[]},N5t="wrapper";function k5t(e){let{components:n,...t}=e;return(0,s.yg)(N5t,(0,p.A)({},b5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}k5t.isMDXComponent=!0;const z5t={toc:[]},P5t="wrapper";function I5t(e){let{components:n,...t}=e;return(0,s.yg)(P5t,(0,p.A)({},z5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}I5t.isMDXComponent=!0;const R5t={toc:[]},W5t="wrapper";function S5t(e){let{components:n,...t}=e;return(0,s.yg)(W5t,(0,p.A)({},R5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}S5t.isMDXComponent=!0;const B5t={toc:[]},E5t="wrapper";function G5t(e){let{components:n,...t}=e;return(0,s.yg)(E5t,(0,p.A)({},B5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}G5t.isMDXComponent=!0;const O5t={toc:[]},U5t="wrapper";function F5t(e){let{components:n,...t}=e;return(0,s.yg)(U5t,(0,p.A)({},O5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}F5t.isMDXComponent=!0;const V5t={toc:[]},q5t="wrapper";function j5t(e){let{components:n,...t}=e;return(0,s.yg)(q5t,(0,p.A)({},V5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}j5t.isMDXComponent=!0;const H5t={toc:[]},Y5t="wrapper";function Q5t(e){let{components:n,...t}=e;return(0,s.yg)(Y5t,(0,p.A)({},H5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}Q5t.isMDXComponent=!0;const $5t={toc:[]},K5t="wrapper";function J5t(e){let{components:n,...t}=e;return(0,s.yg)(K5t,(0,p.A)({},$5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}J5t.isMDXComponent=!0;const Z5t={toc:[]},e7t="wrapper";function n7t(e){let{components:n,...t}=e;return(0,s.yg)(e7t,(0,p.A)({},Z5t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}n7t.isMDXComponent=!0;const t7t={toc:[]},o7t="wrapper";function p7t(e){let{components:n,...t}=e;return(0,s.yg)(o7t,(0,p.A)({},t7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}p7t.isMDXComponent=!0;const r7t={toc:[]},s7t="wrapper";function c7t(e){let{components:n,...t}=e;return(0,s.yg)(s7t,(0,p.A)({},r7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}c7t.isMDXComponent=!0;const a7t={toc:[]},i7t="wrapper";function l7t(e){let{components:n,...t}=e;return(0,s.yg)(i7t,(0,p.A)({},a7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}l7t.isMDXComponent=!0;const u7t={toc:[]},m7t="wrapper";function y7t(e){let{components:n,...t}=e;return(0,s.yg)(m7t,(0,p.A)({},u7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}y7t.isMDXComponent=!0;const d7t={toc:[]},h7t="wrapper";function g7t(e){let{components:n,...t}=e;return(0,s.yg)(h7t,(0,p.A)({},d7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}g7t.isMDXComponent=!0;const f7t={toc:[]},D7t="wrapper";function M7t(e){let{components:n,...t}=e;return(0,s.yg)(D7t,(0,p.A)({},f7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}M7t.isMDXComponent=!0;const X7t={toc:[]},_7t="wrapper";function w7t(e){let{components:n,...t}=e;return(0,s.yg)(_7t,(0,p.A)({},X7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}w7t.isMDXComponent=!0;const T7t={toc:[]},C7t="wrapper";function x7t(e){let{components:n,...t}=e;return(0,s.yg)(C7t,(0,p.A)({},T7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}x7t.isMDXComponent=!0;const A7t={toc:[]},v7t="wrapper";function L7t(e){let{components:n,...t}=e;return(0,s.yg)(v7t,(0,p.A)({},A7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}L7t.isMDXComponent=!0;const b7t={toc:[]},N7t="wrapper";function k7t(e){let{components:n,...t}=e;return(0,s.yg)(N7t,(0,p.A)({},b7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}k7t.isMDXComponent=!0;const z7t={toc:[]},P7t="wrapper";function I7t(e){let{components:n,...t}=e;return(0,s.yg)(P7t,(0,p.A)({},z7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}I7t.isMDXComponent=!0;const R7t={toc:[]},W7t="wrapper";function S7t(e){let{components:n,...t}=e;return(0,s.yg)(W7t,(0,p.A)({},R7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}S7t.isMDXComponent=!0;const B7t={toc:[]},E7t="wrapper";function G7t(e){let{components:n,...t}=e;return(0,s.yg)(E7t,(0,p.A)({},B7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}G7t.isMDXComponent=!0;const O7t={toc:[]},U7t="wrapper";function F7t(e){let{components:n,...t}=e;return(0,s.yg)(U7t,(0,p.A)({},O7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}F7t.isMDXComponent=!0;const V7t={toc:[]},q7t="wrapper";function j7t(e){let{components:n,...t}=e;return(0,s.yg)(q7t,(0,p.A)({},V7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}j7t.isMDXComponent=!0;const H7t={toc:[]},Y7t="wrapper";function Q7t(e){let{components:n,...t}=e;return(0,s.yg)(Y7t,(0,p.A)({},H7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Q7t.isMDXComponent=!0;const $7t={toc:[]},K7t="wrapper";function J7t(e){let{components:n,...t}=e;return(0,s.yg)(K7t,(0,p.A)({},$7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}J7t.isMDXComponent=!0;const Z7t={toc:[]},eeo="wrapper";function neo(e){let{components:n,...t}=e;return(0,s.yg)(eeo,(0,p.A)({},Z7t,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}neo.isMDXComponent=!0;const teo={toc:[]},oeo="wrapper";function peo(e){let{components:n,...t}=e;return(0,s.yg)(oeo,(0,p.A)({},teo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}peo.isMDXComponent=!0;const reo={toc:[]},seo="wrapper";function ceo(e){let{components:n,...t}=e;return(0,s.yg)(seo,(0,p.A)({},reo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}ceo.isMDXComponent=!0;const aeo={toc:[]},ieo="wrapper";function leo(e){let{components:n,...t}=e;return(0,s.yg)(ieo,(0,p.A)({},aeo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}leo.isMDXComponent=!0;const ueo={toc:[]},meo="wrapper";function yeo(e){let{components:n,...t}=e;return(0,s.yg)(meo,(0,p.A)({},ueo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}yeo.isMDXComponent=!0;const deo={toc:[]},heo="wrapper";function geo(e){let{components:n,...t}=e;return(0,s.yg)(heo,(0,p.A)({},deo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}geo.isMDXComponent=!0;const feo={toc:[]},Deo="wrapper";function Meo(e){let{components:n,...t}=e;return(0,s.yg)(Deo,(0,p.A)({},feo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Meo.isMDXComponent=!0;const Xeo={toc:[]},_eo="wrapper";function weo(e){let{components:n,...t}=e;return(0,s.yg)(_eo,(0,p.A)({},Xeo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}weo.isMDXComponent=!0;const Teo={toc:[]},Ceo="wrapper";function xeo(e){let{components:n,...t}=e;return(0,s.yg)(Ceo,(0,p.A)({},Teo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}xeo.isMDXComponent=!0;const Aeo={toc:[]},veo="wrapper";function Leo(e){let{components:n,...t}=e;return(0,s.yg)(veo,(0,p.A)({},Aeo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}Leo.isMDXComponent=!0;const beo={toc:[]},Neo="wrapper";function keo(e){let{components:n,...t}=e;return(0,s.yg)(Neo,(0,p.A)({},beo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}keo.isMDXComponent=!0;const zeo={toc:[]},Peo="wrapper";function Ieo(e){let{components:n,...t}=e;return(0,s.yg)(Peo,(0,p.A)({},zeo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}Ieo.isMDXComponent=!0;const Reo={toc:[]},Weo="wrapper";function Seo(e){let{components:n,...t}=e;return(0,s.yg)(Weo,(0,p.A)({},Reo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Seo.isMDXComponent=!0;const Beo={toc:[]},Eeo="wrapper";function Geo(e){let{components:n,...t}=e;return(0,s.yg)(Eeo,(0,p.A)({},Beo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Geo.isMDXComponent=!0;const Oeo={toc:[]},Ueo="wrapper";function Feo(e){let{components:n,...t}=e;return(0,s.yg)(Ueo,(0,p.A)({},Oeo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Feo.isMDXComponent=!0;const Veo={toc:[]},qeo="wrapper";function jeo(e){let{components:n,...t}=e;return(0,s.yg)(qeo,(0,p.A)({},Veo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}jeo.isMDXComponent=!0;const Heo={toc:[]},Yeo="wrapper";function Qeo(e){let{components:n,...t}=e;return(0,s.yg)(Yeo,(0,p.A)({},Heo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Qeo.isMDXComponent=!0;const $eo={toc:[]},Keo="wrapper";function Jeo(e){let{components:n,...t}=e;return(0,s.yg)(Keo,(0,p.A)({},$eo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Jeo.isMDXComponent=!0;const Zeo={toc:[]},eno="wrapper";function nno(e){let{components:n,...t}=e;return(0,s.yg)(eno,(0,p.A)({},Zeo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}nno.isMDXComponent=!0;const tno={toc:[]},ono="wrapper";function pno(e){let{components:n,...t}=e;return(0,s.yg)(ono,(0,p.A)({},tno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}pno.isMDXComponent=!0;const rno={toc:[]},sno="wrapper";function cno(e){let{components:n,...t}=e;return(0,s.yg)(sno,(0,p.A)({},rno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}cno.isMDXComponent=!0;const ano={toc:[]},ino="wrapper";function lno(e){let{components:n,...t}=e;return(0,s.yg)(ino,(0,p.A)({},ano,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}lno.isMDXComponent=!0;const uno={toc:[]},mno="wrapper";function yno(e){let{components:n,...t}=e;return(0,s.yg)(mno,(0,p.A)({},uno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}yno.isMDXComponent=!0;const dno={toc:[]},hno="wrapper";function gno(e){let{components:n,...t}=e;return(0,s.yg)(hno,(0,p.A)({},dno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}gno.isMDXComponent=!0;const fno={toc:[]},Dno="wrapper";function Mno(e){let{components:n,...t}=e;return(0,s.yg)(Dno,(0,p.A)({},fno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Mno.isMDXComponent=!0;const Xno={toc:[]},_no="wrapper";function wno(e){let{components:n,...t}=e;return(0,s.yg)(_no,(0,p.A)({},Xno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}wno.isMDXComponent=!0;const Tno={toc:[]},Cno="wrapper";function xno(e){let{components:n,...t}=e;return(0,s.yg)(Cno,(0,p.A)({},Tno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D} from '@revideo/2d';\nimport {Ray} from '@revideo/2d';\nimport {createRef} from '@revideo/core';\n\nexport default makeScene2D(function* (view) {\n  const ray = createRef<Ray>();\n\n  view.add(\n    <Ray\n      ref={ray}\n      lineWidth={8}\n      endArrow\n      stroke={'lightseagreen'}\n      fromX={-200}\n      toX={200}\n    />,\n  );\n\n  yield* ray().start(1, 1);\n  yield* ray().start(0).end(0).start(1, 1);\n});\n")))}xno.isMDXComponent=!0;const Ano={toc:[]},vno="wrapper";function Lno(e){let{components:n,...t}=e;return(0,s.yg)(vno,(0,p.A)({},Ano,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing an individual line segment."))}Lno.isMDXComponent=!0;const bno={toc:[]},Nno="wrapper";function kno(e){let{components:n,...t}=e;return(0,s.yg)(Nno,(0,p.A)({},bno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}kno.isMDXComponent=!0;const zno={toc:[]},Pno="wrapper";function Ino(e){let{components:n,...t}=e;return(0,s.yg)(Pno,(0,p.A)({},zno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}Ino.isMDXComponent=!0;const Rno={toc:[]},Wno="wrapper";function Sno(e){let{components:n,...t}=e;return(0,s.yg)(Wno,(0,p.A)({},Rno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Sno.isMDXComponent=!0;const Bno={toc:[]},Eno="wrapper";function Gno(e){let{components:n,...t}=e;return(0,s.yg)(Eno,(0,p.A)({},Bno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}Gno.isMDXComponent=!0;const Ono={toc:[]},Uno="wrapper";function Fno(e){let{components:n,...t}=e;return(0,s.yg)(Uno,(0,p.A)({},Ono,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Fno.isMDXComponent=!0;const Vno={toc:[]},qno="wrapper";function jno(e){let{components:n,...t}=e;return(0,s.yg)(qno,(0,p.A)({},Vno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}jno.isMDXComponent=!0;const Hno={toc:[]},Yno="wrapper";function Qno(e){let{components:n,...t}=e;return(0,s.yg)(Yno,(0,p.A)({},Hno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Qno.isMDXComponent=!0;const $no={toc:[]},Kno="wrapper";function Jno(e){let{components:n,...t}=e;return(0,s.yg)(Kno,(0,p.A)({},$no,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}Jno.isMDXComponent=!0;const Zno={toc:[]},eto="wrapper";function nto(e){let{components:n,...t}=e;return(0,s.yg)(eto,(0,p.A)({},Zno,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}nto.isMDXComponent=!0;const tto={toc:[]},oto="wrapper";function pto(e){let{components:n,...t}=e;return(0,s.yg)(oto,(0,p.A)({},tto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}pto.isMDXComponent=!0;const rto={toc:[]},sto="wrapper";function cto(e){let{components:n,...t}=e;return(0,s.yg)(sto,(0,p.A)({},rto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}cto.isMDXComponent=!0;const ato={toc:[]},ito="wrapper";function lto(e){let{components:n,...t}=e;return(0,s.yg)(ito,(0,p.A)({},ato,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}lto.isMDXComponent=!0;const uto={toc:[]},mto="wrapper";function yto(e){let{components:n,...t}=e;return(0,s.yg)(mto,(0,p.A)({},uto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}yto.isMDXComponent=!0;const dto={toc:[]},hto="wrapper";function gto(e){let{components:n,...t}=e;return(0,s.yg)(hto,(0,p.A)({},dto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}gto.isMDXComponent=!0;const fto={toc:[]},Dto="wrapper";function Mto(e){let{components:n,...t}=e;return(0,s.yg)(Dto,(0,p.A)({},fto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Mto.isMDXComponent=!0;const Xto={toc:[]},_to="wrapper";function wto(e){let{components:n,...t}=e;return(0,s.yg)(_to,(0,p.A)({},Xto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}wto.isMDXComponent=!0;const Tto={toc:[]},Cto="wrapper";function xto(e){let{components:n,...t}=e;return(0,s.yg)(Cto,(0,p.A)({},Tto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}xto.isMDXComponent=!0;const Ato={toc:[]},vto="wrapper";function Lto(e){let{components:n,...t}=e;return(0,s.yg)(vto,(0,p.A)({},Ato,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}Lto.isMDXComponent=!0;const bto={toc:[]},Nto="wrapper";function kto(e){let{components:n,...t}=e;return(0,s.yg)(Nto,(0,p.A)({},bto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}kto.isMDXComponent=!0;const zto={toc:[]},Pto="wrapper";function Ito(e){let{components:n,...t}=e;return(0,s.yg)(Pto,(0,p.A)({},zto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}Ito.isMDXComponent=!0;const Rto={toc:[]},Wto="wrapper";function Sto(e){let{components:n,...t}=e;return(0,s.yg)(Wto,(0,p.A)({},Rto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Sto.isMDXComponent=!0;const Bto={toc:[]},Eto="wrapper";function Gto(e){let{components:n,...t}=e;return(0,s.yg)(Eto,(0,p.A)({},Bto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}Gto.isMDXComponent=!0;const Oto={toc:[]},Uto="wrapper";function Fto(e){let{components:n,...t}=e;return(0,s.yg)(Uto,(0,p.A)({},Oto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Fto.isMDXComponent=!0;const Vto={toc:[]},qto="wrapper";function jto(e){let{components:n,...t}=e;return(0,s.yg)(qto,(0,p.A)({},Vto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}jto.isMDXComponent=!0;const Hto={toc:[]},Yto="wrapper";function Qto(e){let{components:n,...t}=e;return(0,s.yg)(Yto,(0,p.A)({},Hto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The starting point of the ray."))}Qto.isMDXComponent=!0;const $to={toc:[]},Kto="wrapper";function Jto(e){let{components:n,...t}=e;return(0,s.yg)(Kto,(0,p.A)({},$to,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Jto.isMDXComponent=!0;const Zto={toc:[]},eoo="wrapper";function noo(e){let{components:n,...t}=e;return(0,s.yg)(eoo,(0,p.A)({},Zto,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}noo.isMDXComponent=!0;const too={toc:[]},ooo="wrapper";function poo(e){let{components:n,...t}=e;return(0,s.yg)(ooo,(0,p.A)({},too,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}poo.isMDXComponent=!0;const roo={toc:[]},soo="wrapper";function coo(e){let{components:n,...t}=e;return(0,s.yg)(soo,(0,p.A)({},roo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}coo.isMDXComponent=!0;const aoo={toc:[]},ioo="wrapper";function loo(e){let{components:n,...t}=e;return(0,s.yg)(ioo,(0,p.A)({},aoo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}loo.isMDXComponent=!0;const uoo={toc:[]},moo="wrapper";function yoo(e){let{components:n,...t}=e;return(0,s.yg)(moo,(0,p.A)({},uoo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}yoo.isMDXComponent=!0;const doo={toc:[]},hoo="wrapper";function goo(e){let{components:n,...t}=e;return(0,s.yg)(hoo,(0,p.A)({},doo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}goo.isMDXComponent=!0;const foo={toc:[]},Doo="wrapper";function Moo(e){let{components:n,...t}=e;return(0,s.yg)(Doo,(0,p.A)({},foo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}Moo.isMDXComponent=!0;const Xoo={toc:[]},_oo="wrapper";function woo(e){let{components:n,...t}=e;return(0,s.yg)(_oo,(0,p.A)({},Xoo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}woo.isMDXComponent=!0;const Too={toc:[]},Coo="wrapper";function xoo(e){let{components:n,...t}=e;return(0,s.yg)(Coo,(0,p.A)({},Too,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}xoo.isMDXComponent=!0;const Aoo={toc:[]},voo="wrapper";function Loo(e){let{components:n,...t}=e;return(0,s.yg)(voo,(0,p.A)({},Aoo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Loo.isMDXComponent=!0;const boo={toc:[]},Noo="wrapper";function koo(e){let{components:n,...t}=e;return(0,s.yg)(Noo,(0,p.A)({},boo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}koo.isMDXComponent=!0;const zoo={toc:[]},Poo="wrapper";function Ioo(e){let{components:n,...t}=e;return(0,s.yg)(Poo,(0,p.A)({},zoo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Ioo.isMDXComponent=!0;const Roo={toc:[]},Woo="wrapper";function Soo(e){let{components:n,...t}=e;return(0,s.yg)(Woo,(0,p.A)({},Roo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Soo.isMDXComponent=!0;const Boo={toc:[]},Eoo="wrapper";function Goo(e){let{components:n,...t}=e;return(0,s.yg)(Eoo,(0,p.A)({},Boo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}Goo.isMDXComponent=!0;const Ooo={toc:[]},Uoo="wrapper";function Foo(e){let{components:n,...t}=e;return(0,s.yg)(Uoo,(0,p.A)({},Ooo,t,{components:n,mdxType:"MDXLayout"}))}Foo.isMDXComponent=!0;const Voo={toc:[]},qoo="wrapper";function joo(e){let{components:n,...t}=e;return(0,s.yg)(qoo,(0,p.A)({},Voo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}joo.isMDXComponent=!0;const Hoo={toc:[]},Yoo="wrapper";function Qoo(e){let{components:n,...t}=e;return(0,s.yg)(Yoo,(0,p.A)({},Hoo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Qoo.isMDXComponent=!0;const $oo={toc:[]},Koo="wrapper";function Joo(e){let{components:n,...t}=e;return(0,s.yg)(Koo,(0,p.A)({},$oo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}Joo.isMDXComponent=!0;const Zoo={toc:[]},epo="wrapper";function npo(e){let{components:n,...t}=e;return(0,s.yg)(epo,(0,p.A)({},Zoo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}npo.isMDXComponent=!0;const tpo={toc:[]},opo="wrapper";function ppo(e){let{components:n,...t}=e;return(0,s.yg)(opo,(0,p.A)({},tpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}ppo.isMDXComponent=!0;const rpo={toc:[]},spo="wrapper";function cpo(e){let{components:n,...t}=e;return(0,s.yg)(spo,(0,p.A)({},rpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}cpo.isMDXComponent=!0;const apo={toc:[]},ipo="wrapper";function lpo(e){let{components:n,...t}=e;return(0,s.yg)(ipo,(0,p.A)({},apo,t,{components:n,mdxType:"MDXLayout"}))}lpo.isMDXComponent=!0;const upo={toc:[]},mpo="wrapper";function ypo(e){let{components:n,...t}=e;return(0,s.yg)(mpo,(0,p.A)({},upo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}ypo.isMDXComponent=!0;const dpo={toc:[]},hpo="wrapper";function gpo(e){let{components:n,...t}=e;return(0,s.yg)(hpo,(0,p.A)({},dpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}gpo.isMDXComponent=!0;const fpo={toc:[]},Dpo="wrapper";function Mpo(e){let{components:n,...t}=e;return(0,s.yg)(Dpo,(0,p.A)({},fpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Mpo.isMDXComponent=!0;const Xpo={toc:[]},_po="wrapper";function wpo(e){let{components:n,...t}=e;return(0,s.yg)(_po,(0,p.A)({},Xpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}wpo.isMDXComponent=!0;const Tpo={toc:[]},Cpo="wrapper";function xpo(e){let{components:n,...t}=e;return(0,s.yg)(Cpo,(0,p.A)({},Tpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}xpo.isMDXComponent=!0;const Apo={toc:[]},vpo="wrapper";function Lpo(e){let{components:n,...t}=e;return(0,s.yg)(vpo,(0,p.A)({},Apo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}Lpo.isMDXComponent=!0;const bpo={toc:[]},Npo="wrapper";function kpo(e){let{components:n,...t}=e;return(0,s.yg)(Npo,(0,p.A)({},bpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ending point of the ray."))}kpo.isMDXComponent=!0;const zpo={toc:[]},Ppo="wrapper";function Ipo(e){let{components:n,...t}=e;return(0,s.yg)(Ppo,(0,p.A)({},zpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Ipo.isMDXComponent=!0;const Rpo={toc:[]},Wpo="wrapper";function Spo(e){let{components:n,...t}=e;return(0,s.yg)(Wpo,(0,p.A)({},Rpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Spo.isMDXComponent=!0;const Bpo={toc:[]},Epo="wrapper";function Gpo(e){let{components:n,...t}=e;return(0,s.yg)(Epo,(0,p.A)({},Bpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Gpo.isMDXComponent=!0;const Opo={toc:[]},Upo="wrapper";function Fpo(e){let{components:n,...t}=e;return(0,s.yg)(Upo,(0,p.A)({},Opo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Fpo.isMDXComponent=!0;const Vpo={toc:[]},qpo="wrapper";function jpo(e){let{components:n,...t}=e;return(0,s.yg)(qpo,(0,p.A)({},Vpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}jpo.isMDXComponent=!0;const Hpo={toc:[]},Ypo="wrapper";function Qpo(e){let{components:n,...t}=e;return(0,s.yg)(Ypo,(0,p.A)({},Hpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Qpo.isMDXComponent=!0;const $po={toc:[]},Kpo="wrapper";function Jpo(e){let{components:n,...t}=e;return(0,s.yg)(Kpo,(0,p.A)({},$po,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}Jpo.isMDXComponent=!0;const Zpo={toc:[]},ero="wrapper";function nro(e){let{components:n,...t}=e;return(0,s.yg)(ero,(0,p.A)({},Zpo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}nro.isMDXComponent=!0;const tro={toc:[]},oro="wrapper";function pro(e){let{components:n,...t}=e;return(0,s.yg)(oro,(0,p.A)({},tro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}pro.isMDXComponent=!0;const rro={toc:[]},sro="wrapper";function cro(e){let{components:n,...t}=e;return(0,s.yg)(sro,(0,p.A)({},rro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}cro.isMDXComponent=!0;const aro={toc:[]},iro="wrapper";function lro(e){let{components:n,...t}=e;return(0,s.yg)(iro,(0,p.A)({},aro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}lro.isMDXComponent=!0;const uro={toc:[]},mro="wrapper";function yro(e){let{components:n,...t}=e;return(0,s.yg)(mro,(0,p.A)({},uro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}yro.isMDXComponent=!0;const dro={toc:[]},hro="wrapper";function gro(e){let{components:n,...t}=e;return(0,s.yg)(hro,(0,p.A)({},dro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}gro.isMDXComponent=!0;const fro={toc:[]},Dro="wrapper";function Mro(e){let{components:n,...t}=e;return(0,s.yg)(Dro,(0,p.A)({},fro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}Mro.isMDXComponent=!0;const Xro={toc:[]},_ro="wrapper";function wro(e){let{components:n,...t}=e;return(0,s.yg)(_ro,(0,p.A)({},Xro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}wro.isMDXComponent=!0;const Tro={toc:[]},Cro="wrapper";function xro(e){let{components:n,...t}=e;return(0,s.yg)(Cro,(0,p.A)({},Tro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}xro.isMDXComponent=!0;const Aro={toc:[]},vro="wrapper";function Lro(e){let{components:n,...t}=e;return(0,s.yg)(vro,(0,p.A)({},Aro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}Lro.isMDXComponent=!0;const bro={toc:[]},Nro="wrapper";function kro(e){let{components:n,...t}=e;return(0,s.yg)(Nro,(0,p.A)({},bro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}kro.isMDXComponent=!0;const zro={toc:[]},Pro="wrapper";function Iro(e){let{components:n,...t}=e;return(0,s.yg)(Pro,(0,p.A)({},zro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Iro.isMDXComponent=!0;const Rro={toc:[]},Wro="wrapper";function Sro(e){let{components:n,...t}=e;return(0,s.yg)(Wro,(0,p.A)({},Rro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}Sro.isMDXComponent=!0;const Bro={toc:[]},Ero="wrapper";function Gro(e){let{components:n,...t}=e;return(0,s.yg)(Ero,(0,p.A)({},Bro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Gro.isMDXComponent=!0;const Oro={toc:[]},Uro="wrapper";function Fro(e){let{components:n,...t}=e;return(0,s.yg)(Uro,(0,p.A)({},Oro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Fro.isMDXComponent=!0;const Vro={toc:[]},qro="wrapper";function jro(e){let{components:n,...t}=e;return(0,s.yg)(qro,(0,p.A)({},Vro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}jro.isMDXComponent=!0;const Hro={toc:[]},Yro="wrapper";function Qro(e){let{components:n,...t}=e;return(0,s.yg)(Yro,(0,p.A)({},Hro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}Qro.isMDXComponent=!0;const $ro={toc:[]},Kro="wrapper";function Jro(e){let{components:n,...t}=e;return(0,s.yg)(Kro,(0,p.A)({},$ro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}Jro.isMDXComponent=!0;const Zro={toc:[]},eso="wrapper";function nso(e){let{components:n,...t}=e;return(0,s.yg)(eso,(0,p.A)({},Zro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}nso.isMDXComponent=!0;const tso={toc:[]},oso="wrapper";function pso(e){let{components:n,...t}=e;return(0,s.yg)(oso,(0,p.A)({},tso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}pso.isMDXComponent=!0;const rso={toc:[]},sso="wrapper";function cso(e){let{components:n,...t}=e;return(0,s.yg)(sso,(0,p.A)({},rso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}cso.isMDXComponent=!0;const aso={toc:[]},iso="wrapper";function lso(e){let{components:n,...t}=e;return(0,s.yg)(iso,(0,p.A)({},aso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}lso.isMDXComponent=!0;const uso={toc:[]},mso="wrapper";function yso(e){let{components:n,...t}=e;return(0,s.yg)(mso,(0,p.A)({},uso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}yso.isMDXComponent=!0;const dso={toc:[]},hso="wrapper";function gso(e){let{components:n,...t}=e;return(0,s.yg)(hso,(0,p.A)({},dso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}gso.isMDXComponent=!0;const fso={toc:[]},Dso="wrapper";function Mso(e){let{components:n,...t}=e;return(0,s.yg)(Dso,(0,p.A)({},fso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}Mso.isMDXComponent=!0;const Xso={toc:[]},_so="wrapper";function wso(e){let{components:n,...t}=e;return(0,s.yg)(_so,(0,p.A)({},Xso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}wso.isMDXComponent=!0;const Tso={toc:[]},Cso="wrapper";function xso(e){let{components:n,...t}=e;return(0,s.yg)(Cso,(0,p.A)({},Tso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}xso.isMDXComponent=!0;const Aso={toc:[]},vso="wrapper";function Lso(e){let{components:n,...t}=e;return(0,s.yg)(vso,(0,p.A)({},Aso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Lso.isMDXComponent=!0;const bso={toc:[]},Nso="wrapper";function kso(e){let{components:n,...t}=e;return(0,s.yg)(Nso,(0,p.A)({},bso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}kso.isMDXComponent=!0;const zso={toc:[]},Pso="wrapper";function Iso(e){let{components:n,...t}=e;return(0,s.yg)(Pso,(0,p.A)({},zso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Iso.isMDXComponent=!0;const Rso={toc:[]},Wso="wrapper";function Sso(e){let{components:n,...t}=e;return(0,s.yg)(Wso,(0,p.A)({},Rso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}Sso.isMDXComponent=!0;const Bso={toc:[]},Eso="wrapper";function Gso(e){let{components:n,...t}=e;return(0,s.yg)(Eso,(0,p.A)({},Bso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}Gso.isMDXComponent=!0;const Oso={toc:[]},Uso="wrapper";function Fso(e){let{components:n,...t}=e;return(0,s.yg)(Uso,(0,p.A)({},Oso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Fso.isMDXComponent=!0;const Vso={toc:[]},qso="wrapper";function jso(e){let{components:n,...t}=e;return(0,s.yg)(qso,(0,p.A)({},Vso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}jso.isMDXComponent=!0;const Hso={toc:[]},Yso="wrapper";function Qso(e){let{components:n,...t}=e;return(0,s.yg)(Yso,(0,p.A)({},Hso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Qso.isMDXComponent=!0;const $so={toc:[]},Kso="wrapper";function Jso(e){let{components:n,...t}=e;return(0,s.yg)(Kso,(0,p.A)({},$so,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Jso.isMDXComponent=!0;const Zso={toc:[]},eco="wrapper";function nco(e){let{components:n,...t}=e;return(0,s.yg)(eco,(0,p.A)({},Zso,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}nco.isMDXComponent=!0;const tco={toc:[]},oco="wrapper";function pco(e){let{components:n,...t}=e;return(0,s.yg)(oco,(0,p.A)({},tco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}pco.isMDXComponent=!0;const rco={toc:[]},sco="wrapper";function cco(e){let{components:n,...t}=e;return(0,s.yg)(sco,(0,p.A)({},rco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}cco.isMDXComponent=!0;const aco={toc:[]},ico="wrapper";function lco(e){let{components:n,...t}=e;return(0,s.yg)(ico,(0,p.A)({},aco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}lco.isMDXComponent=!0;const uco={toc:[]},mco="wrapper";function yco(e){let{components:n,...t}=e;return(0,s.yg)(mco,(0,p.A)({},uco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}yco.isMDXComponent=!0;const dco={toc:[]},hco="wrapper";function gco(e){let{components:n,...t}=e;return(0,s.yg)(hco,(0,p.A)({},dco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}gco.isMDXComponent=!0;const fco={toc:[]},Dco="wrapper";function Mco(e){let{components:n,...t}=e;return(0,s.yg)(Dco,(0,p.A)({},fco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Mco.isMDXComponent=!0;const Xco={toc:[]},_co="wrapper";function wco(e){let{components:n,...t}=e;return(0,s.yg)(_co,(0,p.A)({},Xco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}wco.isMDXComponent=!0;const Tco={toc:[]},Cco="wrapper";function xco(e){let{components:n,...t}=e;return(0,s.yg)(Cco,(0,p.A)({},Tco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}xco.isMDXComponent=!0;const Aco={toc:[]},vco="wrapper";function Lco(e){let{components:n,...t}=e;return(0,s.yg)(vco,(0,p.A)({},Aco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Lco.isMDXComponent=!0;const bco={toc:[]},Nco="wrapper";function kco(e){let{components:n,...t}=e;return(0,s.yg)(Nco,(0,p.A)({},bco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}kco.isMDXComponent=!0;const zco={toc:[]},Pco="wrapper";function Ico(e){let{components:n,...t}=e;return(0,s.yg)(Pco,(0,p.A)({},zco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Ico.isMDXComponent=!0;const Rco={toc:[]},Wco="wrapper";function Sco(e){let{components:n,...t}=e;return(0,s.yg)(Wco,(0,p.A)({},Rco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Sco.isMDXComponent=!0;const Bco={toc:[]},Eco="wrapper";function Gco(e){let{components:n,...t}=e;return(0,s.yg)(Eco,(0,p.A)({},Bco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Gco.isMDXComponent=!0;const Oco={toc:[]},Uco="wrapper";function Fco(e){let{components:n,...t}=e;return(0,s.yg)(Uco,(0,p.A)({},Oco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Fco.isMDXComponent=!0;const Vco={toc:[]},qco="wrapper";function jco(e){let{components:n,...t}=e;return(0,s.yg)(qco,(0,p.A)({},Vco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}jco.isMDXComponent=!0;const Hco={toc:[]},Yco="wrapper";function Qco(e){let{components:n,...t}=e;return(0,s.yg)(Yco,(0,p.A)({},Hco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Qco.isMDXComponent=!0;const $co={toc:[]},Kco="wrapper";function Jco(e){let{components:n,...t}=e;return(0,s.yg)(Kco,(0,p.A)({},$co,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Jco.isMDXComponent=!0;const Zco={toc:[]},eao="wrapper";function nao(e){let{components:n,...t}=e;return(0,s.yg)(eao,(0,p.A)({},Zco,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}nao.isMDXComponent=!0;const tao={toc:[]},oao="wrapper";function pao(e){let{components:n,...t}=e;return(0,s.yg)(oao,(0,p.A)({},tao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}pao.isMDXComponent=!0;const rao={toc:[]},sao="wrapper";function cao(e){let{components:n,...t}=e;return(0,s.yg)(sao,(0,p.A)({},rao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}cao.isMDXComponent=!0;const aao={toc:[]},iao="wrapper";function lao(e){let{components:n,...t}=e;return(0,s.yg)(iao,(0,p.A)({},aao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}lao.isMDXComponent=!0;const uao={toc:[]},mao="wrapper";function yao(e){let{components:n,...t}=e;return(0,s.yg)(mao,(0,p.A)({},uao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}yao.isMDXComponent=!0;const dao={toc:[]},hao="wrapper";function gao(e){let{components:n,...t}=e;return(0,s.yg)(hao,(0,p.A)({},dao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}gao.isMDXComponent=!0;const fao={toc:[]},Dao="wrapper";function Mao(e){let{components:n,...t}=e;return(0,s.yg)(Dao,(0,p.A)({},fao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}Mao.isMDXComponent=!0;const Xao={toc:[]},_ao="wrapper";function wao(e){let{components:n,...t}=e;return(0,s.yg)(_ao,(0,p.A)({},Xao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}wao.isMDXComponent=!0;const Tao={toc:[]},Cao="wrapper";function xao(e){let{components:n,...t}=e;return(0,s.yg)(Cao,(0,p.A)({},Tao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}xao.isMDXComponent=!0;const Aao={toc:[]},vao="wrapper";function Lao(e){let{components:n,...t}=e;return(0,s.yg)(vao,(0,p.A)({},Aao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Lao.isMDXComponent=!0;const bao={toc:[]},Nao="wrapper";function kao(e){let{components:n,...t}=e;return(0,s.yg)(Nao,(0,p.A)({},bao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}kao.isMDXComponent=!0;const zao={toc:[]},Pao="wrapper";function Iao(e){let{components:n,...t}=e;return(0,s.yg)(Pao,(0,p.A)({},zao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}Iao.isMDXComponent=!0;const Rao={toc:[]},Wao="wrapper";function Sao(e){let{components:n,...t}=e;return(0,s.yg)(Wao,(0,p.A)({},Rao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}Sao.isMDXComponent=!0;const Bao={toc:[]},Eao="wrapper";function Gao(e){let{components:n,...t}=e;return(0,s.yg)(Eao,(0,p.A)({},Bao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}Gao.isMDXComponent=!0;const Oao={toc:[]},Uao="wrapper";function Fao(e){let{components:n,...t}=e;return(0,s.yg)(Uao,(0,p.A)({},Oao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}Fao.isMDXComponent=!0;const Vao={toc:[]},qao="wrapper";function jao(e){let{components:n,...t}=e;return(0,s.yg)(qao,(0,p.A)({},Vao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}jao.isMDXComponent=!0;const Hao={toc:[]},Yao="wrapper";function Qao(e){let{components:n,...t}=e;return(0,s.yg)(Yao,(0,p.A)({},Hao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}Qao.isMDXComponent=!0;const $ao={toc:[]},Kao="wrapper";function Jao(e){let{components:n,...t}=e;return(0,s.yg)(Kao,(0,p.A)({},$ao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Jao.isMDXComponent=!0;const Zao={toc:[]},eio="wrapper";function nio(e){let{components:n,...t}=e;return(0,s.yg)(eio,(0,p.A)({},Zao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}nio.isMDXComponent=!0;const tio={toc:[]},oio="wrapper";function pio(e){let{components:n,...t}=e;return(0,s.yg)(oio,(0,p.A)({},tio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}pio.isMDXComponent=!0;const rio={toc:[]},sio="wrapper";function cio(e){let{components:n,...t}=e;return(0,s.yg)(sio,(0,p.A)({},rio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}cio.isMDXComponent=!0;const aio={toc:[]},iio="wrapper";function lio(e){let{components:n,...t}=e;return(0,s.yg)(iio,(0,p.A)({},aio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}lio.isMDXComponent=!0;const uio={toc:[]},mio="wrapper";function yio(e){let{components:n,...t}=e;return(0,s.yg)(mio,(0,p.A)({},uio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}yio.isMDXComponent=!0;const dio={toc:[]},hio="wrapper";function gio(e){let{components:n,...t}=e;return(0,s.yg)(hio,(0,p.A)({},dio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}gio.isMDXComponent=!0;const fio={toc:[]},Dio="wrapper";function Mio(e){let{components:n,...t}=e;return(0,s.yg)(Dio,(0,p.A)({},fio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}Mio.isMDXComponent=!0;const Xio={toc:[]},_io="wrapper";function wio(e){let{components:n,...t}=e;return(0,s.yg)(_io,(0,p.A)({},Xio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}wio.isMDXComponent=!0;const Tio={toc:[]},Cio="wrapper";function xio(e){let{components:n,...t}=e;return(0,s.yg)(Cio,(0,p.A)({},Tio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}xio.isMDXComponent=!0;const Aio={toc:[]},vio="wrapper";function Lio(e){let{components:n,...t}=e;return(0,s.yg)(vio,(0,p.A)({},Aio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Lio.isMDXComponent=!0;const bio={toc:[]},Nio="wrapper";function kio(e){let{components:n,...t}=e;return(0,s.yg)(Nio,(0,p.A)({},bio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}kio.isMDXComponent=!0;const zio={toc:[]},Pio="wrapper";function Iio(e){let{components:n,...t}=e;return(0,s.yg)(Pio,(0,p.A)({},zio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Iio.isMDXComponent=!0;const Rio={toc:[]},Wio="wrapper";function Sio(e){let{components:n,...t}=e;return(0,s.yg)(Wio,(0,p.A)({},Rio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}Sio.isMDXComponent=!0;const Bio={toc:[]},Eio="wrapper";function Gio(e){let{components:n,...t}=e;return(0,s.yg)(Eio,(0,p.A)({},Bio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Gio.isMDXComponent=!0;const Oio={toc:[]},Uio="wrapper";function Fio(e){let{components:n,...t}=e;return(0,s.yg)(Uio,(0,p.A)({},Oio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Fio.isMDXComponent=!0;const Vio={toc:[]},qio="wrapper";function jio(e){let{components:n,...t}=e;return(0,s.yg)(qio,(0,p.A)({},Vio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}jio.isMDXComponent=!0;const Hio={toc:[]},Yio="wrapper";function Qio(e){let{components:n,...t}=e;return(0,s.yg)(Yio,(0,p.A)({},Hio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}Qio.isMDXComponent=!0;const $io={toc:[]},Kio="wrapper";function Jio(e){let{components:n,...t}=e;return(0,s.yg)(Kio,(0,p.A)({},$io,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Jio.isMDXComponent=!0;const Zio={toc:[]},elo="wrapper";function nlo(e){let{components:n,...t}=e;return(0,s.yg)(elo,(0,p.A)({},Zio,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}nlo.isMDXComponent=!0;const tlo={toc:[]},olo="wrapper";function plo(e){let{components:n,...t}=e;return(0,s.yg)(olo,(0,p.A)({},tlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}plo.isMDXComponent=!0;const rlo={toc:[]},slo="wrapper";function clo(e){let{components:n,...t}=e;return(0,s.yg)(slo,(0,p.A)({},rlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}clo.isMDXComponent=!0;const alo={toc:[]},ilo="wrapper";function llo(e){let{components:n,...t}=e;return(0,s.yg)(ilo,(0,p.A)({},alo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}llo.isMDXComponent=!0;const ulo={toc:[]},mlo="wrapper";function ylo(e){let{components:n,...t}=e;return(0,s.yg)(mlo,(0,p.A)({},ulo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}ylo.isMDXComponent=!0;const dlo={toc:[]},hlo="wrapper";function glo(e){let{components:n,...t}=e;return(0,s.yg)(hlo,(0,p.A)({},dlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}glo.isMDXComponent=!0;const flo={toc:[]},Dlo="wrapper";function Mlo(e){let{components:n,...t}=e;return(0,s.yg)(Dlo,(0,p.A)({},flo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Mlo.isMDXComponent=!0;const Xlo={toc:[]},_lo="wrapper";function wlo(e){let{components:n,...t}=e;return(0,s.yg)(_lo,(0,p.A)({},Xlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}wlo.isMDXComponent=!0;const Tlo={toc:[]},Clo="wrapper";function xlo(e){let{components:n,...t}=e;return(0,s.yg)(Clo,(0,p.A)({},Tlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}xlo.isMDXComponent=!0;const Alo={toc:[]},vlo="wrapper";function Llo(e){let{components:n,...t}=e;return(0,s.yg)(vlo,(0,p.A)({},Alo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}Llo.isMDXComponent=!0;const blo={toc:[]},Nlo="wrapper";function klo(e){let{components:n,...t}=e;return(0,s.yg)(Nlo,(0,p.A)({},blo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}klo.isMDXComponent=!0;const zlo={toc:[]},Plo="wrapper";function Ilo(e){let{components:n,...t}=e;return(0,s.yg)(Plo,(0,p.A)({},zlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}Ilo.isMDXComponent=!0;const Rlo={toc:[]},Wlo="wrapper";function Slo(e){let{components:n,...t}=e;return(0,s.yg)(Wlo,(0,p.A)({},Rlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}Slo.isMDXComponent=!0;const Blo={toc:[]},Elo="wrapper";function Glo(e){let{components:n,...t}=e;return(0,s.yg)(Elo,(0,p.A)({},Blo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Glo.isMDXComponent=!0;const Olo={toc:[]},Ulo="wrapper";function Flo(e){let{components:n,...t}=e;return(0,s.yg)(Ulo,(0,p.A)({},Olo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}Flo.isMDXComponent=!0;const Vlo={toc:[]},qlo="wrapper";function jlo(e){let{components:n,...t}=e;return(0,s.yg)(qlo,(0,p.A)({},Vlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}jlo.isMDXComponent=!0;const Hlo={toc:[]},Ylo="wrapper";function Qlo(e){let{components:n,...t}=e;return(0,s.yg)(Ylo,(0,p.A)({},Hlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}Qlo.isMDXComponent=!0;const $lo={toc:[]},Klo="wrapper";function Jlo(e){let{components:n,...t}=e;return(0,s.yg)(Klo,(0,p.A)({},$lo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Jlo.isMDXComponent=!0;const Zlo={toc:[]},euo="wrapper";function nuo(e){let{components:n,...t}=e;return(0,s.yg)(euo,(0,p.A)({},Zlo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}nuo.isMDXComponent=!0;const tuo={toc:[]},ouo="wrapper";function puo(e){let{components:n,...t}=e;return(0,s.yg)(ouo,(0,p.A)({},tuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}puo.isMDXComponent=!0;const ruo={toc:[]},suo="wrapper";function cuo(e){let{components:n,...t}=e;return(0,s.yg)(suo,(0,p.A)({},ruo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}cuo.isMDXComponent=!0;const auo={toc:[]},iuo="wrapper";function luo(e){let{components:n,...t}=e;return(0,s.yg)(iuo,(0,p.A)({},auo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}luo.isMDXComponent=!0;const uuo={toc:[]},muo="wrapper";function yuo(e){let{components:n,...t}=e;return(0,s.yg)(muo,(0,p.A)({},uuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}yuo.isMDXComponent=!0;const duo={toc:[]},huo="wrapper";function guo(e){let{components:n,...t}=e;return(0,s.yg)(huo,(0,p.A)({},duo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}guo.isMDXComponent=!0;const fuo={toc:[]},Duo="wrapper";function Muo(e){let{components:n,...t}=e;return(0,s.yg)(Duo,(0,p.A)({},fuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}Muo.isMDXComponent=!0;const Xuo={toc:[]},_uo="wrapper";function wuo(e){let{components:n,...t}=e;return(0,s.yg)(_uo,(0,p.A)({},Xuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}wuo.isMDXComponent=!0;const Tuo={toc:[]},Cuo="wrapper";function xuo(e){let{components:n,...t}=e;return(0,s.yg)(Cuo,(0,p.A)({},Tuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}xuo.isMDXComponent=!0;const Auo={toc:[]},vuo="wrapper";function Luo(e){let{components:n,...t}=e;return(0,s.yg)(vuo,(0,p.A)({},Auo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Luo.isMDXComponent=!0;const buo={toc:[]},Nuo="wrapper";function kuo(e){let{components:n,...t}=e;return(0,s.yg)(Nuo,(0,p.A)({},buo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}kuo.isMDXComponent=!0;const zuo={toc:[]},Puo="wrapper";function Iuo(e){let{components:n,...t}=e;return(0,s.yg)(Puo,(0,p.A)({},zuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}Iuo.isMDXComponent=!0;const Ruo={toc:[]},Wuo="wrapper";function Suo(e){let{components:n,...t}=e;return(0,s.yg)(Wuo,(0,p.A)({},Ruo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}Suo.isMDXComponent=!0;const Buo={toc:[]},Euo="wrapper";function Guo(e){let{components:n,...t}=e;return(0,s.yg)(Euo,(0,p.A)({},Buo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Guo.isMDXComponent=!0;const Ouo={toc:[]},Uuo="wrapper";function Fuo(e){let{components:n,...t}=e;return(0,s.yg)(Uuo,(0,p.A)({},Ouo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}Fuo.isMDXComponent=!0;const Vuo={toc:[]},quo="wrapper";function juo(e){let{components:n,...t}=e;return(0,s.yg)(quo,(0,p.A)({},Vuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}juo.isMDXComponent=!0;const Huo={toc:[]},Yuo="wrapper";function Quo(e){let{components:n,...t}=e;return(0,s.yg)(Yuo,(0,p.A)({},Huo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Quo.isMDXComponent=!0;const $uo={toc:[]},Kuo="wrapper";function Juo(e){let{components:n,...t}=e;return(0,s.yg)(Kuo,(0,p.A)({},$uo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}Juo.isMDXComponent=!0;const Zuo={toc:[]},emo="wrapper";function nmo(e){let{components:n,...t}=e;return(0,s.yg)(emo,(0,p.A)({},Zuo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}nmo.isMDXComponent=!0;const tmo={toc:[]},omo="wrapper";function pmo(e){let{components:n,...t}=e;return(0,s.yg)(omo,(0,p.A)({},tmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}pmo.isMDXComponent=!0;const rmo={toc:[]},smo="wrapper";function cmo(e){let{components:n,...t}=e;return(0,s.yg)(smo,(0,p.A)({},rmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}cmo.isMDXComponent=!0;const amo={toc:[]},imo="wrapper";function lmo(e){let{components:n,...t}=e;return(0,s.yg)(imo,(0,p.A)({},amo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}lmo.isMDXComponent=!0;const umo={toc:[]},mmo="wrapper";function ymo(e){let{components:n,...t}=e;return(0,s.yg)(mmo,(0,p.A)({},umo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}ymo.isMDXComponent=!0;const dmo={toc:[]},hmo="wrapper";function gmo(e){let{components:n,...t}=e;return(0,s.yg)(hmo,(0,p.A)({},dmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}gmo.isMDXComponent=!0;const fmo={toc:[]},Dmo="wrapper";function Mmo(e){let{components:n,...t}=e;return(0,s.yg)(Dmo,(0,p.A)({},fmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Mmo.isMDXComponent=!0;const Xmo={toc:[]},_mo="wrapper";function wmo(e){let{components:n,...t}=e;return(0,s.yg)(_mo,(0,p.A)({},Xmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}wmo.isMDXComponent=!0;const Tmo={toc:[]},Cmo="wrapper";function xmo(e){let{components:n,...t}=e;return(0,s.yg)(Cmo,(0,p.A)({},Tmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}xmo.isMDXComponent=!0;const Amo={toc:[]},vmo="wrapper";function Lmo(e){let{components:n,...t}=e;return(0,s.yg)(vmo,(0,p.A)({},Amo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Lmo.isMDXComponent=!0;const bmo={toc:[]},Nmo="wrapper";function kmo(e){let{components:n,...t}=e;return(0,s.yg)(Nmo,(0,p.A)({},bmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}kmo.isMDXComponent=!0;const zmo={toc:[]},Pmo="wrapper";function Imo(e){let{components:n,...t}=e;return(0,s.yg)(Pmo,(0,p.A)({},zmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}Imo.isMDXComponent=!0;const Rmo={toc:[]},Wmo="wrapper";function Smo(e){let{components:n,...t}=e;return(0,s.yg)(Wmo,(0,p.A)({},Rmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}Smo.isMDXComponent=!0;const Bmo={toc:[]},Emo="wrapper";function Gmo(e){let{components:n,...t}=e;return(0,s.yg)(Emo,(0,p.A)({},Bmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Gmo.isMDXComponent=!0;const Omo={toc:[]},Umo="wrapper";function Fmo(e){let{components:n,...t}=e;return(0,s.yg)(Umo,(0,p.A)({},Omo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}Fmo.isMDXComponent=!0;const Vmo={toc:[]},qmo="wrapper";function jmo(e){let{components:n,...t}=e;return(0,s.yg)(qmo,(0,p.A)({},Vmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}jmo.isMDXComponent=!0;const Hmo={toc:[]},Ymo="wrapper";function Qmo(e){let{components:n,...t}=e;return(0,s.yg)(Ymo,(0,p.A)({},Hmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Qmo.isMDXComponent=!0;const $mo={toc:[]},Kmo="wrapper";function Jmo(e){let{components:n,...t}=e;return(0,s.yg)(Kmo,(0,p.A)({},$mo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Jmo.isMDXComponent=!0;const Zmo={toc:[]},eyo="wrapper";function nyo(e){let{components:n,...t}=e;return(0,s.yg)(eyo,(0,p.A)({},Zmo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}nyo.isMDXComponent=!0;const tyo={toc:[]},oyo="wrapper";function pyo(e){let{components:n,...t}=e;return(0,s.yg)(oyo,(0,p.A)({},tyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}pyo.isMDXComponent=!0;const ryo={toc:[]},syo="wrapper";function cyo(e){let{components:n,...t}=e;return(0,s.yg)(syo,(0,p.A)({},ryo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}cyo.isMDXComponent=!0;const ayo={toc:[]},iyo="wrapper";function lyo(e){let{components:n,...t}=e;return(0,s.yg)(iyo,(0,p.A)({},ayo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}lyo.isMDXComponent=!0;const uyo={toc:[]},myo="wrapper";function yyo(e){let{components:n,...t}=e;return(0,s.yg)(myo,(0,p.A)({},uyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Ray#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}yyo.isMDXComponent=!0;const dyo={toc:[]},hyo="wrapper";function gyo(e){let{components:n,...t}=e;return(0,s.yg)(hyo,(0,p.A)({},dyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}gyo.isMDXComponent=!0;const fyo={toc:[]},Dyo="wrapper";function Myo(e){let{components:n,...t}=e;return(0,s.yg)(Dyo,(0,p.A)({},fyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Myo.isMDXComponent=!0;const Xyo={toc:[]},_yo="wrapper";function wyo(e){let{components:n,...t}=e;return(0,s.yg)(_yo,(0,p.A)({},Xyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}wyo.isMDXComponent=!0;const Tyo={toc:[]},Cyo="wrapper";function xyo(e){let{components:n,...t}=e;return(0,s.yg)(Cyo,(0,p.A)({},Tyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}xyo.isMDXComponent=!0;const Ayo={toc:[]},vyo="wrapper";function Lyo(e){let{components:n,...t}=e;return(0,s.yg)(vyo,(0,p.A)({},Ayo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Lyo.isMDXComponent=!0;const byo={toc:[]},Nyo="wrapper";function kyo(e){let{components:n,...t}=e;return(0,s.yg)(Nyo,(0,p.A)({},byo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}kyo.isMDXComponent=!0;const zyo={toc:[]},Pyo="wrapper";function Iyo(e){let{components:n,...t}=e;return(0,s.yg)(Pyo,(0,p.A)({},zyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Iyo.isMDXComponent=!0;const Ryo={toc:[]},Wyo="wrapper";function Syo(e){let{components:n,...t}=e;return(0,s.yg)(Wyo,(0,p.A)({},Ryo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}Syo.isMDXComponent=!0;const Byo={toc:[]},Eyo="wrapper";function Gyo(e){let{components:n,...t}=e;return(0,s.yg)(Eyo,(0,p.A)({},Byo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Gyo.isMDXComponent=!0;const Oyo={toc:[]},Uyo="wrapper";function Fyo(e){let{components:n,...t}=e;return(0,s.yg)(Uyo,(0,p.A)({},Oyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}Fyo.isMDXComponent=!0;const Vyo={toc:[]},qyo="wrapper";function jyo(e){let{components:n,...t}=e;return(0,s.yg)(qyo,(0,p.A)({},Vyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}jyo.isMDXComponent=!0;const Hyo={toc:[]},Yyo="wrapper";function Qyo(e){let{components:n,...t}=e;return(0,s.yg)(Yyo,(0,p.A)({},Hyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}Qyo.isMDXComponent=!0;const $yo={toc:[]},Kyo="wrapper";function Jyo(e){let{components:n,...t}=e;return(0,s.yg)(Kyo,(0,p.A)({},$yo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Jyo.isMDXComponent=!0;const Zyo={toc:[]},edo="wrapper";function ndo(e){let{components:n,...t}=e;return(0,s.yg)(edo,(0,p.A)({},Zyo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}ndo.isMDXComponent=!0;const tdo={toc:[]},odo="wrapper";function pdo(e){let{components:n,...t}=e;return(0,s.yg)(odo,(0,p.A)({},tdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}pdo.isMDXComponent=!0;const rdo={toc:[]},sdo="wrapper";function cdo(e){let{components:n,...t}=e;return(0,s.yg)(sdo,(0,p.A)({},rdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}cdo.isMDXComponent=!0;const ado={toc:[]},ido="wrapper";function ldo(e){let{components:n,...t}=e;return(0,s.yg)(ido,(0,p.A)({},ado,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}ldo.isMDXComponent=!0;const udo={toc:[]},mdo="wrapper";function ydo(e){let{components:n,...t}=e;return(0,s.yg)(mdo,(0,p.A)({},udo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}ydo.isMDXComponent=!0;const ddo={toc:[]},hdo="wrapper";function gdo(e){let{components:n,...t}=e;return(0,s.yg)(hdo,(0,p.A)({},ddo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}gdo.isMDXComponent=!0;const fdo={toc:[]},Ddo="wrapper";function Mdo(e){let{components:n,...t}=e;return(0,s.yg)(Ddo,(0,p.A)({},fdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Mdo.isMDXComponent=!0;const Xdo={toc:[]},_do="wrapper";function wdo(e){let{components:n,...t}=e;return(0,s.yg)(_do,(0,p.A)({},Xdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}wdo.isMDXComponent=!0;const Tdo={toc:[]},Cdo="wrapper";function xdo(e){let{components:n,...t}=e;return(0,s.yg)(Cdo,(0,p.A)({},Tdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}xdo.isMDXComponent=!0;const Ado={toc:[]},vdo="wrapper";function Ldo(e){let{components:n,...t}=e;return(0,s.yg)(vdo,(0,p.A)({},Ado,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}Ldo.isMDXComponent=!0;const bdo={toc:[]},Ndo="wrapper";function kdo(e){let{components:n,...t}=e;return(0,s.yg)(Ndo,(0,p.A)({},bdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}kdo.isMDXComponent=!0;const zdo={toc:[]},Pdo="wrapper";function Ido(e){let{components:n,...t}=e;return(0,s.yg)(Pdo,(0,p.A)({},zdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Ido.isMDXComponent=!0;const Rdo={toc:[]},Wdo="wrapper";function Sdo(e){let{components:n,...t}=e;return(0,s.yg)(Wdo,(0,p.A)({},Rdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Sdo.isMDXComponent=!0;const Bdo={toc:[]},Edo="wrapper";function Gdo(e){let{components:n,...t}=e;return(0,s.yg)(Edo,(0,p.A)({},Bdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Gdo.isMDXComponent=!0;const Odo={toc:[]},Udo="wrapper";function Fdo(e){let{components:n,...t}=e;return(0,s.yg)(Udo,(0,p.A)({},Odo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Fdo.isMDXComponent=!0;const Vdo={toc:[]},qdo="wrapper";function jdo(e){let{components:n,...t}=e;return(0,s.yg)(qdo,(0,p.A)({},Vdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}jdo.isMDXComponent=!0;const Hdo={toc:[]},Ydo="wrapper";function Qdo(e){let{components:n,...t}=e;return(0,s.yg)(Ydo,(0,p.A)({},Hdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Qdo.isMDXComponent=!0;const $do={toc:[]},Kdo="wrapper";function Jdo(e){let{components:n,...t}=e;return(0,s.yg)(Kdo,(0,p.A)({},$do,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}Jdo.isMDXComponent=!0;const Zdo={toc:[]},eho="wrapper";function nho(e){let{components:n,...t}=e;return(0,s.yg)(eho,(0,p.A)({},Zdo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}nho.isMDXComponent=!0;const tho={toc:[]},oho="wrapper";function pho(e){let{components:n,...t}=e;return(0,s.yg)(oho,(0,p.A)({},tho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}pho.isMDXComponent=!0;const rho={toc:[]},sho="wrapper";function cho(e){let{components:n,...t}=e;return(0,s.yg)(sho,(0,p.A)({},rho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}cho.isMDXComponent=!0;const aho={toc:[]},iho="wrapper";function lho(e){let{components:n,...t}=e;return(0,s.yg)(iho,(0,p.A)({},aho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}lho.isMDXComponent=!0;const uho={toc:[]},mho="wrapper";function yho(e){let{components:n,...t}=e;return(0,s.yg)(mho,(0,p.A)({},uho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}yho.isMDXComponent=!0;const dho={toc:[]},hho="wrapper";function gho(e){let{components:n,...t}=e;return(0,s.yg)(hho,(0,p.A)({},dho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}gho.isMDXComponent=!0;const fho={toc:[]},Dho="wrapper";function Mho(e){let{components:n,...t}=e;return(0,s.yg)(Dho,(0,p.A)({},fho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Mho.isMDXComponent=!0;const Xho={toc:[]},_ho="wrapper";function who(e){let{components:n,...t}=e;return(0,s.yg)(_ho,(0,p.A)({},Xho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}who.isMDXComponent=!0;const Tho={toc:[]},Cho="wrapper";function xho(e){let{components:n,...t}=e;return(0,s.yg)(Cho,(0,p.A)({},Tho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}xho.isMDXComponent=!0;const Aho={toc:[]},vho="wrapper";function Lho(e){let{components:n,...t}=e;return(0,s.yg)(vho,(0,p.A)({},Aho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}Lho.isMDXComponent=!0;const bho={toc:[]},Nho="wrapper";function kho(e){let{components:n,...t}=e;return(0,s.yg)(Nho,(0,p.A)({},bho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}kho.isMDXComponent=!0;const zho={toc:[]},Pho="wrapper";function Iho(e){let{components:n,...t}=e;return(0,s.yg)(Pho,(0,p.A)({},zho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}Iho.isMDXComponent=!0;const Rho={toc:[]},Who="wrapper";function Sho(e){let{components:n,...t}=e;return(0,s.yg)(Who,(0,p.A)({},Rho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Sho.isMDXComponent=!0;const Bho={toc:[]},Eho="wrapper";function Gho(e){let{components:n,...t}=e;return(0,s.yg)(Eho,(0,p.A)({},Bho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"One uniform radius:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}Gho.isMDXComponent=!0;const Oho={toc:[]},Uho="wrapper";function Fho(e){let{components:n,...t}=e;return(0,s.yg)(Uho,(0,p.A)({},Oho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Individual radii for each corner:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}Fho.isMDXComponent=!0;const Vho={toc:[]},qho="wrapper";function jho(e){let{components:n,...t}=e;return(0,s.yg)(qho,(0,p.A)({},Vho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}jho.isMDXComponent=!0;const Hho={toc:[]},Yho="wrapper";function Qho(e){let{components:n,...t}=e;return(0,s.yg)(Yho,(0,p.A)({},Hho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Qho.isMDXComponent=!0;const $ho={toc:[]},Kho="wrapper";function Jho(e){let{components:n,...t}=e;return(0,s.yg)(Kho,(0,p.A)({},$ho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Jho.isMDXComponent=!0;const Zho={toc:[]},ego="wrapper";function ngo(e){let{components:n,...t}=e;return(0,s.yg)(ego,(0,p.A)({},Zho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}ngo.isMDXComponent=!0;const tgo={toc:[]},ogo="wrapper";function pgo(e){let{components:n,...t}=e;return(0,s.yg)(ogo,(0,p.A)({},tgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}pgo.isMDXComponent=!0;const rgo={toc:[]},sgo="wrapper";function cgo(e){let{components:n,...t}=e;return(0,s.yg)(sgo,(0,p.A)({},rgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}cgo.isMDXComponent=!0;const ago={toc:[]},igo="wrapper";function lgo(e){let{components:n,...t}=e;return(0,s.yg)(igo,(0,p.A)({},ago,t,{components:n,mdxType:"MDXLayout"}))}lgo.isMDXComponent=!0;const ugo={toc:[]},mgo="wrapper";function ygo(e){let{components:n,...t}=e;return(0,s.yg)(mgo,(0,p.A)({},ugo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}ygo.isMDXComponent=!0;const dgo={toc:[]},hgo="wrapper";function ggo(e){let{components:n,...t}=e;return(0,s.yg)(hgo,(0,p.A)({},dgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}ggo.isMDXComponent=!0;const fgo={toc:[]},Dgo="wrapper";function Mgo(e){let{components:n,...t}=e;return(0,s.yg)(Dgo,(0,p.A)({},fgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}Mgo.isMDXComponent=!0;const Xgo={toc:[]},_go="wrapper";function wgo(e){let{components:n,...t}=e;return(0,s.yg)(_go,(0,p.A)({},Xgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}wgo.isMDXComponent=!0;const Tgo={toc:[]},Cgo="wrapper";function xgo(e){let{components:n,...t}=e;return(0,s.yg)(Cgo,(0,p.A)({},Tgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}xgo.isMDXComponent=!0;const Ago={toc:[]},vgo="wrapper";function Lgo(e){let{components:n,...t}=e;return(0,s.yg)(vgo,(0,p.A)({},Ago,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Lgo.isMDXComponent=!0;const bgo={toc:[]},Ngo="wrapper";function kgo(e){let{components:n,...t}=e;return(0,s.yg)(Ngo,(0,p.A)({},bgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}kgo.isMDXComponent=!0;const zgo={toc:[]},Pgo="wrapper";function Igo(e){let{components:n,...t}=e;return(0,s.yg)(Pgo,(0,p.A)({},zgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}Igo.isMDXComponent=!0;const Rgo={toc:[]},Wgo="wrapper";function Sgo(e){let{components:n,...t}=e;return(0,s.yg)(Wgo,(0,p.A)({},Rgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Sgo.isMDXComponent=!0;const Bgo={toc:[]},Ego="wrapper";function Ggo(e){let{components:n,...t}=e;return(0,s.yg)(Ego,(0,p.A)({},Bgo,t,{components:n,mdxType:"MDXLayout"}))}Ggo.isMDXComponent=!0;const Ogo={toc:[]},Ugo="wrapper";function Fgo(e){let{components:n,...t}=e;return(0,s.yg)(Ugo,(0,p.A)({},Ogo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Fgo.isMDXComponent=!0;const Vgo={toc:[]},qgo="wrapper";function jgo(e){let{components:n,...t}=e;return(0,s.yg)(qgo,(0,p.A)({},Vgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}jgo.isMDXComponent=!0;const Hgo={toc:[]},Ygo="wrapper";function Qgo(e){let{components:n,...t}=e;return(0,s.yg)(Ygo,(0,p.A)({},Hgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Qgo.isMDXComponent=!0;const $go={toc:[]},Kgo="wrapper";function Jgo(e){let{components:n,...t}=e;return(0,s.yg)(Kgo,(0,p.A)({},$go,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Jgo.isMDXComponent=!0;const Zgo={toc:[]},efo="wrapper";function nfo(e){let{components:n,...t}=e;return(0,s.yg)(efo,(0,p.A)({},Zgo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}nfo.isMDXComponent=!0;const tfo={toc:[]},ofo="wrapper";function pfo(e){let{components:n,...t}=e;return(0,s.yg)(ofo,(0,p.A)({},tfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}pfo.isMDXComponent=!0;const rfo={toc:[]},sfo="wrapper";function cfo(e){let{components:n,...t}=e;return(0,s.yg)(sfo,(0,p.A)({},rfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}cfo.isMDXComponent=!0;const afo={toc:[]},ifo="wrapper";function lfo(e){let{components:n,...t}=e;return(0,s.yg)(ifo,(0,p.A)({},afo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}lfo.isMDXComponent=!0;const ufo={toc:[]},mfo="wrapper";function yfo(e){let{components:n,...t}=e;return(0,s.yg)(mfo,(0,p.A)({},ufo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}yfo.isMDXComponent=!0;const dfo={toc:[]},hfo="wrapper";function gfo(e){let{components:n,...t}=e;return(0,s.yg)(hfo,(0,p.A)({},dfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}gfo.isMDXComponent=!0;const ffo={toc:[]},Dfo="wrapper";function Mfo(e){let{components:n,...t}=e;return(0,s.yg)(Dfo,(0,p.A)({},ffo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Mfo.isMDXComponent=!0;const Xfo={toc:[]},_fo="wrapper";function wfo(e){let{components:n,...t}=e;return(0,s.yg)(_fo,(0,p.A)({},Xfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}wfo.isMDXComponent=!0;const Tfo={toc:[]},Cfo="wrapper";function xfo(e){let{components:n,...t}=e;return(0,s.yg)(Cfo,(0,p.A)({},Tfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}xfo.isMDXComponent=!0;const Afo={toc:[]},vfo="wrapper";function Lfo(e){let{components:n,...t}=e;return(0,s.yg)(vfo,(0,p.A)({},Afo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Lfo.isMDXComponent=!0;const bfo={toc:[]},Nfo="wrapper";function kfo(e){let{components:n,...t}=e;return(0,s.yg)(Nfo,(0,p.A)({},bfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}kfo.isMDXComponent=!0;const zfo={toc:[]},Pfo="wrapper";function Ifo(e){let{components:n,...t}=e;return(0,s.yg)(Pfo,(0,p.A)({},zfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}Ifo.isMDXComponent=!0;const Rfo={toc:[]},Wfo="wrapper";function Sfo(e){let{components:n,...t}=e;return(0,s.yg)(Wfo,(0,p.A)({},Rfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Sfo.isMDXComponent=!0;const Bfo={toc:[]},Efo="wrapper";function Gfo(e){let{components:n,...t}=e;return(0,s.yg)(Efo,(0,p.A)({},Bfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}Gfo.isMDXComponent=!0;const Ofo={toc:[]},Ufo="wrapper";function Ffo(e){let{components:n,...t}=e;return(0,s.yg)(Ufo,(0,p.A)({},Ofo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Ffo.isMDXComponent=!0;const Vfo={toc:[]},qfo="wrapper";function jfo(e){let{components:n,...t}=e;return(0,s.yg)(qfo,(0,p.A)({},Vfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}jfo.isMDXComponent=!0;const Hfo={toc:[]},Yfo="wrapper";function Qfo(e){let{components:n,...t}=e;return(0,s.yg)(Yfo,(0,p.A)({},Hfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Qfo.isMDXComponent=!0;const $fo={toc:[]},Kfo="wrapper";function Jfo(e){let{components:n,...t}=e;return(0,s.yg)(Kfo,(0,p.A)({},$fo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Jfo.isMDXComponent=!0;const Zfo={toc:[]},eDo="wrapper";function nDo(e){let{components:n,...t}=e;return(0,s.yg)(eDo,(0,p.A)({},Zfo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}nDo.isMDXComponent=!0;const tDo={toc:[]},oDo="wrapper";function pDo(e){let{components:n,...t}=e;return(0,s.yg)(oDo,(0,p.A)({},tDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}pDo.isMDXComponent=!0;const rDo={toc:[]},sDo="wrapper";function cDo(e){let{components:n,...t}=e;return(0,s.yg)(sDo,(0,p.A)({},rDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}cDo.isMDXComponent=!0;const aDo={toc:[]},iDo="wrapper";function lDo(e){let{components:n,...t}=e;return(0,s.yg)(iDo,(0,p.A)({},aDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}lDo.isMDXComponent=!0;const uDo={toc:[]},mDo="wrapper";function yDo(e){let{components:n,...t}=e;return(0,s.yg)(mDo,(0,p.A)({},uDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}yDo.isMDXComponent=!0;const dDo={toc:[]},hDo="wrapper";function gDo(e){let{components:n,...t}=e;return(0,s.yg)(hDo,(0,p.A)({},dDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}gDo.isMDXComponent=!0;const fDo={toc:[]},DDo="wrapper";function MDo(e){let{components:n,...t}=e;return(0,s.yg)(DDo,(0,p.A)({},fDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}MDo.isMDXComponent=!0;const XDo={toc:[]},_Do="wrapper";function wDo(e){let{components:n,...t}=e;return(0,s.yg)(_Do,(0,p.A)({},XDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}wDo.isMDXComponent=!0;const TDo={toc:[]},CDo="wrapper";function xDo(e){let{components:n,...t}=e;return(0,s.yg)(CDo,(0,p.A)({},TDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}xDo.isMDXComponent=!0;const ADo={toc:[]},vDo="wrapper";function LDo(e){let{components:n,...t}=e;return(0,s.yg)(vDo,(0,p.A)({},ADo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}LDo.isMDXComponent=!0;const bDo={toc:[]},NDo="wrapper";function kDo(e){let{components:n,...t}=e;return(0,s.yg)(NDo,(0,p.A)({},bDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}kDo.isMDXComponent=!0;const zDo={toc:[]},PDo="wrapper";function IDo(e){let{components:n,...t}=e;return(0,s.yg)(PDo,(0,p.A)({},zDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}IDo.isMDXComponent=!0;const RDo={toc:[]},WDo="wrapper";function SDo(e){let{components:n,...t}=e;return(0,s.yg)(WDo,(0,p.A)({},RDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}SDo.isMDXComponent=!0;const BDo={toc:[]},EDo="wrapper";function GDo(e){let{components:n,...t}=e;return(0,s.yg)(EDo,(0,p.A)({},BDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}GDo.isMDXComponent=!0;const ODo={toc:[]},UDo="wrapper";function FDo(e){let{components:n,...t}=e;return(0,s.yg)(UDo,(0,p.A)({},ODo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}FDo.isMDXComponent=!0;const VDo={toc:[]},qDo="wrapper";function jDo(e){let{components:n,...t}=e;return(0,s.yg)(qDo,(0,p.A)({},VDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}jDo.isMDXComponent=!0;const HDo={toc:[]},YDo="wrapper";function QDo(e){let{components:n,...t}=e;return(0,s.yg)(YDo,(0,p.A)({},HDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}QDo.isMDXComponent=!0;const $Do={toc:[]},KDo="wrapper";function JDo(e){let{components:n,...t}=e;return(0,s.yg)(KDo,(0,p.A)({},$Do,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}JDo.isMDXComponent=!0;const ZDo={toc:[]},eMo="wrapper";function nMo(e){let{components:n,...t}=e;return(0,s.yg)(eMo,(0,p.A)({},ZDo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}nMo.isMDXComponent=!0;const tMo={toc:[]},oMo="wrapper";function pMo(e){let{components:n,...t}=e;return(0,s.yg)(oMo,(0,p.A)({},tMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}pMo.isMDXComponent=!0;const rMo={toc:[]},sMo="wrapper";function cMo(e){let{components:n,...t}=e;return(0,s.yg)(sMo,(0,p.A)({},rMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}cMo.isMDXComponent=!0;const aMo={toc:[]},iMo="wrapper";function lMo(e){let{components:n,...t}=e;return(0,s.yg)(iMo,(0,p.A)({},aMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}lMo.isMDXComponent=!0;const uMo={toc:[]},mMo="wrapper";function yMo(e){let{components:n,...t}=e;return(0,s.yg)(mMo,(0,p.A)({},uMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}yMo.isMDXComponent=!0;const dMo={toc:[]},hMo="wrapper";function gMo(e){let{components:n,...t}=e;return(0,s.yg)(hMo,(0,p.A)({},dMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}gMo.isMDXComponent=!0;const fMo={toc:[]},DMo="wrapper";function MMo(e){let{components:n,...t}=e;return(0,s.yg)(DMo,(0,p.A)({},fMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}MMo.isMDXComponent=!0;const XMo={toc:[]},_Mo="wrapper";function wMo(e){let{components:n,...t}=e;return(0,s.yg)(_Mo,(0,p.A)({},XMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}wMo.isMDXComponent=!0;const TMo={toc:[]},CMo="wrapper";function xMo(e){let{components:n,...t}=e;return(0,s.yg)(CMo,(0,p.A)({},TMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}xMo.isMDXComponent=!0;const AMo={toc:[]},vMo="wrapper";function LMo(e){let{components:n,...t}=e;return(0,s.yg)(vMo,(0,p.A)({},AMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}LMo.isMDXComponent=!0;const bMo={toc:[]},NMo="wrapper";function kMo(e){let{components:n,...t}=e;return(0,s.yg)(NMo,(0,p.A)({},bMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}kMo.isMDXComponent=!0;const zMo={toc:[]},PMo="wrapper";function IMo(e){let{components:n,...t}=e;return(0,s.yg)(PMo,(0,p.A)({},zMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}IMo.isMDXComponent=!0;const RMo={toc:[]},WMo="wrapper";function SMo(e){let{components:n,...t}=e;return(0,s.yg)(WMo,(0,p.A)({},RMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}SMo.isMDXComponent=!0;const BMo={toc:[]},EMo="wrapper";function GMo(e){let{components:n,...t}=e;return(0,s.yg)(EMo,(0,p.A)({},BMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}GMo.isMDXComponent=!0;const OMo={toc:[]},UMo="wrapper";function FMo(e){let{components:n,...t}=e;return(0,s.yg)(UMo,(0,p.A)({},OMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}FMo.isMDXComponent=!0;const VMo={toc:[]},qMo="wrapper";function jMo(e){let{components:n,...t}=e;return(0,s.yg)(qMo,(0,p.A)({},VMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}jMo.isMDXComponent=!0;const HMo={toc:[]},YMo="wrapper";function QMo(e){let{components:n,...t}=e;return(0,s.yg)(YMo,(0,p.A)({},HMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}QMo.isMDXComponent=!0;const $Mo={toc:[]},KMo="wrapper";function JMo(e){let{components:n,...t}=e;return(0,s.yg)(KMo,(0,p.A)({},$Mo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}JMo.isMDXComponent=!0;const ZMo={toc:[]},eXo="wrapper";function nXo(e){let{components:n,...t}=e;return(0,s.yg)(eXo,(0,p.A)({},ZMo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}nXo.isMDXComponent=!0;const tXo={toc:[]},oXo="wrapper";function pXo(e){let{components:n,...t}=e;return(0,s.yg)(oXo,(0,p.A)({},tXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}pXo.isMDXComponent=!0;const rXo={toc:[]},sXo="wrapper";function cXo(e){let{components:n,...t}=e;return(0,s.yg)(sXo,(0,p.A)({},rXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}cXo.isMDXComponent=!0;const aXo={toc:[]},iXo="wrapper";function lXo(e){let{components:n,...t}=e;return(0,s.yg)(iXo,(0,p.A)({},aXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}lXo.isMDXComponent=!0;const uXo={toc:[]},mXo="wrapper";function yXo(e){let{components:n,...t}=e;return(0,s.yg)(mXo,(0,p.A)({},uXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}yXo.isMDXComponent=!0;const dXo={toc:[]},hXo="wrapper";function gXo(e){let{components:n,...t}=e;return(0,s.yg)(hXo,(0,p.A)({},dXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}gXo.isMDXComponent=!0;const fXo={toc:[]},DXo="wrapper";function MXo(e){let{components:n,...t}=e;return(0,s.yg)(DXo,(0,p.A)({},fXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}MXo.isMDXComponent=!0;const XXo={toc:[]},_Xo="wrapper";function wXo(e){let{components:n,...t}=e;return(0,s.yg)(_Xo,(0,p.A)({},XXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}wXo.isMDXComponent=!0;const TXo={toc:[]},CXo="wrapper";function xXo(e){let{components:n,...t}=e;return(0,s.yg)(CXo,(0,p.A)({},TXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}xXo.isMDXComponent=!0;const AXo={toc:[]},vXo="wrapper";function LXo(e){let{components:n,...t}=e;return(0,s.yg)(vXo,(0,p.A)({},AXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}LXo.isMDXComponent=!0;const bXo={toc:[]},NXo="wrapper";function kXo(e){let{components:n,...t}=e;return(0,s.yg)(NXo,(0,p.A)({},bXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}kXo.isMDXComponent=!0;const zXo={toc:[]},PXo="wrapper";function IXo(e){let{components:n,...t}=e;return(0,s.yg)(PXo,(0,p.A)({},zXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}IXo.isMDXComponent=!0;const RXo={toc:[]},WXo="wrapper";function SXo(e){let{components:n,...t}=e;return(0,s.yg)(WXo,(0,p.A)({},RXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}SXo.isMDXComponent=!0;const BXo={toc:[]},EXo="wrapper";function GXo(e){let{components:n,...t}=e;return(0,s.yg)(EXo,(0,p.A)({},BXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}GXo.isMDXComponent=!0;const OXo={toc:[]},UXo="wrapper";function FXo(e){let{components:n,...t}=e;return(0,s.yg)(UXo,(0,p.A)({},OXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}FXo.isMDXComponent=!0;const VXo={toc:[]},qXo="wrapper";function jXo(e){let{components:n,...t}=e;return(0,s.yg)(qXo,(0,p.A)({},VXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}jXo.isMDXComponent=!0;const HXo={toc:[]},YXo="wrapper";function QXo(e){let{components:n,...t}=e;return(0,s.yg)(YXo,(0,p.A)({},HXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}QXo.isMDXComponent=!0;const $Xo={toc:[]},KXo="wrapper";function JXo(e){let{components:n,...t}=e;return(0,s.yg)(KXo,(0,p.A)({},$Xo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}JXo.isMDXComponent=!0;const ZXo={toc:[]},e_o="wrapper";function n_o(e){let{components:n,...t}=e;return(0,s.yg)(e_o,(0,p.A)({},ZXo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}n_o.isMDXComponent=!0;const t_o={toc:[]},o_o="wrapper";function p_o(e){let{components:n,...t}=e;return(0,s.yg)(o_o,(0,p.A)({},t_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}p_o.isMDXComponent=!0;const r_o={toc:[]},s_o="wrapper";function c_o(e){let{components:n,...t}=e;return(0,s.yg)(s_o,(0,p.A)({},r_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}c_o.isMDXComponent=!0;const a_o={toc:[]},i_o="wrapper";function l_o(e){let{components:n,...t}=e;return(0,s.yg)(i_o,(0,p.A)({},a_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}l_o.isMDXComponent=!0;const u_o={toc:[]},m_o="wrapper";function y_o(e){let{components:n,...t}=e;return(0,s.yg)(m_o,(0,p.A)({},u_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}y_o.isMDXComponent=!0;const d_o={toc:[]},h_o="wrapper";function g_o(e){let{components:n,...t}=e;return(0,s.yg)(h_o,(0,p.A)({},d_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}g_o.isMDXComponent=!0;const f_o={toc:[]},D_o="wrapper";function M_o(e){let{components:n,...t}=e;return(0,s.yg)(D_o,(0,p.A)({},f_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}M_o.isMDXComponent=!0;const X_o={toc:[]},__o="wrapper";function w_o(e){let{components:n,...t}=e;return(0,s.yg)(__o,(0,p.A)({},X_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}w_o.isMDXComponent=!0;const T_o={toc:[]},C_o="wrapper";function x_o(e){let{components:n,...t}=e;return(0,s.yg)(C_o,(0,p.A)({},T_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}x_o.isMDXComponent=!0;const A_o={toc:[]},v_o="wrapper";function L_o(e){let{components:n,...t}=e;return(0,s.yg)(v_o,(0,p.A)({},A_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}L_o.isMDXComponent=!0;const b_o={toc:[]},N_o="wrapper";function k_o(e){let{components:n,...t}=e;return(0,s.yg)(N_o,(0,p.A)({},b_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}k_o.isMDXComponent=!0;const z_o={toc:[]},P_o="wrapper";function I_o(e){let{components:n,...t}=e;return(0,s.yg)(P_o,(0,p.A)({},z_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}I_o.isMDXComponent=!0;const R_o={toc:[]},W_o="wrapper";function S_o(e){let{components:n,...t}=e;return(0,s.yg)(W_o,(0,p.A)({},R_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}S_o.isMDXComponent=!0;const B_o={toc:[]},E_o="wrapper";function G_o(e){let{components:n,...t}=e;return(0,s.yg)(E_o,(0,p.A)({},B_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}G_o.isMDXComponent=!0;const O_o={toc:[]},U_o="wrapper";function F_o(e){let{components:n,...t}=e;return(0,s.yg)(U_o,(0,p.A)({},O_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}F_o.isMDXComponent=!0;const V_o={toc:[]},q_o="wrapper";function j_o(e){let{components:n,...t}=e;return(0,s.yg)(q_o,(0,p.A)({},V_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}j_o.isMDXComponent=!0;const H_o={toc:[]},Y_o="wrapper";function Q_o(e){let{components:n,...t}=e;return(0,s.yg)(Y_o,(0,p.A)({},H_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Q_o.isMDXComponent=!0;const $_o={toc:[]},K_o="wrapper";function J_o(e){let{components:n,...t}=e;return(0,s.yg)(K_o,(0,p.A)({},$_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}J_o.isMDXComponent=!0;const Z_o={toc:[]},ewo="wrapper";function nwo(e){let{components:n,...t}=e;return(0,s.yg)(ewo,(0,p.A)({},Z_o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}nwo.isMDXComponent=!0;const two={toc:[]},owo="wrapper";function pwo(e){let{components:n,...t}=e;return(0,s.yg)(owo,(0,p.A)({},two,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}pwo.isMDXComponent=!0;const rwo={toc:[]},swo="wrapper";function cwo(e){let{components:n,...t}=e;return(0,s.yg)(swo,(0,p.A)({},rwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}cwo.isMDXComponent=!0;const awo={toc:[]},iwo="wrapper";function lwo(e){let{components:n,...t}=e;return(0,s.yg)(iwo,(0,p.A)({},awo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}lwo.isMDXComponent=!0;const uwo={toc:[]},mwo="wrapper";function ywo(e){let{components:n,...t}=e;return(0,s.yg)(mwo,(0,p.A)({},uwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}ywo.isMDXComponent=!0;const dwo={toc:[]},hwo="wrapper";function gwo(e){let{components:n,...t}=e;return(0,s.yg)(hwo,(0,p.A)({},dwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}gwo.isMDXComponent=!0;const fwo={toc:[]},Dwo="wrapper";function Mwo(e){let{components:n,...t}=e;return(0,s.yg)(Dwo,(0,p.A)({},fwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Mwo.isMDXComponent=!0;const Xwo={toc:[]},_wo="wrapper";function wwo(e){let{components:n,...t}=e;return(0,s.yg)(_wo,(0,p.A)({},Xwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}wwo.isMDXComponent=!0;const Two={toc:[]},Cwo="wrapper";function xwo(e){let{components:n,...t}=e;return(0,s.yg)(Cwo,(0,p.A)({},Two,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}xwo.isMDXComponent=!0;const Awo={toc:[]},vwo="wrapper";function Lwo(e){let{components:n,...t}=e;return(0,s.yg)(vwo,(0,p.A)({},Awo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}Lwo.isMDXComponent=!0;const bwo={toc:[]},Nwo="wrapper";function kwo(e){let{components:n,...t}=e;return(0,s.yg)(Nwo,(0,p.A)({},bwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}kwo.isMDXComponent=!0;const zwo={toc:[]},Pwo="wrapper";function Iwo(e){let{components:n,...t}=e;return(0,s.yg)(Pwo,(0,p.A)({},zwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}Iwo.isMDXComponent=!0;const Rwo={toc:[]},Wwo="wrapper";function Swo(e){let{components:n,...t}=e;return(0,s.yg)(Wwo,(0,p.A)({},Rwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}Swo.isMDXComponent=!0;const Bwo={toc:[]},Ewo="wrapper";function Gwo(e){let{components:n,...t}=e;return(0,s.yg)(Ewo,(0,p.A)({},Bwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Gwo.isMDXComponent=!0;const Owo={toc:[]},Uwo="wrapper";function Fwo(e){let{components:n,...t}=e;return(0,s.yg)(Uwo,(0,p.A)({},Owo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}Fwo.isMDXComponent=!0;const Vwo={toc:[]},qwo="wrapper";function jwo(e){let{components:n,...t}=e;return(0,s.yg)(qwo,(0,p.A)({},Vwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}jwo.isMDXComponent=!0;const Hwo={toc:[]},Ywo="wrapper";function Qwo(e){let{components:n,...t}=e;return(0,s.yg)(Ywo,(0,p.A)({},Hwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}Qwo.isMDXComponent=!0;const $wo={toc:[]},Kwo="wrapper";function Jwo(e){let{components:n,...t}=e;return(0,s.yg)(Kwo,(0,p.A)({},$wo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Jwo.isMDXComponent=!0;const Zwo={toc:[]},eTo="wrapper";function nTo(e){let{components:n,...t}=e;return(0,s.yg)(eTo,(0,p.A)({},Zwo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}nTo.isMDXComponent=!0;const tTo={toc:[]},oTo="wrapper";function pTo(e){let{components:n,...t}=e;return(0,s.yg)(oTo,(0,p.A)({},tTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}pTo.isMDXComponent=!0;const rTo={toc:[]},sTo="wrapper";function cTo(e){let{components:n,...t}=e;return(0,s.yg)(sTo,(0,p.A)({},rTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}cTo.isMDXComponent=!0;const aTo={toc:[]},iTo="wrapper";function lTo(e){let{components:n,...t}=e;return(0,s.yg)(iTo,(0,p.A)({},aTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}lTo.isMDXComponent=!0;const uTo={toc:[]},mTo="wrapper";function yTo(e){let{components:n,...t}=e;return(0,s.yg)(mTo,(0,p.A)({},uTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}yTo.isMDXComponent=!0;const dTo={toc:[]},hTo="wrapper";function gTo(e){let{components:n,...t}=e;return(0,s.yg)(hTo,(0,p.A)({},dTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}gTo.isMDXComponent=!0;const fTo={toc:[]},DTo="wrapper";function MTo(e){let{components:n,...t}=e;return(0,s.yg)(DTo,(0,p.A)({},fTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}MTo.isMDXComponent=!0;const XTo={toc:[]},_To="wrapper";function wTo(e){let{components:n,...t}=e;return(0,s.yg)(_To,(0,p.A)({},XTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}wTo.isMDXComponent=!0;const TTo={toc:[]},CTo="wrapper";function xTo(e){let{components:n,...t}=e;return(0,s.yg)(CTo,(0,p.A)({},TTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}xTo.isMDXComponent=!0;const ATo={toc:[]},vTo="wrapper";function LTo(e){let{components:n,...t}=e;return(0,s.yg)(vTo,(0,p.A)({},ATo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}LTo.isMDXComponent=!0;const bTo={toc:[]},NTo="wrapper";function kTo(e){let{components:n,...t}=e;return(0,s.yg)(NTo,(0,p.A)({},bTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}kTo.isMDXComponent=!0;const zTo={toc:[]},PTo="wrapper";function ITo(e){let{components:n,...t}=e;return(0,s.yg)(PTo,(0,p.A)({},zTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}ITo.isMDXComponent=!0;const RTo={toc:[]},WTo="wrapper";function STo(e){let{components:n,...t}=e;return(0,s.yg)(WTo,(0,p.A)({},RTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}STo.isMDXComponent=!0;const BTo={toc:[]},ETo="wrapper";function GTo(e){let{components:n,...t}=e;return(0,s.yg)(ETo,(0,p.A)({},BTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}GTo.isMDXComponent=!0;const OTo={toc:[]},UTo="wrapper";function FTo(e){let{components:n,...t}=e;return(0,s.yg)(UTo,(0,p.A)({},OTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}FTo.isMDXComponent=!0;const VTo={toc:[]},qTo="wrapper";function jTo(e){let{components:n,...t}=e;return(0,s.yg)(qTo,(0,p.A)({},VTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}jTo.isMDXComponent=!0;const HTo={toc:[]},YTo="wrapper";function QTo(e){let{components:n,...t}=e;return(0,s.yg)(YTo,(0,p.A)({},HTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}QTo.isMDXComponent=!0;const $To={toc:[]},KTo="wrapper";function JTo(e){let{components:n,...t}=e;return(0,s.yg)(KTo,(0,p.A)({},$To,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}JTo.isMDXComponent=!0;const ZTo={toc:[]},eCo="wrapper";function nCo(e){let{components:n,...t}=e;return(0,s.yg)(eCo,(0,p.A)({},ZTo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}nCo.isMDXComponent=!0;const tCo={toc:[]},oCo="wrapper";function pCo(e){let{components:n,...t}=e;return(0,s.yg)(oCo,(0,p.A)({},tCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}pCo.isMDXComponent=!0;const rCo={toc:[]},sCo="wrapper";function cCo(e){let{components:n,...t}=e;return(0,s.yg)(sCo,(0,p.A)({},rCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}cCo.isMDXComponent=!0;const aCo={toc:[]},iCo="wrapper";function lCo(e){let{components:n,...t}=e;return(0,s.yg)(iCo,(0,p.A)({},aCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}lCo.isMDXComponent=!0;const uCo={toc:[]},mCo="wrapper";function yCo(e){let{components:n,...t}=e;return(0,s.yg)(mCo,(0,p.A)({},uCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}yCo.isMDXComponent=!0;const dCo={toc:[]},hCo="wrapper";function gCo(e){let{components:n,...t}=e;return(0,s.yg)(hCo,(0,p.A)({},dCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}gCo.isMDXComponent=!0;const fCo={toc:[]},DCo="wrapper";function MCo(e){let{components:n,...t}=e;return(0,s.yg)(DCo,(0,p.A)({},fCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}MCo.isMDXComponent=!0;const XCo={toc:[]},_Co="wrapper";function wCo(e){let{components:n,...t}=e;return(0,s.yg)(_Co,(0,p.A)({},XCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}wCo.isMDXComponent=!0;const TCo={toc:[]},CCo="wrapper";function xCo(e){let{components:n,...t}=e;return(0,s.yg)(CCo,(0,p.A)({},TCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}xCo.isMDXComponent=!0;const ACo={toc:[]},vCo="wrapper";function LCo(e){let{components:n,...t}=e;return(0,s.yg)(vCo,(0,p.A)({},ACo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}LCo.isMDXComponent=!0;const bCo={toc:[]},NCo="wrapper";function kCo(e){let{components:n,...t}=e;return(0,s.yg)(NCo,(0,p.A)({},bCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}kCo.isMDXComponent=!0;const zCo={toc:[]},PCo="wrapper";function ICo(e){let{components:n,...t}=e;return(0,s.yg)(PCo,(0,p.A)({},zCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}ICo.isMDXComponent=!0;const RCo={toc:[]},WCo="wrapper";function SCo(e){let{components:n,...t}=e;return(0,s.yg)(WCo,(0,p.A)({},RCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}SCo.isMDXComponent=!0;const BCo={toc:[]},ECo="wrapper";function GCo(e){let{components:n,...t}=e;return(0,s.yg)(ECo,(0,p.A)({},BCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}GCo.isMDXComponent=!0;const OCo={toc:[]},UCo="wrapper";function FCo(e){let{components:n,...t}=e;return(0,s.yg)(UCo,(0,p.A)({},OCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}FCo.isMDXComponent=!0;const VCo={toc:[]},qCo="wrapper";function jCo(e){let{components:n,...t}=e;return(0,s.yg)(qCo,(0,p.A)({},VCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}jCo.isMDXComponent=!0;const HCo={toc:[]},YCo="wrapper";function QCo(e){let{components:n,...t}=e;return(0,s.yg)(YCo,(0,p.A)({},HCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}QCo.isMDXComponent=!0;const $Co={toc:[]},KCo="wrapper";function JCo(e){let{components:n,...t}=e;return(0,s.yg)(KCo,(0,p.A)({},$Co,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}JCo.isMDXComponent=!0;const ZCo={toc:[]},exo="wrapper";function nxo(e){let{components:n,...t}=e;return(0,s.yg)(exo,(0,p.A)({},ZCo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}nxo.isMDXComponent=!0;const txo={toc:[]},oxo="wrapper";function pxo(e){let{components:n,...t}=e;return(0,s.yg)(oxo,(0,p.A)({},txo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}pxo.isMDXComponent=!0;const rxo={toc:[]},sxo="wrapper";function cxo(e){let{components:n,...t}=e;return(0,s.yg)(sxo,(0,p.A)({},rxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}cxo.isMDXComponent=!0;const axo={toc:[]},ixo="wrapper";function lxo(e){let{components:n,...t}=e;return(0,s.yg)(ixo,(0,p.A)({},axo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}lxo.isMDXComponent=!0;const uxo={toc:[]},mxo="wrapper";function yxo(e){let{components:n,...t}=e;return(0,s.yg)(mxo,(0,p.A)({},uxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}yxo.isMDXComponent=!0;const dxo={toc:[]},hxo="wrapper";function gxo(e){let{components:n,...t}=e;return(0,s.yg)(hxo,(0,p.A)({},dxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}gxo.isMDXComponent=!0;const fxo={toc:[]},Dxo="wrapper";function Mxo(e){let{components:n,...t}=e;return(0,s.yg)(Dxo,(0,p.A)({},fxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Mxo.isMDXComponent=!0;const Xxo={toc:[]},_xo="wrapper";function wxo(e){let{components:n,...t}=e;return(0,s.yg)(_xo,(0,p.A)({},Xxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}wxo.isMDXComponent=!0;const Txo={toc:[]},Cxo="wrapper";function xxo(e){let{components:n,...t}=e;return(0,s.yg)(Cxo,(0,p.A)({},Txo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}xxo.isMDXComponent=!0;const Axo={toc:[]},vxo="wrapper";function Lxo(e){let{components:n,...t}=e;return(0,s.yg)(vxo,(0,p.A)({},Axo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Lxo.isMDXComponent=!0;const bxo={toc:[]},Nxo="wrapper";function kxo(e){let{components:n,...t}=e;return(0,s.yg)(Nxo,(0,p.A)({},bxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}kxo.isMDXComponent=!0;const zxo={toc:[]},Pxo="wrapper";function Ixo(e){let{components:n,...t}=e;return(0,s.yg)(Pxo,(0,p.A)({},zxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Ixo.isMDXComponent=!0;const Rxo={toc:[]},Wxo="wrapper";function Sxo(e){let{components:n,...t}=e;return(0,s.yg)(Wxo,(0,p.A)({},Rxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}Sxo.isMDXComponent=!0;const Bxo={toc:[]},Exo="wrapper";function Gxo(e){let{components:n,...t}=e;return(0,s.yg)(Exo,(0,p.A)({},Bxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Rect#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Gxo.isMDXComponent=!0;const Oxo={toc:[]},Uxo="wrapper";function Fxo(e){let{components:n,...t}=e;return(0,s.yg)(Uxo,(0,p.A)({},Oxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Fxo.isMDXComponent=!0;const Vxo={toc:[]},qxo="wrapper";function jxo(e){let{components:n,...t}=e;return(0,s.yg)(qxo,(0,p.A)({},Vxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}jxo.isMDXComponent=!0;const Hxo={toc:[]},Yxo="wrapper";function Qxo(e){let{components:n,...t}=e;return(0,s.yg)(Yxo,(0,p.A)({},Hxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Qxo.isMDXComponent=!0;const $xo={toc:[]},Kxo="wrapper";function Jxo(e){let{components:n,...t}=e;return(0,s.yg)(Kxo,(0,p.A)({},$xo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}Jxo.isMDXComponent=!0;const Zxo={toc:[]},eAo="wrapper";function nAo(e){let{components:n,...t}=e;return(0,s.yg)(eAo,(0,p.A)({},Zxo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}nAo.isMDXComponent=!0;const tAo={toc:[]},oAo="wrapper";function pAo(e){let{components:n,...t}=e;return(0,s.yg)(oAo,(0,p.A)({},tAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}pAo.isMDXComponent=!0;const rAo={toc:[]},sAo="wrapper";function cAo(e){let{components:n,...t}=e;return(0,s.yg)(sAo,(0,p.A)({},rAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If you're not interested in animating SVG, you can use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Img"},(0,s.yg)("inlineCode",{parentName:"a"},"Img"))," instead."))}cAo.isMDXComponent=!0;const aAo={toc:[]},iAo="wrapper";function lAo(e){let{components:n,...t}=e;return(0,s.yg)(iAo,(0,p.A)({},aAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A Node for drawing and animating SVG images."))}lAo.isMDXComponent=!0;const uAo={toc:[]},mAo="wrapper";function yAo(e){let{components:n,...t}=e;return(0,s.yg)(mAo,(0,p.A)({},uAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}yAo.isMDXComponent=!0;const dAo={toc:[]},hAo="wrapper";function gAo(e){let{components:n,...t}=e;return(0,s.yg)(hAo,(0,p.A)({},dAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}gAo.isMDXComponent=!0;const fAo={toc:[]},DAo="wrapper";function MAo(e){let{components:n,...t}=e;return(0,s.yg)(DAo,(0,p.A)({},fAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}MAo.isMDXComponent=!0;const XAo={toc:[]},_Ao="wrapper";function wAo(e){let{components:n,...t}=e;return(0,s.yg)(_Ao,(0,p.A)({},XAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}wAo.isMDXComponent=!0;const TAo={toc:[]},CAo="wrapper";function xAo(e){let{components:n,...t}=e;return(0,s.yg)(CAo,(0,p.A)({},TAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}xAo.isMDXComponent=!0;const AAo={toc:[]},vAo="wrapper";function LAo(e){let{components:n,...t}=e;return(0,s.yg)(vAo,(0,p.A)({},AAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}LAo.isMDXComponent=!0;const bAo={toc:[]},NAo="wrapper";function kAo(e){let{components:n,...t}=e;return(0,s.yg)(NAo,(0,p.A)({},bAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}kAo.isMDXComponent=!0;const zAo={toc:[]},PAo="wrapper";function IAo(e){let{components:n,...t}=e;return(0,s.yg)(PAo,(0,p.A)({},zAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}IAo.isMDXComponent=!0;const RAo={toc:[]},WAo="wrapper";function SAo(e){let{components:n,...t}=e;return(0,s.yg)(WAo,(0,p.A)({},RAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}SAo.isMDXComponent=!0;const BAo={toc:[]},EAo="wrapper";function GAo(e){let{components:n,...t}=e;return(0,s.yg)(EAo,(0,p.A)({},BAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}GAo.isMDXComponent=!0;const OAo={toc:[]},UAo="wrapper";function FAo(e){let{components:n,...t}=e;return(0,s.yg)(UAo,(0,p.A)({},OAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}FAo.isMDXComponent=!0;const VAo={toc:[]},qAo="wrapper";function jAo(e){let{components:n,...t}=e;return(0,s.yg)(qAo,(0,p.A)({},VAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}jAo.isMDXComponent=!0;const HAo={toc:[]},YAo="wrapper";function QAo(e){let{components:n,...t}=e;return(0,s.yg)(YAo,(0,p.A)({},HAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}QAo.isMDXComponent=!0;const $Ao={toc:[]},KAo="wrapper";function JAo(e){let{components:n,...t}=e;return(0,s.yg)(KAo,(0,p.A)({},$Ao,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}JAo.isMDXComponent=!0;const ZAo={toc:[]},evo="wrapper";function nvo(e){let{components:n,...t}=e;return(0,s.yg)(evo,(0,p.A)({},ZAo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}nvo.isMDXComponent=!0;const tvo={toc:[]},ovo="wrapper";function pvo(e){let{components:n,...t}=e;return(0,s.yg)(ovo,(0,p.A)({},tvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}pvo.isMDXComponent=!0;const rvo={toc:[]},svo="wrapper";function cvo(e){let{components:n,...t}=e;return(0,s.yg)(svo,(0,p.A)({},rvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}cvo.isMDXComponent=!0;const avo={toc:[]},ivo="wrapper";function lvo(e){let{components:n,...t}=e;return(0,s.yg)(ivo,(0,p.A)({},avo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}lvo.isMDXComponent=!0;const uvo={toc:[]},mvo="wrapper";function yvo(e){let{components:n,...t}=e;return(0,s.yg)(mvo,(0,p.A)({},uvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}yvo.isMDXComponent=!0;const dvo={toc:[]},hvo="wrapper";function gvo(e){let{components:n,...t}=e;return(0,s.yg)(hvo,(0,p.A)({},dvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}gvo.isMDXComponent=!0;const fvo={toc:[]},Dvo="wrapper";function Mvo(e){let{components:n,...t}=e;return(0,s.yg)(Dvo,(0,p.A)({},fvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}Mvo.isMDXComponent=!0;const Xvo={toc:[]},_vo="wrapper";function wvo(e){let{components:n,...t}=e;return(0,s.yg)(_vo,(0,p.A)({},Xvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}wvo.isMDXComponent=!0;const Tvo={toc:[]},Cvo="wrapper";function xvo(e){let{components:n,...t}=e;return(0,s.yg)(Cvo,(0,p.A)({},Tvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}xvo.isMDXComponent=!0;const Avo={toc:[]},vvo="wrapper";function Lvo(e){let{components:n,...t}=e;return(0,s.yg)(vvo,(0,p.A)({},Avo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}Lvo.isMDXComponent=!0;const bvo={toc:[]},Nvo="wrapper";function kvo(e){let{components:n,...t}=e;return(0,s.yg)(Nvo,(0,p.A)({},bvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}kvo.isMDXComponent=!0;const zvo={toc:[]},Pvo="wrapper";function Ivo(e){let{components:n,...t}=e;return(0,s.yg)(Pvo,(0,p.A)({},zvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Ivo.isMDXComponent=!0;const Rvo={toc:[]},Wvo="wrapper";function Svo(e){let{components:n,...t}=e;return(0,s.yg)(Wvo,(0,p.A)({},Rvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Svo.isMDXComponent=!0;const Bvo={toc:[]},Evo="wrapper";function Gvo(e){let{components:n,...t}=e;return(0,s.yg)(Evo,(0,p.A)({},Bvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Gvo.isMDXComponent=!0;const Ovo={toc:[]},Uvo="wrapper";function Fvo(e){let{components:n,...t}=e;return(0,s.yg)(Uvo,(0,p.A)({},Ovo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}Fvo.isMDXComponent=!0;const Vvo={toc:[]},qvo="wrapper";function jvo(e){let{components:n,...t}=e;return(0,s.yg)(qvo,(0,p.A)({},Vvo,t,{components:n,mdxType:"MDXLayout"}))}jvo.isMDXComponent=!0;const Hvo={toc:[]},Yvo="wrapper";function Qvo(e){let{components:n,...t}=e;return(0,s.yg)(Yvo,(0,p.A)({},Hvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Qvo.isMDXComponent=!0;const $vo={toc:[]},Kvo="wrapper";function Jvo(e){let{components:n,...t}=e;return(0,s.yg)(Kvo,(0,p.A)({},$vo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Jvo.isMDXComponent=!0;const Zvo={toc:[]},eLo="wrapper";function nLo(e){let{components:n,...t}=e;return(0,s.yg)(eLo,(0,p.A)({},Zvo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}nLo.isMDXComponent=!0;const tLo={toc:[]},oLo="wrapper";function pLo(e){let{components:n,...t}=e;return(0,s.yg)(oLo,(0,p.A)({},tLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}pLo.isMDXComponent=!0;const rLo={toc:[]},sLo="wrapper";function cLo(e){let{components:n,...t}=e;return(0,s.yg)(sLo,(0,p.A)({},rLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}cLo.isMDXComponent=!0;const aLo={toc:[]},iLo="wrapper";function lLo(e){let{components:n,...t}=e;return(0,s.yg)(iLo,(0,p.A)({},aLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}lLo.isMDXComponent=!0;const uLo={toc:[]},mLo="wrapper";function yLo(e){let{components:n,...t}=e;return(0,s.yg)(mLo,(0,p.A)({},uLo,t,{components:n,mdxType:"MDXLayout"}))}yLo.isMDXComponent=!0;const dLo={toc:[]},hLo="wrapper";function gLo(e){let{components:n,...t}=e;return(0,s.yg)(hLo,(0,p.A)({},dLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"SVG string to be rendered"))}gLo.isMDXComponent=!0;const fLo={toc:[]},DLo="wrapper";function MLo(e){let{components:n,...t}=e;return(0,s.yg)(DLo,(0,p.A)({},fLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}MLo.isMDXComponent=!0;const XLo={toc:[]},_Lo="wrapper";function wLo(e){let{components:n,...t}=e;return(0,s.yg)(_Lo,(0,p.A)({},XLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}wLo.isMDXComponent=!0;const TLo={toc:[]},CLo="wrapper";function xLo(e){let{components:n,...t}=e;return(0,s.yg)(CLo,(0,p.A)({},TLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}xLo.isMDXComponent=!0;const ALo={toc:[]},vLo="wrapper";function LLo(e){let{components:n,...t}=e;return(0,s.yg)(vLo,(0,p.A)({},ALo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}LLo.isMDXComponent=!0;const bLo={toc:[]},NLo="wrapper";function kLo(e){let{components:n,...t}=e;return(0,s.yg)(NLo,(0,p.A)({},bLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}kLo.isMDXComponent=!0;const zLo={toc:[]},PLo="wrapper";function ILo(e){let{components:n,...t}=e;return(0,s.yg)(PLo,(0,p.A)({},zLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}ILo.isMDXComponent=!0;const RLo={toc:[]},WLo="wrapper";function SLo(e){let{components:n,...t}=e;return(0,s.yg)(WLo,(0,p.A)({},RLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Child to wrap all SVG node"))}SLo.isMDXComponent=!0;const BLo={toc:[]},ELo="wrapper";function GLo(e){let{components:n,...t}=e;return(0,s.yg)(ELo,(0,p.A)({},BLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}GLo.isMDXComponent=!0;const OLo={toc:[]},ULo="wrapper";function FLo(e){let{components:n,...t}=e;return(0,s.yg)(ULo,(0,p.A)({},OLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}FLo.isMDXComponent=!0;const VLo={toc:[]},qLo="wrapper";function jLo(e){let{components:n,...t}=e;return(0,s.yg)(qLo,(0,p.A)({},VLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}jLo.isMDXComponent=!0;const HLo={toc:[]},YLo="wrapper";function QLo(e){let{components:n,...t}=e;return(0,s.yg)(YLo,(0,p.A)({},HLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}QLo.isMDXComponent=!0;const $Lo={toc:[]},KLo="wrapper";function JLo(e){let{components:n,...t}=e;return(0,s.yg)(KLo,(0,p.A)({},$Lo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}JLo.isMDXComponent=!0;const ZLo={toc:[]},ebo="wrapper";function nbo(e){let{components:n,...t}=e;return(0,s.yg)(ebo,(0,p.A)({},ZLo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}nbo.isMDXComponent=!0;const tbo={toc:[]},obo="wrapper";function pbo(e){let{components:n,...t}=e;return(0,s.yg)(obo,(0,p.A)({},tbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}pbo.isMDXComponent=!0;const rbo={toc:[]},sbo="wrapper";function cbo(e){let{components:n,...t}=e;return(0,s.yg)(sbo,(0,p.A)({},rbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}cbo.isMDXComponent=!0;const abo={toc:[]},ibo="wrapper";function lbo(e){let{components:n,...t}=e;return(0,s.yg)(ibo,(0,p.A)({},abo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}lbo.isMDXComponent=!0;const ubo={toc:[]},mbo="wrapper";function ybo(e){let{components:n,...t}=e;return(0,s.yg)(mbo,(0,p.A)({},ubo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}ybo.isMDXComponent=!0;const dbo={toc:[]},hbo="wrapper";function gbo(e){let{components:n,...t}=e;return(0,s.yg)(hbo,(0,p.A)({},dbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert ",(0,s.yg)("inlineCode",{parentName:"p"},"SVGDocumentData")," to ",(0,s.yg)("inlineCode",{parentName:"p"},"SVGDocument"),"."))}gbo.isMDXComponent=!0;const fbo={toc:[]},Dbo="wrapper";function Mbo(e){let{components:n,...t}=e;return(0,s.yg)(Dbo,(0,p.A)({},fbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"SVGDocumentData")," to convert."))}Mbo.isMDXComponent=!0;const Xbo={toc:[]},_bo="wrapper";function wbo(e){let{components:n,...t}=e;return(0,s.yg)(_bo,(0,p.A)({},Xbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert ",(0,s.yg)("inlineCode",{parentName:"p"},"SVGShapeData")," to ",(0,s.yg)("inlineCode",{parentName:"p"},"SVGShape"),"."))}wbo.isMDXComponent=!0;const Tbo={toc:[]},Cbo="wrapper";function xbo(e){let{components:n,...t}=e;return(0,s.yg)(Cbo,(0,p.A)({},Tbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"SVGShapeData")," to convert."))}xbo.isMDXComponent=!0;const Abo={toc:[]},vbo="wrapper";function Lbo(e){let{components:n,...t}=e;return(0,s.yg)(vbo,(0,p.A)({},Abo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Lbo.isMDXComponent=!0;const bbo={toc:[]},Nbo="wrapper";function kbo(e){let{components:n,...t}=e;return(0,s.yg)(Nbo,(0,p.A)({},bbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}kbo.isMDXComponent=!0;const zbo={toc:[]},Pbo="wrapper";function Ibo(e){let{components:n,...t}=e;return(0,s.yg)(Pbo,(0,p.A)({},zbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}Ibo.isMDXComponent=!0;const Rbo={toc:[]},Wbo="wrapper";function Sbo(e){let{components:n,...t}=e;return(0,s.yg)(Wbo,(0,p.A)({},Rbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}Sbo.isMDXComponent=!0;const Bbo={toc:[]},Ebo="wrapper";function Gbo(e){let{components:n,...t}=e;return(0,s.yg)(Ebo,(0,p.A)({},Bbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}Gbo.isMDXComponent=!0;const Obo={toc:[]},Ubo="wrapper";function Fbo(e){let{components:n,...t}=e;return(0,s.yg)(Ubo,(0,p.A)({},Obo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Fbo.isMDXComponent=!0;const Vbo={toc:[]},qbo="wrapper";function jbo(e){let{components:n,...t}=e;return(0,s.yg)(qbo,(0,p.A)({},Vbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}jbo.isMDXComponent=!0;const Hbo={toc:[]},Ybo="wrapper";function Qbo(e){let{components:n,...t}=e;return(0,s.yg)(Ybo,(0,p.A)({},Hbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}Qbo.isMDXComponent=!0;const $bo={toc:[]},Kbo="wrapper";function Jbo(e){let{components:n,...t}=e;return(0,s.yg)(Kbo,(0,p.A)({},$bo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Jbo.isMDXComponent=!0;const Zbo={toc:[]},eNo="wrapper";function nNo(e){let{components:n,...t}=e;return(0,s.yg)(eNo,(0,p.A)({},Zbo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}nNo.isMDXComponent=!0;const tNo={toc:[]},oNo="wrapper";function pNo(e){let{components:n,...t}=e;return(0,s.yg)(oNo,(0,p.A)({},tNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}pNo.isMDXComponent=!0;const rNo={toc:[]},sNo="wrapper";function cNo(e){let{components:n,...t}=e;return(0,s.yg)(sNo,(0,p.A)({},rNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}cNo.isMDXComponent=!0;const aNo={toc:[]},iNo="wrapper";function lNo(e){let{components:n,...t}=e;return(0,s.yg)(iNo,(0,p.A)({},aNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}lNo.isMDXComponent=!0;const uNo={toc:[]},mNo="wrapper";function yNo(e){let{components:n,...t}=e;return(0,s.yg)(mNo,(0,p.A)({},uNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}yNo.isMDXComponent=!0;const dNo={toc:[]},hNo="wrapper";function gNo(e){let{components:n,...t}=e;return(0,s.yg)(hNo,(0,p.A)({},dNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}gNo.isMDXComponent=!0;const fNo={toc:[]},DNo="wrapper";function MNo(e){let{components:n,...t}=e;return(0,s.yg)(DNo,(0,p.A)({},fNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}MNo.isMDXComponent=!0;const XNo={toc:[]},_No="wrapper";function wNo(e){let{components:n,...t}=e;return(0,s.yg)(_No,(0,p.A)({},XNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}wNo.isMDXComponent=!0;const TNo={toc:[]},CNo="wrapper";function xNo(e){let{components:n,...t}=e;return(0,s.yg)(CNo,(0,p.A)({},TNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}xNo.isMDXComponent=!0;const ANo={toc:[]},vNo="wrapper";function LNo(e){let{components:n,...t}=e;return(0,s.yg)(vNo,(0,p.A)({},ANo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}LNo.isMDXComponent=!0;const bNo={toc:[]},NNo="wrapper";function kNo(e){let{components:n,...t}=e;return(0,s.yg)(NNo,(0,p.A)({},bNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}kNo.isMDXComponent=!0;const zNo={toc:[]},PNo="wrapper";function INo(e){let{components:n,...t}=e;return(0,s.yg)(PNo,(0,p.A)({},zNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}INo.isMDXComponent=!0;const RNo={toc:[]},WNo="wrapper";function SNo(e){let{components:n,...t}=e;return(0,s.yg)(WNo,(0,p.A)({},RNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}SNo.isMDXComponent=!0;const BNo={toc:[]},ENo="wrapper";function GNo(e){let{components:n,...t}=e;return(0,s.yg)(ENo,(0,p.A)({},BNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}GNo.isMDXComponent=!0;const ONo={toc:[]},UNo="wrapper";function FNo(e){let{components:n,...t}=e;return(0,s.yg)(UNo,(0,p.A)({},ONo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}FNo.isMDXComponent=!0;const VNo={toc:[]},qNo="wrapper";function jNo(e){let{components:n,...t}=e;return(0,s.yg)(qNo,(0,p.A)({},VNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}jNo.isMDXComponent=!0;const HNo={toc:[]},YNo="wrapper";function QNo(e){let{components:n,...t}=e;return(0,s.yg)(YNo,(0,p.A)({},HNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}QNo.isMDXComponent=!0;const $No={toc:[]},KNo="wrapper";function JNo(e){let{components:n,...t}=e;return(0,s.yg)(KNo,(0,p.A)({},$No,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}JNo.isMDXComponent=!0;const ZNo={toc:[]},eko="wrapper";function nko(e){let{components:n,...t}=e;return(0,s.yg)(eko,(0,p.A)({},ZNo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}nko.isMDXComponent=!0;const tko={toc:[]},oko="wrapper";function pko(e){let{components:n,...t}=e;return(0,s.yg)(oko,(0,p.A)({},tko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}pko.isMDXComponent=!0;const rko={toc:[]},sko="wrapper";function cko(e){let{components:n,...t}=e;return(0,s.yg)(sko,(0,p.A)({},rko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}cko.isMDXComponent=!0;const ako={toc:[]},iko="wrapper";function lko(e){let{components:n,...t}=e;return(0,s.yg)(iko,(0,p.A)({},ako,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}lko.isMDXComponent=!0;const uko={toc:[]},mko="wrapper";function yko(e){let{components:n,...t}=e;return(0,s.yg)(mko,(0,p.A)({},uko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}yko.isMDXComponent=!0;const dko={toc:[]},hko="wrapper";function gko(e){let{components:n,...t}=e;return(0,s.yg)(hko,(0,p.A)({},dko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}gko.isMDXComponent=!0;const fko={toc:[]},Dko="wrapper";function Mko(e){let{components:n,...t}=e;return(0,s.yg)(Dko,(0,p.A)({},fko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Mko.isMDXComponent=!0;const Xko={toc:[]},_ko="wrapper";function wko(e){let{components:n,...t}=e;return(0,s.yg)(_ko,(0,p.A)({},Xko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}wko.isMDXComponent=!0;const Tko={toc:[]},Cko="wrapper";function xko(e){let{components:n,...t}=e;return(0,s.yg)(Cko,(0,p.A)({},Tko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}xko.isMDXComponent=!0;const Ako={toc:[]},vko="wrapper";function Lko(e){let{components:n,...t}=e;return(0,s.yg)(vko,(0,p.A)({},Ako,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Lko.isMDXComponent=!0;const bko={toc:[]},Nko="wrapper";function kko(e){let{components:n,...t}=e;return(0,s.yg)(Nko,(0,p.A)({},bko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}kko.isMDXComponent=!0;const zko={toc:[]},Pko="wrapper";function Iko(e){let{components:n,...t}=e;return(0,s.yg)(Pko,(0,p.A)({},zko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Iko.isMDXComponent=!0;const Rko={toc:[]},Wko="wrapper";function Sko(e){let{components:n,...t}=e;return(0,s.yg)(Wko,(0,p.A)({},Rko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a tweening list to tween between two SVG nodes."))}Sko.isMDXComponent=!0;const Bko={toc:[]},Eko="wrapper";function Gko(e){let{components:n,...t}=e;return(0,s.yg)(Eko,(0,p.A)({},Bko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial node,"))}Gko.isMDXComponent=!0;const Oko={toc:[]},Uko="wrapper";function Fko(e){let{components:n,...t}=e;return(0,s.yg)(Uko,(0,p.A)({},Oko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The final node."))}Fko.isMDXComponent=!0;const Vko={toc:[]},qko="wrapper";function jko(e){let{components:n,...t}=e;return(0,s.yg)(qko,(0,p.A)({},Vko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the tween."))}jko.isMDXComponent=!0;const Hko={toc:[]},Yko="wrapper";function Qko(e){let{components:n,...t}=e;return(0,s.yg)(Yko,(0,p.A)({},Hko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function."))}Qko.isMDXComponent=!0;const $ko={toc:[]},Kko="wrapper";function Jko(e){let{components:n,...t}=e;return(0,s.yg)(Kko,(0,p.A)({},$ko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}Jko.isMDXComponent=!0;const Zko={toc:[]},ezo="wrapper";function nzo(e){let{components:n,...t}=e;return(0,s.yg)(ezo,(0,p.A)({},Zko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}nzo.isMDXComponent=!0;const tzo={toc:[]},ozo="wrapper";function pzo(e){let{components:n,...t}=e;return(0,s.yg)(ozo,(0,p.A)({},tzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get all SVG nodes with the given id."))}pzo.isMDXComponent=!0;const rzo={toc:[]},szo="wrapper";function czo(e){let{components:n,...t}=e;return(0,s.yg)(szo,(0,p.A)({},rzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An id to query."))}czo.isMDXComponent=!0;const azo={toc:[]},izo="wrapper";function lzo(e){let{components:n,...t}=e;return(0,s.yg)(izo,(0,p.A)({},azo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}lzo.isMDXComponent=!0;const uzo={toc:[]},mzo="wrapper";function yzo(e){let{components:n,...t}=e;return(0,s.yg)(mzo,(0,p.A)({},uzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}yzo.isMDXComponent=!0;const dzo={toc:[]},hzo="wrapper";function gzo(e){let{components:n,...t}=e;return(0,s.yg)(hzo,(0,p.A)({},dzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}gzo.isMDXComponent=!0;const fzo={toc:[]},Dzo="wrapper";function Mzo(e){let{components:n,...t}=e;return(0,s.yg)(Dzo,(0,p.A)({},fzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}Mzo.isMDXComponent=!0;const Xzo={toc:[]},_zo="wrapper";function wzo(e){let{components:n,...t}=e;return(0,s.yg)(_zo,(0,p.A)({},Xzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}wzo.isMDXComponent=!0;const Tzo={toc:[]},Czo="wrapper";function xzo(e){let{components:n,...t}=e;return(0,s.yg)(Czo,(0,p.A)({},Tzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}xzo.isMDXComponent=!0;const Azo={toc:[]},vzo="wrapper";function Lzo(e){let{components:n,...t}=e;return(0,s.yg)(vzo,(0,p.A)({},Azo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}Lzo.isMDXComponent=!0;const bzo={toc:[]},Nzo="wrapper";function kzo(e){let{components:n,...t}=e;return(0,s.yg)(Nzo,(0,p.A)({},bzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}kzo.isMDXComponent=!0;const zzo={toc:[]},Pzo="wrapper";function Izo(e){let{components:n,...t}=e;return(0,s.yg)(Pzo,(0,p.A)({},zzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}Izo.isMDXComponent=!0;const Rzo={toc:[]},Wzo="wrapper";function Szo(e){let{components:n,...t}=e;return(0,s.yg)(Wzo,(0,p.A)({},Rzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}Szo.isMDXComponent=!0;const Bzo={toc:[]},Ezo="wrapper";function Gzo(e){let{components:n,...t}=e;return(0,s.yg)(Ezo,(0,p.A)({},Bzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Gzo.isMDXComponent=!0;const Ozo={toc:[]},Uzo="wrapper";function Fzo(e){let{components:n,...t}=e;return(0,s.yg)(Uzo,(0,p.A)({},Ozo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}Fzo.isMDXComponent=!0;const Vzo={toc:[]},qzo="wrapper";function jzo(e){let{components:n,...t}=e;return(0,s.yg)(qzo,(0,p.A)({},Vzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}jzo.isMDXComponent=!0;const Hzo={toc:[]},Yzo="wrapper";function Qzo(e){let{components:n,...t}=e;return(0,s.yg)(Yzo,(0,p.A)({},Hzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}Qzo.isMDXComponent=!0;const $zo={toc:[]},Kzo="wrapper";function Jzo(e){let{components:n,...t}=e;return(0,s.yg)(Kzo,(0,p.A)({},$zo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Jzo.isMDXComponent=!0;const Zzo={toc:[]},ePo="wrapper";function nPo(e){let{components:n,...t}=e;return(0,s.yg)(ePo,(0,p.A)({},Zzo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}nPo.isMDXComponent=!0;const tPo={toc:[]},oPo="wrapper";function pPo(e){let{components:n,...t}=e;return(0,s.yg)(oPo,(0,p.A)({},tPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}pPo.isMDXComponent=!0;const rPo={toc:[]},sPo="wrapper";function cPo(e){let{components:n,...t}=e;return(0,s.yg)(sPo,(0,p.A)({},rPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}cPo.isMDXComponent=!0;const aPo={toc:[]},iPo="wrapper";function lPo(e){let{components:n,...t}=e;return(0,s.yg)(iPo,(0,p.A)({},aPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}lPo.isMDXComponent=!0;const uPo={toc:[]},mPo="wrapper";function yPo(e){let{components:n,...t}=e;return(0,s.yg)(mPo,(0,p.A)({},uPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}yPo.isMDXComponent=!0;const dPo={toc:[]},hPo="wrapper";function gPo(e){let{components:n,...t}=e;return(0,s.yg)(hPo,(0,p.A)({},dPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}gPo.isMDXComponent=!0;const fPo={toc:[]},DPo="wrapper";function MPo(e){let{components:n,...t}=e;return(0,s.yg)(DPo,(0,p.A)({},fPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}MPo.isMDXComponent=!0;const XPo={toc:[]},_Po="wrapper";function wPo(e){let{components:n,...t}=e;return(0,s.yg)(_Po,(0,p.A)({},XPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}wPo.isMDXComponent=!0;const TPo={toc:[]},CPo="wrapper";function xPo(e){let{components:n,...t}=e;return(0,s.yg)(CPo,(0,p.A)({},TPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}xPo.isMDXComponent=!0;const APo={toc:[]},vPo="wrapper";function LPo(e){let{components:n,...t}=e;return(0,s.yg)(vPo,(0,p.A)({},APo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}LPo.isMDXComponent=!0;const bPo={toc:[]},NPo="wrapper";function kPo(e){let{components:n,...t}=e;return(0,s.yg)(NPo,(0,p.A)({},bPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}kPo.isMDXComponent=!0;const zPo={toc:[]},PPo="wrapper";function IPo(e){let{components:n,...t}=e;return(0,s.yg)(PPo,(0,p.A)({},zPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}IPo.isMDXComponent=!0;const RPo={toc:[]},WPo="wrapper";function SPo(e){let{components:n,...t}=e;return(0,s.yg)(WPo,(0,p.A)({},RPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}SPo.isMDXComponent=!0;const BPo={toc:[]},EPo="wrapper";function GPo(e){let{components:n,...t}=e;return(0,s.yg)(EPo,(0,p.A)({},BPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}GPo.isMDXComponent=!0;const OPo={toc:[]},UPo="wrapper";function FPo(e){let{components:n,...t}=e;return(0,s.yg)(UPo,(0,p.A)({},OPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}FPo.isMDXComponent=!0;const VPo={toc:[]},qPo="wrapper";function jPo(e){let{components:n,...t}=e;return(0,s.yg)(qPo,(0,p.A)({},VPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}jPo.isMDXComponent=!0;const HPo={toc:[]},YPo="wrapper";function QPo(e){let{components:n,...t}=e;return(0,s.yg)(YPo,(0,p.A)({},HPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}QPo.isMDXComponent=!0;const $Po={toc:[]},KPo="wrapper";function JPo(e){let{components:n,...t}=e;return(0,s.yg)(KPo,(0,p.A)({},$Po,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}JPo.isMDXComponent=!0;const ZPo={toc:[]},eIo="wrapper";function nIo(e){let{components:n,...t}=e;return(0,s.yg)(eIo,(0,p.A)({},ZPo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}nIo.isMDXComponent=!0;const tIo={toc:[]},oIo="wrapper";function pIo(e){let{components:n,...t}=e;return(0,s.yg)(oIo,(0,p.A)({},tIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}pIo.isMDXComponent=!0;const rIo={toc:[]},sIo="wrapper";function cIo(e){let{components:n,...t}=e;return(0,s.yg)(sIo,(0,p.A)({},rIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}cIo.isMDXComponent=!0;const aIo={toc:[]},iIo="wrapper";function lIo(e){let{components:n,...t}=e;return(0,s.yg)(iIo,(0,p.A)({},aIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}lIo.isMDXComponent=!0;const uIo={toc:[]},mIo="wrapper";function yIo(e){let{components:n,...t}=e;return(0,s.yg)(mIo,(0,p.A)({},uIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}yIo.isMDXComponent=!0;const dIo={toc:[]},hIo="wrapper";function gIo(e){let{components:n,...t}=e;return(0,s.yg)(hIo,(0,p.A)({},dIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}gIo.isMDXComponent=!0;const fIo={toc:[]},DIo="wrapper";function MIo(e){let{components:n,...t}=e;return(0,s.yg)(DIo,(0,p.A)({},fIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}MIo.isMDXComponent=!0;const XIo={toc:[]},_Io="wrapper";function wIo(e){let{components:n,...t}=e;return(0,s.yg)(_Io,(0,p.A)({},XIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}wIo.isMDXComponent=!0;const TIo={toc:[]},CIo="wrapper";function xIo(e){let{components:n,...t}=e;return(0,s.yg)(CIo,(0,p.A)({},TIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}xIo.isMDXComponent=!0;const AIo={toc:[]},vIo="wrapper";function LIo(e){let{components:n,...t}=e;return(0,s.yg)(vIo,(0,p.A)({},AIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}LIo.isMDXComponent=!0;const bIo={toc:[]},NIo="wrapper";function kIo(e){let{components:n,...t}=e;return(0,s.yg)(NIo,(0,p.A)({},bIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}kIo.isMDXComponent=!0;const zIo={toc:[]},PIo="wrapper";function IIo(e){let{components:n,...t}=e;return(0,s.yg)(PIo,(0,p.A)({},zIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert an SVG string to ",(0,s.yg)("inlineCode",{parentName:"p"},"SVGDocument"),"."))}IIo.isMDXComponent=!0;const RIo={toc:[]},WIo="wrapper";function SIo(e){let{components:n,...t}=e;return(0,s.yg)(WIo,(0,p.A)({},RIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An SVG string to be parsed."))}SIo.isMDXComponent=!0;const BIo={toc:[]},EIo="wrapper";function GIo(e){let{components:n,...t}=e;return(0,s.yg)(EIo,(0,p.A)({},BIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}GIo.isMDXComponent=!0;const OIo={toc:[]},UIo="wrapper";function FIo(e){let{components:n,...t}=e;return(0,s.yg)(UIo,(0,p.A)({},OIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}FIo.isMDXComponent=!0;const VIo={toc:[]},qIo="wrapper";function jIo(e){let{components:n,...t}=e;return(0,s.yg)(qIo,(0,p.A)({},VIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}jIo.isMDXComponent=!0;const HIo={toc:[]},YIo="wrapper";function QIo(e){let{components:n,...t}=e;return(0,s.yg)(YIo,(0,p.A)({},HIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}QIo.isMDXComponent=!0;const $Io={toc:[]},KIo="wrapper";function JIo(e){let{components:n,...t}=e;return(0,s.yg)(KIo,(0,p.A)({},$Io,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}JIo.isMDXComponent=!0;const ZIo={toc:[]},eRo="wrapper";function nRo(e){let{components:n,...t}=e;return(0,s.yg)(eRo,(0,p.A)({},ZIo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}nRo.isMDXComponent=!0;const tRo={toc:[]},oRo="wrapper";function pRo(e){let{components:n,...t}=e;return(0,s.yg)(oRo,(0,p.A)({},tRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}pRo.isMDXComponent=!0;const rRo={toc:[]},sRo="wrapper";function cRo(e){let{components:n,...t}=e;return(0,s.yg)(sRo,(0,p.A)({},rRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}cRo.isMDXComponent=!0;const aRo={toc:[]},iRo="wrapper";function lRo(e){let{components:n,...t}=e;return(0,s.yg)(iRo,(0,p.A)({},aRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}lRo.isMDXComponent=!0;const uRo={toc:[]},mRo="wrapper";function yRo(e){let{components:n,...t}=e;return(0,s.yg)(mRo,(0,p.A)({},uRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}yRo.isMDXComponent=!0;const dRo={toc:[]},hRo="wrapper";function gRo(e){let{components:n,...t}=e;return(0,s.yg)(hRo,(0,p.A)({},dRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}gRo.isMDXComponent=!0;const fRo={toc:[]},DRo="wrapper";function MRo(e){let{components:n,...t}=e;return(0,s.yg)(DRo,(0,p.A)({},fRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}MRo.isMDXComponent=!0;const XRo={toc:[]},_Ro="wrapper";function wRo(e){let{components:n,...t}=e;return(0,s.yg)(_Ro,(0,p.A)({},XRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}wRo.isMDXComponent=!0;const TRo={toc:[]},CRo="wrapper";function xRo(e){let{components:n,...t}=e;return(0,s.yg)(CRo,(0,p.A)({},TRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}xRo.isMDXComponent=!0;const ARo={toc:[]},vRo="wrapper";function LRo(e){let{components:n,...t}=e;return(0,s.yg)(vRo,(0,p.A)({},ARo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}LRo.isMDXComponent=!0;const bRo={toc:[]},NRo="wrapper";function kRo(e){let{components:n,...t}=e;return(0,s.yg)(NRo,(0,p.A)({},bRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}kRo.isMDXComponent=!0;const zRo={toc:[]},PRo="wrapper";function IRo(e){let{components:n,...t}=e;return(0,s.yg)(PRo,(0,p.A)({},zRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}IRo.isMDXComponent=!0;const RRo={toc:[]},WRo="wrapper";function SRo(e){let{components:n,...t}=e;return(0,s.yg)(WRo,(0,p.A)({},RRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}SRo.isMDXComponent=!0;const BRo={toc:[]},ERo="wrapper";function GRo(e){let{components:n,...t}=e;return(0,s.yg)(ERo,(0,p.A)({},BRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}GRo.isMDXComponent=!0;const ORo={toc:[]},URo="wrapper";function FRo(e){let{components:n,...t}=e;return(0,s.yg)(URo,(0,p.A)({},ORo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}FRo.isMDXComponent=!0;const VRo={toc:[]},qRo="wrapper";function jRo(e){let{components:n,...t}=e;return(0,s.yg)(qRo,(0,p.A)({},VRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}jRo.isMDXComponent=!0;const HRo={toc:[]},YRo="wrapper";function QRo(e){let{components:n,...t}=e;return(0,s.yg)(YRo,(0,p.A)({},HRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}QRo.isMDXComponent=!0;const $Ro={toc:[]},KRo="wrapper";function JRo(e){let{components:n,...t}=e;return(0,s.yg)(KRo,(0,p.A)({},$Ro,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}JRo.isMDXComponent=!0;const ZRo={toc:[]},eWo="wrapper";function nWo(e){let{components:n,...t}=e;return(0,s.yg)(eWo,(0,p.A)({},ZRo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}nWo.isMDXComponent=!0;const tWo={toc:[]},oWo="wrapper";function pWo(e){let{components:n,...t}=e;return(0,s.yg)(oWo,(0,p.A)({},tWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}pWo.isMDXComponent=!0;const rWo={toc:[]},sWo="wrapper";function cWo(e){let{components:n,...t}=e;return(0,s.yg)(sWo,(0,p.A)({},rWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}cWo.isMDXComponent=!0;const aWo={toc:[]},iWo="wrapper";function lWo(e){let{components:n,...t}=e;return(0,s.yg)(iWo,(0,p.A)({},aWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}lWo.isMDXComponent=!0;const uWo={toc:[]},mWo="wrapper";function yWo(e){let{components:n,...t}=e;return(0,s.yg)(mWo,(0,p.A)({},uWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}yWo.isMDXComponent=!0;const dWo={toc:[]},hWo="wrapper";function gWo(e){let{components:n,...t}=e;return(0,s.yg)(hWo,(0,p.A)({},dWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}gWo.isMDXComponent=!0;const fWo={toc:[]},DWo="wrapper";function MWo(e){let{components:n,...t}=e;return(0,s.yg)(DWo,(0,p.A)({},fWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}MWo.isMDXComponent=!0;const XWo={toc:[]},_Wo="wrapper";function wWo(e){let{components:n,...t}=e;return(0,s.yg)(_Wo,(0,p.A)({},XWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}wWo.isMDXComponent=!0;const TWo={toc:[]},CWo="wrapper";function xWo(e){let{components:n,...t}=e;return(0,s.yg)(CWo,(0,p.A)({},TWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}xWo.isMDXComponent=!0;const AWo={toc:[]},vWo="wrapper";function LWo(e){let{components:n,...t}=e;return(0,s.yg)(vWo,(0,p.A)({},AWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}LWo.isMDXComponent=!0;const bWo={toc:[]},NWo="wrapper";function kWo(e){let{components:n,...t}=e;return(0,s.yg)(NWo,(0,p.A)({},bWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}kWo.isMDXComponent=!0;const zWo={toc:[]},PWo="wrapper";function IWo(e){let{components:n,...t}=e;return(0,s.yg)(PWo,(0,p.A)({},zWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}IWo.isMDXComponent=!0;const RWo={toc:[]},WWo="wrapper";function SWo(e){let{components:n,...t}=e;return(0,s.yg)(WWo,(0,p.A)({},RWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}SWo.isMDXComponent=!0;const BWo={toc:[]},EWo="wrapper";function GWo(e){let{components:n,...t}=e;return(0,s.yg)(EWo,(0,p.A)({},BWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}GWo.isMDXComponent=!0;const OWo={toc:[]},UWo="wrapper";function FWo(e){let{components:n,...t}=e;return(0,s.yg)(UWo,(0,p.A)({},OWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}FWo.isMDXComponent=!0;const VWo={toc:[]},qWo="wrapper";function jWo(e){let{components:n,...t}=e;return(0,s.yg)(qWo,(0,p.A)({},VWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVG#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}jWo.isMDXComponent=!0;const HWo={toc:[]},YWo="wrapper";function QWo(e){let{components:n,...t}=e;return(0,s.yg)(YWo,(0,p.A)({},HWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}QWo.isMDXComponent=!0;const $Wo={toc:[]},KWo="wrapper";function JWo(e){let{components:n,...t}=e;return(0,s.yg)(KWo,(0,p.A)({},$Wo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}JWo.isMDXComponent=!0;const ZWo={toc:[]},eSo="wrapper";function nSo(e){let{components:n,...t}=e;return(0,s.yg)(eSo,(0,p.A)({},ZWo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}nSo.isMDXComponent=!0;const tSo={toc:[]},oSo="wrapper";function pSo(e){let{components:n,...t}=e;return(0,s.yg)(oSo,(0,p.A)({},tSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}pSo.isMDXComponent=!0;const rSo={toc:[]},sSo="wrapper";function cSo(e){let{components:n,...t}=e;return(0,s.yg)(sSo,(0,p.A)({},rSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}cSo.isMDXComponent=!0;const aSo={toc:[]},iSo="wrapper";function lSo(e){let{components:n,...t}=e;return(0,s.yg)(iSo,(0,p.A)({},aSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}lSo.isMDXComponent=!0;const uSo={toc:[]},mSo="wrapper";function ySo(e){let{components:n,...t}=e;return(0,s.yg)(mSo,(0,p.A)({},uSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"MotionCanvas Shape properties"))}ySo.isMDXComponent=!0;const dSo={toc:[]},hSo="wrapper";function gSo(e){let{components:n,...t}=e;return(0,s.yg)(hSo,(0,p.A)({},dSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get position, rotation and scale from Matrix transformation as Shape properties"))}gSo.isMDXComponent=!0;const fSo={toc:[]},DSo="wrapper";function MSo(e){let{components:n,...t}=e;return(0,s.yg)(DSo,(0,p.A)({},fSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Matrix transformation"))}MSo.isMDXComponent=!0;const XSo={toc:[]},_So="wrapper";function wSo(e){let{components:n,...t}=e;return(0,s.yg)(_So,(0,p.A)({},XSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"SVGDocumentData")," that can be used to build SVGDocument."))}wSo.isMDXComponent=!0;const TSo={toc:[]},CSo="wrapper";function xSo(e){let{components:n,...t}=e;return(0,s.yg)(CSo,(0,p.A)({},TSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse an SVG string as ",(0,s.yg)("inlineCode",{parentName:"p"},"SVGDocumentData"),"."))}xSo.isMDXComponent=!0;const ASo={toc:[]},vSo="wrapper";function LSo(e){let{components:n,...t}=e;return(0,s.yg)(vSo,(0,p.A)({},ASo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"And SVG string to be parsed."))}LSo.isMDXComponent=!0;const bSo={toc:[]},NSo="wrapper";function kSo(e){let{components:n,...t}=e;return(0,s.yg)(NSo,(0,p.A)({},bSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}kSo.isMDXComponent=!0;const zSo={toc:[]},PSo="wrapper";function ISo(e){let{components:n,...t}=e;return(0,s.yg)(PSo,(0,p.A)({},zSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}ISo.isMDXComponent=!0;const RSo={toc:[]},WSo="wrapper";function SSo(e){let{components:n,...t}=e;return(0,s.yg)(WSo,(0,p.A)({},RSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}SSo.isMDXComponent=!0;const BSo={toc:[]},ESo="wrapper";function GSo(e){let{components:n,...t}=e;return(0,s.yg)(ESo,(0,p.A)({},BSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}GSo.isMDXComponent=!0;const OSo={toc:[]},USo="wrapper";function FSo(e){let{components:n,...t}=e;return(0,s.yg)(USo,(0,p.A)({},OSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}FSo.isMDXComponent=!0;const VSo={toc:[]},qSo="wrapper";function jSo(e){let{components:n,...t}=e;return(0,s.yg)(qSo,(0,p.A)({},VSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}jSo.isMDXComponent=!0;const HSo={toc:[]},YSo="wrapper";function QSo(e){let{components:n,...t}=e;return(0,s.yg)(YSo,(0,p.A)({},HSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}QSo.isMDXComponent=!0;const $So={toc:[]},KSo="wrapper";function JSo(e){let{components:n,...t}=e;return(0,s.yg)(KSo,(0,p.A)({},$So,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}JSo.isMDXComponent=!0;const ZSo={toc:[]},eBo="wrapper";function nBo(e){let{components:n,...t}=e;return(0,s.yg)(eBo,(0,p.A)({},ZSo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}nBo.isMDXComponent=!0;const tBo={toc:[]},oBo="wrapper";function pBo(e){let{components:n,...t}=e;return(0,s.yg)(oBo,(0,p.A)({},tBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}pBo.isMDXComponent=!0;const rBo={toc:[]},sBo="wrapper";function cBo(e){let{components:n,...t}=e;return(0,s.yg)(sBo,(0,p.A)({},rBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}cBo.isMDXComponent=!0;const aBo={toc:[]},iBo="wrapper";function lBo(e){let{components:n,...t}=e;return(0,s.yg)(iBo,(0,p.A)({},aBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}lBo.isMDXComponent=!0;const uBo={toc:[]},mBo="wrapper";function yBo(e){let{components:n,...t}=e;return(0,s.yg)(mBo,(0,p.A)({},uBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}yBo.isMDXComponent=!0;const dBo={toc:[]},hBo="wrapper";function gBo(e){let{components:n,...t}=e;return(0,s.yg)(hBo,(0,p.A)({},dBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}gBo.isMDXComponent=!0;const fBo={toc:[]},DBo="wrapper";function MBo(e){let{components:n,...t}=e;return(0,s.yg)(DBo,(0,p.A)({},fBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}MBo.isMDXComponent=!0;const XBo={toc:[]},_Bo="wrapper";function wBo(e){let{components:n,...t}=e;return(0,s.yg)(_Bo,(0,p.A)({},XBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}wBo.isMDXComponent=!0;const TBo={toc:[]},CBo="wrapper";function xBo(e){let{components:n,...t}=e;return(0,s.yg)(CBo,(0,p.A)({},TBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}xBo.isMDXComponent=!0;const ABo={toc:[]},vBo="wrapper";function LBo(e){let{components:n,...t}=e;return(0,s.yg)(vBo,(0,p.A)({},ABo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}LBo.isMDXComponent=!0;const bBo={toc:[]},NBo="wrapper";function kBo(e){let{components:n,...t}=e;return(0,s.yg)(NBo,(0,p.A)({},bBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}kBo.isMDXComponent=!0;const zBo={toc:[]},PBo="wrapper";function IBo(e){let{components:n,...t}=e;return(0,s.yg)(PBo,(0,p.A)({},zBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}IBo.isMDXComponent=!0;const RBo={toc:[]},WBo="wrapper";function SBo(e){let{components:n,...t}=e;return(0,s.yg)(WBo,(0,p.A)({},RBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}SBo.isMDXComponent=!0;const BBo={toc:[]},EBo="wrapper";function GBo(e){let{components:n,...t}=e;return(0,s.yg)(EBo,(0,p.A)({},BBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}GBo.isMDXComponent=!0;const OBo={toc:[]},UBo="wrapper";function FBo(e){let{components:n,...t}=e;return(0,s.yg)(UBo,(0,p.A)({},OBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}FBo.isMDXComponent=!0;const VBo={toc:[]},qBo="wrapper";function jBo(e){let{components:n,...t}=e;return(0,s.yg)(qBo,(0,p.A)({},VBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}jBo.isMDXComponent=!0;const HBo={toc:[]},YBo="wrapper";function QBo(e){let{components:n,...t}=e;return(0,s.yg)(YBo,(0,p.A)({},HBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}QBo.isMDXComponent=!0;const $Bo={toc:[]},KBo="wrapper";function JBo(e){let{components:n,...t}=e;return(0,s.yg)(KBo,(0,p.A)({},$Bo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}JBo.isMDXComponent=!0;const ZBo={toc:[]},eEo="wrapper";function nEo(e){let{components:n,...t}=e;return(0,s.yg)(eEo,(0,p.A)({},ZBo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}nEo.isMDXComponent=!0;const tEo={toc:[]},oEo="wrapper";function pEo(e){let{components:n,...t}=e;return(0,s.yg)(oEo,(0,p.A)({},tEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}pEo.isMDXComponent=!0;const rEo={toc:[]},sEo="wrapper";function cEo(e){let{components:n,...t}=e;return(0,s.yg)(sEo,(0,p.A)({},rEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}cEo.isMDXComponent=!0;const aEo={toc:[]},iEo="wrapper";function lEo(e){let{components:n,...t}=e;return(0,s.yg)(iEo,(0,p.A)({},aEo,t,{components:n,mdxType:"MDXLayout"}))}lEo.isMDXComponent=!0;const uEo={toc:[]},mEo="wrapper";function yEo(e){let{components:n,...t}=e;return(0,s.yg)(mEo,(0,p.A)({},uEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}yEo.isMDXComponent=!0;const dEo={toc:[]},hEo="wrapper";function gEo(e){let{components:n,...t}=e;return(0,s.yg)(hEo,(0,p.A)({},dEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}gEo.isMDXComponent=!0;const fEo={toc:[]},DEo="wrapper";function MEo(e){let{components:n,...t}=e;return(0,s.yg)(DEo,(0,p.A)({},fEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}MEo.isMDXComponent=!0;const XEo={toc:[]},_Eo="wrapper";function wEo(e){let{components:n,...t}=e;return(0,s.yg)(_Eo,(0,p.A)({},XEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}wEo.isMDXComponent=!0;const TEo={toc:[]},CEo="wrapper";function xEo(e){let{components:n,...t}=e;return(0,s.yg)(CEo,(0,p.A)({},TEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}xEo.isMDXComponent=!0;const AEo={toc:[]},vEo="wrapper";function LEo(e){let{components:n,...t}=e;return(0,s.yg)(vEo,(0,p.A)({},AEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}LEo.isMDXComponent=!0;const bEo={toc:[]},NEo="wrapper";function kEo(e){let{components:n,...t}=e;return(0,s.yg)(NEo,(0,p.A)({},bEo,t,{components:n,mdxType:"MDXLayout"}))}kEo.isMDXComponent=!0;const zEo={toc:[]},PEo="wrapper";function IEo(e){let{components:n,...t}=e;return(0,s.yg)(PEo,(0,p.A)({},zEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}IEo.isMDXComponent=!0;const REo={toc:[]},WEo="wrapper";function SEo(e){let{components:n,...t}=e;return(0,s.yg)(WEo,(0,p.A)({},REo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}SEo.isMDXComponent=!0;const BEo={toc:[]},EEo="wrapper";function GEo(e){let{components:n,...t}=e;return(0,s.yg)(EEo,(0,p.A)({},BEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}GEo.isMDXComponent=!0;const OEo={toc:[]},UEo="wrapper";function FEo(e){let{components:n,...t}=e;return(0,s.yg)(UEo,(0,p.A)({},OEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}FEo.isMDXComponent=!0;const VEo={toc:[]},qEo="wrapper";function jEo(e){let{components:n,...t}=e;return(0,s.yg)(qEo,(0,p.A)({},VEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}jEo.isMDXComponent=!0;const HEo={toc:[]},YEo="wrapper";function QEo(e){let{components:n,...t}=e;return(0,s.yg)(YEo,(0,p.A)({},HEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}QEo.isMDXComponent=!0;const $Eo={toc:[]},KEo="wrapper";function JEo(e){let{components:n,...t}=e;return(0,s.yg)(KEo,(0,p.A)({},$Eo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}JEo.isMDXComponent=!0;const ZEo={toc:[]},eGo="wrapper";function nGo(e){let{components:n,...t}=e;return(0,s.yg)(eGo,(0,p.A)({},ZEo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}nGo.isMDXComponent=!0;const tGo={toc:[]},oGo="wrapper";function pGo(e){let{components:n,...t}=e;return(0,s.yg)(oGo,(0,p.A)({},tGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}pGo.isMDXComponent=!0;const rGo={toc:[]},sGo="wrapper";function cGo(e){let{components:n,...t}=e;return(0,s.yg)(sGo,(0,p.A)({},rGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}cGo.isMDXComponent=!0;const aGo={toc:[]},iGo="wrapper";function lGo(e){let{components:n,...t}=e;return(0,s.yg)(iGo,(0,p.A)({},aGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}lGo.isMDXComponent=!0;const uGo={toc:[]},mGo="wrapper";function yGo(e){let{components:n,...t}=e;return(0,s.yg)(mGo,(0,p.A)({},uGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}yGo.isMDXComponent=!0;const dGo={toc:[]},hGo="wrapper";function gGo(e){let{components:n,...t}=e;return(0,s.yg)(hGo,(0,p.A)({},dGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}gGo.isMDXComponent=!0;const fGo={toc:[]},DGo="wrapper";function MGo(e){let{components:n,...t}=e;return(0,s.yg)(DGo,(0,p.A)({},fGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}MGo.isMDXComponent=!0;const XGo={toc:[]},_Go="wrapper";function wGo(e){let{components:n,...t}=e;return(0,s.yg)(_Go,(0,p.A)({},XGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}wGo.isMDXComponent=!0;const TGo={toc:[]},CGo="wrapper";function xGo(e){let{components:n,...t}=e;return(0,s.yg)(CGo,(0,p.A)({},TGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}xGo.isMDXComponent=!0;const AGo={toc:[]},vGo="wrapper";function LGo(e){let{components:n,...t}=e;return(0,s.yg)(vGo,(0,p.A)({},AGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}LGo.isMDXComponent=!0;const bGo={toc:[]},NGo="wrapper";function kGo(e){let{components:n,...t}=e;return(0,s.yg)(NGo,(0,p.A)({},bGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}kGo.isMDXComponent=!0;const zGo={toc:[]},PGo="wrapper";function IGo(e){let{components:n,...t}=e;return(0,s.yg)(PGo,(0,p.A)({},zGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}IGo.isMDXComponent=!0;const RGo={toc:[]},WGo="wrapper";function SGo(e){let{components:n,...t}=e;return(0,s.yg)(WGo,(0,p.A)({},RGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}SGo.isMDXComponent=!0;const BGo={toc:[]},EGo="wrapper";function GGo(e){let{components:n,...t}=e;return(0,s.yg)(EGo,(0,p.A)({},BGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}GGo.isMDXComponent=!0;const OGo={toc:[]},UGo="wrapper";function FGo(e){let{components:n,...t}=e;return(0,s.yg)(UGo,(0,p.A)({},OGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}FGo.isMDXComponent=!0;const VGo={toc:[]},qGo="wrapper";function jGo(e){let{components:n,...t}=e;return(0,s.yg)(qGo,(0,p.A)({},VGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}jGo.isMDXComponent=!0;const HGo={toc:[]},YGo="wrapper";function QGo(e){let{components:n,...t}=e;return(0,s.yg)(YGo,(0,p.A)({},HGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}QGo.isMDXComponent=!0;const $Go={toc:[]},KGo="wrapper";function JGo(e){let{components:n,...t}=e;return(0,s.yg)(KGo,(0,p.A)({},$Go,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}JGo.isMDXComponent=!0;const ZGo={toc:[]},eOo="wrapper";function nOo(e){let{components:n,...t}=e;return(0,s.yg)(eOo,(0,p.A)({},ZGo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}nOo.isMDXComponent=!0;const tOo={toc:[]},oOo="wrapper";function pOo(e){let{components:n,...t}=e;return(0,s.yg)(oOo,(0,p.A)({},tOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}pOo.isMDXComponent=!0;const rOo={toc:[]},sOo="wrapper";function cOo(e){let{components:n,...t}=e;return(0,s.yg)(sOo,(0,p.A)({},rOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}cOo.isMDXComponent=!0;const aOo={toc:[]},iOo="wrapper";function lOo(e){let{components:n,...t}=e;return(0,s.yg)(iOo,(0,p.A)({},aOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}lOo.isMDXComponent=!0;const uOo={toc:[]},mOo="wrapper";function yOo(e){let{components:n,...t}=e;return(0,s.yg)(mOo,(0,p.A)({},uOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}yOo.isMDXComponent=!0;const dOo={toc:[]},hOo="wrapper";function gOo(e){let{components:n,...t}=e;return(0,s.yg)(hOo,(0,p.A)({},dOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}gOo.isMDXComponent=!0;const fOo={toc:[]},DOo="wrapper";function MOo(e){let{components:n,...t}=e;return(0,s.yg)(DOo,(0,p.A)({},fOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}MOo.isMDXComponent=!0;const XOo={toc:[]},_Oo="wrapper";function wOo(e){let{components:n,...t}=e;return(0,s.yg)(_Oo,(0,p.A)({},XOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}wOo.isMDXComponent=!0;const TOo={toc:[]},COo="wrapper";function xOo(e){let{components:n,...t}=e;return(0,s.yg)(COo,(0,p.A)({},TOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}xOo.isMDXComponent=!0;const AOo={toc:[]},vOo="wrapper";function LOo(e){let{components:n,...t}=e;return(0,s.yg)(vOo,(0,p.A)({},AOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}LOo.isMDXComponent=!0;const bOo={toc:[]},NOo="wrapper";function kOo(e){let{components:n,...t}=e;return(0,s.yg)(NOo,(0,p.A)({},bOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}kOo.isMDXComponent=!0;const zOo={toc:[]},POo="wrapper";function IOo(e){let{components:n,...t}=e;return(0,s.yg)(POo,(0,p.A)({},zOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}IOo.isMDXComponent=!0;const ROo={toc:[]},WOo="wrapper";function SOo(e){let{components:n,...t}=e;return(0,s.yg)(WOo,(0,p.A)({},ROo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}SOo.isMDXComponent=!0;const BOo={toc:[]},EOo="wrapper";function GOo(e){let{components:n,...t}=e;return(0,s.yg)(EOo,(0,p.A)({},BOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}GOo.isMDXComponent=!0;const OOo={toc:[]},UOo="wrapper";function FOo(e){let{components:n,...t}=e;return(0,s.yg)(UOo,(0,p.A)({},OOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}FOo.isMDXComponent=!0;const VOo={toc:[]},qOo="wrapper";function jOo(e){let{components:n,...t}=e;return(0,s.yg)(qOo,(0,p.A)({},VOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}jOo.isMDXComponent=!0;const HOo={toc:[]},YOo="wrapper";function QOo(e){let{components:n,...t}=e;return(0,s.yg)(YOo,(0,p.A)({},HOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}QOo.isMDXComponent=!0;const $Oo={toc:[]},KOo="wrapper";function JOo(e){let{components:n,...t}=e;return(0,s.yg)(KOo,(0,p.A)({},$Oo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}JOo.isMDXComponent=!0;const ZOo={toc:[]},eUo="wrapper";function nUo(e){let{components:n,...t}=e;return(0,s.yg)(eUo,(0,p.A)({},ZOo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}nUo.isMDXComponent=!0;const tUo={toc:[]},oUo="wrapper";function pUo(e){let{components:n,...t}=e;return(0,s.yg)(oUo,(0,p.A)({},tUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}pUo.isMDXComponent=!0;const rUo={toc:[]},sUo="wrapper";function cUo(e){let{components:n,...t}=e;return(0,s.yg)(sUo,(0,p.A)({},rUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}cUo.isMDXComponent=!0;const aUo={toc:[]},iUo="wrapper";function lUo(e){let{components:n,...t}=e;return(0,s.yg)(iUo,(0,p.A)({},aUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}lUo.isMDXComponent=!0;const uUo={toc:[]},mUo="wrapper";function yUo(e){let{components:n,...t}=e;return(0,s.yg)(mUo,(0,p.A)({},uUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}yUo.isMDXComponent=!0;const dUo={toc:[]},hUo="wrapper";function gUo(e){let{components:n,...t}=e;return(0,s.yg)(hUo,(0,p.A)({},dUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}gUo.isMDXComponent=!0;const fUo={toc:[]},DUo="wrapper";function MUo(e){let{components:n,...t}=e;return(0,s.yg)(DUo,(0,p.A)({},fUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}MUo.isMDXComponent=!0;const XUo={toc:[]},_Uo="wrapper";function wUo(e){let{components:n,...t}=e;return(0,s.yg)(_Uo,(0,p.A)({},XUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}wUo.isMDXComponent=!0;const TUo={toc:[]},CUo="wrapper";function xUo(e){let{components:n,...t}=e;return(0,s.yg)(CUo,(0,p.A)({},TUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}xUo.isMDXComponent=!0;const AUo={toc:[]},vUo="wrapper";function LUo(e){let{components:n,...t}=e;return(0,s.yg)(vUo,(0,p.A)({},AUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}LUo.isMDXComponent=!0;const bUo={toc:[]},NUo="wrapper";function kUo(e){let{components:n,...t}=e;return(0,s.yg)(NUo,(0,p.A)({},bUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}kUo.isMDXComponent=!0;const zUo={toc:[]},PUo="wrapper";function IUo(e){let{components:n,...t}=e;return(0,s.yg)(PUo,(0,p.A)({},zUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}IUo.isMDXComponent=!0;const RUo={toc:[]},WUo="wrapper";function SUo(e){let{components:n,...t}=e;return(0,s.yg)(WUo,(0,p.A)({},RUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}SUo.isMDXComponent=!0;const BUo={toc:[]},EUo="wrapper";function GUo(e){let{components:n,...t}=e;return(0,s.yg)(EUo,(0,p.A)({},BUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}GUo.isMDXComponent=!0;const OUo={toc:[]},UUo="wrapper";function FUo(e){let{components:n,...t}=e;return(0,s.yg)(UUo,(0,p.A)({},OUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}FUo.isMDXComponent=!0;const VUo={toc:[]},qUo="wrapper";function jUo(e){let{components:n,...t}=e;return(0,s.yg)(qUo,(0,p.A)({},VUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}jUo.isMDXComponent=!0;const HUo={toc:[]},YUo="wrapper";function QUo(e){let{components:n,...t}=e;return(0,s.yg)(YUo,(0,p.A)({},HUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}QUo.isMDXComponent=!0;const $Uo={toc:[]},KUo="wrapper";function JUo(e){let{components:n,...t}=e;return(0,s.yg)(KUo,(0,p.A)({},$Uo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}JUo.isMDXComponent=!0;const ZUo={toc:[]},eFo="wrapper";function nFo(e){let{components:n,...t}=e;return(0,s.yg)(eFo,(0,p.A)({},ZUo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}nFo.isMDXComponent=!0;const tFo={toc:[]},oFo="wrapper";function pFo(e){let{components:n,...t}=e;return(0,s.yg)(oFo,(0,p.A)({},tFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}pFo.isMDXComponent=!0;const rFo={toc:[]},sFo="wrapper";function cFo(e){let{components:n,...t}=e;return(0,s.yg)(sFo,(0,p.A)({},rFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}cFo.isMDXComponent=!0;const aFo={toc:[]},iFo="wrapper";function lFo(e){let{components:n,...t}=e;return(0,s.yg)(iFo,(0,p.A)({},aFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}lFo.isMDXComponent=!0;const uFo={toc:[]},mFo="wrapper";function yFo(e){let{components:n,...t}=e;return(0,s.yg)(mFo,(0,p.A)({},uFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}yFo.isMDXComponent=!0;const dFo={toc:[]},hFo="wrapper";function gFo(e){let{components:n,...t}=e;return(0,s.yg)(hFo,(0,p.A)({},dFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}gFo.isMDXComponent=!0;const fFo={toc:[]},DFo="wrapper";function MFo(e){let{components:n,...t}=e;return(0,s.yg)(DFo,(0,p.A)({},fFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}MFo.isMDXComponent=!0;const XFo={toc:[]},_Fo="wrapper";function wFo(e){let{components:n,...t}=e;return(0,s.yg)(_Fo,(0,p.A)({},XFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}wFo.isMDXComponent=!0;const TFo={toc:[]},CFo="wrapper";function xFo(e){let{components:n,...t}=e;return(0,s.yg)(CFo,(0,p.A)({},TFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}xFo.isMDXComponent=!0;const AFo={toc:[]},vFo="wrapper";function LFo(e){let{components:n,...t}=e;return(0,s.yg)(vFo,(0,p.A)({},AFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}LFo.isMDXComponent=!0;const bFo={toc:[]},NFo="wrapper";function kFo(e){let{components:n,...t}=e;return(0,s.yg)(NFo,(0,p.A)({},bFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}kFo.isMDXComponent=!0;const zFo={toc:[]},PFo="wrapper";function IFo(e){let{components:n,...t}=e;return(0,s.yg)(PFo,(0,p.A)({},zFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}IFo.isMDXComponent=!0;const RFo={toc:[]},WFo="wrapper";function SFo(e){let{components:n,...t}=e;return(0,s.yg)(WFo,(0,p.A)({},RFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}SFo.isMDXComponent=!0;const BFo={toc:[]},EFo="wrapper";function GFo(e){let{components:n,...t}=e;return(0,s.yg)(EFo,(0,p.A)({},BFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}GFo.isMDXComponent=!0;const OFo={toc:[]},UFo="wrapper";function FFo(e){let{components:n,...t}=e;return(0,s.yg)(UFo,(0,p.A)({},OFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}FFo.isMDXComponent=!0;const VFo={toc:[]},qFo="wrapper";function jFo(e){let{components:n,...t}=e;return(0,s.yg)(qFo,(0,p.A)({},VFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}jFo.isMDXComponent=!0;const HFo={toc:[]},YFo="wrapper";function QFo(e){let{components:n,...t}=e;return(0,s.yg)(YFo,(0,p.A)({},HFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}QFo.isMDXComponent=!0;const $Fo={toc:[]},KFo="wrapper";function JFo(e){let{components:n,...t}=e;return(0,s.yg)(KFo,(0,p.A)({},$Fo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}JFo.isMDXComponent=!0;const ZFo={toc:[]},eVo="wrapper";function nVo(e){let{components:n,...t}=e;return(0,s.yg)(eVo,(0,p.A)({},ZFo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}nVo.isMDXComponent=!0;const tVo={toc:[]},oVo="wrapper";function pVo(e){let{components:n,...t}=e;return(0,s.yg)(oVo,(0,p.A)({},tVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}pVo.isMDXComponent=!0;const rVo={toc:[]},sVo="wrapper";function cVo(e){let{components:n,...t}=e;return(0,s.yg)(sVo,(0,p.A)({},rVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}cVo.isMDXComponent=!0;const aVo={toc:[]},iVo="wrapper";function lVo(e){let{components:n,...t}=e;return(0,s.yg)(iVo,(0,p.A)({},aVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}lVo.isMDXComponent=!0;const uVo={toc:[]},mVo="wrapper";function yVo(e){let{components:n,...t}=e;return(0,s.yg)(mVo,(0,p.A)({},uVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}yVo.isMDXComponent=!0;const dVo={toc:[]},hVo="wrapper";function gVo(e){let{components:n,...t}=e;return(0,s.yg)(hVo,(0,p.A)({},dVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}gVo.isMDXComponent=!0;const fVo={toc:[]},DVo="wrapper";function MVo(e){let{components:n,...t}=e;return(0,s.yg)(DVo,(0,p.A)({},fVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}MVo.isMDXComponent=!0;const XVo={toc:[]},_Vo="wrapper";function wVo(e){let{components:n,...t}=e;return(0,s.yg)(_Vo,(0,p.A)({},XVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}wVo.isMDXComponent=!0;const TVo={toc:[]},CVo="wrapper";function xVo(e){let{components:n,...t}=e;return(0,s.yg)(CVo,(0,p.A)({},TVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}xVo.isMDXComponent=!0;const AVo={toc:[]},vVo="wrapper";function LVo(e){let{components:n,...t}=e;return(0,s.yg)(vVo,(0,p.A)({},AVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}LVo.isMDXComponent=!0;const bVo={toc:[]},NVo="wrapper";function kVo(e){let{components:n,...t}=e;return(0,s.yg)(NVo,(0,p.A)({},bVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}kVo.isMDXComponent=!0;const zVo={toc:[]},PVo="wrapper";function IVo(e){let{components:n,...t}=e;return(0,s.yg)(PVo,(0,p.A)({},zVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}IVo.isMDXComponent=!0;const RVo={toc:[]},WVo="wrapper";function SVo(e){let{components:n,...t}=e;return(0,s.yg)(WVo,(0,p.A)({},RVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}SVo.isMDXComponent=!0;const BVo={toc:[]},EVo="wrapper";function GVo(e){let{components:n,...t}=e;return(0,s.yg)(EVo,(0,p.A)({},BVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}GVo.isMDXComponent=!0;const OVo={toc:[]},UVo="wrapper";function FVo(e){let{components:n,...t}=e;return(0,s.yg)(UVo,(0,p.A)({},OVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}FVo.isMDXComponent=!0;const VVo={toc:[]},qVo="wrapper";function jVo(e){let{components:n,...t}=e;return(0,s.yg)(qVo,(0,p.A)({},VVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}jVo.isMDXComponent=!0;const HVo={toc:[]},YVo="wrapper";function QVo(e){let{components:n,...t}=e;return(0,s.yg)(YVo,(0,p.A)({},HVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}QVo.isMDXComponent=!0;const $Vo={toc:[]},KVo="wrapper";function JVo(e){let{components:n,...t}=e;return(0,s.yg)(KVo,(0,p.A)({},$Vo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}JVo.isMDXComponent=!0;const ZVo={toc:[]},eqo="wrapper";function nqo(e){let{components:n,...t}=e;return(0,s.yg)(eqo,(0,p.A)({},ZVo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}nqo.isMDXComponent=!0;const tqo={toc:[]},oqo="wrapper";function pqo(e){let{components:n,...t}=e;return(0,s.yg)(oqo,(0,p.A)({},tqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}pqo.isMDXComponent=!0;const rqo={toc:[]},sqo="wrapper";function cqo(e){let{components:n,...t}=e;return(0,s.yg)(sqo,(0,p.A)({},rqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}cqo.isMDXComponent=!0;const aqo={toc:[]},iqo="wrapper";function lqo(e){let{components:n,...t}=e;return(0,s.yg)(iqo,(0,p.A)({},aqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}lqo.isMDXComponent=!0;const uqo={toc:[]},mqo="wrapper";function yqo(e){let{components:n,...t}=e;return(0,s.yg)(mqo,(0,p.A)({},uqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}yqo.isMDXComponent=!0;const dqo={toc:[]},hqo="wrapper";function gqo(e){let{components:n,...t}=e;return(0,s.yg)(hqo,(0,p.A)({},dqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}gqo.isMDXComponent=!0;const fqo={toc:[]},Dqo="wrapper";function Mqo(e){let{components:n,...t}=e;return(0,s.yg)(Dqo,(0,p.A)({},fqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Mqo.isMDXComponent=!0;const Xqo={toc:[]},_qo="wrapper";function wqo(e){let{components:n,...t}=e;return(0,s.yg)(_qo,(0,p.A)({},Xqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}wqo.isMDXComponent=!0;const Tqo={toc:[]},Cqo="wrapper";function xqo(e){let{components:n,...t}=e;return(0,s.yg)(Cqo,(0,p.A)({},Tqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}xqo.isMDXComponent=!0;const Aqo={toc:[]},vqo="wrapper";function Lqo(e){let{components:n,...t}=e;return(0,s.yg)(vqo,(0,p.A)({},Aqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}Lqo.isMDXComponent=!0;const bqo={toc:[]},Nqo="wrapper";function kqo(e){let{components:n,...t}=e;return(0,s.yg)(Nqo,(0,p.A)({},bqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}kqo.isMDXComponent=!0;const zqo={toc:[]},Pqo="wrapper";function Iqo(e){let{components:n,...t}=e;return(0,s.yg)(Pqo,(0,p.A)({},zqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}Iqo.isMDXComponent=!0;const Rqo={toc:[]},Wqo="wrapper";function Sqo(e){let{components:n,...t}=e;return(0,s.yg)(Wqo,(0,p.A)({},Rqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}Sqo.isMDXComponent=!0;const Bqo={toc:[]},Eqo="wrapper";function Gqo(e){let{components:n,...t}=e;return(0,s.yg)(Eqo,(0,p.A)({},Bqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}Gqo.isMDXComponent=!0;const Oqo={toc:[]},Uqo="wrapper";function Fqo(e){let{components:n,...t}=e;return(0,s.yg)(Uqo,(0,p.A)({},Oqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Fqo.isMDXComponent=!0;const Vqo={toc:[]},qqo="wrapper";function jqo(e){let{components:n,...t}=e;return(0,s.yg)(qqo,(0,p.A)({},Vqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}jqo.isMDXComponent=!0;const Hqo={toc:[]},Yqo="wrapper";function Qqo(e){let{components:n,...t}=e;return(0,s.yg)(Yqo,(0,p.A)({},Hqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}Qqo.isMDXComponent=!0;const $qo={toc:[]},Kqo="wrapper";function Jqo(e){let{components:n,...t}=e;return(0,s.yg)(Kqo,(0,p.A)({},$qo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Jqo.isMDXComponent=!0;const Zqo={toc:[]},ejo="wrapper";function njo(e){let{components:n,...t}=e;return(0,s.yg)(ejo,(0,p.A)({},Zqo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}njo.isMDXComponent=!0;const tjo={toc:[]},ojo="wrapper";function pjo(e){let{components:n,...t}=e;return(0,s.yg)(ojo,(0,p.A)({},tjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}pjo.isMDXComponent=!0;const rjo={toc:[]},sjo="wrapper";function cjo(e){let{components:n,...t}=e;return(0,s.yg)(sjo,(0,p.A)({},rjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}cjo.isMDXComponent=!0;const ajo={toc:[]},ijo="wrapper";function ljo(e){let{components:n,...t}=e;return(0,s.yg)(ijo,(0,p.A)({},ajo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}ljo.isMDXComponent=!0;const ujo={toc:[]},mjo="wrapper";function yjo(e){let{components:n,...t}=e;return(0,s.yg)(mjo,(0,p.A)({},ujo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}yjo.isMDXComponent=!0;const djo={toc:[]},hjo="wrapper";function gjo(e){let{components:n,...t}=e;return(0,s.yg)(hjo,(0,p.A)({},djo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}gjo.isMDXComponent=!0;const fjo={toc:[]},Djo="wrapper";function Mjo(e){let{components:n,...t}=e;return(0,s.yg)(Djo,(0,p.A)({},fjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Mjo.isMDXComponent=!0;const Xjo={toc:[]},_jo="wrapper";function wjo(e){let{components:n,...t}=e;return(0,s.yg)(_jo,(0,p.A)({},Xjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}wjo.isMDXComponent=!0;const Tjo={toc:[]},Cjo="wrapper";function xjo(e){let{components:n,...t}=e;return(0,s.yg)(Cjo,(0,p.A)({},Tjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}xjo.isMDXComponent=!0;const Ajo={toc:[]},vjo="wrapper";function Ljo(e){let{components:n,...t}=e;return(0,s.yg)(vjo,(0,p.A)({},Ajo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Ljo.isMDXComponent=!0;const bjo={toc:[]},Njo="wrapper";function kjo(e){let{components:n,...t}=e;return(0,s.yg)(Njo,(0,p.A)({},bjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}kjo.isMDXComponent=!0;const zjo={toc:[]},Pjo="wrapper";function Ijo(e){let{components:n,...t}=e;return(0,s.yg)(Pjo,(0,p.A)({},zjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Ijo.isMDXComponent=!0;const Rjo={toc:[]},Wjo="wrapper";function Sjo(e){let{components:n,...t}=e;return(0,s.yg)(Wjo,(0,p.A)({},Rjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Sjo.isMDXComponent=!0;const Bjo={toc:[]},Ejo="wrapper";function Gjo(e){let{components:n,...t}=e;return(0,s.yg)(Ejo,(0,p.A)({},Bjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}Gjo.isMDXComponent=!0;const Ojo={toc:[]},Ujo="wrapper";function Fjo(e){let{components:n,...t}=e;return(0,s.yg)(Ujo,(0,p.A)({},Ojo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}Fjo.isMDXComponent=!0;const Vjo={toc:[]},qjo="wrapper";function jjo(e){let{components:n,...t}=e;return(0,s.yg)(qjo,(0,p.A)({},Vjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}jjo.isMDXComponent=!0;const Hjo={toc:[]},Yjo="wrapper";function Qjo(e){let{components:n,...t}=e;return(0,s.yg)(Yjo,(0,p.A)({},Hjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}Qjo.isMDXComponent=!0;const $jo={toc:[]},Kjo="wrapper";function Jjo(e){let{components:n,...t}=e;return(0,s.yg)(Kjo,(0,p.A)({},$jo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Jjo.isMDXComponent=!0;const Zjo={toc:[]},eHo="wrapper";function nHo(e){let{components:n,...t}=e;return(0,s.yg)(eHo,(0,p.A)({},Zjo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}nHo.isMDXComponent=!0;const tHo={toc:[]},oHo="wrapper";function pHo(e){let{components:n,...t}=e;return(0,s.yg)(oHo,(0,p.A)({},tHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}pHo.isMDXComponent=!0;const rHo={toc:[]},sHo="wrapper";function cHo(e){let{components:n,...t}=e;return(0,s.yg)(sHo,(0,p.A)({},rHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}cHo.isMDXComponent=!0;const aHo={toc:[]},iHo="wrapper";function lHo(e){let{components:n,...t}=e;return(0,s.yg)(iHo,(0,p.A)({},aHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}lHo.isMDXComponent=!0;const uHo={toc:[]},mHo="wrapper";function yHo(e){let{components:n,...t}=e;return(0,s.yg)(mHo,(0,p.A)({},uHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}yHo.isMDXComponent=!0;const dHo={toc:[]},hHo="wrapper";function gHo(e){let{components:n,...t}=e;return(0,s.yg)(hHo,(0,p.A)({},dHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}gHo.isMDXComponent=!0;const fHo={toc:[]},DHo="wrapper";function MHo(e){let{components:n,...t}=e;return(0,s.yg)(DHo,(0,p.A)({},fHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Shape#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}MHo.isMDXComponent=!0;const XHo={toc:[]},_Ho="wrapper";function wHo(e){let{components:n,...t}=e;return(0,s.yg)(_Ho,(0,p.A)({},XHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}wHo.isMDXComponent=!0;const THo={toc:[]},CHo="wrapper";function xHo(e){let{components:n,...t}=e;return(0,s.yg)(CHo,(0,p.A)({},THo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}xHo.isMDXComponent=!0;const AHo={toc:[]},vHo="wrapper";function LHo(e){let{components:n,...t}=e;return(0,s.yg)(vHo,(0,p.A)({},AHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}LHo.isMDXComponent=!0;const bHo={toc:[]},NHo="wrapper";function kHo(e){let{components:n,...t}=e;return(0,s.yg)(NHo,(0,p.A)({},bHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}kHo.isMDXComponent=!0;const zHo={toc:[]},PHo="wrapper";function IHo(e){let{components:n,...t}=e;return(0,s.yg)(PHo,(0,p.A)({},zHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}IHo.isMDXComponent=!0;const RHo={toc:[]},WHo="wrapper";function SHo(e){let{components:n,...t}=e;return(0,s.yg)(WHo,(0,p.A)({},RHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}SHo.isMDXComponent=!0;const BHo={toc:[]},EHo="wrapper";function GHo(e){let{components:n,...t}=e;return(0,s.yg)(EHo,(0,p.A)({},BHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This node uses B\xe9zier curves for drawing each segment of the spline."))}GHo.isMDXComponent=!0;const OHo={toc:[]},UHo="wrapper";function FHo(e){let{components:n,...t}=e;return(0,s.yg)(UHo,(0,p.A)({},OHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Defining knots using the ",(0,s.yg)("inlineCode",{parentName:"p"},"points")," property. This will automatically\ncalculate the handle positions for each knot do draw a smooth curve. You\ncan control the smoothness of the resulting curve via the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothness"))," property:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Spline\n  lineWidth={4}\n  stroke={'white'}\n  smoothness={0.4}\n  points={[\n    [-400, 0],\n    [-200, -300],\n    [0, 0],\n    [200, -300],\n    [400, 0],\n  ]}\n/>\n")),(0,s.yg)("p",null,"Defining knots with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Knot"},(0,s.yg)("inlineCode",{parentName:"a"},"Knot"))," nodes:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Spline lineWidth={4} stroke={'white'}>\n  <Knot position={[-400, 0]} />\n  <Knot position={[-200, -300]} />\n  <Knot\n    position={[0, 0]}\n    startHandle={[-100, 200]}\n    endHandle={[100, 200]}\n  />\n  <Knot position={[200, -300]} />\n  <Knot position={[400, 0]} />\n</Spline>\n")))}FHo.isMDXComponent=!0;const VHo={toc:[]},qHo="wrapper";function jHo(e){let{components:n,...t}=e;return(0,s.yg)(qHo,(0,p.A)({},VHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node for drawing a smooth line through a number of points."))}jHo.isMDXComponent=!0;const HHo={toc:[]},YHo="wrapper";function QHo(e){let{components:n,...t}=e;return(0,s.yg)(YHo,(0,p.A)({},HHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}QHo.isMDXComponent=!0;const $Ho={toc:[]},KHo="wrapper";function JHo(e){let{components:n,...t}=e;return(0,s.yg)(KHo,(0,p.A)({},$Ho,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}JHo.isMDXComponent=!0;const ZHo={toc:[]},eYo="wrapper";function nYo(e){let{components:n,...t}=e;return(0,s.yg)(eYo,(0,p.A)({},ZHo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}nYo.isMDXComponent=!0;const tYo={toc:[]},oYo="wrapper";function pYo(e){let{components:n,...t}=e;return(0,s.yg)(oYo,(0,p.A)({},tYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}pYo.isMDXComponent=!0;const rYo={toc:[]},sYo="wrapper";function cYo(e){let{components:n,...t}=e;return(0,s.yg)(sYo,(0,p.A)({},rYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}cYo.isMDXComponent=!0;const aYo={toc:[]},iYo="wrapper";function lYo(e){let{components:n,...t}=e;return(0,s.yg)(iYo,(0,p.A)({},aYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}lYo.isMDXComponent=!0;const uYo={toc:[]},mYo="wrapper";function yYo(e){let{components:n,...t}=e;return(0,s.yg)(mYo,(0,p.A)({},uYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}yYo.isMDXComponent=!0;const dYo={toc:[]},hYo="wrapper";function gYo(e){let{components:n,...t}=e;return(0,s.yg)(hYo,(0,p.A)({},dYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}gYo.isMDXComponent=!0;const fYo={toc:[]},DYo="wrapper";function MYo(e){let{components:n,...t}=e;return(0,s.yg)(DYo,(0,p.A)({},fYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}MYo.isMDXComponent=!0;const XYo={toc:[]},_Yo="wrapper";function wYo(e){let{components:n,...t}=e;return(0,s.yg)(_Yo,(0,p.A)({},XYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}wYo.isMDXComponent=!0;const TYo={toc:[]},CYo="wrapper";function xYo(e){let{components:n,...t}=e;return(0,s.yg)(CYo,(0,p.A)({},TYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}xYo.isMDXComponent=!0;const AYo={toc:[]},vYo="wrapper";function LYo(e){let{components:n,...t}=e;return(0,s.yg)(vYo,(0,p.A)({},AYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}LYo.isMDXComponent=!0;const bYo={toc:[]},NYo="wrapper";function kYo(e){let{components:n,...t}=e;return(0,s.yg)(NYo,(0,p.A)({},bYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}kYo.isMDXComponent=!0;const zYo={toc:[]},PYo="wrapper";function IYo(e){let{components:n,...t}=e;return(0,s.yg)(PYo,(0,p.A)({},zYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}IYo.isMDXComponent=!0;const RYo={toc:[]},WYo="wrapper";function SYo(e){let{components:n,...t}=e;return(0,s.yg)(WYo,(0,p.A)({},RYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}SYo.isMDXComponent=!0;const BYo={toc:[]},EYo="wrapper";function GYo(e){let{components:n,...t}=e;return(0,s.yg)(EYo,(0,p.A)({},BYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}GYo.isMDXComponent=!0;const OYo={toc:[]},UYo="wrapper";function FYo(e){let{components:n,...t}=e;return(0,s.yg)(UYo,(0,p.A)({},OYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}FYo.isMDXComponent=!0;const VYo={toc:[]},qYo="wrapper";function jYo(e){let{components:n,...t}=e;return(0,s.yg)(qYo,(0,p.A)({},VYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}jYo.isMDXComponent=!0;const HYo={toc:[]},YYo="wrapper";function QYo(e){let{components:n,...t}=e;return(0,s.yg)(YYo,(0,p.A)({},HYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}QYo.isMDXComponent=!0;const $Yo={toc:[]},KYo="wrapper";function JYo(e){let{components:n,...t}=e;return(0,s.yg)(KYo,(0,p.A)({},$Yo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}JYo.isMDXComponent=!0;const ZYo={toc:[]},eQo="wrapper";function nQo(e){let{components:n,...t}=e;return(0,s.yg)(eQo,(0,p.A)({},ZYo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}nQo.isMDXComponent=!0;const tQo={toc:[]},oQo="wrapper";function pQo(e){let{components:n,...t}=e;return(0,s.yg)(oQo,(0,p.A)({},tQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}pQo.isMDXComponent=!0;const rQo={toc:[]},sQo="wrapper";function cQo(e){let{components:n,...t}=e;return(0,s.yg)(sQo,(0,p.A)({},rQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}cQo.isMDXComponent=!0;const aQo={toc:[]},iQo="wrapper";function lQo(e){let{components:n,...t}=e;return(0,s.yg)(iQo,(0,p.A)({},aQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}lQo.isMDXComponent=!0;const uQo={toc:[]},mQo="wrapper";function yQo(e){let{components:n,...t}=e;return(0,s.yg)(mQo,(0,p.A)({},uQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}yQo.isMDXComponent=!0;const dQo={toc:[]},hQo="wrapper";function gQo(e){let{components:n,...t}=e;return(0,s.yg)(hQo,(0,p.A)({},dQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}gQo.isMDXComponent=!0;const fQo={toc:[]},DQo="wrapper";function MQo(e){let{components:n,...t}=e;return(0,s.yg)(DQo,(0,p.A)({},fQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}MQo.isMDXComponent=!0;const XQo={toc:[]},_Qo="wrapper";function wQo(e){let{components:n,...t}=e;return(0,s.yg)(_Qo,(0,p.A)({},XQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}wQo.isMDXComponent=!0;const TQo={toc:[]},CQo="wrapper";function xQo(e){let{components:n,...t}=e;return(0,s.yg)(CQo,(0,p.A)({},TQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}xQo.isMDXComponent=!0;const AQo={toc:[]},vQo="wrapper";function LQo(e){let{components:n,...t}=e;return(0,s.yg)(vQo,(0,p.A)({},AQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}LQo.isMDXComponent=!0;const bQo={toc:[]},NQo="wrapper";function kQo(e){let{components:n,...t}=e;return(0,s.yg)(NQo,(0,p.A)({},bQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}kQo.isMDXComponent=!0;const zQo={toc:[]},PQo="wrapper";function IQo(e){let{components:n,...t}=e;return(0,s.yg)(PQo,(0,p.A)({},zQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}IQo.isMDXComponent=!0;const RQo={toc:[]},WQo="wrapper";function SQo(e){let{components:n,...t}=e;return(0,s.yg)(WQo,(0,p.A)({},RQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"You can control the smoothness of the resulting curve\nvia the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothness"))," property."))}SQo.isMDXComponent=!0;const BQo={toc:[]},EQo="wrapper";function GQo(e){let{components:n,...t}=e;return(0,s.yg)(EQo,(0,p.A)({},BQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The knots of the spline as an array of knots with auto-calculated handles."))}GQo.isMDXComponent=!0;const OQo={toc:[]},UQo="wrapper";function FQo(e){let{components:n,...t}=e;return(0,s.yg)(UQo,(0,p.A)({},OQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}FQo.isMDXComponent=!0;const VQo={toc:[]},qQo="wrapper";function jQo(e){let{components:n,...t}=e;return(0,s.yg)(qQo,(0,p.A)({},VQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}jQo.isMDXComponent=!0;const HQo={toc:[]},YQo="wrapper";function QQo(e){let{components:n,...t}=e;return(0,s.yg)(YQo,(0,p.A)({},HQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}QQo.isMDXComponent=!0;const $Qo={toc:[]},KQo="wrapper";function JQo(e){let{components:n,...t}=e;return(0,s.yg)(KQo,(0,p.A)({},$Qo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}JQo.isMDXComponent=!0;const ZQo={toc:[]},e$o="wrapper";function n$o(e){let{components:n,...t}=e;return(0,s.yg)(e$o,(0,p.A)({},ZQo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}n$o.isMDXComponent=!0;const t$o={toc:[]},o$o="wrapper";function p$o(e){let{components:n,...t}=e;return(0,s.yg)(o$o,(0,p.A)({},t$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}p$o.isMDXComponent=!0;const r$o={toc:[]},s$o="wrapper";function c$o(e){let{components:n,...t}=e;return(0,s.yg)(s$o,(0,p.A)({},r$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}c$o.isMDXComponent=!0;const a$o={toc:[]},i$o="wrapper";function l$o(e){let{components:n,...t}=e;return(0,s.yg)(i$o,(0,p.A)({},a$o,t,{components:n,mdxType:"MDXLayout"}))}l$o.isMDXComponent=!0;const u$o={toc:[]},m$o="wrapper";function y$o(e){let{components:n,...t}=e;return(0,s.yg)(m$o,(0,p.A)({},u$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}y$o.isMDXComponent=!0;const d$o={toc:[]},h$o="wrapper";function g$o(e){let{components:n,...t}=e;return(0,s.yg)(h$o,(0,p.A)({},d$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}g$o.isMDXComponent=!0;const f$o={toc:[]},D$o="wrapper";function M$o(e){let{components:n,...t}=e;return(0,s.yg)(D$o,(0,p.A)({},f$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}M$o.isMDXComponent=!0;const X$o={toc:[]},_$o="wrapper";function w$o(e){let{components:n,...t}=e;return(0,s.yg)(_$o,(0,p.A)({},X$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}w$o.isMDXComponent=!0;const T$o={toc:[]},C$o="wrapper";function x$o(e){let{components:n,...t}=e;return(0,s.yg)(C$o,(0,p.A)({},T$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}x$o.isMDXComponent=!0;const A$o={toc:[]},v$o="wrapper";function L$o(e){let{components:n,...t}=e;return(0,s.yg)(v$o,(0,p.A)({},A$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property is only applied to knots that don't use explicit handles."))}L$o.isMDXComponent=!0;const b$o={toc:[]},N$o="wrapper";function k$o(e){let{components:n,...t}=e;return(0,s.yg)(N$o,(0,p.A)({},b$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"0.4"))}k$o.isMDXComponent=!0;const z$o={toc:[]},P$o="wrapper";function I$o(e){let{components:n,...t}=e;return(0,s.yg)(P$o,(0,p.A)({},z$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The smoothness of the spline when using auto-calculated handles."))}I$o.isMDXComponent=!0;const R$o={toc:[]},W$o="wrapper";function S$o(e){let{components:n,...t}=e;return(0,s.yg)(W$o,(0,p.A)({},R$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}S$o.isMDXComponent=!0;const B$o={toc:[]},E$o="wrapper";function G$o(e){let{components:n,...t}=e;return(0,s.yg)(E$o,(0,p.A)({},B$o,t,{components:n,mdxType:"MDXLayout"}))}G$o.isMDXComponent=!0;const O$o={toc:[]},U$o="wrapper";function F$o(e){let{components:n,...t}=e;return(0,s.yg)(U$o,(0,p.A)({},O$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}F$o.isMDXComponent=!0;const V$o={toc:[]},q$o="wrapper";function j$o(e){let{components:n,...t}=e;return(0,s.yg)(q$o,(0,p.A)({},V$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}j$o.isMDXComponent=!0;const H$o={toc:[]},Y$o="wrapper";function Q$o(e){let{components:n,...t}=e;return(0,s.yg)(Y$o,(0,p.A)({},H$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Q$o.isMDXComponent=!0;const $$o={toc:[]},K$o="wrapper";function J$o(e){let{components:n,...t}=e;return(0,s.yg)(K$o,(0,p.A)({},$$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}J$o.isMDXComponent=!0;const Z$o={toc:[]},eKo="wrapper";function nKo(e){let{components:n,...t}=e;return(0,s.yg)(eKo,(0,p.A)({},Z$o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}nKo.isMDXComponent=!0;const tKo={toc:[]},oKo="wrapper";function pKo(e){let{components:n,...t}=e;return(0,s.yg)(oKo,(0,p.A)({},tKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}pKo.isMDXComponent=!0;const rKo={toc:[]},sKo="wrapper";function cKo(e){let{components:n,...t}=e;return(0,s.yg)(sKo,(0,p.A)({},rKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}cKo.isMDXComponent=!0;const aKo={toc:[]},iKo="wrapper";function lKo(e){let{components:n,...t}=e;return(0,s.yg)(iKo,(0,p.A)({},aKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}lKo.isMDXComponent=!0;const uKo={toc:[]},mKo="wrapper";function yKo(e){let{components:n,...t}=e;return(0,s.yg)(mKo,(0,p.A)({},uKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}yKo.isMDXComponent=!0;const dKo={toc:[]},hKo="wrapper";function gKo(e){let{components:n,...t}=e;return(0,s.yg)(hKo,(0,p.A)({},dKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}gKo.isMDXComponent=!0;const fKo={toc:[]},DKo="wrapper";function MKo(e){let{components:n,...t}=e;return(0,s.yg)(DKo,(0,p.A)({},fKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}MKo.isMDXComponent=!0;const XKo={toc:[]},_Ko="wrapper";function wKo(e){let{components:n,...t}=e;return(0,s.yg)(_Ko,(0,p.A)({},XKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}wKo.isMDXComponent=!0;const TKo={toc:[]},CKo="wrapper";function xKo(e){let{components:n,...t}=e;return(0,s.yg)(CKo,(0,p.A)({},TKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}xKo.isMDXComponent=!0;const AKo={toc:[]},vKo="wrapper";function LKo(e){let{components:n,...t}=e;return(0,s.yg)(vKo,(0,p.A)({},AKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}LKo.isMDXComponent=!0;const bKo={toc:[]},NKo="wrapper";function kKo(e){let{components:n,...t}=e;return(0,s.yg)(NKo,(0,p.A)({},bKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}kKo.isMDXComponent=!0;const zKo={toc:[]},PKo="wrapper";function IKo(e){let{components:n,...t}=e;return(0,s.yg)(PKo,(0,p.A)({},zKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}IKo.isMDXComponent=!0;const RKo={toc:[]},WKo="wrapper";function SKo(e){let{components:n,...t}=e;return(0,s.yg)(WKo,(0,p.A)({},RKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}SKo.isMDXComponent=!0;const BKo={toc:[]},EKo="wrapper";function GKo(e){let{components:n,...t}=e;return(0,s.yg)(EKo,(0,p.A)({},BKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}GKo.isMDXComponent=!0;const OKo={toc:[]},UKo="wrapper";function FKo(e){let{components:n,...t}=e;return(0,s.yg)(UKo,(0,p.A)({},OKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}FKo.isMDXComponent=!0;const VKo={toc:[]},qKo="wrapper";function jKo(e){let{components:n,...t}=e;return(0,s.yg)(qKo,(0,p.A)({},VKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}jKo.isMDXComponent=!0;const HKo={toc:[]},YKo="wrapper";function QKo(e){let{components:n,...t}=e;return(0,s.yg)(YKo,(0,p.A)({},HKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}QKo.isMDXComponent=!0;const $Ko={toc:[]},KKo="wrapper";function JKo(e){let{components:n,...t}=e;return(0,s.yg)(KKo,(0,p.A)({},$Ko,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}JKo.isMDXComponent=!0;const ZKo={toc:[]},eJo="wrapper";function nJo(e){let{components:n,...t}=e;return(0,s.yg)(eJo,(0,p.A)({},ZKo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}nJo.isMDXComponent=!0;const tJo={toc:[]},oJo="wrapper";function pJo(e){let{components:n,...t}=e;return(0,s.yg)(oJo,(0,p.A)({},tJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}pJo.isMDXComponent=!0;const rJo={toc:[]},sJo="wrapper";function cJo(e){let{components:n,...t}=e;return(0,s.yg)(sJo,(0,p.A)({},rJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}cJo.isMDXComponent=!0;const aJo={toc:[]},iJo="wrapper";function lJo(e){let{components:n,...t}=e;return(0,s.yg)(iJo,(0,p.A)({},aJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}lJo.isMDXComponent=!0;const uJo={toc:[]},mJo="wrapper";function yJo(e){let{components:n,...t}=e;return(0,s.yg)(mJo,(0,p.A)({},uJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}yJo.isMDXComponent=!0;const dJo={toc:[]},hJo="wrapper";function gJo(e){let{components:n,...t}=e;return(0,s.yg)(hJo,(0,p.A)({},dJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}gJo.isMDXComponent=!0;const fJo={toc:[]},DJo="wrapper";function MJo(e){let{components:n,...t}=e;return(0,s.yg)(DJo,(0,p.A)({},fJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}MJo.isMDXComponent=!0;const XJo={toc:[]},_Jo="wrapper";function wJo(e){let{components:n,...t}=e;return(0,s.yg)(_Jo,(0,p.A)({},XJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}wJo.isMDXComponent=!0;const TJo={toc:[]},CJo="wrapper";function xJo(e){let{components:n,...t}=e;return(0,s.yg)(CJo,(0,p.A)({},TJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}xJo.isMDXComponent=!0;const AJo={toc:[]},vJo="wrapper";function LJo(e){let{components:n,...t}=e;return(0,s.yg)(vJo,(0,p.A)({},AJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}LJo.isMDXComponent=!0;const bJo={toc:[]},NJo="wrapper";function kJo(e){let{components:n,...t}=e;return(0,s.yg)(NJo,(0,p.A)({},bJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}kJo.isMDXComponent=!0;const zJo={toc:[]},PJo="wrapper";function IJo(e){let{components:n,...t}=e;return(0,s.yg)(PJo,(0,p.A)({},zJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}IJo.isMDXComponent=!0;const RJo={toc:[]},WJo="wrapper";function SJo(e){let{components:n,...t}=e;return(0,s.yg)(WJo,(0,p.A)({},RJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}SJo.isMDXComponent=!0;const BJo={toc:[]},EJo="wrapper";function GJo(e){let{components:n,...t}=e;return(0,s.yg)(EJo,(0,p.A)({},BJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}GJo.isMDXComponent=!0;const OJo={toc:[]},UJo="wrapper";function FJo(e){let{components:n,...t}=e;return(0,s.yg)(UJo,(0,p.A)({},OJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}FJo.isMDXComponent=!0;const VJo={toc:[]},qJo="wrapper";function jJo(e){let{components:n,...t}=e;return(0,s.yg)(qJo,(0,p.A)({},VJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}jJo.isMDXComponent=!0;const HJo={toc:[]},YJo="wrapper";function QJo(e){let{components:n,...t}=e;return(0,s.yg)(YJo,(0,p.A)({},HJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}QJo.isMDXComponent=!0;const $Jo={toc:[]},KJo="wrapper";function JJo(e){let{components:n,...t}=e;return(0,s.yg)(KJo,(0,p.A)({},$Jo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}JJo.isMDXComponent=!0;const ZJo={toc:[]},eZo="wrapper";function nZo(e){let{components:n,...t}=e;return(0,s.yg)(eZo,(0,p.A)({},ZJo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}nZo.isMDXComponent=!0;const tZo={toc:[]},oZo="wrapper";function pZo(e){let{components:n,...t}=e;return(0,s.yg)(oZo,(0,p.A)({},tZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}pZo.isMDXComponent=!0;const rZo={toc:[]},sZo="wrapper";function cZo(e){let{components:n,...t}=e;return(0,s.yg)(sZo,(0,p.A)({},rZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}cZo.isMDXComponent=!0;const aZo={toc:[]},iZo="wrapper";function lZo(e){let{components:n,...t}=e;return(0,s.yg)(iZo,(0,p.A)({},aZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}lZo.isMDXComponent=!0;const uZo={toc:[]},mZo="wrapper";function yZo(e){let{components:n,...t}=e;return(0,s.yg)(mZo,(0,p.A)({},uZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}yZo.isMDXComponent=!0;const dZo={toc:[]},hZo="wrapper";function gZo(e){let{components:n,...t}=e;return(0,s.yg)(hZo,(0,p.A)({},dZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}gZo.isMDXComponent=!0;const fZo={toc:[]},DZo="wrapper";function MZo(e){let{components:n,...t}=e;return(0,s.yg)(DZo,(0,p.A)({},fZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}MZo.isMDXComponent=!0;const XZo={toc:[]},_Zo="wrapper";function wZo(e){let{components:n,...t}=e;return(0,s.yg)(_Zo,(0,p.A)({},XZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}wZo.isMDXComponent=!0;const TZo={toc:[]},CZo="wrapper";function xZo(e){let{components:n,...t}=e;return(0,s.yg)(CZo,(0,p.A)({},TZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}xZo.isMDXComponent=!0;const AZo={toc:[]},vZo="wrapper";function LZo(e){let{components:n,...t}=e;return(0,s.yg)(vZo,(0,p.A)({},AZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}LZo.isMDXComponent=!0;const bZo={toc:[]},NZo="wrapper";function kZo(e){let{components:n,...t}=e;return(0,s.yg)(NZo,(0,p.A)({},bZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}kZo.isMDXComponent=!0;const zZo={toc:[]},PZo="wrapper";function IZo(e){let{components:n,...t}=e;return(0,s.yg)(PZo,(0,p.A)({},zZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}IZo.isMDXComponent=!0;const RZo={toc:[]},WZo="wrapper";function SZo(e){let{components:n,...t}=e;return(0,s.yg)(WZo,(0,p.A)({},RZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}SZo.isMDXComponent=!0;const BZo={toc:[]},EZo="wrapper";function GZo(e){let{components:n,...t}=e;return(0,s.yg)(EZo,(0,p.A)({},BZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}GZo.isMDXComponent=!0;const OZo={toc:[]},UZo="wrapper";function FZo(e){let{components:n,...t}=e;return(0,s.yg)(UZo,(0,p.A)({},OZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}FZo.isMDXComponent=!0;const VZo={toc:[]},qZo="wrapper";function jZo(e){let{components:n,...t}=e;return(0,s.yg)(qZo,(0,p.A)({},VZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}jZo.isMDXComponent=!0;const HZo={toc:[]},YZo="wrapper";function QZo(e){let{components:n,...t}=e;return(0,s.yg)(YZo,(0,p.A)({},HZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}QZo.isMDXComponent=!0;const $Zo={toc:[]},KZo="wrapper";function JZo(e){let{components:n,...t}=e;return(0,s.yg)(KZo,(0,p.A)({},$Zo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}JZo.isMDXComponent=!0;const ZZo={toc:[]},e0o="wrapper";function n0o(e){let{components:n,...t}=e;return(0,s.yg)(e0o,(0,p.A)({},ZZo,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}n0o.isMDXComponent=!0;const t0o={toc:[]},o0o="wrapper";function p0o(e){let{components:n,...t}=e;return(0,s.yg)(o0o,(0,p.A)({},t0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}p0o.isMDXComponent=!0;const r0o={toc:[]},s0o="wrapper";function c0o(e){let{components:n,...t}=e;return(0,s.yg)(s0o,(0,p.A)({},r0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}c0o.isMDXComponent=!0;const a0o={toc:[]},i0o="wrapper";function l0o(e){let{components:n,...t}=e;return(0,s.yg)(i0o,(0,p.A)({},a0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}l0o.isMDXComponent=!0;const u0o={toc:[]},m0o="wrapper";function y0o(e){let{components:n,...t}=e;return(0,s.yg)(m0o,(0,p.A)({},u0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}y0o.isMDXComponent=!0;const d0o={toc:[]},h0o="wrapper";function g0o(e){let{components:n,...t}=e;return(0,s.yg)(h0o,(0,p.A)({},d0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}g0o.isMDXComponent=!0;const f0o={toc:[]},D0o="wrapper";function M0o(e){let{components:n,...t}=e;return(0,s.yg)(D0o,(0,p.A)({},f0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}M0o.isMDXComponent=!0;const X0o={toc:[]},_0o="wrapper";function w0o(e){let{components:n,...t}=e;return(0,s.yg)(_0o,(0,p.A)({},X0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}w0o.isMDXComponent=!0;const T0o={toc:[]},C0o="wrapper";function x0o(e){let{components:n,...t}=e;return(0,s.yg)(C0o,(0,p.A)({},T0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}x0o.isMDXComponent=!0;const A0o={toc:[]},v0o="wrapper";function L0o(e){let{components:n,...t}=e;return(0,s.yg)(v0o,(0,p.A)({},A0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}L0o.isMDXComponent=!0;const b0o={toc:[]},N0o="wrapper";function k0o(e){let{components:n,...t}=e;return(0,s.yg)(N0o,(0,p.A)({},b0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}k0o.isMDXComponent=!0;const z0o={toc:[]},P0o="wrapper";function I0o(e){let{components:n,...t}=e;return(0,s.yg)(P0o,(0,p.A)({},z0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}I0o.isMDXComponent=!0;const R0o={toc:[]},W0o="wrapper";function S0o(e){let{components:n,...t}=e;return(0,s.yg)(W0o,(0,p.A)({},R0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}S0o.isMDXComponent=!0;const B0o={toc:[]},E0o="wrapper";function G0o(e){let{components:n,...t}=e;return(0,s.yg)(E0o,(0,p.A)({},B0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}G0o.isMDXComponent=!0;const O0o={toc:[]},U0o="wrapper";function F0o(e){let{components:n,...t}=e;return(0,s.yg)(U0o,(0,p.A)({},O0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}F0o.isMDXComponent=!0;const V0o={toc:[]},q0o="wrapper";function j0o(e){let{components:n,...t}=e;return(0,s.yg)(q0o,(0,p.A)({},V0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}j0o.isMDXComponent=!0;const H0o={toc:[]},Y0o="wrapper";function Q0o(e){let{components:n,...t}=e;return(0,s.yg)(Y0o,(0,p.A)({},H0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}Q0o.isMDXComponent=!0;const $0o={toc:[]},K0o="wrapper";function J0o(e){let{components:n,...t}=e;return(0,s.yg)(K0o,(0,p.A)({},$0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}J0o.isMDXComponent=!0;const Z0o={toc:[]},e3o="wrapper";function n3o(e){let{components:n,...t}=e;return(0,s.yg)(e3o,(0,p.A)({},Z0o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}n3o.isMDXComponent=!0;const t3o={toc:[]},o3o="wrapper";function p3o(e){let{components:n,...t}=e;return(0,s.yg)(o3o,(0,p.A)({},t3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}p3o.isMDXComponent=!0;const r3o={toc:[]},s3o="wrapper";function c3o(e){let{components:n,...t}=e;return(0,s.yg)(s3o,(0,p.A)({},r3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}c3o.isMDXComponent=!0;const a3o={toc:[]},i3o="wrapper";function l3o(e){let{components:n,...t}=e;return(0,s.yg)(i3o,(0,p.A)({},a3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}l3o.isMDXComponent=!0;const u3o={toc:[]},m3o="wrapper";function y3o(e){let{components:n,...t}=e;return(0,s.yg)(m3o,(0,p.A)({},u3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}y3o.isMDXComponent=!0;const d3o={toc:[]},h3o="wrapper";function g3o(e){let{components:n,...t}=e;return(0,s.yg)(h3o,(0,p.A)({},d3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}g3o.isMDXComponent=!0;const f3o={toc:[]},D3o="wrapper";function M3o(e){let{components:n,...t}=e;return(0,s.yg)(D3o,(0,p.A)({},f3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}M3o.isMDXComponent=!0;const X3o={toc:[]},_3o="wrapper";function w3o(e){let{components:n,...t}=e;return(0,s.yg)(_3o,(0,p.A)({},X3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}w3o.isMDXComponent=!0;const T3o={toc:[]},C3o="wrapper";function x3o(e){let{components:n,...t}=e;return(0,s.yg)(C3o,(0,p.A)({},T3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}x3o.isMDXComponent=!0;const A3o={toc:[]},v3o="wrapper";function L3o(e){let{components:n,...t}=e;return(0,s.yg)(v3o,(0,p.A)({},A3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}L3o.isMDXComponent=!0;const b3o={toc:[]},N3o="wrapper";function k3o(e){let{components:n,...t}=e;return(0,s.yg)(N3o,(0,p.A)({},b3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}k3o.isMDXComponent=!0;const z3o={toc:[]},P3o="wrapper";function I3o(e){let{components:n,...t}=e;return(0,s.yg)(P3o,(0,p.A)({},z3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}I3o.isMDXComponent=!0;const R3o={toc:[]},W3o="wrapper";function S3o(e){let{components:n,...t}=e;return(0,s.yg)(W3o,(0,p.A)({},R3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}S3o.isMDXComponent=!0;const B3o={toc:[]},E3o="wrapper";function G3o(e){let{components:n,...t}=e;return(0,s.yg)(E3o,(0,p.A)({},B3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}G3o.isMDXComponent=!0;const O3o={toc:[]},U3o="wrapper";function F3o(e){let{components:n,...t}=e;return(0,s.yg)(U3o,(0,p.A)({},O3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}F3o.isMDXComponent=!0;const V3o={toc:[]},q3o="wrapper";function j3o(e){let{components:n,...t}=e;return(0,s.yg)(q3o,(0,p.A)({},V3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}j3o.isMDXComponent=!0;const H3o={toc:[]},Y3o="wrapper";function Q3o(e){let{components:n,...t}=e;return(0,s.yg)(Y3o,(0,p.A)({},H3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Q3o.isMDXComponent=!0;const $3o={toc:[]},K3o="wrapper";function J3o(e){let{components:n,...t}=e;return(0,s.yg)(K3o,(0,p.A)({},$3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}J3o.isMDXComponent=!0;const Z3o={toc:[]},e1o="wrapper";function n1o(e){let{components:n,...t}=e;return(0,s.yg)(e1o,(0,p.A)({},Z3o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}n1o.isMDXComponent=!0;const t1o={toc:[]},o1o="wrapper";function p1o(e){let{components:n,...t}=e;return(0,s.yg)(o1o,(0,p.A)({},t1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}p1o.isMDXComponent=!0;const r1o={toc:[]},s1o="wrapper";function c1o(e){let{components:n,...t}=e;return(0,s.yg)(s1o,(0,p.A)({},r1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}c1o.isMDXComponent=!0;const a1o={toc:[]},i1o="wrapper";function l1o(e){let{components:n,...t}=e;return(0,s.yg)(i1o,(0,p.A)({},a1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}l1o.isMDXComponent=!0;const u1o={toc:[]},m1o="wrapper";function y1o(e){let{components:n,...t}=e;return(0,s.yg)(m1o,(0,p.A)({},u1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}y1o.isMDXComponent=!0;const d1o={toc:[]},h1o="wrapper";function g1o(e){let{components:n,...t}=e;return(0,s.yg)(h1o,(0,p.A)({},d1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}g1o.isMDXComponent=!0;const f1o={toc:[]},D1o="wrapper";function M1o(e){let{components:n,...t}=e;return(0,s.yg)(D1o,(0,p.A)({},f1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}M1o.isMDXComponent=!0;const X1o={toc:[]},_1o="wrapper";function w1o(e){let{components:n,...t}=e;return(0,s.yg)(_1o,(0,p.A)({},X1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}w1o.isMDXComponent=!0;const T1o={toc:[]},C1o="wrapper";function x1o(e){let{components:n,...t}=e;return(0,s.yg)(C1o,(0,p.A)({},T1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}x1o.isMDXComponent=!0;const A1o={toc:[]},v1o="wrapper";function L1o(e){let{components:n,...t}=e;return(0,s.yg)(v1o,(0,p.A)({},A1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}L1o.isMDXComponent=!0;const b1o={toc:[]},N1o="wrapper";function k1o(e){let{components:n,...t}=e;return(0,s.yg)(N1o,(0,p.A)({},b1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}k1o.isMDXComponent=!0;const z1o={toc:[]},P1o="wrapper";function I1o(e){let{components:n,...t}=e;return(0,s.yg)(P1o,(0,p.A)({},z1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}I1o.isMDXComponent=!0;const R1o={toc:[]},W1o="wrapper";function S1o(e){let{components:n,...t}=e;return(0,s.yg)(W1o,(0,p.A)({},R1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}S1o.isMDXComponent=!0;const B1o={toc:[]},E1o="wrapper";function G1o(e){let{components:n,...t}=e;return(0,s.yg)(E1o,(0,p.A)({},B1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}G1o.isMDXComponent=!0;const O1o={toc:[]},U1o="wrapper";function F1o(e){let{components:n,...t}=e;return(0,s.yg)(U1o,(0,p.A)({},O1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}F1o.isMDXComponent=!0;const V1o={toc:[]},q1o="wrapper";function j1o(e){let{components:n,...t}=e;return(0,s.yg)(q1o,(0,p.A)({},V1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}j1o.isMDXComponent=!0;const H1o={toc:[]},Y1o="wrapper";function Q1o(e){let{components:n,...t}=e;return(0,s.yg)(Y1o,(0,p.A)({},H1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}Q1o.isMDXComponent=!0;const $1o={toc:[]},K1o="wrapper";function J1o(e){let{components:n,...t}=e;return(0,s.yg)(K1o,(0,p.A)({},$1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}J1o.isMDXComponent=!0;const Z1o={toc:[]},e9o="wrapper";function n9o(e){let{components:n,...t}=e;return(0,s.yg)(e9o,(0,p.A)({},Z1o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}n9o.isMDXComponent=!0;const t9o={toc:[]},o9o="wrapper";function p9o(e){let{components:n,...t}=e;return(0,s.yg)(o9o,(0,p.A)({},t9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}p9o.isMDXComponent=!0;const r9o={toc:[]},s9o="wrapper";function c9o(e){let{components:n,...t}=e;return(0,s.yg)(s9o,(0,p.A)({},r9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}c9o.isMDXComponent=!0;const a9o={toc:[]},i9o="wrapper";function l9o(e){let{components:n,...t}=e;return(0,s.yg)(i9o,(0,p.A)({},a9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}l9o.isMDXComponent=!0;const u9o={toc:[]},m9o="wrapper";function y9o(e){let{components:n,...t}=e;return(0,s.yg)(m9o,(0,p.A)({},u9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}y9o.isMDXComponent=!0;const d9o={toc:[]},h9o="wrapper";function g9o(e){let{components:n,...t}=e;return(0,s.yg)(h9o,(0,p.A)({},d9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}g9o.isMDXComponent=!0;const f9o={toc:[]},D9o="wrapper";function M9o(e){let{components:n,...t}=e;return(0,s.yg)(D9o,(0,p.A)({},f9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}M9o.isMDXComponent=!0;const X9o={toc:[]},_9o="wrapper";function w9o(e){let{components:n,...t}=e;return(0,s.yg)(_9o,(0,p.A)({},X9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}w9o.isMDXComponent=!0;const T9o={toc:[]},C9o="wrapper";function x9o(e){let{components:n,...t}=e;return(0,s.yg)(C9o,(0,p.A)({},T9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}x9o.isMDXComponent=!0;const A9o={toc:[]},v9o="wrapper";function L9o(e){let{components:n,...t}=e;return(0,s.yg)(v9o,(0,p.A)({},A9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}L9o.isMDXComponent=!0;const b9o={toc:[]},N9o="wrapper";function k9o(e){let{components:n,...t}=e;return(0,s.yg)(N9o,(0,p.A)({},b9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}k9o.isMDXComponent=!0;const z9o={toc:[]},P9o="wrapper";function I9o(e){let{components:n,...t}=e;return(0,s.yg)(P9o,(0,p.A)({},z9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}I9o.isMDXComponent=!0;const R9o={toc:[]},W9o="wrapper";function S9o(e){let{components:n,...t}=e;return(0,s.yg)(W9o,(0,p.A)({},R9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}S9o.isMDXComponent=!0;const B9o={toc:[]},E9o="wrapper";function G9o(e){let{components:n,...t}=e;return(0,s.yg)(E9o,(0,p.A)({},B9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}G9o.isMDXComponent=!0;const O9o={toc:[]},U9o="wrapper";function F9o(e){let{components:n,...t}=e;return(0,s.yg)(U9o,(0,p.A)({},O9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}F9o.isMDXComponent=!0;const V9o={toc:[]},q9o="wrapper";function j9o(e){let{components:n,...t}=e;return(0,s.yg)(q9o,(0,p.A)({},V9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}j9o.isMDXComponent=!0;const H9o={toc:[]},Y9o="wrapper";function Q9o(e){let{components:n,...t}=e;return(0,s.yg)(Y9o,(0,p.A)({},H9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}Q9o.isMDXComponent=!0;const $9o={toc:[]},K9o="wrapper";function J9o(e){let{components:n,...t}=e;return(0,s.yg)(K9o,(0,p.A)({},$9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}J9o.isMDXComponent=!0;const Z9o={toc:[]},e2o="wrapper";function n2o(e){let{components:n,...t}=e;return(0,s.yg)(e2o,(0,p.A)({},Z9o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}n2o.isMDXComponent=!0;const t2o={toc:[]},o2o="wrapper";function p2o(e){let{components:n,...t}=e;return(0,s.yg)(o2o,(0,p.A)({},t2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}p2o.isMDXComponent=!0;const r2o={toc:[]},s2o="wrapper";function c2o(e){let{components:n,...t}=e;return(0,s.yg)(s2o,(0,p.A)({},r2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}c2o.isMDXComponent=!0;const a2o={toc:[]},i2o="wrapper";function l2o(e){let{components:n,...t}=e;return(0,s.yg)(i2o,(0,p.A)({},a2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}l2o.isMDXComponent=!0;const u2o={toc:[]},m2o="wrapper";function y2o(e){let{components:n,...t}=e;return(0,s.yg)(m2o,(0,p.A)({},u2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}y2o.isMDXComponent=!0;const d2o={toc:[]},h2o="wrapper";function g2o(e){let{components:n,...t}=e;return(0,s.yg)(h2o,(0,p.A)({},d2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}g2o.isMDXComponent=!0;const f2o={toc:[]},D2o="wrapper";function M2o(e){let{components:n,...t}=e;return(0,s.yg)(D2o,(0,p.A)({},f2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}M2o.isMDXComponent=!0;const X2o={toc:[]},_2o="wrapper";function w2o(e){let{components:n,...t}=e;return(0,s.yg)(_2o,(0,p.A)({},X2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}w2o.isMDXComponent=!0;const T2o={toc:[]},C2o="wrapper";function x2o(e){let{components:n,...t}=e;return(0,s.yg)(C2o,(0,p.A)({},T2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}x2o.isMDXComponent=!0;const A2o={toc:[]},v2o="wrapper";function L2o(e){let{components:n,...t}=e;return(0,s.yg)(v2o,(0,p.A)({},A2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}L2o.isMDXComponent=!0;const b2o={toc:[]},N2o="wrapper";function k2o(e){let{components:n,...t}=e;return(0,s.yg)(N2o,(0,p.A)({},b2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}k2o.isMDXComponent=!0;const z2o={toc:[]},P2o="wrapper";function I2o(e){let{components:n,...t}=e;return(0,s.yg)(P2o,(0,p.A)({},z2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}I2o.isMDXComponent=!0;const R2o={toc:[]},W2o="wrapper";function S2o(e){let{components:n,...t}=e;return(0,s.yg)(W2o,(0,p.A)({},R2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}S2o.isMDXComponent=!0;const B2o={toc:[]},E2o="wrapper";function G2o(e){let{components:n,...t}=e;return(0,s.yg)(E2o,(0,p.A)({},B2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}G2o.isMDXComponent=!0;const O2o={toc:[]},U2o="wrapper";function F2o(e){let{components:n,...t}=e;return(0,s.yg)(U2o,(0,p.A)({},O2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}F2o.isMDXComponent=!0;const V2o={toc:[]},q2o="wrapper";function j2o(e){let{components:n,...t}=e;return(0,s.yg)(q2o,(0,p.A)({},V2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}j2o.isMDXComponent=!0;const H2o={toc:[]},Y2o="wrapper";function Q2o(e){let{components:n,...t}=e;return(0,s.yg)(Y2o,(0,p.A)({},H2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Q2o.isMDXComponent=!0;const $2o={toc:[]},K2o="wrapper";function J2o(e){let{components:n,...t}=e;return(0,s.yg)(K2o,(0,p.A)({},$2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}J2o.isMDXComponent=!0;const Z2o={toc:[]},e4o="wrapper";function n4o(e){let{components:n,...t}=e;return(0,s.yg)(e4o,(0,p.A)({},Z2o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}n4o.isMDXComponent=!0;const t4o={toc:[]},o4o="wrapper";function p4o(e){let{components:n,...t}=e;return(0,s.yg)(o4o,(0,p.A)({},t4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}p4o.isMDXComponent=!0;const r4o={toc:[]},s4o="wrapper";function c4o(e){let{components:n,...t}=e;return(0,s.yg)(s4o,(0,p.A)({},r4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}c4o.isMDXComponent=!0;const a4o={toc:[]},i4o="wrapper";function l4o(e){let{components:n,...t}=e;return(0,s.yg)(i4o,(0,p.A)({},a4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}l4o.isMDXComponent=!0;const u4o={toc:[]},m4o="wrapper";function y4o(e){let{components:n,...t}=e;return(0,s.yg)(m4o,(0,p.A)({},u4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}y4o.isMDXComponent=!0;const d4o={toc:[]},h4o="wrapper";function g4o(e){let{components:n,...t}=e;return(0,s.yg)(h4o,(0,p.A)({},d4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}g4o.isMDXComponent=!0;const f4o={toc:[]},D4o="wrapper";function M4o(e){let{components:n,...t}=e;return(0,s.yg)(D4o,(0,p.A)({},f4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}M4o.isMDXComponent=!0;const X4o={toc:[]},_4o="wrapper";function w4o(e){let{components:n,...t}=e;return(0,s.yg)(_4o,(0,p.A)({},X4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}w4o.isMDXComponent=!0;const T4o={toc:[]},C4o="wrapper";function x4o(e){let{components:n,...t}=e;return(0,s.yg)(C4o,(0,p.A)({},T4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}x4o.isMDXComponent=!0;const A4o={toc:[]},v4o="wrapper";function L4o(e){let{components:n,...t}=e;return(0,s.yg)(v4o,(0,p.A)({},A4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}L4o.isMDXComponent=!0;const b4o={toc:[]},N4o="wrapper";function k4o(e){let{components:n,...t}=e;return(0,s.yg)(N4o,(0,p.A)({},b4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}k4o.isMDXComponent=!0;const z4o={toc:[]},P4o="wrapper";function I4o(e){let{components:n,...t}=e;return(0,s.yg)(P4o,(0,p.A)({},z4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}I4o.isMDXComponent=!0;const R4o={toc:[]},W4o="wrapper";function S4o(e){let{components:n,...t}=e;return(0,s.yg)(W4o,(0,p.A)({},R4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}S4o.isMDXComponent=!0;const B4o={toc:[]},E4o="wrapper";function G4o(e){let{components:n,...t}=e;return(0,s.yg)(E4o,(0,p.A)({},B4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}G4o.isMDXComponent=!0;const O4o={toc:[]},U4o="wrapper";function F4o(e){let{components:n,...t}=e;return(0,s.yg)(U4o,(0,p.A)({},O4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}F4o.isMDXComponent=!0;const V4o={toc:[]},q4o="wrapper";function j4o(e){let{components:n,...t}=e;return(0,s.yg)(q4o,(0,p.A)({},V4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}j4o.isMDXComponent=!0;const H4o={toc:[]},Y4o="wrapper";function Q4o(e){let{components:n,...t}=e;return(0,s.yg)(Y4o,(0,p.A)({},H4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Q4o.isMDXComponent=!0;const $4o={toc:[]},K4o="wrapper";function J4o(e){let{components:n,...t}=e;return(0,s.yg)(K4o,(0,p.A)({},$4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}J4o.isMDXComponent=!0;const Z4o={toc:[]},e6o="wrapper";function n6o(e){let{components:n,...t}=e;return(0,s.yg)(e6o,(0,p.A)({},Z4o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}n6o.isMDXComponent=!0;const t6o={toc:[]},o6o="wrapper";function p6o(e){let{components:n,...t}=e;return(0,s.yg)(o6o,(0,p.A)({},t6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}p6o.isMDXComponent=!0;const r6o={toc:[]},s6o="wrapper";function c6o(e){let{components:n,...t}=e;return(0,s.yg)(s6o,(0,p.A)({},r6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}c6o.isMDXComponent=!0;const a6o={toc:[]},i6o="wrapper";function l6o(e){let{components:n,...t}=e;return(0,s.yg)(i6o,(0,p.A)({},a6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}l6o.isMDXComponent=!0;const u6o={toc:[]},m6o="wrapper";function y6o(e){let{components:n,...t}=e;return(0,s.yg)(m6o,(0,p.A)({},u6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}y6o.isMDXComponent=!0;const d6o={toc:[]},h6o="wrapper";function g6o(e){let{components:n,...t}=e;return(0,s.yg)(h6o,(0,p.A)({},d6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}g6o.isMDXComponent=!0;const f6o={toc:[]},D6o="wrapper";function M6o(e){let{components:n,...t}=e;return(0,s.yg)(D6o,(0,p.A)({},f6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}M6o.isMDXComponent=!0;const X6o={toc:[]},_6o="wrapper";function w6o(e){let{components:n,...t}=e;return(0,s.yg)(_6o,(0,p.A)({},X6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}w6o.isMDXComponent=!0;const T6o={toc:[]},C6o="wrapper";function x6o(e){let{components:n,...t}=e;return(0,s.yg)(C6o,(0,p.A)({},T6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}x6o.isMDXComponent=!0;const A6o={toc:[]},v6o="wrapper";function L6o(e){let{components:n,...t}=e;return(0,s.yg)(v6o,(0,p.A)({},A6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}L6o.isMDXComponent=!0;const b6o={toc:[]},N6o="wrapper";function k6o(e){let{components:n,...t}=e;return(0,s.yg)(N6o,(0,p.A)({},b6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}k6o.isMDXComponent=!0;const z6o={toc:[]},P6o="wrapper";function I6o(e){let{components:n,...t}=e;return(0,s.yg)(P6o,(0,p.A)({},z6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}I6o.isMDXComponent=!0;const R6o={toc:[]},W6o="wrapper";function S6o(e){let{components:n,...t}=e;return(0,s.yg)(W6o,(0,p.A)({},R6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}S6o.isMDXComponent=!0;const B6o={toc:[]},E6o="wrapper";function G6o(e){let{components:n,...t}=e;return(0,s.yg)(E6o,(0,p.A)({},B6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}G6o.isMDXComponent=!0;const O6o={toc:[]},U6o="wrapper";function F6o(e){let{components:n,...t}=e;return(0,s.yg)(U6o,(0,p.A)({},O6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}F6o.isMDXComponent=!0;const V6o={toc:[]},q6o="wrapper";function j6o(e){let{components:n,...t}=e;return(0,s.yg)(q6o,(0,p.A)({},V6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}j6o.isMDXComponent=!0;const H6o={toc:[]},Y6o="wrapper";function Q6o(e){let{components:n,...t}=e;return(0,s.yg)(Y6o,(0,p.A)({},H6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Q6o.isMDXComponent=!0;const $6o={toc:[]},K6o="wrapper";function J6o(e){let{components:n,...t}=e;return(0,s.yg)(K6o,(0,p.A)({},$6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}J6o.isMDXComponent=!0;const Z6o={toc:[]},e8o="wrapper";function n8o(e){let{components:n,...t}=e;return(0,s.yg)(e8o,(0,p.A)({},Z6o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}n8o.isMDXComponent=!0;const t8o={toc:[]},o8o="wrapper";function p8o(e){let{components:n,...t}=e;return(0,s.yg)(o8o,(0,p.A)({},t8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}p8o.isMDXComponent=!0;const r8o={toc:[]},s8o="wrapper";function c8o(e){let{components:n,...t}=e;return(0,s.yg)(s8o,(0,p.A)({},r8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}c8o.isMDXComponent=!0;const a8o={toc:[]},i8o="wrapper";function l8o(e){let{components:n,...t}=e;return(0,s.yg)(i8o,(0,p.A)({},a8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}l8o.isMDXComponent=!0;const u8o={toc:[]},m8o="wrapper";function y8o(e){let{components:n,...t}=e;return(0,s.yg)(m8o,(0,p.A)({},u8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}y8o.isMDXComponent=!0;const d8o={toc:[]},h8o="wrapper";function g8o(e){let{components:n,...t}=e;return(0,s.yg)(h8o,(0,p.A)({},d8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}g8o.isMDXComponent=!0;const f8o={toc:[]},D8o="wrapper";function M8o(e){let{components:n,...t}=e;return(0,s.yg)(D8o,(0,p.A)({},f8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}M8o.isMDXComponent=!0;const X8o={toc:[]},_8o="wrapper";function w8o(e){let{components:n,...t}=e;return(0,s.yg)(_8o,(0,p.A)({},X8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}w8o.isMDXComponent=!0;const T8o={toc:[]},C8o="wrapper";function x8o(e){let{components:n,...t}=e;return(0,s.yg)(C8o,(0,p.A)({},T8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}x8o.isMDXComponent=!0;const A8o={toc:[]},v8o="wrapper";function L8o(e){let{components:n,...t}=e;return(0,s.yg)(v8o,(0,p.A)({},A8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}L8o.isMDXComponent=!0;const b8o={toc:[]},N8o="wrapper";function k8o(e){let{components:n,...t}=e;return(0,s.yg)(N8o,(0,p.A)({},b8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}k8o.isMDXComponent=!0;const z8o={toc:[]},P8o="wrapper";function I8o(e){let{components:n,...t}=e;return(0,s.yg)(P8o,(0,p.A)({},z8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}I8o.isMDXComponent=!0;const R8o={toc:[]},W8o="wrapper";function S8o(e){let{components:n,...t}=e;return(0,s.yg)(W8o,(0,p.A)({},R8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}S8o.isMDXComponent=!0;const B8o={toc:[]},E8o="wrapper";function G8o(e){let{components:n,...t}=e;return(0,s.yg)(E8o,(0,p.A)({},B8o,t,{components:n,mdxType:"MDXLayout"}))}G8o.isMDXComponent=!0;const O8o={toc:[]},U8o="wrapper";function F8o(e){let{components:n,...t}=e;return(0,s.yg)(U8o,(0,p.A)({},O8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}F8o.isMDXComponent=!0;const V8o={toc:[]},q8o="wrapper";function j8o(e){let{components:n,...t}=e;return(0,s.yg)(q8o,(0,p.A)({},V8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}j8o.isMDXComponent=!0;const H8o={toc:[]},Y8o="wrapper";function Q8o(e){let{components:n,...t}=e;return(0,s.yg)(Y8o,(0,p.A)({},H8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}Q8o.isMDXComponent=!0;const $8o={toc:[]},K8o="wrapper";function J8o(e){let{components:n,...t}=e;return(0,s.yg)(K8o,(0,p.A)({},$8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}J8o.isMDXComponent=!0;const Z8o={toc:[]},e5o="wrapper";function n5o(e){let{components:n,...t}=e;return(0,s.yg)(e5o,(0,p.A)({},Z8o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}n5o.isMDXComponent=!0;const t5o={toc:[]},o5o="wrapper";function p5o(e){let{components:n,...t}=e;return(0,s.yg)(o5o,(0,p.A)({},t5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}p5o.isMDXComponent=!0;const r5o={toc:[]},s5o="wrapper";function c5o(e){let{components:n,...t}=e;return(0,s.yg)(s5o,(0,p.A)({},r5o,t,{components:n,mdxType:"MDXLayout"}))}c5o.isMDXComponent=!0;const a5o={toc:[]},i5o="wrapper";function l5o(e){let{components:n,...t}=e;return(0,s.yg)(i5o,(0,p.A)({},a5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}l5o.isMDXComponent=!0;const u5o={toc:[]},m5o="wrapper";function y5o(e){let{components:n,...t}=e;return(0,s.yg)(m5o,(0,p.A)({},u5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}y5o.isMDXComponent=!0;const d5o={toc:[]},h5o="wrapper";function g5o(e){let{components:n,...t}=e;return(0,s.yg)(h5o,(0,p.A)({},d5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}g5o.isMDXComponent=!0;const f5o={toc:[]},D5o="wrapper";function M5o(e){let{components:n,...t}=e;return(0,s.yg)(D5o,(0,p.A)({},f5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}M5o.isMDXComponent=!0;const X5o={toc:[]},_5o="wrapper";function w5o(e){let{components:n,...t}=e;return(0,s.yg)(_5o,(0,p.A)({},X5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}w5o.isMDXComponent=!0;const T5o={toc:[]},C5o="wrapper";function x5o(e){let{components:n,...t}=e;return(0,s.yg)(C5o,(0,p.A)({},T5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}x5o.isMDXComponent=!0;const A5o={toc:[]},v5o="wrapper";function L5o(e){let{components:n,...t}=e;return(0,s.yg)(v5o,(0,p.A)({},A5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}L5o.isMDXComponent=!0;const b5o={toc:[]},N5o="wrapper";function k5o(e){let{components:n,...t}=e;return(0,s.yg)(N5o,(0,p.A)({},b5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}k5o.isMDXComponent=!0;const z5o={toc:[]},P5o="wrapper";function I5o(e){let{components:n,...t}=e;return(0,s.yg)(P5o,(0,p.A)({},z5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}I5o.isMDXComponent=!0;const R5o={toc:[]},W5o="wrapper";function S5o(e){let{components:n,...t}=e;return(0,s.yg)(W5o,(0,p.A)({},R5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}S5o.isMDXComponent=!0;const B5o={toc:[]},E5o="wrapper";function G5o(e){let{components:n,...t}=e;return(0,s.yg)(E5o,(0,p.A)({},B5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}G5o.isMDXComponent=!0;const O5o={toc:[]},U5o="wrapper";function F5o(e){let{components:n,...t}=e;return(0,s.yg)(U5o,(0,p.A)({},O5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}F5o.isMDXComponent=!0;const V5o={toc:[]},q5o="wrapper";function j5o(e){let{components:n,...t}=e;return(0,s.yg)(q5o,(0,p.A)({},V5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}j5o.isMDXComponent=!0;const H5o={toc:[]},Y5o="wrapper";function Q5o(e){let{components:n,...t}=e;return(0,s.yg)(Y5o,(0,p.A)({},H5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}Q5o.isMDXComponent=!0;const $5o={toc:[]},K5o="wrapper";function J5o(e){let{components:n,...t}=e;return(0,s.yg)(K5o,(0,p.A)({},$5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}J5o.isMDXComponent=!0;const Z5o={toc:[]},e7o="wrapper";function n7o(e){let{components:n,...t}=e;return(0,s.yg)(e7o,(0,p.A)({},Z5o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}n7o.isMDXComponent=!0;const t7o={toc:[]},o7o="wrapper";function p7o(e){let{components:n,...t}=e;return(0,s.yg)(o7o,(0,p.A)({},t7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}p7o.isMDXComponent=!0;const r7o={toc:[]},s7o="wrapper";function c7o(e){let{components:n,...t}=e;return(0,s.yg)(s7o,(0,p.A)({},r7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}c7o.isMDXComponent=!0;const a7o={toc:[]},i7o="wrapper";function l7o(e){let{components:n,...t}=e;return(0,s.yg)(i7o,(0,p.A)({},a7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}l7o.isMDXComponent=!0;const u7o={toc:[]},m7o="wrapper";function y7o(e){let{components:n,...t}=e;return(0,s.yg)(m7o,(0,p.A)({},u7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}y7o.isMDXComponent=!0;const d7o={toc:[]},h7o="wrapper";function g7o(e){let{components:n,...t}=e;return(0,s.yg)(h7o,(0,p.A)({},d7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}g7o.isMDXComponent=!0;const f7o={toc:[]},D7o="wrapper";function M7o(e){let{components:n,...t}=e;return(0,s.yg)(D7o,(0,p.A)({},f7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}M7o.isMDXComponent=!0;const X7o={toc:[]},_7o="wrapper";function w7o(e){let{components:n,...t}=e;return(0,s.yg)(_7o,(0,p.A)({},X7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}w7o.isMDXComponent=!0;const T7o={toc:[]},C7o="wrapper";function x7o(e){let{components:n,...t}=e;return(0,s.yg)(C7o,(0,p.A)({},T7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}x7o.isMDXComponent=!0;const A7o={toc:[]},v7o="wrapper";function L7o(e){let{components:n,...t}=e;return(0,s.yg)(v7o,(0,p.A)({},A7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}L7o.isMDXComponent=!0;const b7o={toc:[]},N7o="wrapper";function k7o(e){let{components:n,...t}=e;return(0,s.yg)(N7o,(0,p.A)({},b7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}k7o.isMDXComponent=!0;const z7o={toc:[]},P7o="wrapper";function I7o(e){let{components:n,...t}=e;return(0,s.yg)(P7o,(0,p.A)({},z7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}I7o.isMDXComponent=!0;const R7o={toc:[]},W7o="wrapper";function S7o(e){let{components:n,...t}=e;return(0,s.yg)(W7o,(0,p.A)({},R7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}S7o.isMDXComponent=!0;const B7o={toc:[]},E7o="wrapper";function G7o(e){let{components:n,...t}=e;return(0,s.yg)(E7o,(0,p.A)({},B7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}G7o.isMDXComponent=!0;const O7o={toc:[]},U7o="wrapper";function F7o(e){let{components:n,...t}=e;return(0,s.yg)(U7o,(0,p.A)({},O7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}F7o.isMDXComponent=!0;const V7o={toc:[]},q7o="wrapper";function j7o(e){let{components:n,...t}=e;return(0,s.yg)(q7o,(0,p.A)({},V7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}j7o.isMDXComponent=!0;const H7o={toc:[]},Y7o="wrapper";function Q7o(e){let{components:n,...t}=e;return(0,s.yg)(Y7o,(0,p.A)({},H7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}Q7o.isMDXComponent=!0;const $7o={toc:[]},K7o="wrapper";function J7o(e){let{components:n,...t}=e;return(0,s.yg)(K7o,(0,p.A)({},$7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}J7o.isMDXComponent=!0;const Z7o={toc:[]},eep="wrapper";function nep(e){let{components:n,...t}=e;return(0,s.yg)(eep,(0,p.A)({},Z7o,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}nep.isMDXComponent=!0;const tep={toc:[]},oep="wrapper";function pep(e){let{components:n,...t}=e;return(0,s.yg)(oep,(0,p.A)({},tep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}pep.isMDXComponent=!0;const rep={toc:[]},sep="wrapper";function cep(e){let{components:n,...t}=e;return(0,s.yg)(sep,(0,p.A)({},rep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}cep.isMDXComponent=!0;const aep={toc:[]},iep="wrapper";function lep(e){let{components:n,...t}=e;return(0,s.yg)(iep,(0,p.A)({},aep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}lep.isMDXComponent=!0;const uep={toc:[]},mep="wrapper";function yep(e){let{components:n,...t}=e;return(0,s.yg)(mep,(0,p.A)({},uep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}yep.isMDXComponent=!0;const dep={toc:[]},hep="wrapper";function gep(e){let{components:n,...t}=e;return(0,s.yg)(hep,(0,p.A)({},dep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}gep.isMDXComponent=!0;const fep={toc:[]},Dep="wrapper";function Mep(e){let{components:n,...t}=e;return(0,s.yg)(Dep,(0,p.A)({},fep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}Mep.isMDXComponent=!0;const Xep={toc:[]},_ep="wrapper";function wep(e){let{components:n,...t}=e;return(0,s.yg)(_ep,(0,p.A)({},Xep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}wep.isMDXComponent=!0;const Tep={toc:[]},Cep="wrapper";function xep(e){let{components:n,...t}=e;return(0,s.yg)(Cep,(0,p.A)({},Tep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}xep.isMDXComponent=!0;const Aep={toc:[]},vep="wrapper";function Lep(e){let{components:n,...t}=e;return(0,s.yg)(vep,(0,p.A)({},Aep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Lep.isMDXComponent=!0;const bep={toc:[]},Nep="wrapper";function kep(e){let{components:n,...t}=e;return(0,s.yg)(Nep,(0,p.A)({},bep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}kep.isMDXComponent=!0;const zep={toc:[]},Pep="wrapper";function Iep(e){let{components:n,...t}=e;return(0,s.yg)(Pep,(0,p.A)({},zep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Iep.isMDXComponent=!0;const Rep={toc:[]},Wep="wrapper";function Sep(e){let{components:n,...t}=e;return(0,s.yg)(Wep,(0,p.A)({},Rep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Sep.isMDXComponent=!0;const Bep={toc:[]},Eep="wrapper";function Gep(e){let{components:n,...t}=e;return(0,s.yg)(Eep,(0,p.A)({},Bep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Gep.isMDXComponent=!0;const Oep={toc:[]},Uep="wrapper";function Fep(e){let{components:n,...t}=e;return(0,s.yg)(Uep,(0,p.A)({},Oep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Fep.isMDXComponent=!0;const Vep={toc:[]},qep="wrapper";function jep(e){let{components:n,...t}=e;return(0,s.yg)(qep,(0,p.A)({},Vep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}jep.isMDXComponent=!0;const Hep={toc:[]},Yep="wrapper";function Qep(e){let{components:n,...t}=e;return(0,s.yg)(Yep,(0,p.A)({},Hep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Qep.isMDXComponent=!0;const $ep={toc:[]},Kep="wrapper";function Jep(e){let{components:n,...t}=e;return(0,s.yg)(Kep,(0,p.A)({},$ep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Jep.isMDXComponent=!0;const Zep={toc:[]},enp="wrapper";function nnp(e){let{components:n,...t}=e;return(0,s.yg)(enp,(0,p.A)({},Zep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}nnp.isMDXComponent=!0;const tnp={toc:[]},onp="wrapper";function pnp(e){let{components:n,...t}=e;return(0,s.yg)(onp,(0,p.A)({},tnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}pnp.isMDXComponent=!0;const rnp={toc:[]},snp="wrapper";function cnp(e){let{components:n,...t}=e;return(0,s.yg)(snp,(0,p.A)({},rnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}cnp.isMDXComponent=!0;const anp={toc:[]},inp="wrapper";function lnp(e){let{components:n,...t}=e;return(0,s.yg)(inp,(0,p.A)({},anp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}lnp.isMDXComponent=!0;const unp={toc:[]},mnp="wrapper";function ynp(e){let{components:n,...t}=e;return(0,s.yg)(mnp,(0,p.A)({},unp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}ynp.isMDXComponent=!0;const dnp={toc:[]},hnp="wrapper";function gnp(e){let{components:n,...t}=e;return(0,s.yg)(hnp,(0,p.A)({},dnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}gnp.isMDXComponent=!0;const fnp={toc:[]},Dnp="wrapper";function Mnp(e){let{components:n,...t}=e;return(0,s.yg)(Dnp,(0,p.A)({},fnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Mnp.isMDXComponent=!0;const Xnp={toc:[]},_np="wrapper";function wnp(e){let{components:n,...t}=e;return(0,s.yg)(_np,(0,p.A)({},Xnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}wnp.isMDXComponent=!0;const Tnp={toc:[]},Cnp="wrapper";function xnp(e){let{components:n,...t}=e;return(0,s.yg)(Cnp,(0,p.A)({},Tnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}xnp.isMDXComponent=!0;const Anp={toc:[]},vnp="wrapper";function Lnp(e){let{components:n,...t}=e;return(0,s.yg)(vnp,(0,p.A)({},Anp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}Lnp.isMDXComponent=!0;const bnp={toc:[]},Nnp="wrapper";function knp(e){let{components:n,...t}=e;return(0,s.yg)(Nnp,(0,p.A)({},bnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}knp.isMDXComponent=!0;const znp={toc:[]},Pnp="wrapper";function Inp(e){let{components:n,...t}=e;return(0,s.yg)(Pnp,(0,p.A)({},znp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}Inp.isMDXComponent=!0;const Rnp={toc:[]},Wnp="wrapper";function Snp(e){let{components:n,...t}=e;return(0,s.yg)(Wnp,(0,p.A)({},Rnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}Snp.isMDXComponent=!0;const Bnp={toc:[]},Enp="wrapper";function Gnp(e){let{components:n,...t}=e;return(0,s.yg)(Enp,(0,p.A)({},Bnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}Gnp.isMDXComponent=!0;const Onp={toc:[]},Unp="wrapper";function Fnp(e){let{components:n,...t}=e;return(0,s.yg)(Unp,(0,p.A)({},Onp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}Fnp.isMDXComponent=!0;const Vnp={toc:[]},qnp="wrapper";function jnp(e){let{components:n,...t}=e;return(0,s.yg)(qnp,(0,p.A)({},Vnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}jnp.isMDXComponent=!0;const Hnp={toc:[]},Ynp="wrapper";function Qnp(e){let{components:n,...t}=e;return(0,s.yg)(Ynp,(0,p.A)({},Hnp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Qnp.isMDXComponent=!0;const $np={toc:[]},Knp="wrapper";function Jnp(e){let{components:n,...t}=e;return(0,s.yg)(Knp,(0,p.A)({},$np,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}Jnp.isMDXComponent=!0;const Znp={toc:[]},etp="wrapper";function ntp(e){let{components:n,...t}=e;return(0,s.yg)(etp,(0,p.A)({},Znp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}ntp.isMDXComponent=!0;const ttp={toc:[]},otp="wrapper";function ptp(e){let{components:n,...t}=e;return(0,s.yg)(otp,(0,p.A)({},ttp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}ptp.isMDXComponent=!0;const rtp={toc:[]},stp="wrapper";function ctp(e){let{components:n,...t}=e;return(0,s.yg)(stp,(0,p.A)({},rtp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}ctp.isMDXComponent=!0;const atp={toc:[]},itp="wrapper";function ltp(e){let{components:n,...t}=e;return(0,s.yg)(itp,(0,p.A)({},atp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}ltp.isMDXComponent=!0;const utp={toc:[]},mtp="wrapper";function ytp(e){let{components:n,...t}=e;return(0,s.yg)(mtp,(0,p.A)({},utp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}ytp.isMDXComponent=!0;const dtp={toc:[]},htp="wrapper";function gtp(e){let{components:n,...t}=e;return(0,s.yg)(htp,(0,p.A)({},dtp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}gtp.isMDXComponent=!0;const ftp={toc:[]},Dtp="wrapper";function Mtp(e){let{components:n,...t}=e;return(0,s.yg)(Dtp,(0,p.A)({},ftp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}Mtp.isMDXComponent=!0;const Xtp={toc:[]},_tp="wrapper";function wtp(e){let{components:n,...t}=e;return(0,s.yg)(_tp,(0,p.A)({},Xtp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}wtp.isMDXComponent=!0;const Ttp={toc:[]},Ctp="wrapper";function xtp(e){let{components:n,...t}=e;return(0,s.yg)(Ctp,(0,p.A)({},Ttp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}xtp.isMDXComponent=!0;const Atp={toc:[]},vtp="wrapper";function Ltp(e){let{components:n,...t}=e;return(0,s.yg)(vtp,(0,p.A)({},Atp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}Ltp.isMDXComponent=!0;const btp={toc:[]},Ntp="wrapper";function ktp(e){let{components:n,...t}=e;return(0,s.yg)(Ntp,(0,p.A)({},btp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}ktp.isMDXComponent=!0;const ztp={toc:[]},Ptp="wrapper";function Itp(e){let{components:n,...t}=e;return(0,s.yg)(Ptp,(0,p.A)({},ztp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Itp.isMDXComponent=!0;const Rtp={toc:[]},Wtp="wrapper";function Stp(e){let{components:n,...t}=e;return(0,s.yg)(Wtp,(0,p.A)({},Rtp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Stp.isMDXComponent=!0;const Btp={toc:[]},Etp="wrapper";function Gtp(e){let{components:n,...t}=e;return(0,s.yg)(Etp,(0,p.A)({},Btp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}Gtp.isMDXComponent=!0;const Otp={toc:[]},Utp="wrapper";function Ftp(e){let{components:n,...t}=e;return(0,s.yg)(Utp,(0,p.A)({},Otp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Ftp.isMDXComponent=!0;const Vtp={toc:[]},qtp="wrapper";function jtp(e){let{components:n,...t}=e;return(0,s.yg)(qtp,(0,p.A)({},Vtp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}jtp.isMDXComponent=!0;const Htp={toc:[]},Ytp="wrapper";function Qtp(e){let{components:n,...t}=e;return(0,s.yg)(Ytp,(0,p.A)({},Htp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Qtp.isMDXComponent=!0;const $tp={toc:[]},Ktp="wrapper";function Jtp(e){let{components:n,...t}=e;return(0,s.yg)(Ktp,(0,p.A)({},$tp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}Jtp.isMDXComponent=!0;const Ztp={toc:[]},eop="wrapper";function nop(e){let{components:n,...t}=e;return(0,s.yg)(eop,(0,p.A)({},Ztp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}nop.isMDXComponent=!0;const top={toc:[]},oop="wrapper";function pop(e){let{components:n,...t}=e;return(0,s.yg)(oop,(0,p.A)({},top,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}pop.isMDXComponent=!0;const rop={toc:[]},sop="wrapper";function cop(e){let{components:n,...t}=e;return(0,s.yg)(sop,(0,p.A)({},rop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}cop.isMDXComponent=!0;const aop={toc:[]},iop="wrapper";function lop(e){let{components:n,...t}=e;return(0,s.yg)(iop,(0,p.A)({},aop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}lop.isMDXComponent=!0;const uop={toc:[]},mop="wrapper";function yop(e){let{components:n,...t}=e;return(0,s.yg)(mop,(0,p.A)({},uop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}yop.isMDXComponent=!0;const dop={toc:[]},hop="wrapper";function gop(e){let{components:n,...t}=e;return(0,s.yg)(hop,(0,p.A)({},dop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}gop.isMDXComponent=!0;const fop={toc:[]},Dop="wrapper";function Mop(e){let{components:n,...t}=e;return(0,s.yg)(Dop,(0,p.A)({},fop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}Mop.isMDXComponent=!0;const Xop={toc:[]},_op="wrapper";function wop(e){let{components:n,...t}=e;return(0,s.yg)(_op,(0,p.A)({},Xop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}wop.isMDXComponent=!0;const Top={toc:[]},Cop="wrapper";function xop(e){let{components:n,...t}=e;return(0,s.yg)(Cop,(0,p.A)({},Top,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}xop.isMDXComponent=!0;const Aop={toc:[]},vop="wrapper";function Lop(e){let{components:n,...t}=e;return(0,s.yg)(vop,(0,p.A)({},Aop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Lop.isMDXComponent=!0;const bop={toc:[]},Nop="wrapper";function kop(e){let{components:n,...t}=e;return(0,s.yg)(Nop,(0,p.A)({},bop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}kop.isMDXComponent=!0;const zop={toc:[]},Pop="wrapper";function Iop(e){let{components:n,...t}=e;return(0,s.yg)(Pop,(0,p.A)({},zop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}Iop.isMDXComponent=!0;const Rop={toc:[]},Wop="wrapper";function Sop(e){let{components:n,...t}=e;return(0,s.yg)(Wop,(0,p.A)({},Rop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Sop.isMDXComponent=!0;const Bop={toc:[]},Eop="wrapper";function Gop(e){let{components:n,...t}=e;return(0,s.yg)(Eop,(0,p.A)({},Bop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}Gop.isMDXComponent=!0;const Oop={toc:[]},Uop="wrapper";function Fop(e){let{components:n,...t}=e;return(0,s.yg)(Uop,(0,p.A)({},Oop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}Fop.isMDXComponent=!0;const Vop={toc:[]},qop="wrapper";function jop(e){let{components:n,...t}=e;return(0,s.yg)(qop,(0,p.A)({},Vop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}jop.isMDXComponent=!0;const Hop={toc:[]},Yop="wrapper";function Qop(e){let{components:n,...t}=e;return(0,s.yg)(Yop,(0,p.A)({},Hop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Qop.isMDXComponent=!0;const $op={toc:[]},Kop="wrapper";function Jop(e){let{components:n,...t}=e;return(0,s.yg)(Kop,(0,p.A)({},$op,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}Jop.isMDXComponent=!0;const Zop={toc:[]},epp="wrapper";function npp(e){let{components:n,...t}=e;return(0,s.yg)(epp,(0,p.A)({},Zop,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}npp.isMDXComponent=!0;const tpp={toc:[]},opp="wrapper";function ppp(e){let{components:n,...t}=e;return(0,s.yg)(opp,(0,p.A)({},tpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}ppp.isMDXComponent=!0;const rpp={toc:[]},spp="wrapper";function cpp(e){let{components:n,...t}=e;return(0,s.yg)(spp,(0,p.A)({},rpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}cpp.isMDXComponent=!0;const app={toc:[]},ipp="wrapper";function lpp(e){let{components:n,...t}=e;return(0,s.yg)(ipp,(0,p.A)({},app,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}lpp.isMDXComponent=!0;const upp={toc:[]},mpp="wrapper";function ypp(e){let{components:n,...t}=e;return(0,s.yg)(mpp,(0,p.A)({},upp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}ypp.isMDXComponent=!0;const dpp={toc:[]},hpp="wrapper";function gpp(e){let{components:n,...t}=e;return(0,s.yg)(hpp,(0,p.A)({},dpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}gpp.isMDXComponent=!0;const fpp={toc:[]},Dpp="wrapper";function Mpp(e){let{components:n,...t}=e;return(0,s.yg)(Dpp,(0,p.A)({},fpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Mpp.isMDXComponent=!0;const Xpp={toc:[]},_pp="wrapper";function wpp(e){let{components:n,...t}=e;return(0,s.yg)(_pp,(0,p.A)({},Xpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}wpp.isMDXComponent=!0;const Tpp={toc:[]},Cpp="wrapper";function xpp(e){let{components:n,...t}=e;return(0,s.yg)(Cpp,(0,p.A)({},Tpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}xpp.isMDXComponent=!0;const App={toc:[]},vpp="wrapper";function Lpp(e){let{components:n,...t}=e;return(0,s.yg)(vpp,(0,p.A)({},App,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Lpp.isMDXComponent=!0;const bpp={toc:[]},Npp="wrapper";function kpp(e){let{components:n,...t}=e;return(0,s.yg)(Npp,(0,p.A)({},bpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}kpp.isMDXComponent=!0;const zpp={toc:[]},Ppp="wrapper";function Ipp(e){let{components:n,...t}=e;return(0,s.yg)(Ppp,(0,p.A)({},zpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}Ipp.isMDXComponent=!0;const Rpp={toc:[]},Wpp="wrapper";function Spp(e){let{components:n,...t}=e;return(0,s.yg)(Wpp,(0,p.A)({},Rpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Spp.isMDXComponent=!0;const Bpp={toc:[]},Epp="wrapper";function Gpp(e){let{components:n,...t}=e;return(0,s.yg)(Epp,(0,p.A)({},Bpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Gpp.isMDXComponent=!0;const Opp={toc:[]},Upp="wrapper";function Fpp(e){let{components:n,...t}=e;return(0,s.yg)(Upp,(0,p.A)({},Opp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}Fpp.isMDXComponent=!0;const Vpp={toc:[]},qpp="wrapper";function jpp(e){let{components:n,...t}=e;return(0,s.yg)(qpp,(0,p.A)({},Vpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}jpp.isMDXComponent=!0;const Hpp={toc:[]},Ypp="wrapper";function Qpp(e){let{components:n,...t}=e;return(0,s.yg)(Ypp,(0,p.A)({},Hpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Qpp.isMDXComponent=!0;const $pp={toc:[]},Kpp="wrapper";function Jpp(e){let{components:n,...t}=e;return(0,s.yg)(Kpp,(0,p.A)({},$pp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}Jpp.isMDXComponent=!0;const Zpp={toc:[]},erp="wrapper";function nrp(e){let{components:n,...t}=e;return(0,s.yg)(erp,(0,p.A)({},Zpp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}nrp.isMDXComponent=!0;const trp={toc:[]},orp="wrapper";function prp(e){let{components:n,...t}=e;return(0,s.yg)(orp,(0,p.A)({},trp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}prp.isMDXComponent=!0;const rrp={toc:[]},srp="wrapper";function crp(e){let{components:n,...t}=e;return(0,s.yg)(srp,(0,p.A)({},rrp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}crp.isMDXComponent=!0;const arp={toc:[]},irp="wrapper";function lrp(e){let{components:n,...t}=e;return(0,s.yg)(irp,(0,p.A)({},arp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}lrp.isMDXComponent=!0;const urp={toc:[]},mrp="wrapper";function yrp(e){let{components:n,...t}=e;return(0,s.yg)(mrp,(0,p.A)({},urp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}yrp.isMDXComponent=!0;const drp={toc:[]},hrp="wrapper";function grp(e){let{components:n,...t}=e;return(0,s.yg)(hrp,(0,p.A)({},drp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}grp.isMDXComponent=!0;const frp={toc:[]},Drp="wrapper";function Mrp(e){let{components:n,...t}=e;return(0,s.yg)(Drp,(0,p.A)({},frp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}Mrp.isMDXComponent=!0;const Xrp={toc:[]},_rp="wrapper";function wrp(e){let{components:n,...t}=e;return(0,s.yg)(_rp,(0,p.A)({},Xrp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}wrp.isMDXComponent=!0;const Trp={toc:[]},Crp="wrapper";function xrp(e){let{components:n,...t}=e;return(0,s.yg)(Crp,(0,p.A)({},Trp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}xrp.isMDXComponent=!0;const Arp={toc:[]},vrp="wrapper";function Lrp(e){let{components:n,...t}=e;return(0,s.yg)(vrp,(0,p.A)({},Arp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Lrp.isMDXComponent=!0;const brp={toc:[]},Nrp="wrapper";function krp(e){let{components:n,...t}=e;return(0,s.yg)(Nrp,(0,p.A)({},brp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}krp.isMDXComponent=!0;const zrp={toc:[]},Prp="wrapper";function Irp(e){let{components:n,...t}=e;return(0,s.yg)(Prp,(0,p.A)({},zrp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Irp.isMDXComponent=!0;const Rrp={toc:[]},Wrp="wrapper";function Srp(e){let{components:n,...t}=e;return(0,s.yg)(Wrp,(0,p.A)({},Rrp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Srp.isMDXComponent=!0;const Brp={toc:[]},Erp="wrapper";function Grp(e){let{components:n,...t}=e;return(0,s.yg)(Erp,(0,p.A)({},Brp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Grp.isMDXComponent=!0;const Orp={toc:[]},Urp="wrapper";function Frp(e){let{components:n,...t}=e;return(0,s.yg)(Urp,(0,p.A)({},Orp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Frp.isMDXComponent=!0;const Vrp={toc:[]},qrp="wrapper";function jrp(e){let{components:n,...t}=e;return(0,s.yg)(qrp,(0,p.A)({},Vrp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}jrp.isMDXComponent=!0;const Hrp={toc:[]},Yrp="wrapper";function Qrp(e){let{components:n,...t}=e;return(0,s.yg)(Yrp,(0,p.A)({},Hrp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Txt#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Qrp.isMDXComponent=!0;const $rp={toc:[]},Krp="wrapper";function Jrp(e){let{components:n,...t}=e;return(0,s.yg)(Krp,(0,p.A)({},$rp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Jrp.isMDXComponent=!0;const Zrp={toc:[]},esp="wrapper";function nsp(e){let{components:n,...t}=e;return(0,s.yg)(esp,(0,p.A)({},Zrp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}nsp.isMDXComponent=!0;const tsp={toc:[]},osp="wrapper";function psp(e){let{components:n,...t}=e;return(0,s.yg)(osp,(0,p.A)({},tsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}psp.isMDXComponent=!0;const rsp={toc:[]},ssp="wrapper";function csp(e){let{components:n,...t}=e;return(0,s.yg)(ssp,(0,p.A)({},rsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}csp.isMDXComponent=!0;const asp={toc:[]},isp="wrapper";function lsp(e){let{components:n,...t}=e;return(0,s.yg)(isp,(0,p.A)({},asp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}lsp.isMDXComponent=!0;const usp={toc:[]},msp="wrapper";function ysp(e){let{components:n,...t}=e;return(0,s.yg)(msp,(0,p.A)({},usp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}ysp.isMDXComponent=!0;const dsp={toc:[]},hsp="wrapper";function gsp(e){let{components:n,...t}=e;return(0,s.yg)(hsp,(0,p.A)({},dsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is a shortcut for"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Txt fontWeight={700} />\n")))}gsp.isMDXComponent=!0;const fsp={toc:[]},Dsp="wrapper";function Msp(e){let{components:n,...t}=e;return(0,s.yg)(Dsp,(0,p.A)({},fsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a bold text node."))}Msp.isMDXComponent=!0;const Xsp={toc:[]},_sp="wrapper";function wsp(e){let{components:n,...t}=e;return(0,s.yg)(_sp,(0,p.A)({},Xsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Additional text properties."))}wsp.isMDXComponent=!0;const Tsp={toc:[]},Csp="wrapper";function xsp(e){let{components:n,...t}=e;return(0,s.yg)(Csp,(0,p.A)({},Tsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is a shortcut for"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Txt fontStyle={'italic'} />\n")))}xsp.isMDXComponent=!0;const Asp={toc:[]},vsp="wrapper";function Lsp(e){let{components:n,...t}=e;return(0,s.yg)(vsp,(0,p.A)({},Asp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an italic text node."))}Lsp.isMDXComponent=!0;const bsp={toc:[]},Nsp="wrapper";function ksp(e){let{components:n,...t}=e;return(0,s.yg)(Nsp,(0,p.A)({},bsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Additional text properties."))}ksp.isMDXComponent=!0;const zsp={toc:[]},Psp="wrapper";function Isp(e){let{components:n,...t}=e;return(0,s.yg)(Psp,(0,p.A)({},zsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}Isp.isMDXComponent=!0;const Rsp={toc:[]},Wsp="wrapper";function Ssp(e){let{components:n,...t}=e;return(0,s.yg)(Wsp,(0,p.A)({},Rsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}Ssp.isMDXComponent=!0;const Bsp={toc:[]},Esp="wrapper";function Gsp(e){let{components:n,...t}=e;return(0,s.yg)(Esp,(0,p.A)({},Bsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Gsp.isMDXComponent=!0;const Osp={toc:[]},Usp="wrapper";function Fsp(e){let{components:n,...t}=e;return(0,s.yg)(Usp,(0,p.A)({},Osp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}Fsp.isMDXComponent=!0;const Vsp={toc:[]},qsp="wrapper";function jsp(e){let{components:n,...t}=e;return(0,s.yg)(qsp,(0,p.A)({},Vsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}jsp.isMDXComponent=!0;const Hsp={toc:[]},Ysp="wrapper";function Qsp(e){let{components:n,...t}=e;return(0,s.yg)(Ysp,(0,p.A)({},Hsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}Qsp.isMDXComponent=!0;const $sp={toc:[]},Ksp="wrapper";function Jsp(e){let{components:n,...t}=e;return(0,s.yg)(Ksp,(0,p.A)({},$sp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}Jsp.isMDXComponent=!0;const Zsp={toc:[]},ecp="wrapper";function ncp(e){let{components:n,...t}=e;return(0,s.yg)(ecp,(0,p.A)({},Zsp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this video."))}ncp.isMDXComponent=!0;const tcp={toc:[]},ocp="wrapper";function pcp(e){let{components:n,...t}=e;return(0,s.yg)(ocp,(0,p.A)({},tcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}pcp.isMDXComponent=!0;const rcp={toc:[]},scp="wrapper";function ccp(e){let{components:n,...t}=e;return(0,s.yg)(scp,(0,p.A)({},rcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}ccp.isMDXComponent=!0;const acp={toc:[]},icp="wrapper";function lcp(e){let{components:n,...t}=e;return(0,s.yg)(icp,(0,p.A)({},acp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}lcp.isMDXComponent=!0;const ucp={toc:[]},mcp="wrapper";function ycp(e){let{components:n,...t}=e;return(0,s.yg)(mcp,(0,p.A)({},ucp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}ycp.isMDXComponent=!0;const dcp={toc:[]},hcp="wrapper";function gcp(e){let{components:n,...t}=e;return(0,s.yg)(hcp,(0,p.A)({},dcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}gcp.isMDXComponent=!0;const fcp={toc:[]},Dcp="wrapper";function Mcp(e){let{components:n,...t}=e;return(0,s.yg)(Dcp,(0,p.A)({},fcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Mcp.isMDXComponent=!0;const Xcp={toc:[]},_cp="wrapper";function wcp(e){let{components:n,...t}=e;return(0,s.yg)(_cp,(0,p.A)({},Xcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}wcp.isMDXComponent=!0;const Tcp={toc:[]},Ccp="wrapper";function xcp(e){let{components:n,...t}=e;return(0,s.yg)(Ccp,(0,p.A)({},Tcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}xcp.isMDXComponent=!0;const Acp={toc:[]},vcp="wrapper";function Lcp(e){let{components:n,...t}=e;return(0,s.yg)(vcp,(0,p.A)({},Acp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Lcp.isMDXComponent=!0;const bcp={toc:[]},Ncp="wrapper";function kcp(e){let{components:n,...t}=e;return(0,s.yg)(Ncp,(0,p.A)({},bcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}kcp.isMDXComponent=!0;const zcp={toc:[]},Pcp="wrapper";function Icp(e){let{components:n,...t}=e;return(0,s.yg)(Pcp,(0,p.A)({},zcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}Icp.isMDXComponent=!0;const Rcp={toc:[]},Wcp="wrapper";function Scp(e){let{components:n,...t}=e;return(0,s.yg)(Wcp,(0,p.A)({},Rcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}Scp.isMDXComponent=!0;const Bcp={toc:[]},Ecp="wrapper";function Gcp(e){let{components:n,...t}=e;return(0,s.yg)(Ecp,(0,p.A)({},Bcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Gcp.isMDXComponent=!0;const Ocp={toc:[]},Ucp="wrapper";function Fcp(e){let{components:n,...t}=e;return(0,s.yg)(Ucp,(0,p.A)({},Ocp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Fcp.isMDXComponent=!0;const Vcp={toc:[]},qcp="wrapper";function jcp(e){let{components:n,...t}=e;return(0,s.yg)(qcp,(0,p.A)({},Vcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}jcp.isMDXComponent=!0;const Hcp={toc:[]},Ycp="wrapper";function Qcp(e){let{components:n,...t}=e;return(0,s.yg)(Ycp,(0,p.A)({},Hcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"null"))}Qcp.isMDXComponent=!0;const $cp={toc:[]},Kcp="wrapper";function Jcp(e){let{components:n,...t}=e;return(0,s.yg)(Kcp,(0,p.A)({},$cp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Which decoder to use during rendering. The ",(0,s.yg)("inlineCode",{parentName:"p"},"web")," decoder is the fastest\nbut only supports MP4 files. The ",(0,s.yg)("inlineCode",{parentName:"p"},"ffmpeg")," decoder is slower and more resource\nintensive but supports more formats. The ",(0,s.yg)("inlineCode",{parentName:"p"},"slow")," decoder is the slowest but\nsupports all formats."))}Jcp.isMDXComponent=!0;const Zcp={toc:[]},eap="wrapper";function nap(e){let{components:n,...t}=e;return(0,s.yg)(eap,(0,p.A)({},Zcp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}nap.isMDXComponent=!0;const tap={toc:[]},oap="wrapper";function pap(e){let{components:n,...t}=e;return(0,s.yg)(oap,(0,p.A)({},tap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}pap.isMDXComponent=!0;const rap={toc:[]},sap="wrapper";function cap(e){let{components:n,...t}=e;return(0,s.yg)(sap,(0,p.A)({},rap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}cap.isMDXComponent=!0;const aap={toc:[]},iap="wrapper";function lap(e){let{components:n,...t}=e;return(0,s.yg)(iap,(0,p.A)({},aap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}lap.isMDXComponent=!0;const uap={toc:[]},map="wrapper";function yap(e){let{components:n,...t}=e;return(0,s.yg)(map,(0,p.A)({},uap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}yap.isMDXComponent=!0;const dap={toc:[]},hap="wrapper";function gap(e){let{components:n,...t}=e;return(0,s.yg)(hap,(0,p.A)({},dap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}gap.isMDXComponent=!0;const fap={toc:[]},Dap="wrapper";function Map(e){let{components:n,...t}=e;return(0,s.yg)(Dap,(0,p.A)({},fap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Map.isMDXComponent=!0;const Xap={toc:[]},_ap="wrapper";function wap(e){let{components:n,...t}=e;return(0,s.yg)(_ap,(0,p.A)({},Xap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}wap.isMDXComponent=!0;const Tap={toc:[]},Cap="wrapper";function xap(e){let{components:n,...t}=e;return(0,s.yg)(Cap,(0,p.A)({},Tap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}xap.isMDXComponent=!0;const Aap={toc:[]},vap="wrapper";function Lap(e){let{components:n,...t}=e;return(0,s.yg)(vap,(0,p.A)({},Aap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Lap.isMDXComponent=!0;const bap={toc:[]},Nap="wrapper";function kap(e){let{components:n,...t}=e;return(0,s.yg)(Nap,(0,p.A)({},bap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}kap.isMDXComponent=!0;const zap={toc:[]},Pap="wrapper";function Iap(e){let{components:n,...t}=e;return(0,s.yg)(Pap,(0,p.A)({},zap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}Iap.isMDXComponent=!0;const Rap={toc:[]},Wap="wrapper";function Sap(e){let{components:n,...t}=e;return(0,s.yg)(Wap,(0,p.A)({},Rap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}Sap.isMDXComponent=!0;const Bap={toc:[]},Eap="wrapper";function Gap(e){let{components:n,...t}=e;return(0,s.yg)(Eap,(0,p.A)({},Bap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}Gap.isMDXComponent=!0;const Oap={toc:[]},Uap="wrapper";function Fap(e){let{components:n,...t}=e;return(0,s.yg)(Uap,(0,p.A)({},Oap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Fap.isMDXComponent=!0;const Vap={toc:[]},qap="wrapper";function jap(e){let{components:n,...t}=e;return(0,s.yg)(qap,(0,p.A)({},Vap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}jap.isMDXComponent=!0;const Hap={toc:[]},Yap="wrapper";function Qap(e){let{components:n,...t}=e;return(0,s.yg)(Yap,(0,p.A)({},Hap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Qap.isMDXComponent=!0;const $ap={toc:[]},Kap="wrapper";function Jap(e){let{components:n,...t}=e;return(0,s.yg)(Kap,(0,p.A)({},$ap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"One uniform radius:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}Jap.isMDXComponent=!0;const Zap={toc:[]},eip="wrapper";function nip(e){let{components:n,...t}=e;return(0,s.yg)(eip,(0,p.A)({},Zap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Individual radii for each corner:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}nip.isMDXComponent=!0;const tip={toc:[]},oip="wrapper";function pip(e){let{components:n,...t}=e;return(0,s.yg)(oip,(0,p.A)({},tip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}pip.isMDXComponent=!0;const rip={toc:[]},sip="wrapper";function cip(e){let{components:n,...t}=e;return(0,s.yg)(sip,(0,p.A)({},rip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}cip.isMDXComponent=!0;const aip={toc:[]},iip="wrapper";function lip(e){let{components:n,...t}=e;return(0,s.yg)(iip,(0,p.A)({},aip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}lip.isMDXComponent=!0;const uip={toc:[]},mip="wrapper";function yip(e){let{components:n,...t}=e;return(0,s.yg)(mip,(0,p.A)({},uip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}yip.isMDXComponent=!0;const dip={toc:[]},hip="wrapper";function gip(e){let{components:n,...t}=e;return(0,s.yg)(hip,(0,p.A)({},dip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}gip.isMDXComponent=!0;const fip={toc:[]},Dip="wrapper";function Mip(e){let{components:n,...t}=e;return(0,s.yg)(Dip,(0,p.A)({},fip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}Mip.isMDXComponent=!0;const Xip={toc:[]},_ip="wrapper";function wip(e){let{components:n,...t}=e;return(0,s.yg)(_ip,(0,p.A)({},Xip,t,{components:n,mdxType:"MDXLayout"}))}wip.isMDXComponent=!0;const Tip={toc:[]},Cip="wrapper";function xip(e){let{components:n,...t}=e;return(0,s.yg)(Cip,(0,p.A)({},Tip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}xip.isMDXComponent=!0;const Aip={toc:[]},vip="wrapper";function Lip(e){let{components:n,...t}=e;return(0,s.yg)(vip,(0,p.A)({},Aip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Lip.isMDXComponent=!0;const bip={toc:[]},Nip="wrapper";function kip(e){let{components:n,...t}=e;return(0,s.yg)(Nip,(0,p.A)({},bip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}kip.isMDXComponent=!0;const zip={toc:[]},Pip="wrapper";function Iip(e){let{components:n,...t}=e;return(0,s.yg)(Pip,(0,p.A)({},zip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Iip.isMDXComponent=!0;const Rip={toc:[]},Wip="wrapper";function Sip(e){let{components:n,...t}=e;return(0,s.yg)(Wip,(0,p.A)({},Rip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}Sip.isMDXComponent=!0;const Bip={toc:[]},Eip="wrapper";function Gip(e){let{components:n,...t}=e;return(0,s.yg)(Eip,(0,p.A)({},Bip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Gip.isMDXComponent=!0;const Oip={toc:[]},Uip="wrapper";function Fip(e){let{components:n,...t}=e;return(0,s.yg)(Uip,(0,p.A)({},Oip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}Fip.isMDXComponent=!0;const Vip={toc:[]},qip="wrapper";function jip(e){let{components:n,...t}=e;return(0,s.yg)(qip,(0,p.A)({},Vip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}jip.isMDXComponent=!0;const Hip={toc:[]},Yip="wrapper";function Qip(e){let{components:n,...t}=e;return(0,s.yg)(Yip,(0,p.A)({},Hip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}Qip.isMDXComponent=!0;const $ip={toc:[]},Kip="wrapper";function Jip(e){let{components:n,...t}=e;return(0,s.yg)(Kip,(0,p.A)({},$ip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"true"))}Jip.isMDXComponent=!0;const Zip={toc:[]},elp="wrapper";function nlp(e){let{components:n,...t}=e;return(0,s.yg)(elp,(0,p.A)({},Zip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the video should be smoothed."))}nlp.isMDXComponent=!0;const tlp={toc:[]},olp="wrapper";function plp(e){let{components:n,...t}=e;return(0,s.yg)(olp,(0,p.A)({},tlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}plp.isMDXComponent=!0;const rlp={toc:[]},slp="wrapper";function clp(e){let{components:n,...t}=e;return(0,s.yg)(slp,(0,p.A)({},rlp,t,{components:n,mdxType:"MDXLayout"}))}clp.isMDXComponent=!0;const alp={toc:[]},ilp="wrapper";function llp(e){let{components:n,...t}=e;return(0,s.yg)(ilp,(0,p.A)({},alp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}llp.isMDXComponent=!0;const ulp={toc:[]},mlp="wrapper";function ylp(e){let{components:n,...t}=e;return(0,s.yg)(mlp,(0,p.A)({},ulp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}ylp.isMDXComponent=!0;const dlp={toc:[]},hlp="wrapper";function glp(e){let{components:n,...t}=e;return(0,s.yg)(hlp,(0,p.A)({},dlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}glp.isMDXComponent=!0;const flp={toc:[]},Dlp="wrapper";function Mlp(e){let{components:n,...t}=e;return(0,s.yg)(Dlp,(0,p.A)({},flp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Mlp.isMDXComponent=!0;const Xlp={toc:[]},_lp="wrapper";function wlp(e){let{components:n,...t}=e;return(0,s.yg)(_lp,(0,p.A)({},Xlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}wlp.isMDXComponent=!0;const Tlp={toc:[]},Clp="wrapper";function xlp(e){let{components:n,...t}=e;return(0,s.yg)(Clp,(0,p.A)({},Tlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}xlp.isMDXComponent=!0;const Alp={toc:[]},vlp="wrapper";function Llp(e){let{components:n,...t}=e;return(0,s.yg)(vlp,(0,p.A)({},Alp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Llp.isMDXComponent=!0;const blp={toc:[]},Nlp="wrapper";function klp(e){let{components:n,...t}=e;return(0,s.yg)(Nlp,(0,p.A)({},blp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}klp.isMDXComponent=!0;const zlp={toc:[]},Plp="wrapper";function Ilp(e){let{components:n,...t}=e;return(0,s.yg)(Plp,(0,p.A)({},zlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Ilp.isMDXComponent=!0;const Rlp={toc:[]},Wlp="wrapper";function Slp(e){let{components:n,...t}=e;return(0,s.yg)(Wlp,(0,p.A)({},Rlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Slp.isMDXComponent=!0;const Blp={toc:[]},Elp="wrapper";function Glp(e){let{components:n,...t}=e;return(0,s.yg)(Elp,(0,p.A)({},Blp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Glp.isMDXComponent=!0;const Olp={toc:[]},Ulp="wrapper";function Flp(e){let{components:n,...t}=e;return(0,s.yg)(Ulp,(0,p.A)({},Olp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Flp.isMDXComponent=!0;const Vlp={toc:[]},qlp="wrapper";function jlp(e){let{components:n,...t}=e;return(0,s.yg)(qlp,(0,p.A)({},Vlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}jlp.isMDXComponent=!0;const Hlp={toc:[]},Ylp="wrapper";function Qlp(e){let{components:n,...t}=e;return(0,s.yg)(Ylp,(0,p.A)({},Hlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Qlp.isMDXComponent=!0;const $lp={toc:[]},Klp="wrapper";function Jlp(e){let{components:n,...t}=e;return(0,s.yg)(Klp,(0,p.A)({},$lp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}Jlp.isMDXComponent=!0;const Zlp={toc:[]},eup="wrapper";function nup(e){let{components:n,...t}=e;return(0,s.yg)(eup,(0,p.A)({},Zlp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}nup.isMDXComponent=!0;const tup={toc:[]},oup="wrapper";function pup(e){let{components:n,...t}=e;return(0,s.yg)(oup,(0,p.A)({},tup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}pup.isMDXComponent=!0;const rup={toc:[]},sup="wrapper";function cup(e){let{components:n,...t}=e;return(0,s.yg)(sup,(0,p.A)({},rup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}cup.isMDXComponent=!0;const aup={toc:[]},iup="wrapper";function lup(e){let{components:n,...t}=e;return(0,s.yg)(iup,(0,p.A)({},aup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}lup.isMDXComponent=!0;const uup={toc:[]},mup="wrapper";function yup(e){let{components:n,...t}=e;return(0,s.yg)(mup,(0,p.A)({},uup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}yup.isMDXComponent=!0;const dup={toc:[]},hup="wrapper";function gup(e){let{components:n,...t}=e;return(0,s.yg)(hup,(0,p.A)({},dup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}gup.isMDXComponent=!0;const fup={toc:[]},Dup="wrapper";function Mup(e){let{components:n,...t}=e;return(0,s.yg)(Dup,(0,p.A)({},fup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Mup.isMDXComponent=!0;const Xup={toc:[]},_up="wrapper";function wup(e){let{components:n,...t}=e;return(0,s.yg)(_up,(0,p.A)({},Xup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}wup.isMDXComponent=!0;const Tup={toc:[]},Cup="wrapper";function xup(e){let{components:n,...t}=e;return(0,s.yg)(Cup,(0,p.A)({},Tup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}xup.isMDXComponent=!0;const Aup={toc:[]},vup="wrapper";function Lup(e){let{components:n,...t}=e;return(0,s.yg)(vup,(0,p.A)({},Aup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Lup.isMDXComponent=!0;const bup={toc:[]},Nup="wrapper";function kup(e){let{components:n,...t}=e;return(0,s.yg)(Nup,(0,p.A)({},bup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}kup.isMDXComponent=!0;const zup={toc:[]},Pup="wrapper";function Iup(e){let{components:n,...t}=e;return(0,s.yg)(Pup,(0,p.A)({},zup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Iup.isMDXComponent=!0;const Rup={toc:[]},Wup="wrapper";function Sup(e){let{components:n,...t}=e;return(0,s.yg)(Wup,(0,p.A)({},Rup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Sup.isMDXComponent=!0;const Bup={toc:[]},Eup="wrapper";function Gup(e){let{components:n,...t}=e;return(0,s.yg)(Eup,(0,p.A)({},Bup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}Gup.isMDXComponent=!0;const Oup={toc:[]},Uup="wrapper";function Fup(e){let{components:n,...t}=e;return(0,s.yg)(Uup,(0,p.A)({},Oup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}Fup.isMDXComponent=!0;const Vup={toc:[]},qup="wrapper";function jup(e){let{components:n,...t}=e;return(0,s.yg)(qup,(0,p.A)({},Vup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}jup.isMDXComponent=!0;const Hup={toc:[]},Yup="wrapper";function Qup(e){let{components:n,...t}=e;return(0,s.yg)(Yup,(0,p.A)({},Hup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Qup.isMDXComponent=!0;const $up={toc:[]},Kup="wrapper";function Jup(e){let{components:n,...t}=e;return(0,s.yg)(Kup,(0,p.A)({},$up,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Jup.isMDXComponent=!0;const Zup={toc:[]},emp="wrapper";function nmp(e){let{components:n,...t}=e;return(0,s.yg)(emp,(0,p.A)({},Zup,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}nmp.isMDXComponent=!0;const tmp={toc:[]},omp="wrapper";function pmp(e){let{components:n,...t}=e;return(0,s.yg)(omp,(0,p.A)({},tmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}pmp.isMDXComponent=!0;const rmp={toc:[]},smp="wrapper";function cmp(e){let{components:n,...t}=e;return(0,s.yg)(smp,(0,p.A)({},rmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}cmp.isMDXComponent=!0;const amp={toc:[]},imp="wrapper";function lmp(e){let{components:n,...t}=e;return(0,s.yg)(imp,(0,p.A)({},amp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}lmp.isMDXComponent=!0;const ump={toc:[]},mmp="wrapper";function ymp(e){let{components:n,...t}=e;return(0,s.yg)(mmp,(0,p.A)({},ump,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}ymp.isMDXComponent=!0;const dmp={toc:[]},hmp="wrapper";function gmp(e){let{components:n,...t}=e;return(0,s.yg)(hmp,(0,p.A)({},dmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}gmp.isMDXComponent=!0;const fmp={toc:[]},Dmp="wrapper";function Mmp(e){let{components:n,...t}=e;return(0,s.yg)(Dmp,(0,p.A)({},fmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Mmp.isMDXComponent=!0;const Xmp={toc:[]},_mp="wrapper";function wmp(e){let{components:n,...t}=e;return(0,s.yg)(_mp,(0,p.A)({},Xmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}wmp.isMDXComponent=!0;const Tmp={toc:[]},Cmp="wrapper";function xmp(e){let{components:n,...t}=e;return(0,s.yg)(Cmp,(0,p.A)({},Tmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}xmp.isMDXComponent=!0;const Amp={toc:[]},vmp="wrapper";function Lmp(e){let{components:n,...t}=e;return(0,s.yg)(vmp,(0,p.A)({},Amp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Lmp.isMDXComponent=!0;const bmp={toc:[]},Nmp="wrapper";function kmp(e){let{components:n,...t}=e;return(0,s.yg)(Nmp,(0,p.A)({},bmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}kmp.isMDXComponent=!0;const zmp={toc:[]},Pmp="wrapper";function Imp(e){let{components:n,...t}=e;return(0,s.yg)(Pmp,(0,p.A)({},zmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Imp.isMDXComponent=!0;const Rmp={toc:[]},Wmp="wrapper";function Smp(e){let{components:n,...t}=e;return(0,s.yg)(Wmp,(0,p.A)({},Rmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Smp.isMDXComponent=!0;const Bmp={toc:[]},Emp="wrapper";function Gmp(e){let{components:n,...t}=e;return(0,s.yg)(Emp,(0,p.A)({},Bmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}Gmp.isMDXComponent=!0;const Omp={toc:[]},Ump="wrapper";function Fmp(e){let{components:n,...t}=e;return(0,s.yg)(Ump,(0,p.A)({},Omp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Fmp.isMDXComponent=!0;const Vmp={toc:[]},qmp="wrapper";function jmp(e){let{components:n,...t}=e;return(0,s.yg)(qmp,(0,p.A)({},Vmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}jmp.isMDXComponent=!0;const Hmp={toc:[]},Ymp="wrapper";function Qmp(e){let{components:n,...t}=e;return(0,s.yg)(Ymp,(0,p.A)({},Hmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}Qmp.isMDXComponent=!0;const $mp={toc:[]},Kmp="wrapper";function Jmp(e){let{components:n,...t}=e;return(0,s.yg)(Kmp,(0,p.A)({},$mp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Jmp.isMDXComponent=!0;const Zmp={toc:[]},eyp="wrapper";function nyp(e){let{components:n,...t}=e;return(0,s.yg)(eyp,(0,p.A)({},Zmp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}nyp.isMDXComponent=!0;const typ={toc:[]},oyp="wrapper";function pyp(e){let{components:n,...t}=e;return(0,s.yg)(oyp,(0,p.A)({},typ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}pyp.isMDXComponent=!0;const ryp={toc:[]},syp="wrapper";function cyp(e){let{components:n,...t}=e;return(0,s.yg)(syp,(0,p.A)({},ryp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}cyp.isMDXComponent=!0;const ayp={toc:[]},iyp="wrapper";function lyp(e){let{components:n,...t}=e;return(0,s.yg)(iyp,(0,p.A)({},ayp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}lyp.isMDXComponent=!0;const uyp={toc:[]},myp="wrapper";function yyp(e){let{components:n,...t}=e;return(0,s.yg)(myp,(0,p.A)({},uyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}yyp.isMDXComponent=!0;const dyp={toc:[]},hyp="wrapper";function gyp(e){let{components:n,...t}=e;return(0,s.yg)(hyp,(0,p.A)({},dyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}gyp.isMDXComponent=!0;const fyp={toc:[]},Dyp="wrapper";function Myp(e){let{components:n,...t}=e;return(0,s.yg)(Dyp,(0,p.A)({},fyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}Myp.isMDXComponent=!0;const Xyp={toc:[]},_yp="wrapper";function wyp(e){let{components:n,...t}=e;return(0,s.yg)(_yp,(0,p.A)({},Xyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}wyp.isMDXComponent=!0;const Typ={toc:[]},Cyp="wrapper";function xyp(e){let{components:n,...t}=e;return(0,s.yg)(Cyp,(0,p.A)({},Typ,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}xyp.isMDXComponent=!0;const Ayp={toc:[]},vyp="wrapper";function Lyp(e){let{components:n,...t}=e;return(0,s.yg)(vyp,(0,p.A)({},Ayp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}Lyp.isMDXComponent=!0;const byp={toc:[]},Nyp="wrapper";function kyp(e){let{components:n,...t}=e;return(0,s.yg)(Nyp,(0,p.A)({},byp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}kyp.isMDXComponent=!0;const zyp={toc:[]},Pyp="wrapper";function Iyp(e){let{components:n,...t}=e;return(0,s.yg)(Pyp,(0,p.A)({},zyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}Iyp.isMDXComponent=!0;const Ryp={toc:[]},Wyp="wrapper";function Syp(e){let{components:n,...t}=e;return(0,s.yg)(Wyp,(0,p.A)({},Ryp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}Syp.isMDXComponent=!0;const Byp={toc:[]},Eyp="wrapper";function Gyp(e){let{components:n,...t}=e;return(0,s.yg)(Eyp,(0,p.A)({},Byp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Gyp.isMDXComponent=!0;const Oyp={toc:[]},Uyp="wrapper";function Fyp(e){let{components:n,...t}=e;return(0,s.yg)(Uyp,(0,p.A)({},Oyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}Fyp.isMDXComponent=!0;const Vyp={toc:[]},qyp="wrapper";function jyp(e){let{components:n,...t}=e;return(0,s.yg)(qyp,(0,p.A)({},Vyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}jyp.isMDXComponent=!0;const Hyp={toc:[]},Yyp="wrapper";function Qyp(e){let{components:n,...t}=e;return(0,s.yg)(Yyp,(0,p.A)({},Hyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Qyp.isMDXComponent=!0;const $yp={toc:[]},Kyp="wrapper";function Jyp(e){let{components:n,...t}=e;return(0,s.yg)(Kyp,(0,p.A)({},$yp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}Jyp.isMDXComponent=!0;const Zyp={toc:[]},edp="wrapper";function ndp(e){let{components:n,...t}=e;return(0,s.yg)(edp,(0,p.A)({},Zyp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}ndp.isMDXComponent=!0;const tdp={toc:[]},odp="wrapper";function pdp(e){let{components:n,...t}=e;return(0,s.yg)(odp,(0,p.A)({},tdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}pdp.isMDXComponent=!0;const rdp={toc:[]},sdp="wrapper";function cdp(e){let{components:n,...t}=e;return(0,s.yg)(sdp,(0,p.A)({},rdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}cdp.isMDXComponent=!0;const adp={toc:[]},idp="wrapper";function ldp(e){let{components:n,...t}=e;return(0,s.yg)(idp,(0,p.A)({},adp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}ldp.isMDXComponent=!0;const udp={toc:[]},mdp="wrapper";function ydp(e){let{components:n,...t}=e;return(0,s.yg)(mdp,(0,p.A)({},udp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}ydp.isMDXComponent=!0;const ddp={toc:[]},hdp="wrapper";function gdp(e){let{components:n,...t}=e;return(0,s.yg)(hdp,(0,p.A)({},ddp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}gdp.isMDXComponent=!0;const fdp={toc:[]},Ddp="wrapper";function Mdp(e){let{components:n,...t}=e;return(0,s.yg)(Ddp,(0,p.A)({},fdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Mdp.isMDXComponent=!0;const Xdp={toc:[]},_dp="wrapper";function wdp(e){let{components:n,...t}=e;return(0,s.yg)(_dp,(0,p.A)({},Xdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}wdp.isMDXComponent=!0;const Tdp={toc:[]},Cdp="wrapper";function xdp(e){let{components:n,...t}=e;return(0,s.yg)(Cdp,(0,p.A)({},Tdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}xdp.isMDXComponent=!0;const Adp={toc:[]},vdp="wrapper";function Ldp(e){let{components:n,...t}=e;return(0,s.yg)(vdp,(0,p.A)({},Adp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}Ldp.isMDXComponent=!0;const bdp={toc:[]},Ndp="wrapper";function kdp(e){let{components:n,...t}=e;return(0,s.yg)(Ndp,(0,p.A)({},bdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}kdp.isMDXComponent=!0;const zdp={toc:[]},Pdp="wrapper";function Idp(e){let{components:n,...t}=e;return(0,s.yg)(Pdp,(0,p.A)({},zdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Idp.isMDXComponent=!0;const Rdp={toc:[]},Wdp="wrapper";function Sdp(e){let{components:n,...t}=e;return(0,s.yg)(Wdp,(0,p.A)({},Rdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}Sdp.isMDXComponent=!0;const Bdp={toc:[]},Edp="wrapper";function Gdp(e){let{components:n,...t}=e;return(0,s.yg)(Edp,(0,p.A)({},Bdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Gdp.isMDXComponent=!0;const Odp={toc:[]},Udp="wrapper";function Fdp(e){let{components:n,...t}=e;return(0,s.yg)(Udp,(0,p.A)({},Odp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}Fdp.isMDXComponent=!0;const Vdp={toc:[]},qdp="wrapper";function jdp(e){let{components:n,...t}=e;return(0,s.yg)(qdp,(0,p.A)({},Vdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}jdp.isMDXComponent=!0;const Hdp={toc:[]},Ydp="wrapper";function Qdp(e){let{components:n,...t}=e;return(0,s.yg)(Ydp,(0,p.A)({},Hdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}Qdp.isMDXComponent=!0;const $dp={toc:[]},Kdp="wrapper";function Jdp(e){let{components:n,...t}=e;return(0,s.yg)(Kdp,(0,p.A)({},$dp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}Jdp.isMDXComponent=!0;const Zdp={toc:[]},ehp="wrapper";function nhp(e){let{components:n,...t}=e;return(0,s.yg)(ehp,(0,p.A)({},Zdp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}nhp.isMDXComponent=!0;const thp={toc:[]},ohp="wrapper";function php(e){let{components:n,...t}=e;return(0,s.yg)(ohp,(0,p.A)({},thp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}php.isMDXComponent=!0;const rhp={toc:[]},shp="wrapper";function chp(e){let{components:n,...t}=e;return(0,s.yg)(shp,(0,p.A)({},rhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}chp.isMDXComponent=!0;const ahp={toc:[]},ihp="wrapper";function lhp(e){let{components:n,...t}=e;return(0,s.yg)(ihp,(0,p.A)({},ahp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}lhp.isMDXComponent=!0;const uhp={toc:[]},mhp="wrapper";function yhp(e){let{components:n,...t}=e;return(0,s.yg)(mhp,(0,p.A)({},uhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}yhp.isMDXComponent=!0;const dhp={toc:[]},hhp="wrapper";function ghp(e){let{components:n,...t}=e;return(0,s.yg)(hhp,(0,p.A)({},dhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}ghp.isMDXComponent=!0;const fhp={toc:[]},Dhp="wrapper";function Mhp(e){let{components:n,...t}=e;return(0,s.yg)(Dhp,(0,p.A)({},fhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Mhp.isMDXComponent=!0;const Xhp={toc:[]},_hp="wrapper";function whp(e){let{components:n,...t}=e;return(0,s.yg)(_hp,(0,p.A)({},Xhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}whp.isMDXComponent=!0;const Thp={toc:[]},Chp="wrapper";function xhp(e){let{components:n,...t}=e;return(0,s.yg)(Chp,(0,p.A)({},Thp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}xhp.isMDXComponent=!0;const Ahp={toc:[]},vhp="wrapper";function Lhp(e){let{components:n,...t}=e;return(0,s.yg)(vhp,(0,p.A)({},Ahp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Lhp.isMDXComponent=!0;const bhp={toc:[]},Nhp="wrapper";function khp(e){let{components:n,...t}=e;return(0,s.yg)(Nhp,(0,p.A)({},bhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}khp.isMDXComponent=!0;const zhp={toc:[]},Php="wrapper";function Ihp(e){let{components:n,...t}=e;return(0,s.yg)(Php,(0,p.A)({},zhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}Ihp.isMDXComponent=!0;const Rhp={toc:[]},Whp="wrapper";function Shp(e){let{components:n,...t}=e;return(0,s.yg)(Whp,(0,p.A)({},Rhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}Shp.isMDXComponent=!0;const Bhp={toc:[]},Ehp="wrapper";function Ghp(e){let{components:n,...t}=e;return(0,s.yg)(Ehp,(0,p.A)({},Bhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}Ghp.isMDXComponent=!0;const Ohp={toc:[]},Uhp="wrapper";function Fhp(e){let{components:n,...t}=e;return(0,s.yg)(Uhp,(0,p.A)({},Ohp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}Fhp.isMDXComponent=!0;const Vhp={toc:[]},qhp="wrapper";function jhp(e){let{components:n,...t}=e;return(0,s.yg)(qhp,(0,p.A)({},Vhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}jhp.isMDXComponent=!0;const Hhp={toc:[]},Yhp="wrapper";function Qhp(e){let{components:n,...t}=e;return(0,s.yg)(Yhp,(0,p.A)({},Hhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Qhp.isMDXComponent=!0;const $hp={toc:[]},Khp="wrapper";function Jhp(e){let{components:n,...t}=e;return(0,s.yg)(Khp,(0,p.A)({},$hp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}Jhp.isMDXComponent=!0;const Zhp={toc:[]},egp="wrapper";function ngp(e){let{components:n,...t}=e;return(0,s.yg)(egp,(0,p.A)({},Zhp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}ngp.isMDXComponent=!0;const tgp={toc:[]},ogp="wrapper";function pgp(e){let{components:n,...t}=e;return(0,s.yg)(ogp,(0,p.A)({},tgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}pgp.isMDXComponent=!0;const rgp={toc:[]},sgp="wrapper";function cgp(e){let{components:n,...t}=e;return(0,s.yg)(sgp,(0,p.A)({},rgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}cgp.isMDXComponent=!0;const agp={toc:[]},igp="wrapper";function lgp(e){let{components:n,...t}=e;return(0,s.yg)(igp,(0,p.A)({},agp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}lgp.isMDXComponent=!0;const ugp={toc:[]},mgp="wrapper";function ygp(e){let{components:n,...t}=e;return(0,s.yg)(mgp,(0,p.A)({},ugp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}ygp.isMDXComponent=!0;const dgp={toc:[]},hgp="wrapper";function ggp(e){let{components:n,...t}=e;return(0,s.yg)(hgp,(0,p.A)({},dgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}ggp.isMDXComponent=!0;const fgp={toc:[]},Dgp="wrapper";function Mgp(e){let{components:n,...t}=e;return(0,s.yg)(Dgp,(0,p.A)({},fgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Mgp.isMDXComponent=!0;const Xgp={toc:[]},_gp="wrapper";function wgp(e){let{components:n,...t}=e;return(0,s.yg)(_gp,(0,p.A)({},Xgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}wgp.isMDXComponent=!0;const Tgp={toc:[]},Cgp="wrapper";function xgp(e){let{components:n,...t}=e;return(0,s.yg)(Cgp,(0,p.A)({},Tgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}xgp.isMDXComponent=!0;const Agp={toc:[]},vgp="wrapper";function Lgp(e){let{components:n,...t}=e;return(0,s.yg)(vgp,(0,p.A)({},Agp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Lgp.isMDXComponent=!0;const bgp={toc:[]},Ngp="wrapper";function kgp(e){let{components:n,...t}=e;return(0,s.yg)(Ngp,(0,p.A)({},bgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}kgp.isMDXComponent=!0;const zgp={toc:[]},Pgp="wrapper";function Igp(e){let{components:n,...t}=e;return(0,s.yg)(Pgp,(0,p.A)({},zgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}Igp.isMDXComponent=!0;const Rgp={toc:[]},Wgp="wrapper";function Sgp(e){let{components:n,...t}=e;return(0,s.yg)(Wgp,(0,p.A)({},Rgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Sgp.isMDXComponent=!0;const Bgp={toc:[]},Egp="wrapper";function Ggp(e){let{components:n,...t}=e;return(0,s.yg)(Egp,(0,p.A)({},Bgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}Ggp.isMDXComponent=!0;const Ogp={toc:[]},Ugp="wrapper";function Fgp(e){let{components:n,...t}=e;return(0,s.yg)(Ugp,(0,p.A)({},Ogp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Fgp.isMDXComponent=!0;const Vgp={toc:[]},qgp="wrapper";function jgp(e){let{components:n,...t}=e;return(0,s.yg)(qgp,(0,p.A)({},Vgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}jgp.isMDXComponent=!0;const Hgp={toc:[]},Ygp="wrapper";function Qgp(e){let{components:n,...t}=e;return(0,s.yg)(Ygp,(0,p.A)({},Hgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}Qgp.isMDXComponent=!0;const $gp={toc:[]},Kgp="wrapper";function Jgp(e){let{components:n,...t}=e;return(0,s.yg)(Kgp,(0,p.A)({},$gp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Jgp.isMDXComponent=!0;const Zgp={toc:[]},efp="wrapper";function nfp(e){let{components:n,...t}=e;return(0,s.yg)(efp,(0,p.A)({},Zgp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}nfp.isMDXComponent=!0;const tfp={toc:[]},ofp="wrapper";function pfp(e){let{components:n,...t}=e;return(0,s.yg)(ofp,(0,p.A)({},tfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}pfp.isMDXComponent=!0;const rfp={toc:[]},sfp="wrapper";function cfp(e){let{components:n,...t}=e;return(0,s.yg)(sfp,(0,p.A)({},rfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}cfp.isMDXComponent=!0;const afp={toc:[]},ifp="wrapper";function lfp(e){let{components:n,...t}=e;return(0,s.yg)(ifp,(0,p.A)({},afp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}lfp.isMDXComponent=!0;const ufp={toc:[]},mfp="wrapper";function yfp(e){let{components:n,...t}=e;return(0,s.yg)(mfp,(0,p.A)({},ufp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}yfp.isMDXComponent=!0;const dfp={toc:[]},hfp="wrapper";function gfp(e){let{components:n,...t}=e;return(0,s.yg)(hfp,(0,p.A)({},dfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}gfp.isMDXComponent=!0;const ffp={toc:[]},Dfp="wrapper";function Mfp(e){let{components:n,...t}=e;return(0,s.yg)(Dfp,(0,p.A)({},ffp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Mfp.isMDXComponent=!0;const Xfp={toc:[]},_fp="wrapper";function wfp(e){let{components:n,...t}=e;return(0,s.yg)(_fp,(0,p.A)({},Xfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}wfp.isMDXComponent=!0;const Tfp={toc:[]},Cfp="wrapper";function xfp(e){let{components:n,...t}=e;return(0,s.yg)(Cfp,(0,p.A)({},Tfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}xfp.isMDXComponent=!0;const Afp={toc:[]},vfp="wrapper";function Lfp(e){let{components:n,...t}=e;return(0,s.yg)(vfp,(0,p.A)({},Afp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Lfp.isMDXComponent=!0;const bfp={toc:[]},Nfp="wrapper";function kfp(e){let{components:n,...t}=e;return(0,s.yg)(Nfp,(0,p.A)({},bfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}kfp.isMDXComponent=!0;const zfp={toc:[]},Pfp="wrapper";function Ifp(e){let{components:n,...t}=e;return(0,s.yg)(Pfp,(0,p.A)({},zfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}Ifp.isMDXComponent=!0;const Rfp={toc:[]},Wfp="wrapper";function Sfp(e){let{components:n,...t}=e;return(0,s.yg)(Wfp,(0,p.A)({},Rfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Sfp.isMDXComponent=!0;const Bfp={toc:[]},Efp="wrapper";function Gfp(e){let{components:n,...t}=e;return(0,s.yg)(Efp,(0,p.A)({},Bfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}Gfp.isMDXComponent=!0;const Ofp={toc:[]},Ufp="wrapper";function Ffp(e){let{components:n,...t}=e;return(0,s.yg)(Ufp,(0,p.A)({},Ofp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}Ffp.isMDXComponent=!0;const Vfp={toc:[]},qfp="wrapper";function jfp(e){let{components:n,...t}=e;return(0,s.yg)(qfp,(0,p.A)({},Vfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}jfp.isMDXComponent=!0;const Hfp={toc:[]},Yfp="wrapper";function Qfp(e){let{components:n,...t}=e;return(0,s.yg)(Yfp,(0,p.A)({},Hfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Qfp.isMDXComponent=!0;const $fp={toc:[]},Kfp="wrapper";function Jfp(e){let{components:n,...t}=e;return(0,s.yg)(Kfp,(0,p.A)({},$fp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}Jfp.isMDXComponent=!0;const Zfp={toc:[]},eDp="wrapper";function nDp(e){let{components:n,...t}=e;return(0,s.yg)(eDp,(0,p.A)({},Zfp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Video#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}nDp.isMDXComponent=!0;const tDp={toc:[]},oDp="wrapper";function pDp(e){let{components:n,...t}=e;return(0,s.yg)(oDp,(0,p.A)({},tDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}pDp.isMDXComponent=!0;const rDp={toc:[]},sDp="wrapper";function cDp(e){let{components:n,...t}=e;return(0,s.yg)(sDp,(0,p.A)({},rDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}cDp.isMDXComponent=!0;const aDp={toc:[]},iDp="wrapper";function lDp(e){let{components:n,...t}=e;return(0,s.yg)(iDp,(0,p.A)({},aDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}lDp.isMDXComponent=!0;const uDp={toc:[]},mDp="wrapper";function yDp(e){let{components:n,...t}=e;return(0,s.yg)(mDp,(0,p.A)({},uDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}yDp.isMDXComponent=!0;const dDp={toc:[]},hDp="wrapper";function gDp(e){let{components:n,...t}=e;return(0,s.yg)(hDp,(0,p.A)({},dDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}gDp.isMDXComponent=!0;const fDp={toc:[]},DDp="wrapper";function MDp(e){let{components:n,...t}=e;return(0,s.yg)(DDp,(0,p.A)({},fDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}MDp.isMDXComponent=!0;const XDp={toc:[]},_Dp="wrapper";function wDp(e){let{components:n,...t}=e;return(0,s.yg)(_Dp,(0,p.A)({},XDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}wDp.isMDXComponent=!0;const TDp={toc:[]},CDp="wrapper";function xDp(e){let{components:n,...t}=e;return(0,s.yg)(CDp,(0,p.A)({},TDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the position in world space."))}xDp.isMDXComponent=!0;const ADp={toc:[]},vDp="wrapper";function LDp(e){let{components:n,...t}=e;return(0,s.yg)(vDp,(0,p.A)({},ADp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.yg)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}LDp.isMDXComponent=!0;const bDp={toc:[]},NDp="wrapper";function kDp(e){let{components:n,...t}=e;return(0,s.yg)(NDp,(0,p.A)({},bDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the rotation in world space."))}kDp.isMDXComponent=!0;const zDp={toc:[]},PDp="wrapper";function IDp(e){let{components:n,...t}=e;return(0,s.yg)(PDp,(0,p.A)({},zDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.yg)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#scale"},(0,s.yg)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"y")," components."))}IDp.isMDXComponent=!0;const RDp={toc:[]},WDp="wrapper";function SDp(e){let{components:n,...t}=e;return(0,s.yg)(WDp,(0,p.A)({},RDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A helper signal for operating on the scale in world space."))}SDp.isMDXComponent=!0;const BDp={toc:[]},EDp="wrapper";function GDp(e){let{components:n,...t}=e;return(0,s.yg)(EDp,(0,p.A)({},BDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}GDp.isMDXComponent=!0;const ODp={toc:[]},UDp="wrapper";function FDp(e){let{components:n,...t}=e;return(0,s.yg)(UDp,(0,p.A)({},ODp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}FDp.isMDXComponent=!0;const VDp={toc:[]},qDp="wrapper";function jDp(e){let{components:n,...t}=e;return(0,s.yg)(qDp,(0,p.A)({},VDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}jDp.isMDXComponent=!0;const HDp={toc:[]},YDp="wrapper";function QDp(e){let{components:n,...t}=e;return(0,s.yg)(YDp,(0,p.A)({},HDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}QDp.isMDXComponent=!0;const $Dp={toc:[]},KDp="wrapper";function JDp(e){let{components:n,...t}=e;return(0,s.yg)(KDp,(0,p.A)({},$Dp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}JDp.isMDXComponent=!0;const ZDp={toc:[]},eMp="wrapper";function nMp(e){let{components:n,...t}=e;return(0,s.yg)(eMp,(0,p.A)({},ZDp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}nMp.isMDXComponent=!0;const tMp={toc:[]},oMp="wrapper";function pMp(e){let{components:n,...t}=e;return(0,s.yg)(oMp,(0,p.A)({},tMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}pMp.isMDXComponent=!0;const rMp={toc:[]},sMp="wrapper";function cMp(e){let{components:n,...t}=e;return(0,s.yg)(sMp,(0,p.A)({},rMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}cMp.isMDXComponent=!0;const aMp={toc:[]},iMp="wrapper";function lMp(e){let{components:n,...t}=e;return(0,s.yg)(iMp,(0,p.A)({},aMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}lMp.isMDXComponent=!0;const uMp={toc:[]},mMp="wrapper";function yMp(e){let{components:n,...t}=e;return(0,s.yg)(mMp,(0,p.A)({},uMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}yMp.isMDXComponent=!0;const dMp={toc:[]},hMp="wrapper";function gMp(e){let{components:n,...t}=e;return(0,s.yg)(hMp,(0,p.A)({},dMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}gMp.isMDXComponent=!0;const fMp={toc:[]},DMp="wrapper";function MMp(e){let{components:n,...t}=e;return(0,s.yg)(DMp,(0,p.A)({},fMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}MMp.isMDXComponent=!0;const XMp={toc:[]},_Mp="wrapper";function wMp(e){let{components:n,...t}=e;return(0,s.yg)(_Mp,(0,p.A)({},XMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}wMp.isMDXComponent=!0;const TMp={toc:[]},CMp="wrapper";function xMp(e){let{components:n,...t}=e;return(0,s.yg)(CMp,(0,p.A)({},TMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}xMp.isMDXComponent=!0;const AMp={toc:[]},vMp="wrapper";function LMp(e){let{components:n,...t}=e;return(0,s.yg)(vMp,(0,p.A)({},AMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}LMp.isMDXComponent=!0;const bMp={toc:[]},NMp="wrapper";function kMp(e){let{components:n,...t}=e;return(0,s.yg)(NMp,(0,p.A)({},bMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}kMp.isMDXComponent=!0;const zMp={toc:[]},PMp="wrapper";function IMp(e){let{components:n,...t}=e;return(0,s.yg)(PMp,(0,p.A)({},zMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}IMp.isMDXComponent=!0;const RMp={toc:[]},WMp="wrapper";function SMp(e){let{components:n,...t}=e;return(0,s.yg)(WMp,(0,p.A)({},RMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}SMp.isMDXComponent=!0;const BMp={toc:[]},EMp="wrapper";function GMp(e){let{components:n,...t}=e;return(0,s.yg)(EMp,(0,p.A)({},BMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}GMp.isMDXComponent=!0;const OMp={toc:[]},UMp="wrapper";function FMp(e){let{components:n,...t}=e;return(0,s.yg)(UMp,(0,p.A)({},OMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}FMp.isMDXComponent=!0;const VMp={toc:[]},qMp="wrapper";function jMp(e){let{components:n,...t}=e;return(0,s.yg)(qMp,(0,p.A)({},VMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}jMp.isMDXComponent=!0;const HMp={toc:[]},YMp="wrapper";function QMp(e){let{components:n,...t}=e;return(0,s.yg)(YMp,(0,p.A)({},HMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}QMp.isMDXComponent=!0;const $Mp={toc:[]},KMp="wrapper";function JMp(e){let{components:n,...t}=e;return(0,s.yg)(KMp,(0,p.A)({},$Mp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}JMp.isMDXComponent=!0;const ZMp={toc:[]},eXp="wrapper";function nXp(e){let{components:n,...t}=e;return(0,s.yg)(eXp,(0,p.A)({},ZMp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.yg)("p",null,"If the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."),(0,s.yg)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}nXp.isMDXComponent=!0;const tXp={toc:[]},oXp="wrapper";function pXp(e){let{components:n,...t}=e;return(0,s.yg)(oXp,(0,p.A)({},tXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}pXp.isMDXComponent=!0;const rXp={toc:[]},sXp="wrapper";function cXp(e){let{components:n,...t}=e;return(0,s.yg)(sXp,(0,p.A)({},rXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.yg)("p",null,"The value is relative to the size of this node. A value of ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}cXp.isMDXComponent=!0;const aXp={toc:[]},iXp="wrapper";function lXp(e){let{components:n,...t}=e;return(0,s.yg)(iXp,(0,p.A)({},aXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the offset of this node's origin."))}lXp.isMDXComponent=!0;const uXp={toc:[]},mXp="wrapper";function yXp(e){let{components:n,...t}=e;return(0,s.yg)(mXp,(0,p.A)({},uXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value is clamped to the range 0-1."))}yXp.isMDXComponent=!0;const dXp={toc:[]},hXp="wrapper";function gXp(e){let{components:n,...t}=e;return(0,s.yg)(hXp,(0,p.A)({},dXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the opacity of this node in the range 0-1."))}gXp.isMDXComponent=!0;const fXp={toc:[]},DXp="wrapper";function MXp(e){let{components:n,...t}=e;return(0,s.yg)(DXp,(0,p.A)({},fXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.yg)("p",null,"Accessing the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.yg)("p",null,"Setting the position:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}MXp.isMDXComponent=!0;const XXp={toc:[]},_Xp="wrapper";function wXp(e){let{components:n,...t}=e;return(0,s.yg)(_Xp,(0,p.A)({},XXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the position of this node in local space of its parent."))}wXp.isMDXComponent=!0;const TXp={toc:[]},CXp="wrapper";function xXp(e){let{components:n,...t}=e;return(0,s.yg)(CXp,(0,p.A)({},TXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}xXp.isMDXComponent=!0;const AXp={toc:[]},vXp="wrapper";function LXp(e){let{components:n,...t}=e;return(0,s.yg)(vXp,(0,p.A)({},AXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"One uniform radius:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}LXp.isMDXComponent=!0;const bXp={toc:[]},NXp="wrapper";function kXp(e){let{components:n,...t}=e;return(0,s.yg)(NXp,(0,p.A)({},bXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Individual radii for each corner:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}kXp.isMDXComponent=!0;const zXp={toc:[]},PXp="wrapper";function IXp(e){let{components:n,...t}=e;return(0,s.yg)(PXp,(0,p.A)({},zXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}IXp.isMDXComponent=!0;const RXp={toc:[]},WXp="wrapper";function SXp(e){let{components:n,...t}=e;return(0,s.yg)(WXp,(0,p.A)({},RXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}SXp.isMDXComponent=!0;const BXp={toc:[]},EXp="wrapper";function GXp(e){let{components:n,...t}=e;return(0,s.yg)(EXp,(0,p.A)({},BXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}GXp.isMDXComponent=!0;const OXp={toc:[]},UXp="wrapper";function FXp(e){let{components:n,...t}=e;return(0,s.yg)(UXp,(0,p.A)({},OXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}FXp.isMDXComponent=!0;const VXp={toc:[]},qXp="wrapper";function jXp(e){let{components:n,...t}=e;return(0,s.yg)(qXp,(0,p.A)({},VXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.yg)("p",null,"Accessing the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.yg)("p",null,"Setting the scale:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}jXp.isMDXComponent=!0;const HXp={toc:[]},YXp="wrapper";function QXp(e){let{components:n,...t}=e;return(0,s.yg)(YXp,(0,p.A)({},HXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the scale of this node in local space of its parent."))}QXp.isMDXComponent=!0;const $Xp={toc:[]},KXp="wrapper";function JXp(e){let{components:n,...t}=e;return(0,s.yg)(KXp,(0,p.A)({},$Xp,t,{components:n,mdxType:"MDXLayout"}))}JXp.isMDXComponent=!0;const ZXp={toc:[]},e_p="wrapper";function n_p(e){let{components:n,...t}=e;return(0,s.yg)(e_p,(0,p.A)({},ZXp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A size is a two-dimensional vector, where ",(0,s.yg)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.yg)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.yg)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.yg)("inlineCode",{parentName:"p"},"height"),"."),(0,s.yg)("p",null,"The value of both x and y is of type ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.yg)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.yg)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.yg)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.yg)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.yg)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.yg)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}n_p.isMDXComponent=!0;const t_p={toc:[]},o_p="wrapper";function p_p(e){let{components:n,...t}=e;return(0,s.yg)(o_p,(0,p.A)({},t_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.yg)("p",null,"Accessing the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.yg)("p",null,"Setting the size:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}p_p.isMDXComponent=!0;const r_p={toc:[]},s_p="wrapper";function c_p(e){let{components:n,...t}=e;return(0,s.yg)(s_p,(0,p.A)({},r_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the size of this node."))}c_p.isMDXComponent=!0;const a_p={toc:[]},i_p="wrapper";function l_p(e){let{components:n,...t}=e;return(0,s.yg)(i_p,(0,p.A)({},a_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Initializing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.yg)("p",null,"Accessing the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.yg)("p",null,"Setting the skew:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}l_p.isMDXComponent=!0;const u_p={toc:[]},m_p="wrapper";function y_p(e){let{components:n,...t}=e;return(0,s.yg)(m_p,(0,p.A)({},u_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents the skew of this node in local space of its parent."))}y_p.isMDXComponent=!0;const d_p={toc:[]},h_p="wrapper";function g_p(e){let{components:n,...t}=e;return(0,s.yg)(h_p,(0,p.A)({},d_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}g_p.isMDXComponent=!0;const f_p={toc:[]},D_p="wrapper";function M_p(e){let{components:n,...t}=e;return(0,s.yg)(D_p,(0,p.A)({},f_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}M_p.isMDXComponent=!0;const X_p={toc:[]},__p="wrapper";function w_p(e){let{components:n,...t}=e;return(0,s.yg)(__p,(0,p.A)({},X_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}w_p.isMDXComponent=!0;const T_p={toc:[]},C_p="wrapper";function x_p(e){let{components:n,...t}=e;return(0,s.yg)(C_p,(0,p.A)({},T_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}x_p.isMDXComponent=!0;const A_p={toc:[]},v_p="wrapper";function L_p(e){let{components:n,...t}=e;return(0,s.yg)(v_p,(0,p.A)({},A_p,t,{components:n,mdxType:"MDXLayout"}))}L_p.isMDXComponent=!0;const b_p={toc:[]},N_p="wrapper";function k_p(e){let{components:n,...t}=e;return(0,s.yg)(N_p,(0,p.A)({},b_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}k_p.isMDXComponent=!0;const z_p={toc:[]},P_p="wrapper";function I_p(e){let{components:n,...t}=e;return(0,s.yg)(P_p,(0,p.A)({},z_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}I_p.isMDXComponent=!0;const R_p={toc:[]},W_p="wrapper";function S_p(e){let{components:n,...t}=e;return(0,s.yg)(W_p,(0,p.A)({},R_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}S_p.isMDXComponent=!0;const B_p={toc:[]},E_p="wrapper";function G_p(e){let{components:n,...t}=e;return(0,s.yg)(E_p,(0,p.A)({},B_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}G_p.isMDXComponent=!0;const O_p={toc:[]},U_p="wrapper";function F_p(e){let{components:n,...t}=e;return(0,s.yg)(U_p,(0,p.A)({},O_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}F_p.isMDXComponent=!0;const V_p={toc:[]},q_p="wrapper";function j_p(e){let{components:n,...t}=e;return(0,s.yg)(q_p,(0,p.A)({},V_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}j_p.isMDXComponent=!0;const H_p={toc:[]},Y_p="wrapper";function Q_p(e){let{components:n,...t}=e;return(0,s.yg)(Y_p,(0,p.A)({},H_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Q_p.isMDXComponent=!0;const $_p={toc:[]},K_p="wrapper";function J_p(e){let{components:n,...t}=e;return(0,s.yg)(K_p,(0,p.A)({},$_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}J_p.isMDXComponent=!0;const Z_p={toc:[]},ewp="wrapper";function nwp(e){let{components:n,...t}=e;return(0,s.yg)(ewp,(0,p.A)({},Z_p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}nwp.isMDXComponent=!0;const twp={toc:[]},owp="wrapper";function pwp(e){let{components:n,...t}=e;return(0,s.yg)(owp,(0,p.A)({},twp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}pwp.isMDXComponent=!0;const rwp={toc:[]},swp="wrapper";function cwp(e){let{components:n,...t}=e;return(0,s.yg)(swp,(0,p.A)({},rwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.yg)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}cwp.isMDXComponent=!0;const awp={toc:[]},iwp="wrapper";function lwp(e){let{components:n,...t}=e;return(0,s.yg)(iwp,(0,p.A)({},awp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}lwp.isMDXComponent=!0;const uwp={toc:[]},mwp="wrapper";function ywp(e){let{components:n,...t}=e;return(0,s.yg)(mwp,(0,p.A)({},uwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The nodes will be appended at the end of the children list."))}ywp.isMDXComponent=!0;const dwp={toc:[]},hwp="wrapper";function gwp(e){let{components:n,...t}=e;return(0,s.yg)(hwp,(0,p.A)({},dwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}gwp.isMDXComponent=!0;const fwp={toc:[]},Dwp="wrapper";function Mwp(e){let{components:n,...t}=e;return(0,s.yg)(Dwp,(0,p.A)({},fwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Add the given node(s) as the children of this node."))}Mwp.isMDXComponent=!0;const Xwp={toc:[]},_wp="wrapper";function wwp(e){let{components:n,...t}=e;return(0,s.yg)(_wp,(0,p.A)({},Xwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to append."))}wwp.isMDXComponent=!0;const Twp={toc:[]},Cwp="wrapper";function xwp(e){let{components:n,...t}=e;return(0,s.yg)(Cwp,(0,p.A)({},Twp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}xwp.isMDXComponent=!0;const Awp={toc:[]},vwp="wrapper";function Lwp(e){let{components:n,...t}=e;return(0,s.yg)(vwp,(0,p.A)({},Awp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to apply to the node."))}Lwp.isMDXComponent=!0;const bwp={toc:[]},Nwp="wrapper";function kwp(e){let{components:n,...t}=e;return(0,s.yg)(Nwp,(0,p.A)({},bwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}kwp.isMDXComponent=!0;const zwp={toc:[]},Pwp="wrapper";function Iwp(e){let{components:n,...t}=e;return(0,s.yg)(Pwp,(0,p.A)({},zwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The state to transition to."))}Iwp.isMDXComponent=!0;const Rwp={toc:[]},Wwp="wrapper";function Swp(e){let{components:n,...t}=e;return(0,s.yg)(Wwp,(0,p.A)({},Rwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Swp.isMDXComponent=!0;const Bwp={toc:[]},Ewp="wrapper";function Gwp(e){let{components:n,...t}=e;return(0,s.yg)(Ewp,(0,p.A)({},Bwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Gwp.isMDXComponent=!0;const Owp={toc:[]},Uwp="wrapper";function Fwp(e){let{components:n,...t}=e;return(0,s.yg)(Uwp,(0,p.A)({},Owp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This arc length accounts for both the offset and the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end"))," properties."))}Fwp.isMDXComponent=!0;const Vwp={toc:[]},qwp="wrapper";function jwp(e){let{components:n,...t}=e;return(0,s.yg)(qwp,(0,p.A)({},Vwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The visible arc length of this curve."))}jwp.isMDXComponent=!0;const Hwp={toc:[]},Ywp="wrapper";function Qwp(e){let{components:n,...t}=e;return(0,s.yg)(Ywp,(0,p.A)({},Hwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Qwp.isMDXComponent=!0;const $wp={toc:[]},Kwp="wrapper";function Jwp(e){let{components:n,...t}=e;return(0,s.yg)(Kwp,(0,p.A)({},$wp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The base arc length of this curve."))}Jwp.isMDXComponent=!0;const Zwp={toc:[]},eTp="wrapper";function nTp(e){let{components:n,...t}=e;return(0,s.yg)(eTp,(0,p.A)({},Zwp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}nTp.isMDXComponent=!0;const tTp={toc:[]},oTp="wrapper";function pTp(e){let{components:n,...t}=e;return(0,s.yg)(oTp,(0,p.A)({},tTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}pTp.isMDXComponent=!0;const rTp={toc:[]},sTp="wrapper";function cTp(e){let{components:n,...t}=e;return(0,s.yg)(sTp,(0,p.A)({},rTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the nth children cast to the specified type."))}cTp.isMDXComponent=!0;const aTp={toc:[]},iTp="wrapper";function lTp(e){let{components:n,...t}=e;return(0,s.yg)(iTp,(0,p.A)({},aTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index of the child to retrieve."))}lTp.isMDXComponent=!0;const uTp={toc:[]},mTp="wrapper";function yTp(e){let{components:n,...t}=e;return(0,s.yg)(mTp,(0,p.A)({},uTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the children array cast to the specified type."))}yTp.isMDXComponent=!0;const dTp={toc:[]},hTp="wrapper";function gTp(e){let{components:n,...t}=e;return(0,s.yg)(hTp,(0,p.A)({},dTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}gTp.isMDXComponent=!0;const fTp={toc:[]},DTp="wrapper";function MTp(e){let{components:n,...t}=e;return(0,s.yg)(DTp,(0,p.A)({},fTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}MTp.isMDXComponent=!0;const XTp={toc:[]},_Tp="wrapper";function wTp(e){let{components:n,...t}=e;return(0,s.yg)(_Tp,(0,p.A)({},XTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Collect all asynchronous resources used by this node."))}wTp.isMDXComponent=!0;const TTp={toc:[]},CTp="wrapper";function xTp(e){let{components:n,...t}=e;return(0,s.yg)(CTp,(0,p.A)({},TTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}xTp.isMDXComponent=!0;const ATp={toc:[]},vTp="wrapper";function LTp(e){let{components:n,...t}=e;return(0,s.yg)(vTp,(0,p.A)({},ATp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage of the curve that's currently visible."))}LTp.isMDXComponent=!0;const bTp={toc:[]},NTp="wrapper";function kTp(e){let{components:n,...t}=e;return(0,s.yg)(NTp,(0,p.A)({},bTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}kTp.isMDXComponent=!0;const zTp={toc:[]},PTp="wrapper";function ITp(e){let{components:n,...t}=e;return(0,s.yg)(PTp,(0,p.A)({},zTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A matrix mapping composite space to world space."))}ITp.isMDXComponent=!0;const RTp={toc:[]},WTp="wrapper";function STp(e){let{components:n,...t}=e;return(0,s.yg)(WTp,(0,p.A)({},RTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}STp.isMDXComponent=!0;const BTp={toc:[]},ETp="wrapper";function GTp(e){let{components:n,...t}=e;return(0,s.yg)(ETp,(0,p.A)({},BTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the desired size of this node."))}GTp.isMDXComponent=!0;const OTp={toc:[]},UTp="wrapper";function FTp(e){let{components:n,...t}=e;return(0,s.yg)(UTp,(0,p.A)({},OTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.yg)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}FTp.isMDXComponent=!0;const VTp={toc:[]},qTp="wrapper";function jTp(e){let{components:n,...t}=e;return(0,s.yg)(qTp,(0,p.A)({},VTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare this node to be disposed of."))}jTp.isMDXComponent=!0;const HTp={toc:[]},YTp="wrapper";function QTp(e){let{components:n,...t}=e;return(0,s.yg)(YTp,(0,p.A)({},HTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}QTp.isMDXComponent=!0;const $Tp={toc:[]},KTp="wrapper";function JTp(e){let{components:n,...t}=e;return(0,s.yg)(KTp,(0,p.A)({},$Tp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a distance along the curve to a percentage."))}JTp.isMDXComponent=!0;const ZTp={toc:[]},eCp="wrapper";function nCp(e){let{components:n,...t}=e;return(0,s.yg)(eCp,(0,p.A)({},ZTp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The distance along the curve."))}nCp.isMDXComponent=!0;const tCp={toc:[]},oCp="wrapper";function pCp(e){let{components:n,...t}=e;return(0,s.yg)(oCp,(0,p.A)({},tCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}pCp.isMDXComponent=!0;const rCp={toc:[]},sCp="wrapper";function cCp(e){let{components:n,...t}=e;return(0,s.yg)(sCp,(0,p.A)({},rCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw this node onto the canvas."))}cCp.isMDXComponent=!0;const aCp={toc:[]},iCp="wrapper";function lCp(e){let{components:n,...t}=e;return(0,s.yg)(iCp,(0,p.A)({},aCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}lCp.isMDXComponent=!0;const uCp={toc:[]},mCp="wrapper";function yCp(e){let{components:n,...t}=e;return(0,s.yg)(mCp,(0,p.A)({},uCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.yg)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}yCp.isMDXComponent=!0;const dCp={toc:[]},hCp="wrapper";function gCp(e){let{components:n,...t}=e;return(0,s.yg)(hCp,(0,p.A)({},dCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Draw an overlay for this node."))}gCp.isMDXComponent=!0;const fCp={toc:[]},DCp="wrapper";function MCp(e){let{components:n,...t}=e;return(0,s.yg)(DCp,(0,p.A)({},fCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}MCp.isMDXComponent=!0;const XCp={toc:[]},_Cp="wrapper";function wCp(e){let{components:n,...t}=e;return(0,s.yg)(_Cp,(0,p.A)({},XCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A local-to-screen matrix."))}wCp.isMDXComponent=!0;const TCp={toc:[]},CCp="wrapper";function xCp(e){let{components:n,...t}=e;return(0,s.yg)(CCp,(0,p.A)({},TCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}xCp.isMDXComponent=!0;const ACp={toc:[]},vCp="wrapper";function LCp(e){let{components:n,...t}=e;return(0,s.yg)(vCp,(0,p.A)({},ACp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}LCp.isMDXComponent=!0;const bCp={toc:[]},NCp="wrapper";function kCp(e){let{components:n,...t}=e;return(0,s.yg)(NCp,(0,p.A)({},bCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find all descendants of this node that match the given predicate."))}kCp.isMDXComponent=!0;const zCp={toc:[]},PCp="wrapper";function ICp(e){let{components:n,...t}=e;return(0,s.yg)(PCp,(0,p.A)({},zCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}ICp.isMDXComponent=!0;const RCp={toc:[]},WCp="wrapper";function SCp(e){let{components:n,...t}=e;return(0,s.yg)(WCp,(0,p.A)({},RCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}SCp.isMDXComponent=!0;const BCp={toc:[]},ECp="wrapper";function GCp(e){let{components:n,...t}=e;return(0,s.yg)(ECp,(0,p.A)({},BCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}GCp.isMDXComponent=!0;const OCp={toc:[]},UCp="wrapper";function FCp(e){let{components:n,...t}=e;return(0,s.yg)(UCp,(0,p.A)({},OCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}FCp.isMDXComponent=!0;const VCp={toc:[]},qCp="wrapper";function jCp(e){let{components:n,...t}=e;return(0,s.yg)(qCp,(0,p.A)({},VCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}jCp.isMDXComponent=!0;const HCp={toc:[]},YCp="wrapper";function QCp(e){let{components:n,...t}=e;return(0,s.yg)(YCp,(0,p.A)({},HCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}QCp.isMDXComponent=!0;const $Cp={toc:[]},KCp="wrapper";function JCp(e){let{components:n,...t}=e;return(0,s.yg)(KCp,(0,p.A)({},$Cp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}JCp.isMDXComponent=!0;const ZCp={toc:[]},exp="wrapper";function nxp(e){let{components:n,...t}=e;return(0,s.yg)(exp,(0,p.A)({},ZCp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the first descendant of this node that matches the given predicate."))}nxp.isMDXComponent=!0;const txp={toc:[]},oxp="wrapper";function pxp(e){let{components:n,...t}=e;return(0,s.yg)(oxp,(0,p.A)({},txp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}pxp.isMDXComponent=!0;const rxp={toc:[]},sxp="wrapper";function cxp(e){let{components:n,...t}=e;return(0,s.yg)(sxp,(0,p.A)({},rxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find a node by its key."))}cxp.isMDXComponent=!0;const axp={toc:[]},ixp="wrapper";function lxp(e){let{components:n,...t}=e;return(0,s.yg)(ixp,(0,p.A)({},axp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The key of the node."))}lxp.isMDXComponent=!0;const uxp={toc:[]},mxp="wrapper";function yxp(e){let{components:n,...t}=e;return(0,s.yg)(mxp,(0,p.A)({},uxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}yxp.isMDXComponent=!0;const dxp={toc:[]},hxp="wrapper";function gxp(e){let{components:n,...t}=e;return(0,s.yg)(hxp,(0,p.A)({},dxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}gxp.isMDXComponent=!0;const fxp={toc:[]},Dxp="wrapper";function Mxp(e){let{components:n,...t}=e;return(0,s.yg)(Dxp,(0,p.A)({},fxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the last descendant of this node that matches the given predicate."))}Mxp.isMDXComponent=!0;const Xxp={toc:[]},_xp="wrapper";function wxp(e){let{components:n,...t}=e;return(0,s.yg)(_xp,(0,p.A)({},Xxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A function that returns true if the node matches."))}wxp.isMDXComponent=!0;const Txp={toc:[]},Cxp="wrapper";function xxp(e){let{components:n,...t}=e;return(0,s.yg)(Cxp,(0,p.A)({},Txp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}xxp.isMDXComponent=!0;const Axp={toc:[]},vxp="wrapper";function Lxp(e){let{components:n,...t}=e;return(0,s.yg)(vxp,(0,p.A)({},Axp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Lxp.isMDXComponent=!0;const bxp={toc:[]},Nxp="wrapper";function kxp(e){let{components:n,...t}=e;return(0,s.yg)(Nxp,(0,p.A)({},bxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned bounding box should be in local space."))}kxp.isMDXComponent=!0;const zxp={toc:[]},Pxp="wrapper";function Ixp(e){let{components:n,...t}=e;return(0,s.yg)(Pxp,(0,p.A)({},zxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box for the contents rendered by this node."))}Ixp.isMDXComponent=!0;const Rxp={toc:[]},Wxp="wrapper";function Sxp(e){let{components:n,...t}=e;return(0,s.yg)(Wxp,(0,p.A)({},Rxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Sxp.isMDXComponent=!0;const Bxp={toc:[]},Exp="wrapper";function Gxp(e){let{components:n,...t}=e;return(0,s.yg)(Exp,(0,p.A)({},Bxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return a snapshot of the node's current signal values."))}Gxp.isMDXComponent=!0;const Oxp={toc:[]},Uxp="wrapper";function Fxp(e){let{components:n,...t}=e;return(0,s.yg)(Uxp,(0,p.A)({},Oxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Try to find a node intersecting the given position."))}Fxp.isMDXComponent=!0;const Vxp={toc:[]},qxp="wrapper";function jxp(e){let{components:n,...t}=e;return(0,s.yg)(qxp,(0,p.A)({},Vxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The searched position."))}jxp.isMDXComponent=!0;const Hxp={toc:[]},Yxp="wrapper";function Qxp(e){let{components:n,...t}=e;return(0,s.yg)(Yxp,(0,p.A)({},Hxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.yg)("p",null,"Result:"),(0,s.yg)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Qxp.isMDXComponent=!0;const $xp={toc:[]},Kxp="wrapper";function Jxp(e){let{components:n,...t}=e;return(0,s.yg)(Kxp,(0,p.A)({},$xp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Insert the given node(s) at the specified index in the children list."))}Jxp.isMDXComponent=!0;const Zxp={toc:[]},eAp="wrapper";function nAp(e){let{components:n,...t}=e;return(0,s.yg)(eAp,(0,p.A)({},Zxp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A node or an array of nodes to insert."))}nAp.isMDXComponent=!0;const tAp={toc:[]},oAp="wrapper";function pAp(e){let{components:n,...t}=e;return(0,s.yg)(oAp,(0,p.A)({},tAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"An index at which to insert the node(s)."))}pAp.isMDXComponent=!0;const rAp={toc:[]},sAp="wrapper";function cAp(e){let{components:n,...t}=e;return(0,s.yg)(sAp,(0,p.A)({},rAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an instance of this node's class."))}cAp.isMDXComponent=!0;const aAp={toc:[]},iAp="wrapper";function lAp(e){let{components:n,...t}=e;return(0,s.yg)(iAp,(0,p.A)({},aAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to pass to the constructor."))}lAp.isMDXComponent=!0;const uAp={toc:[]},mAp="wrapper";function yAp(e){let{components:n,...t}=e;return(0,s.yg)(mAp,(0,p.A)({},uAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the mode is ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,s.yg)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}yAp.isMDXComponent=!0;const dAp={toc:[]},hAp="wrapper";function gAp(e){let{components:n,...t}=e;return(0,s.yg)(hAp,(0,p.A)({},dAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the resolved layout mode of this node."))}gAp.isMDXComponent=!0;const fAp={toc:[]},DAp="wrapper";function MAp(e){let{components:n,...t}=e;return(0,s.yg)(DAp,(0,p.A)({},fAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}MAp.isMDXComponent=!0;const XAp={toc:[]},_Ap="wrapper";function wAp(e){let{components:n,...t}=e;return(0,s.yg)(_Ap,(0,p.A)({},XAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-parent matrix for this node."))}wAp.isMDXComponent=!0;const TAp={toc:[]},CAp="wrapper";function xAp(e){let{components:n,...t}=e;return(0,s.yg)(CAp,(0,p.A)({},TAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}xAp.isMDXComponent=!0;const AAp={toc:[]},vAp="wrapper";function LAp(e){let{components:n,...t}=e;return(0,s.yg)(vAp,(0,p.A)({},AAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}LAp.isMDXComponent=!0;const bAp={toc:[]},NAp="wrapper";function kAp(e){let{components:n,...t}=e;return(0,s.yg)(NAp,(0,p.A)({},bAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the local-to-world matrix for this node."))}kAp.isMDXComponent=!0;const zAp={toc:[]},PAp="wrapper";function IAp(e){let{components:n,...t}=e;return(0,s.yg)(PAp,(0,p.A)({},zAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.yg)("p",null,"A positive ",(0,s.yg)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}IAp.isMDXComponent=!0;const RAp={toc:[]},WAp="wrapper";function SAp(e){let{components:n,...t}=e;return(0,s.yg)(WAp,(0,p.A)({},RAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rearrange this node in relation to its siblings."))}SAp.isMDXComponent=!0;const BAp={toc:[]},EAp="wrapper";function GAp(e){let{components:n,...t}=e;return(0,s.yg)(EAp,(0,p.A)({},BAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Number of places by which the node should be moved."))}GAp.isMDXComponent=!0;const OAp={toc:[]},UAp="wrapper";function FAp(e){let{components:n,...t}=e;return(0,s.yg)(UAp,(0,p.A)({},OAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}FAp.isMDXComponent=!0;const VAp={toc:[]},qAp="wrapper";function jAp(e){let{components:n,...t}=e;return(0,s.yg)(qAp,(0,p.A)({},VAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node above the provided node in the parent's layout."))}jAp.isMDXComponent=!0;const HAp={toc:[]},YAp="wrapper";function QAp(e){let{components:n,...t}=e;return(0,s.yg)(YAp,(0,p.A)({},HAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}QAp.isMDXComponent=!0;const $Ap={toc:[]},KAp="wrapper";function JAp(e){let{components:n,...t}=e;return(0,s.yg)(KAp,(0,p.A)({},$Ap,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}JAp.isMDXComponent=!0;const ZAp={toc:[]},evp="wrapper";function nvp(e){let{components:n,...t}=e;return(0,s.yg)(evp,(0,p.A)({},ZAp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}nvp.isMDXComponent=!0;const tvp={toc:[]},ovp="wrapper";function pvp(e){let{components:n,...t}=e;return(0,s.yg)(ovp,(0,p.A)({},tvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node below the provided node in the parent's layout."))}pvp.isMDXComponent=!0;const rvp={toc:[]},svp="wrapper";function cvp(e){let{components:n,...t}=e;return(0,s.yg)(svp,(0,p.A)({},rvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The sibling node below which to move."))}cvp.isMDXComponent=!0;const avp={toc:[]},ivp="wrapper";function lvp(e){let{components:n,...t}=e;return(0,s.yg)(ivp,(0,p.A)({},avp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}lvp.isMDXComponent=!0;const uvp={toc:[]},mvp="wrapper";function yvp(e){let{components:n,...t}=e;return(0,s.yg)(mvp,(0,p.A)({},uvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}yvp.isMDXComponent=!0;const dvp={toc:[]},hvp="wrapper";function gvp(e){let{components:n,...t}=e;return(0,s.yg)(hvp,(0,p.A)({},dvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node down in relation to its siblings."))}gvp.isMDXComponent=!0;const fvp={toc:[]},Dvp="wrapper";function Mvp(e){let{components:n,...t}=e;return(0,s.yg)(Dvp,(0,p.A)({},fvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Mvp.isMDXComponent=!0;const Xvp={toc:[]},_vp="wrapper";function wvp(e){let{components:n,...t}=e;return(0,s.yg)(_vp,(0,p.A)({},Xvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new offset."))}wvp.isMDXComponent=!0;const Tvp={toc:[]},Cvp="wrapper";function xvp(e){let{components:n,...t}=e;return(0,s.yg)(Cvp,(0,p.A)({},Tvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}xvp.isMDXComponent=!0;const Avp={toc:[]},vvp="wrapper";function Lvp(e){let{components:n,...t}=e;return(0,s.yg)(vvp,(0,p.A)({},Avp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the provided position relative to its siblings."))}Lvp.isMDXComponent=!0;const bvp={toc:[]},Nvp="wrapper";function kvp(e){let{components:n,...t}=e;return(0,s.yg)(Nvp,(0,p.A)({},bvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The index to move the node to."))}kvp.isMDXComponent=!0;const zvp={toc:[]},Pvp="wrapper";function Ivp(e){let{components:n,...t}=e;return(0,s.yg)(Pvp,(0,p.A)({},zvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Ivp.isMDXComponent=!0;const Rvp={toc:[]},Wvp="wrapper";function Svp(e){let{components:n,...t}=e;return(0,s.yg)(Wvp,(0,p.A)({},Rvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the bottom in relation to its siblings."))}Svp.isMDXComponent=!0;const Bvp={toc:[]},Evp="wrapper";function Gvp(e){let{components:n,...t}=e;return(0,s.yg)(Evp,(0,p.A)({},Bvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Gvp.isMDXComponent=!0;const Ovp={toc:[]},Uvp="wrapper";function Fvp(e){let{components:n,...t}=e;return(0,s.yg)(Uvp,(0,p.A)({},Ovp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node to the top in relation to its siblings."))}Fvp.isMDXComponent=!0;const Vvp={toc:[]},qvp="wrapper";function jvp(e){let{components:n,...t}=e;return(0,s.yg)(qvp,(0,p.A)({},Vvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}jvp.isMDXComponent=!0;const Hvp={toc:[]},Yvp="wrapper";function Qvp(e){let{components:n,...t}=e;return(0,s.yg)(Yvp,(0,p.A)({},Hvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Move the node up in relation to its siblings."))}Qvp.isMDXComponent=!0;const $vp={toc:[]},Kvp="wrapper";function Jvp(e){let{components:n,...t}=e;return(0,s.yg)(Kvp,(0,p.A)({},$vp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the length of the curve that accounts for\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"the offsets")),"."))}Jvp.isMDXComponent=!0;const Zvp={toc:[]},eLp="wrapper";function nLp(e){let{components:n,...t}=e;return(0,s.yg)(eLp,(0,p.A)({},Zvp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset arc length of this curve."))}nLp.isMDXComponent=!0;const tLp={toc:[]},oLp="wrapper";function pLp(e){let{components:n,...t}=e;return(0,s.yg)(oLp,(0,p.A)({},tLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the parent cast to the specified type."))}pLp.isMDXComponent=!0;const rLp={toc:[]},sLp="wrapper";function cLp(e){let{components:n,...t}=e;return(0,s.yg)(sLp,(0,p.A)({},rLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Parse any ",(0,s.yg)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}cLp.isMDXComponent=!0;const aLp={toc:[]},iLp="wrapper";function lLp(e){let{components:n,...t}=e;return(0,s.yg)(iLp,(0,p.A)({},aLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to parse."))}lLp.isMDXComponent=!0;const uLp={toc:[]},mLp="wrapper";function yLp(e){let{components:n,...t}=e;return(0,s.yg)(mLp,(0,p.A)({},uLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children")),", this method does not have any side effects.\nIt does not register the ",(0,s.yg)("inlineCode",{parentName:"p"},"children")," signal as a dependency, and it does not\nspawn any children. It can be used to safely retrieve the current state of\nthe scene graph for debugging purposes."))}yLp.isMDXComponent=!0;const dLp={toc:[]},hLp="wrapper";function gLp(e){let{components:n,...t}=e;return(0,s.yg)(hLp,(0,p.A)({},dLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the current children of this node."))}gLp.isMDXComponent=!0;const fLp={toc:[]},DLp="wrapper";function MLp(e){let{components:n,...t}=e;return(0,s.yg)(DLp,(0,p.A)({},fLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),"."))}MLp.isMDXComponent=!0;const XLp={toc:[]},_Lp="wrapper";function wLp(e){let{components:n,...t}=e;return(0,s.yg)(_Lp,(0,p.A)({},XLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Convert a percentage along the curve to a distance."))}wLp.isMDXComponent=!0;const TLp={toc:[]},CLp="wrapper";function xLp(e){let{components:n,...t}=e;return(0,s.yg)(CLp,(0,p.A)({},TLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage along the curve."))}xLp.isMDXComponent=!0;const ALp={toc:[]},vLp="wrapper";function LLp(e){let{components:n,...t}=e;return(0,s.yg)(vLp,(0,p.A)({},ALp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}LLp.isMDXComponent=!0;const bLp={toc:[]},NLp="wrapper";function kLp(e){let{components:n,...t}=e;return(0,s.yg)(NLp,(0,p.A)({},bLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a reactive copy of this node."))}kLp.isMDXComponent=!0;const zLp={toc:[]},PLp="wrapper";function ILp(e){let{components:n,...t}=e;return(0,s.yg)(PLp,(0,p.A)({},zLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}ILp.isMDXComponent=!0;const RLp={toc:[]},WLp="wrapper";function SLp(e){let{components:n,...t}=e;return(0,s.yg)(WLp,(0,p.A)({},RLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove this node from the tree."))}SLp.isMDXComponent=!0;const BLp={toc:[]},ELp="wrapper";function GLp(e){let{components:n,...t}=e;return(0,s.yg)(ELp,(0,p.A)({},BLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove the given child."))}GLp.isMDXComponent=!0;const OLp={toc:[]},ULp="wrapper";function FLp(e){let{components:n,...t}=e;return(0,s.yg)(ULp,(0,p.A)({},OLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Remove all children of this node."))}FLp.isMDXComponent=!0;const VLp={toc:[]},qLp="wrapper";function jLp(e){let{components:n,...t}=e;return(0,s.yg)(qLp,(0,p.A)({},VLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Render this node onto the given canvas."))}jLp.isMDXComponent=!0;const HLp={toc:[]},YLp="wrapper";function QLp(e){let{components:n,...t}=e;return(0,s.yg)(YLp,(0,p.A)({},HLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context to draw with."))}QLp.isMDXComponent=!0;const $Lp={toc:[]},KLp="wrapper";function JLp(e){let{components:n,...t}=e;return(0,s.yg)(KLp,(0,p.A)({},$Lp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}JLp.isMDXComponent=!0;const ZLp={toc:[]},ebp="wrapper";function nbp(e){let{components:n,...t}=e;return(0,s.yg)(ebp,(0,p.A)({},ZLp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Change the parent of this node while keeping the absolute transform."))}nbp.isMDXComponent=!0;const tbp={toc:[]},obp="wrapper";function pbp(e){let{components:n,...t}=e;return(0,s.yg)(obp,(0,p.A)({},tbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The new parent of this node."))}pbp.isMDXComponent=!0;const rbp={toc:[]},sbp="wrapper";function cbp(e){let{components:n,...t}=e;return(0,s.yg)(sbp,(0,p.A)({},rbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new font changes to this node and all of its ancestors."))}cbp.isMDXComponent=!0;const abp={toc:[]},ibp="wrapper";function lbp(e){let{components:n,...t}=e;return(0,s.yg)(ibp,(0,p.A)({},abp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Find the closest layout root and apply any new layout changes."))}lbp.isMDXComponent=!0;const ubp={toc:[]},mbp="wrapper";function ybp(e){let{components:n,...t}=e;return(0,s.yg)(mbp,(0,p.A)({},ubp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether this node should be cached or not."))}ybp.isMDXComponent=!0;const dbp={toc:[]},hbp="wrapper";function gbp(e){let{components:n,...t}=e;return(0,s.yg)(hbp,(0,p.A)({},dbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}gbp.isMDXComponent=!0;const fbp={toc:[]},Dbp="wrapper";function Mbp(e){let{components:n,...t}=e;return(0,s.yg)(Dbp,(0,p.A)({},fbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the path requires a profile."))}Mbp.isMDXComponent=!0;const Xbp={toc:[]},_bp="wrapper";function wbp(e){let{components:n,...t}=e;return(0,s.yg)(_bp,(0,p.A)({},Xbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}wbp.isMDXComponent=!0;const Tbp={toc:[]},Cbp="wrapper";function xbp(e){let{components:n,...t}=e;return(0,s.yg)(Cbp,(0,p.A)({},Tbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}xbp.isMDXComponent=!0;const Abp={toc:[]},vbp="wrapper";function Lbp(e){let{components:n,...t}=e;return(0,s.yg)(vbp,(0,p.A)({},Abp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Restore the node to its last saved state."))}Lbp.isMDXComponent=!0;const bbp={toc:[]},Nbp="wrapper";function kbp(e){let{components:n,...t}=e;return(0,s.yg)(Nbp,(0,p.A)({},bbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,s.yg)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}kbp.isMDXComponent=!0;const zbp={toc:[]},Pbp="wrapper";function Ibp(e){let{components:n,...t}=e;return(0,s.yg)(Pbp,(0,p.A)({},zbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Ibp.isMDXComponent=!0;const Rbp={toc:[]},Wbp="wrapper";function Sbp(e){let{components:n,...t}=e;return(0,s.yg)(Wbp,(0,p.A)({},Rbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Tween the node to its last saved state."))}Sbp.isMDXComponent=!0;const Bbp={toc:[]},Ebp="wrapper";function Gbp(e){let{components:n,...t}=e;return(0,s.yg)(Ebp,(0,p.A)({},Bbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The duration of the transition."))}Gbp.isMDXComponent=!0;const Obp={toc:[]},Ubp="wrapper";function Fbp(e){let{components:n,...t}=e;return(0,s.yg)(Ubp,(0,p.A)({},Obp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The timing function to use for the transition."))}Fbp.isMDXComponent=!0;const Vbp={toc:[]},qbp="wrapper";function jbp(e){let{components:n,...t}=e;return(0,s.yg)(qbp,(0,p.A)({},Vbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used together with the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#restore"},(0,s.yg)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.yg)("inlineCode",{parentName:"p"},"save")," method multiple times."))}jbp.isMDXComponent=!0;const Hbp={toc:[]},Ybp="wrapper";function Qbp(e){let{components:n,...t}=e;return(0,s.yg)(Ybp,(0,p.A)({},Hbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Qbp.isMDXComponent=!0;const $bp={toc:[]},Kbp="wrapper";function Jbp(e){let{components:n,...t}=e;return(0,s.yg)(Kbp,(0,p.A)({},$bp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Jbp.isMDXComponent=!0;const Zbp={toc:[]},eNp="wrapper";function nNp(e){let{components:n,...t}=e;return(0,s.yg)(eNp,(0,p.A)({},Zbp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Set the children without parsing them."))}nNp.isMDXComponent=!0;const tNp={toc:[]},oNp="wrapper";function pNp(e){let{components:n,...t}=e;return(0,s.yg)(oNp,(0,p.A)({},tNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The children to set."))}pNp.isMDXComponent=!0;const rNp={toc:[]},sNp="wrapper";function cNp(e){let{components:n,...t}=e;return(0,s.yg)(sNp,(0,p.A)({},rNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.yg)("p",null,"Whether the node is cached is decided by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,s.yg)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}cNp.isMDXComponent=!0;const aNp={toc:[]},iNp="wrapper";function lNp(e){let{components:n,...t}=e;return(0,s.yg)(iNp,(0,p.A)({},aNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Prepare the given context for drawing a cached node onto it."))}lNp.isMDXComponent=!0;const uNp={toc:[]},mNp="wrapper";function yNp(e){let{components:n,...t}=e;return(0,s.yg)(mNp,(0,p.A)({},uNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The context using which the cache will be drawn."))}yNp.isMDXComponent=!0;const dNp={toc:[]},hNp="wrapper";function gNp(e){let{components:n,...t}=e;return(0,s.yg)(hNp,(0,p.A)({},dNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,s.yg)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}gNp.isMDXComponent=!0;const fNp={toc:[]},DNp="wrapper";function MNp(e){let{components:n,...t}=e;return(0,s.yg)(DNp,(0,p.A)({},fNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a copy of this node."))}MNp.isMDXComponent=!0;const XNp={toc:[]},_Np="wrapper";function wNp(e){let{components:n,...t}=e;return(0,s.yg)(_Np,(0,p.A)({},XNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Properties to override."))}wNp.isMDXComponent=!0;const TNp={toc:[]},CNp="wrapper";function xNp(e){let{components:n,...t}=e;return(0,s.yg)(CNp,(0,p.A)({},TNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}xNp.isMDXComponent=!0;const ANp={toc:[]},vNp="wrapper";function LNp(e){let{components:n,...t}=e;return(0,s.yg)(vNp,(0,p.A)({},ANp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Wait for any asynchronous resources that this node or its children have."))}LNp.isMDXComponent=!0;const bNp={toc:[]},NNp="wrapper";function kNp(e){let{components:n,...t}=e;return(0,s.yg)(NNp,(0,p.A)({},bNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Apply any new layout changes to this node and its children."))}kNp.isMDXComponent=!0;const zNp={toc:[]},PNp="wrapper";function INp(e){let{components:n,...t}=e;return(0,s.yg)(PNp,(0,p.A)({},zNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is the same the bounding box returned by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2D#cacheBBox"},(0,s.yg)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}INp.isMDXComponent=!0;const RNp={toc:[]},WNp="wrapper";function SNp(e){let{components:n,...t}=e;return(0,s.yg)(WNp,(0,p.A)({},RNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}SNp.isMDXComponent=!0;const BNp={toc:[]},ENp="wrapper";function GNp(e){let{components:n,...t}=e;return(0,s.yg)(ENp,(0,p.A)({},BNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}GNp.isMDXComponent=!0;const ONp={toc:[]},UNp="wrapper";function FNp(e){let{components:n,...t}=e;return(0,s.yg)(UNp,(0,p.A)({},ONp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}FNp.isMDXComponent=!0;const VNp={toc:[]},qNp="wrapper";function jNp(e){let{components:n,...t}=e;return(0,s.yg)(qNp,(0,p.A)({},VNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-local matrix for this node."))}jNp.isMDXComponent=!0;const HNp={toc:[]},YNp="wrapper";function QNp(e){let{components:n,...t}=e;return(0,s.yg)(YNp,(0,p.A)({},HNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}QNp.isMDXComponent=!0;const $Np={toc:[]},KNp="wrapper";function JNp(e){let{components:n,...t}=e;return(0,s.yg)(KNp,(0,p.A)({},$Np,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the world-to-parent matrix for this node."))}JNp.isMDXComponent=!0;const ZNp={toc:[]},ekp="wrapper";function nkp(e){let{components:n,...t}=e;return(0,s.yg)(ekp,(0,p.A)({},ZNp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}nkp.isMDXComponent=!0;const tkp={toc:[]},okp="wrapper";function pkp(e){let{components:n,...t}=e;return(0,s.yg)(okp,(0,p.A)({},tkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}pkp.isMDXComponent=!0;const rkp={toc:[]},skp="wrapper";function ckp(e){let{components:n,...t}=e;return(0,s.yg)(skp,(0,p.A)({},rkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}ckp.isMDXComponent=!0;const akp={toc:[]},ikp="wrapper";function lkp(e){let{components:n,...t}=e;return(0,s.yg)(ikp,(0,p.A)({},akp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}lkp.isMDXComponent=!0;const ukp={toc:[]},mkp="wrapper";function ykp(e){let{components:n,...t}=e;return(0,s.yg)(mkp,(0,p.A)({},ukp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}ykp.isMDXComponent=!0;const dkp={toc:[]},hkp="wrapper";function gkp(e){let{components:n,...t}=e;return(0,s.yg)(hkp,(0,p.A)({},dkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}gkp.isMDXComponent=!0;const fkp={toc:[]},Dkp="wrapper";function Mkp(e){let{components:n,...t}=e;return(0,s.yg)(Dkp,(0,p.A)({},fkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Mkp.isMDXComponent=!0;const Xkp={toc:[]},_kp="wrapper";function wkp(e){let{components:n,...t}=e;return(0,s.yg)(_kp,(0,p.A)({},Xkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}wkp.isMDXComponent=!0;const Tkp={toc:[]},Ckp="wrapper";function xkp(e){let{components:n,...t}=e;return(0,s.yg)(Ckp,(0,p.A)({},Tkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}xkp.isMDXComponent=!0;const Akp={toc:[]},vkp="wrapper";function Lkp(e){let{components:n,...t}=e;return(0,s.yg)(vkp,(0,p.A)({},Akp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Lkp.isMDXComponent=!0;const bkp={toc:[]},Nkp="wrapper";function kkp(e){let{components:n,...t}=e;return(0,s.yg)(Nkp,(0,p.A)({},bkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}kkp.isMDXComponent=!0;const zkp={toc:[]},Pkp="wrapper";function Ikp(e){let{components:n,...t}=e;return(0,s.yg)(Pkp,(0,p.A)({},zkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Ikp.isMDXComponent=!0;const Rkp={toc:[]},Wkp="wrapper";function Skp(e){let{components:n,...t}=e;return(0,s.yg)(Wkp,(0,p.A)({},Rkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Skp.isMDXComponent=!0;const Bkp={toc:[]},Ekp="wrapper";function Gkp(e){let{components:n,...t}=e;return(0,s.yg)(Ekp,(0,p.A)({},Bkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Gkp.isMDXComponent=!0;const Okp={toc:[]},Ukp="wrapper";function Fkp(e){let{components:n,...t}=e;return(0,s.yg)(Ukp,(0,p.A)({},Okp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Fkp.isMDXComponent=!0;const Vkp={toc:[]},qkp="wrapper";function jkp(e){let{components:n,...t}=e;return(0,s.yg)(qkp,(0,p.A)({},Vkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}jkp.isMDXComponent=!0;const Hkp={toc:[]},Ykp="wrapper";function Qkp(e){let{components:n,...t}=e;return(0,s.yg)(Ykp,(0,p.A)({},Hkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Qkp.isMDXComponent=!0;const $kp={toc:[]},Kkp="wrapper";function Jkp(e){let{components:n,...t}=e;return(0,s.yg)(Kkp,(0,p.A)({},$kp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Jkp.isMDXComponent=!0;const Zkp={toc:[]},ezp="wrapper";function nzp(e){let{components:n,...t}=e;return(0,s.yg)(ezp,(0,p.A)({},Zkp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}nzp.isMDXComponent=!0;const tzp={toc:[]},ozp="wrapper";function pzp(e){let{components:n,...t}=e;return(0,s.yg)(ozp,(0,p.A)({},tzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the path of this circle should be closed."))}pzp.isMDXComponent=!0;const rzp={toc:[]},szp="wrapper";function czp(e){let{components:n,...t}=e;return(0,s.yg)(szp,(0,p.A)({},rzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the circle begins at ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"startAngle"))," and is drawn clockwise\nuntil reaching ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"endAngle")),". Setting this property to true will reverse\nthis direction."))}czp.isMDXComponent=!0;const azp={toc:[]},izp="wrapper";function lzp(e){let{components:n,...t}=e;return(0,s.yg)(izp,(0,p.A)({},azp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the circle sector should be drawn counterclockwise."))}lzp.isMDXComponent=!0;const uzp={toc:[]},mzp="wrapper";function yzp(e){let{components:n,...t}=e;return(0,s.yg)(mzp,(0,p.A)({},uzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}yzp.isMDXComponent=!0;const dzp={toc:[]},hzp="wrapper";function gzp(e){let{components:n,...t}=e;return(0,s.yg)(hzp,(0,p.A)({},dzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}gzp.isMDXComponent=!0;const fzp={toc:[]},Dzp="wrapper";function Mzp(e){let{components:n,...t}=e;return(0,s.yg)(Dzp,(0,p.A)({},fzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property can be used together with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}Mzp.isMDXComponent=!0;const Xzp={toc:[]},_zp="wrapper";function wzp(e){let{components:n,...t}=e;return(0,s.yg)(_zp,(0,p.A)({},Xzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ending angle in degrees for the circle sector."))}wzp.isMDXComponent=!0;const Tzp={toc:[]},Czp="wrapper";function xzp(e){let{components:n,...t}=e;return(0,s.yg)(Czp,(0,p.A)({},Tzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}xzp.isMDXComponent=!0;const Azp={toc:[]},vzp="wrapper";function Lzp(e){let{components:n,...t}=e;return(0,s.yg)(vzp,(0,p.A)({},Azp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}Lzp.isMDXComponent=!0;const bzp={toc:[]},Nzp="wrapper";function kzp(e){let{components:n,...t}=e;return(0,s.yg)(Nzp,(0,p.A)({},bzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}kzp.isMDXComponent=!0;const zzp={toc:[]},Pzp="wrapper";function Izp(e){let{components:n,...t}=e;return(0,s.yg)(Pzp,(0,p.A)({},zzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}Izp.isMDXComponent=!0;const Rzp={toc:[]},Wzp="wrapper";function Szp(e){let{components:n,...t}=e;return(0,s.yg)(Wzp,(0,p.A)({},Rzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Szp.isMDXComponent=!0;const Bzp={toc:[]},Ezp="wrapper";function Gzp(e){let{components:n,...t}=e;return(0,s.yg)(Ezp,(0,p.A)({},Bzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Gzp.isMDXComponent=!0;const Ozp={toc:[]},Uzp="wrapper";function Fzp(e){let{components:n,...t}=e;return(0,s.yg)(Uzp,(0,p.A)({},Ozp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}Fzp.isMDXComponent=!0;const Vzp={toc:[]},qzp="wrapper";function jzp(e){let{components:n,...t}=e;return(0,s.yg)(qzp,(0,p.A)({},Vzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}jzp.isMDXComponent=!0;const Hzp={toc:[]},Yzp="wrapper";function Qzp(e){let{components:n,...t}=e;return(0,s.yg)(Yzp,(0,p.A)({},Hzp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Qzp.isMDXComponent=!0;const $zp={toc:[]},Kzp="wrapper";function Jzp(e){let{components:n,...t}=e;return(0,s.yg)(Kzp,(0,p.A)({},$zp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Jzp.isMDXComponent=!0;const Zzp={toc:[]},ePp="wrapper";function nPp(e){let{components:n,...t}=e;return(0,s.yg)(ePp,(0,p.A)({},Zzp,t,{components:n,mdxType:"MDXLayout"}))}nPp.isMDXComponent=!0;const tPp={toc:[]},oPp="wrapper";function pPp(e){let{components:n,...t}=e;return(0,s.yg)(oPp,(0,p.A)({},tPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}pPp.isMDXComponent=!0;const rPp={toc:[]},sPp="wrapper";function cPp(e){let{components:n,...t}=e;return(0,s.yg)(sPp,(0,p.A)({},rPp,t,{components:n,mdxType:"MDXLayout"}))}cPp.isMDXComponent=!0;const aPp={toc:[]},iPp="wrapper";function lPp(e){let{components:n,...t}=e;return(0,s.yg)(iPp,(0,p.A)({},aPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}lPp.isMDXComponent=!0;const uPp={toc:[]},mPp="wrapper";function yPp(e){let{components:n,...t}=e;return(0,s.yg)(mPp,(0,p.A)({},uPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}yPp.isMDXComponent=!0;const dPp={toc:[]},hPp="wrapper";function gPp(e){let{components:n,...t}=e;return(0,s.yg)(hPp,(0,p.A)({},dPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property can be used together with ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,s.yg)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}gPp.isMDXComponent=!0;const fPp={toc:[]},DPp="wrapper";function MPp(e){let{components:n,...t}=e;return(0,s.yg)(DPp,(0,p.A)({},fPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The starting angle in degrees for the circle sector."))}MPp.isMDXComponent=!0;const XPp={toc:[]},_Pp="wrapper";function wPp(e){let{components:n,...t}=e;return(0,s.yg)(_Pp,(0,p.A)({},XPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wPp.isMDXComponent=!0;const TPp={toc:[]},CPp="wrapper";function xPp(e){let{components:n,...t}=e;return(0,s.yg)(CPp,(0,p.A)({},TPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}xPp.isMDXComponent=!0;const APp={toc:[]},vPp="wrapper";function LPp(e){let{components:n,...t}=e;return(0,s.yg)(vPp,(0,p.A)({},APp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CircleProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}LPp.isMDXComponent=!0;const bPp={toc:[]},NPp="wrapper";function kPp(e){let{components:n,...t}=e;return(0,s.yg)(NPp,(0,p.A)({},bPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}kPp.isMDXComponent=!0;const zPp={toc:[]},PPp="wrapper";function IPp(e){let{components:n,...t}=e;return(0,s.yg)(PPp,(0,p.A)({},zPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}IPp.isMDXComponent=!0;const RPp={toc:[]},WPp="wrapper";function SPp(e){let{components:n,...t}=e;return(0,s.yg)(WPp,(0,p.A)({},RPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}SPp.isMDXComponent=!0;const BPp={toc:[]},EPp="wrapper";function GPp(e){let{components:n,...t}=e;return(0,s.yg)(EPp,(0,p.A)({},BPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}GPp.isMDXComponent=!0;const OPp={toc:[]},UPp="wrapper";function FPp(e){let{components:n,...t}=e;return(0,s.yg)(UPp,(0,p.A)({},OPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}FPp.isMDXComponent=!0;const VPp={toc:[]},qPp="wrapper";function jPp(e){let{components:n,...t}=e;return(0,s.yg)(qPp,(0,p.A)({},VPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}jPp.isMDXComponent=!0;const HPp={toc:[]},YPp="wrapper";function QPp(e){let{components:n,...t}=e;return(0,s.yg)(YPp,(0,p.A)({},HPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}QPp.isMDXComponent=!0;const $Pp={toc:[]},KPp="wrapper";function JPp(e){let{components:n,...t}=e;return(0,s.yg)(KPp,(0,p.A)({},$Pp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}JPp.isMDXComponent=!0;const ZPp={toc:[]},eIp="wrapper";function nIp(e){let{components:n,...t}=e;return(0,s.yg)(eIp,(0,p.A)({},ZPp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}nIp.isMDXComponent=!0;const tIp={toc:[]},oIp="wrapper";function pIp(e){let{components:n,...t}=e;return(0,s.yg)(oIp,(0,p.A)({},tIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}pIp.isMDXComponent=!0;const rIp={toc:[]},sIp="wrapper";function cIp(e){let{components:n,...t}=e;return(0,s.yg)(sIp,(0,p.A)({},rIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}cIp.isMDXComponent=!0;const aIp={toc:[]},iIp="wrapper";function lIp(e){let{components:n,...t}=e;return(0,s.yg)(iIp,(0,p.A)({},aIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}lIp.isMDXComponent=!0;const uIp={toc:[]},mIp="wrapper";function yIp(e){let{components:n,...t}=e;return(0,s.yg)(mIp,(0,p.A)({},uIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}yIp.isMDXComponent=!0;const dIp={toc:[]},hIp="wrapper";function gIp(e){let{components:n,...t}=e;return(0,s.yg)(hIp,(0,p.A)({},dIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}gIp.isMDXComponent=!0;const fIp={toc:[]},DIp="wrapper";function MIp(e){let{components:n,...t}=e;return(0,s.yg)(DIp,(0,p.A)({},fIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}MIp.isMDXComponent=!0;const XIp={toc:[]},_Ip="wrapper";function wIp(e){let{components:n,...t}=e;return(0,s.yg)(_Ip,(0,p.A)({},XIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}wIp.isMDXComponent=!0;const TIp={toc:[]},CIp="wrapper";function xIp(e){let{components:n,...t}=e;return(0,s.yg)(CIp,(0,p.A)({},TIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}xIp.isMDXComponent=!0;const AIp={toc:[]},vIp="wrapper";function LIp(e){let{components:n,...t}=e;return(0,s.yg)(vIp,(0,p.A)({},AIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}LIp.isMDXComponent=!0;const bIp={toc:[]},NIp="wrapper";function kIp(e){let{components:n,...t}=e;return(0,s.yg)(NIp,(0,p.A)({},bIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}kIp.isMDXComponent=!0;const zIp={toc:[]},PIp="wrapper";function IIp(e){let{components:n,...t}=e;return(0,s.yg)(PIp,(0,p.A)({},zIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}IIp.isMDXComponent=!0;const RIp={toc:[]},WIp="wrapper";function SIp(e){let{components:n,...t}=e;return(0,s.yg)(WIp,(0,p.A)({},RIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}SIp.isMDXComponent=!0;const BIp={toc:[]},EIp="wrapper";function GIp(e){let{components:n,...t}=e;return(0,s.yg)(EIp,(0,p.A)({},BIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}GIp.isMDXComponent=!0;const OIp={toc:[]},UIp="wrapper";function FIp(e){let{components:n,...t}=e;return(0,s.yg)(UIp,(0,p.A)({},OIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}FIp.isMDXComponent=!0;const VIp={toc:[]},qIp="wrapper";function jIp(e){let{components:n,...t}=e;return(0,s.yg)(qIp,(0,p.A)({},VIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code to display."))}jIp.isMDXComponent=!0;const HIp={toc:[]},YIp="wrapper";function QIp(e){let{components:n,...t}=e;return(0,s.yg)(YIp,(0,p.A)({},HIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This value will be passed to the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/CodeHighlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"CodeHighlighter")),"\ndefined by the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#highlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"highlighter"))," property. Different highlighters may use\nit differently."),(0,s.yg)("p",null,"The default ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/LezerHighlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"LezerHighlighter"))," uses it to select\nthe language parser to use. The parser for the given dialect can be\nregistered as follows:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},"// Import the lezer parser:\nimport {parser} from '@lezer/javascript';\n\n// Register it in the highlighter:\nLezerHighlighter.registerParser(parser, 'js');\n\n// Use the dialect in a code node:\n<Code dialect=\"js\" code=\"const a = 7;\" />\n")),(0,s.yg)("p",null,"When no dialect is provided, the highlighter will use the default\nparser:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-tsx"},'// Register the default parser by omitting the dialect:\nLezerHighlighter.registerParser(parser);\n\n// Code nodes with no dialect will now use the default parser:\n<Code code="const a = 7;" />\n')))}QIp.isMDXComponent=!0;const $Ip={toc:[]},KIp="wrapper";function JIp(e){let{components:n,...t}=e;return(0,s.yg)(KIp,(0,p.A)({},$Ip,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The dialect to use for highlighting the code."))}JIp.isMDXComponent=!0;const ZIp={toc:[]},eRp="wrapper";function nRp(e){let{components:n,...t}=e;return(0,s.yg)(eRp,(0,p.A)({},ZIp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check out ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/DrawHooks"},(0,s.yg)("inlineCode",{parentName:"a"},"DrawHooks"))," for available render hooks."))}nRp.isMDXComponent=!0;const tRp={toc:[]},oRp="wrapper";function pRp(e){let{components:n,...t}=e;return(0,s.yg)(oRp,(0,p.A)({},tRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Custom drawing logic for the code."))}pRp.isMDXComponent=!0;const rRp={toc:[]},sRp="wrapper";function cRp(e){let{components:n,...t}=e;return(0,s.yg)(sRp,(0,p.A)({},rRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Defaults to a shared ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code/LezerHighlighter"},(0,s.yg)("inlineCode",{parentName:"a"},"LezerHighlighter")),"."))}cRp.isMDXComponent=!0;const aRp={toc:[]},iRp="wrapper";function lRp(e){let{components:n,...t}=e;return(0,s.yg)(iRp,(0,p.A)({},aRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The code highlighter to use for this code node."))}lRp.isMDXComponent=!0;const uRp={toc:[]},mRp="wrapper";function yRp(e){let{components:n,...t}=e;return(0,s.yg)(mRp,(0,p.A)({},uRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}yRp.isMDXComponent=!0;const dRp={toc:[]},hRp="wrapper";function gRp(e){let{components:n,...t}=e;return(0,s.yg)(hRp,(0,p.A)({},dRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}gRp.isMDXComponent=!0;const fRp={toc:[]},DRp="wrapper";function MRp(e){let{components:n,...t}=e;return(0,s.yg)(DRp,(0,p.A)({},fRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}MRp.isMDXComponent=!0;const XRp={toc:[]},_Rp="wrapper";function wRp(e){let{components:n,...t}=e;return(0,s.yg)(_Rp,(0,p.A)({},XRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}wRp.isMDXComponent=!0;const TRp={toc:[]},CRp="wrapper";function xRp(e){let{components:n,...t}=e;return(0,s.yg)(CRp,(0,p.A)({},TRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}xRp.isMDXComponent=!0;const ARp={toc:[]},vRp="wrapper";function LRp(e){let{components:n,...t}=e;return(0,s.yg)(vRp,(0,p.A)({},ARp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}LRp.isMDXComponent=!0;const bRp={toc:[]},NRp="wrapper";function kRp(e){let{components:n,...t}=e;return(0,s.yg)(NRp,(0,p.A)({},bRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Either a single ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#CodeRange"},(0,s.yg)("inlineCode",{parentName:"a"},"CodeRange"))," or an array of them\ndescribing which parts of the code should be visually emphasized."),(0,s.yg)("p",null,"You can use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#word"},(0,s.yg)("inlineCode",{parentName:"a"},"word"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/code#lines"},(0,s.yg)("inlineCode",{parentName:"a"},"lines"))," to quickly create ranges."))}kRp.isMDXComponent=!0;const zRp={toc:[]},PRp="wrapper";function IRp(e){let{components:n,...t}=e;return(0,s.yg)(PRp,(0,p.A)({},zRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The currently selected code range."))}IRp.isMDXComponent=!0;const RRp={toc:[]},WRp="wrapper";function SRp(e){let{components:n,...t}=e;return(0,s.yg)(WRp,(0,p.A)({},RRp,t,{components:n,mdxType:"MDXLayout"}))}SRp.isMDXComponent=!0;const BRp={toc:[]},ERp="wrapper";function GRp(e){let{components:n,...t}=e;return(0,s.yg)(ERp,(0,p.A)({},BRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CodeProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}GRp.isMDXComponent=!0;const ORp={toc:[]},URp="wrapper";function FRp(e){let{components:n,...t}=e;return(0,s.yg)(URp,(0,p.A)({},ORp,t,{components:n,mdxType:"MDXLayout"}))}FRp.isMDXComponent=!0;const VRp={toc:[]},qRp="wrapper";function jRp(e){let{components:n,...t}=e;return(0,s.yg)(qRp,(0,p.A)({},VRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}jRp.isMDXComponent=!0;const HRp={toc:[]},YRp="wrapper";function QRp(e){let{components:n,...t}=e;return(0,s.yg)(YRp,(0,p.A)({},HRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}QRp.isMDXComponent=!0;const $Rp={toc:[]},KRp="wrapper";function JRp(e){let{components:n,...t}=e;return(0,s.yg)(KRp,(0,p.A)({},$Rp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}JRp.isMDXComponent=!0;const ZRp={toc:[]},eWp="wrapper";function nWp(e){let{components:n,...t}=e;return(0,s.yg)(eWp,(0,p.A)({},ZRp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}nWp.isMDXComponent=!0;const tWp={toc:[]},oWp="wrapper";function pWp(e){let{components:n,...t}=e;return(0,s.yg)(oWp,(0,p.A)({},tWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}pWp.isMDXComponent=!0;const rWp={toc:[]},sWp="wrapper";function cWp(e){let{components:n,...t}=e;return(0,s.yg)(sWp,(0,p.A)({},rWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}cWp.isMDXComponent=!0;const aWp={toc:[]},iWp="wrapper";function lWp(e){let{components:n,...t}=e;return(0,s.yg)(iWp,(0,p.A)({},aWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}lWp.isMDXComponent=!0;const uWp={toc:[]},mWp="wrapper";function yWp(e){let{components:n,...t}=e;return(0,s.yg)(mWp,(0,p.A)({},uWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}yWp.isMDXComponent=!0;const dWp={toc:[]},hWp="wrapper";function gWp(e){let{components:n,...t}=e;return(0,s.yg)(hWp,(0,p.A)({},dWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}gWp.isMDXComponent=!0;const fWp={toc:[]},DWp="wrapper";function MWp(e){let{components:n,...t}=e;return(0,s.yg)(DWp,(0,p.A)({},fWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}MWp.isMDXComponent=!0;const XWp={toc:[]},_Wp="wrapper";function wWp(e){let{components:n,...t}=e;return(0,s.yg)(_Wp,(0,p.A)({},XWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}wWp.isMDXComponent=!0;const TWp={toc:[]},CWp="wrapper";function xWp(e){let{components:n,...t}=e;return(0,s.yg)(CWp,(0,p.A)({},TWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}xWp.isMDXComponent=!0;const AWp={toc:[]},vWp="wrapper";function LWp(e){let{components:n,...t}=e;return(0,s.yg)(vWp,(0,p.A)({},AWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}LWp.isMDXComponent=!0;const bWp={toc:[]},NWp="wrapper";function kWp(e){let{components:n,...t}=e;return(0,s.yg)(NWp,(0,p.A)({},bWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}kWp.isMDXComponent=!0;const zWp={toc:[]},PWp="wrapper";function IWp(e){let{components:n,...t}=e;return(0,s.yg)(PWp,(0,p.A)({},zWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}IWp.isMDXComponent=!0;const RWp={toc:[]},WWp="wrapper";function SWp(e){let{components:n,...t}=e;return(0,s.yg)(WWp,(0,p.A)({},RWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}SWp.isMDXComponent=!0;const BWp={toc:[]},EWp="wrapper";function GWp(e){let{components:n,...t}=e;return(0,s.yg)(EWp,(0,p.A)({},BWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}GWp.isMDXComponent=!0;const OWp={toc:[]},UWp="wrapper";function FWp(e){let{components:n,...t}=e;return(0,s.yg)(UWp,(0,p.A)({},OWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}FWp.isMDXComponent=!0;const VWp={toc:[]},qWp="wrapper";function jWp(e){let{components:n,...t}=e;return(0,s.yg)(qWp,(0,p.A)({},VWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}jWp.isMDXComponent=!0;const HWp={toc:[]},YWp="wrapper";function QWp(e){let{components:n,...t}=e;return(0,s.yg)(YWp,(0,p.A)({},HWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}QWp.isMDXComponent=!0;const $Wp={toc:[]},KWp="wrapper";function JWp(e){let{components:n,...t}=e;return(0,s.yg)(KWp,(0,p.A)({},$Wp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}JWp.isMDXComponent=!0;const ZWp={toc:[]},eSp="wrapper";function nSp(e){let{components:n,...t}=e;return(0,s.yg)(eSp,(0,p.A)({},ZWp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}nSp.isMDXComponent=!0;const tSp={toc:[]},oSp="wrapper";function pSp(e){let{components:n,...t}=e;return(0,s.yg)(oSp,(0,p.A)({},tSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}pSp.isMDXComponent=!0;const rSp={toc:[]},sSp="wrapper";function cSp(e){let{components:n,...t}=e;return(0,s.yg)(sSp,(0,p.A)({},rSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}cSp.isMDXComponent=!0;const aSp={toc:[]},iSp="wrapper";function lSp(e){let{components:n,...t}=e;return(0,s.yg)(iSp,(0,p.A)({},aSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}lSp.isMDXComponent=!0;const uSp={toc:[]},mSp="wrapper";function ySp(e){let{components:n,...t}=e;return(0,s.yg)(mSp,(0,p.A)({},uSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}ySp.isMDXComponent=!0;const dSp={toc:[]},hSp="wrapper";function gSp(e){let{components:n,...t}=e;return(0,s.yg)(hSp,(0,p.A)({},dSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}gSp.isMDXComponent=!0;const fSp={toc:[]},DSp="wrapper";function MSp(e){let{components:n,...t}=e;return(0,s.yg)(DSp,(0,p.A)({},fSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}MSp.isMDXComponent=!0;const XSp={toc:[]},_Sp="wrapper";function wSp(e){let{components:n,...t}=e;return(0,s.yg)(_Sp,(0,p.A)({},XSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wSp.isMDXComponent=!0;const TSp={toc:[]},CSp="wrapper";function xSp(e){let{components:n,...t}=e;return(0,s.yg)(CSp,(0,p.A)({},TSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}xSp.isMDXComponent=!0;const ASp={toc:[]},vSp="wrapper";function LSp(e){let{components:n,...t}=e;return(0,s.yg)(vSp,(0,p.A)({},ASp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}LSp.isMDXComponent=!0;const bSp={toc:[]},NSp="wrapper";function kSp(e){let{components:n,...t}=e;return(0,s.yg)(NSp,(0,p.A)({},bSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}kSp.isMDXComponent=!0;const zSp={toc:[]},PSp="wrapper";function ISp(e){let{components:n,...t}=e;return(0,s.yg)(PSp,(0,p.A)({},zSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}ISp.isMDXComponent=!0;const RSp={toc:[]},WSp="wrapper";function SSp(e){let{components:n,...t}=e;return(0,s.yg)(WSp,(0,p.A)({},RSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}SSp.isMDXComponent=!0;const BSp={toc:[]},ESp="wrapper";function GSp(e){let{components:n,...t}=e;return(0,s.yg)(ESp,(0,p.A)({},BSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}GSp.isMDXComponent=!0;const OSp={toc:[]},USp="wrapper";function FSp(e){let{components:n,...t}=e;return(0,s.yg)(USp,(0,p.A)({},OSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}FSp.isMDXComponent=!0;const VSp={toc:[]},qSp="wrapper";function jSp(e){let{components:n,...t}=e;return(0,s.yg)(qSp,(0,p.A)({},VSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}jSp.isMDXComponent=!0;const HSp={toc:[]},YSp="wrapper";function QSp(e){let{components:n,...t}=e;return(0,s.yg)(YSp,(0,p.A)({},HSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}QSp.isMDXComponent=!0;const $Sp={toc:[]},KSp="wrapper";function JSp(e){let{components:n,...t}=e;return(0,s.yg)(KSp,(0,p.A)({},$Sp,t,{components:n,mdxType:"MDXLayout"}))}JSp.isMDXComponent=!0;const ZSp={toc:[]},eBp="wrapper";function nBp(e){let{components:n,...t}=e;return(0,s.yg)(eBp,(0,p.A)({},ZSp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}nBp.isMDXComponent=!0;const tBp={toc:[]},oBp="wrapper";function pBp(e){let{components:n,...t}=e;return(0,s.yg)(oBp,(0,p.A)({},tBp,t,{components:n,mdxType:"MDXLayout"}))}pBp.isMDXComponent=!0;const rBp={toc:[]},sBp="wrapper";function cBp(e){let{components:n,...t}=e;return(0,s.yg)(sBp,(0,p.A)({},rBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}cBp.isMDXComponent=!0;const aBp={toc:[]},iBp="wrapper";function lBp(e){let{components:n,...t}=e;return(0,s.yg)(iBp,(0,p.A)({},aBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}lBp.isMDXComponent=!0;const uBp={toc:[]},mBp="wrapper";function yBp(e){let{components:n,...t}=e;return(0,s.yg)(mBp,(0,p.A)({},uBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}yBp.isMDXComponent=!0;const dBp={toc:[]},hBp="wrapper";function gBp(e){let{components:n,...t}=e;return(0,s.yg)(hBp,(0,p.A)({},dBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}gBp.isMDXComponent=!0;const fBp={toc:[]},DBp="wrapper";function MBp(e){let{components:n,...t}=e;return(0,s.yg)(DBp,(0,p.A)({},fBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}MBp.isMDXComponent=!0;const XBp={toc:[]},_Bp="wrapper";function wBp(e){let{components:n,...t}=e;return(0,s.yg)(_Bp,(0,p.A)({},XBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}wBp.isMDXComponent=!0;const TBp={toc:[]},CBp="wrapper";function xBp(e){let{components:n,...t}=e;return(0,s.yg)(CBp,(0,p.A)({},TBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}xBp.isMDXComponent=!0;const ABp={toc:[]},vBp="wrapper";function LBp(e){let{components:n,...t}=e;return(0,s.yg)(vBp,(0,p.A)({},ABp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}LBp.isMDXComponent=!0;const bBp={toc:[]},NBp="wrapper";function kBp(e){let{components:n,...t}=e;return(0,s.yg)(NBp,(0,p.A)({},bBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}kBp.isMDXComponent=!0;const zBp={toc:[]},PBp="wrapper";function IBp(e){let{components:n,...t}=e;return(0,s.yg)(PBp,(0,p.A)({},zBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}IBp.isMDXComponent=!0;const RBp={toc:[]},WBp="wrapper";function SBp(e){let{components:n,...t}=e;return(0,s.yg)(WBp,(0,p.A)({},RBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}SBp.isMDXComponent=!0;const BBp={toc:[]},EBp="wrapper";function GBp(e){let{components:n,...t}=e;return(0,s.yg)(EBp,(0,p.A)({},BBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}GBp.isMDXComponent=!0;const OBp={toc:[]},UBp="wrapper";function FBp(e){let{components:n,...t}=e;return(0,s.yg)(UBp,(0,p.A)({},OBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}FBp.isMDXComponent=!0;const VBp={toc:[]},qBp="wrapper";function jBp(e){let{components:n,...t}=e;return(0,s.yg)(qBp,(0,p.A)({},VBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}jBp.isMDXComponent=!0;const HBp={toc:[]},YBp="wrapper";function QBp(e){let{components:n,...t}=e;return(0,s.yg)(YBp,(0,p.A)({},HBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}QBp.isMDXComponent=!0;const $Bp={toc:[]},KBp="wrapper";function JBp(e){let{components:n,...t}=e;return(0,s.yg)(KBp,(0,p.A)({},$Bp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}JBp.isMDXComponent=!0;const ZBp={toc:[]},eEp="wrapper";function nEp(e){let{components:n,...t}=e;return(0,s.yg)(eEp,(0,p.A)({},ZBp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}nEp.isMDXComponent=!0;const tEp={toc:[]},oEp="wrapper";function pEp(e){let{components:n,...t}=e;return(0,s.yg)(oEp,(0,p.A)({},tEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}pEp.isMDXComponent=!0;const rEp={toc:[]},sEp="wrapper";function cEp(e){let{components:n,...t}=e;return(0,s.yg)(sEp,(0,p.A)({},rEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}cEp.isMDXComponent=!0;const aEp={toc:[]},iEp="wrapper";function lEp(e){let{components:n,...t}=e;return(0,s.yg)(iEp,(0,p.A)({},aEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}lEp.isMDXComponent=!0;const uEp={toc:[]},mEp="wrapper";function yEp(e){let{components:n,...t}=e;return(0,s.yg)(mEp,(0,p.A)({},uEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}yEp.isMDXComponent=!0;const dEp={toc:[]},hEp="wrapper";function gEp(e){let{components:n,...t}=e;return(0,s.yg)(hEp,(0,p.A)({},dEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}gEp.isMDXComponent=!0;const fEp={toc:[]},DEp="wrapper";function MEp(e){let{components:n,...t}=e;return(0,s.yg)(DEp,(0,p.A)({},fEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}MEp.isMDXComponent=!0;const XEp={toc:[]},_Ep="wrapper";function wEp(e){let{components:n,...t}=e;return(0,s.yg)(_Ep,(0,p.A)({},XEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}wEp.isMDXComponent=!0;const TEp={toc:[]},CEp="wrapper";function xEp(e){let{components:n,...t}=e;return(0,s.yg)(CEp,(0,p.A)({},TEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}xEp.isMDXComponent=!0;const AEp={toc:[]},vEp="wrapper";function LEp(e){let{components:n,...t}=e;return(0,s.yg)(vEp,(0,p.A)({},AEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}LEp.isMDXComponent=!0;const bEp={toc:[]},NEp="wrapper";function kEp(e){let{components:n,...t}=e;return(0,s.yg)(NEp,(0,p.A)({},bEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}kEp.isMDXComponent=!0;const zEp={toc:[]},PEp="wrapper";function IEp(e){let{components:n,...t}=e;return(0,s.yg)(PEp,(0,p.A)({},zEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}IEp.isMDXComponent=!0;const REp={toc:[]},WEp="wrapper";function SEp(e){let{components:n,...t}=e;return(0,s.yg)(WEp,(0,p.A)({},REp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}SEp.isMDXComponent=!0;const BEp={toc:[]},EEp="wrapper";function GEp(e){let{components:n,...t}=e;return(0,s.yg)(EEp,(0,p.A)({},BEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}GEp.isMDXComponent=!0;const OEp={toc:[]},UEp="wrapper";function FEp(e){let{components:n,...t}=e;return(0,s.yg)(UEp,(0,p.A)({},OEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}FEp.isMDXComponent=!0;const VEp={toc:[]},qEp="wrapper";function jEp(e){let{components:n,...t}=e;return(0,s.yg)(qEp,(0,p.A)({},VEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}jEp.isMDXComponent=!0;const HEp={toc:[]},YEp="wrapper";function QEp(e){let{components:n,...t}=e;return(0,s.yg)(YEp,(0,p.A)({},HEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}QEp.isMDXComponent=!0;const $Ep={toc:[]},KEp="wrapper";function JEp(e){let{components:n,...t}=e;return(0,s.yg)(KEp,(0,p.A)({},$Ep,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}JEp.isMDXComponent=!0;const ZEp={toc:[]},eGp="wrapper";function nGp(e){let{components:n,...t}=e;return(0,s.yg)(eGp,(0,p.A)({},ZEp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}nGp.isMDXComponent=!0;const tGp={toc:[]},oGp="wrapper";function pGp(e){let{components:n,...t}=e;return(0,s.yg)(oGp,(0,p.A)({},tGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}pGp.isMDXComponent=!0;const rGp={toc:[]},sGp="wrapper";function cGp(e){let{components:n,...t}=e;return(0,s.yg)(sGp,(0,p.A)({},rGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}cGp.isMDXComponent=!0;const aGp={toc:[]},iGp="wrapper";function lGp(e){let{components:n,...t}=e;return(0,s.yg)(iGp,(0,p.A)({},aGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}lGp.isMDXComponent=!0;const uGp={toc:[]},mGp="wrapper";function yGp(e){let{components:n,...t}=e;return(0,s.yg)(mGp,(0,p.A)({},uGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}yGp.isMDXComponent=!0;const dGp={toc:[]},hGp="wrapper";function gGp(e){let{components:n,...t}=e;return(0,s.yg)(hGp,(0,p.A)({},dGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}gGp.isMDXComponent=!0;const fGp={toc:[]},DGp="wrapper";function MGp(e){let{components:n,...t}=e;return(0,s.yg)(DGp,(0,p.A)({},fGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}MGp.isMDXComponent=!0;const XGp={toc:[]},_Gp="wrapper";function wGp(e){let{components:n,...t}=e;return(0,s.yg)(_Gp,(0,p.A)({},XGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}wGp.isMDXComponent=!0;const TGp={toc:[]},CGp="wrapper";function xGp(e){let{components:n,...t}=e;return(0,s.yg)(CGp,(0,p.A)({},TGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}xGp.isMDXComponent=!0;const AGp={toc:[]},vGp="wrapper";function LGp(e){let{components:n,...t}=e;return(0,s.yg)(vGp,(0,p.A)({},AGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}LGp.isMDXComponent=!0;const bGp={toc:[]},NGp="wrapper";function kGp(e){let{components:n,...t}=e;return(0,s.yg)(NGp,(0,p.A)({},bGp,t,{components:n,mdxType:"MDXLayout"}))}kGp.isMDXComponent=!0;const zGp={toc:[]},PGp="wrapper";function IGp(e){let{components:n,...t}=e;return(0,s.yg)(PGp,(0,p.A)({},zGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}IGp.isMDXComponent=!0;const RGp={toc:[]},WGp="wrapper";function SGp(e){let{components:n,...t}=e;return(0,s.yg)(WGp,(0,p.A)({},RGp,t,{components:n,mdxType:"MDXLayout"}))}SGp.isMDXComponent=!0;const BGp={toc:[]},EGp="wrapper";function GGp(e){let{components:n,...t}=e;return(0,s.yg)(EGp,(0,p.A)({},BGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}GGp.isMDXComponent=!0;const OGp={toc:[]},UGp="wrapper";function FGp(e){let{components:n,...t}=e;return(0,s.yg)(UGp,(0,p.A)({},OGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}FGp.isMDXComponent=!0;const VGp={toc:[]},qGp="wrapper";function jGp(e){let{components:n,...t}=e;return(0,s.yg)(qGp,(0,p.A)({},VGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}jGp.isMDXComponent=!0;const HGp={toc:[]},YGp="wrapper";function QGp(e){let{components:n,...t}=e;return(0,s.yg)(YGp,(0,p.A)({},HGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}QGp.isMDXComponent=!0;const $Gp={toc:[]},KGp="wrapper";function JGp(e){let{components:n,...t}=e;return(0,s.yg)(KGp,(0,p.A)({},$Gp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/CurveProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}JGp.isMDXComponent=!0;const ZGp={toc:[]},eOp="wrapper";function nOp(e){let{components:n,...t}=e;return(0,s.yg)(eOp,(0,p.A)({},ZGp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}nOp.isMDXComponent=!0;const tOp={toc:[]},oOp="wrapper";function pOp(e){let{components:n,...t}=e;return(0,s.yg)(oOp,(0,p.A)({},tOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}pOp.isMDXComponent=!0;const rOp={toc:[]},sOp="wrapper";function cOp(e){let{components:n,...t}=e;return(0,s.yg)(sOp,(0,p.A)({},rOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}cOp.isMDXComponent=!0;const aOp={toc:[]},iOp="wrapper";function lOp(e){let{components:n,...t}=e;return(0,s.yg)(iOp,(0,p.A)({},aOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}lOp.isMDXComponent=!0;const uOp={toc:[]},mOp="wrapper";function yOp(e){let{components:n,...t}=e;return(0,s.yg)(mOp,(0,p.A)({},uOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}yOp.isMDXComponent=!0;const dOp={toc:[]},hOp="wrapper";function gOp(e){let{components:n,...t}=e;return(0,s.yg)(hOp,(0,p.A)({},dOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}gOp.isMDXComponent=!0;const fOp={toc:[]},DOp="wrapper";function MOp(e){let{components:n,...t}=e;return(0,s.yg)(DOp,(0,p.A)({},fOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}MOp.isMDXComponent=!0;const XOp={toc:[]},_Op="wrapper";function wOp(e){let{components:n,...t}=e;return(0,s.yg)(_Op,(0,p.A)({},XOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Describes custom drawing logic used by the Code node."))}wOp.isMDXComponent=!0;const TOp={toc:[]},COp="wrapper";function xOp(e){let{components:n,...t}=e;return(0,s.yg)(COp,(0,p.A)({},TOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"token(ctx, text, position, color, selection) {\n  const blur = map(3, 0, selection);\n  const alpha = map(0.5, 1, selection);\n  ctx.globalAlpha *= alpha;\n  ctx.filter = `blur(${blur}px)`;\n  ctx.fillStyle = color;\n  ctx.fillText(text, position.x, position.y);\n}\n")))}xOp.isMDXComponent=!0;const AOp={toc:[]},vOp="wrapper";function LOp(e){let{components:n,...t}=e;return(0,s.yg)(vOp,(0,p.A)({},AOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Custom drawing logic for individual code tokens."))}LOp.isMDXComponent=!0;const bOp={toc:[]},NOp="wrapper";function kOp(e){let{components:n,...t}=e;return(0,s.yg)(NOp,(0,p.A)({},bOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}kOp.isMDXComponent=!0;const zOp={toc:[]},POp="wrapper";function IOp(e){let{components:n,...t}=e;return(0,s.yg)(POp,(0,p.A)({},zOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}IOp.isMDXComponent=!0;const ROp={toc:[]},WOp="wrapper";function SOp(e){let{components:n,...t}=e;return(0,s.yg)(WOp,(0,p.A)({},ROp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}SOp.isMDXComponent=!0;const BOp={toc:[]},EOp="wrapper";function GOp(e){let{components:n,...t}=e;return(0,s.yg)(EOp,(0,p.A)({},BOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}GOp.isMDXComponent=!0;const OOp={toc:[]},UOp="wrapper";function FOp(e){let{components:n,...t}=e;return(0,s.yg)(UOp,(0,p.A)({},OOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}FOp.isMDXComponent=!0;const VOp={toc:[]},qOp="wrapper";function jOp(e){let{components:n,...t}=e;return(0,s.yg)(qOp,(0,p.A)({},VOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}jOp.isMDXComponent=!0;const HOp={toc:[]},YOp="wrapper";function QOp(e){let{components:n,...t}=e;return(0,s.yg)(YOp,(0,p.A)({},HOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}QOp.isMDXComponent=!0;const $Op={toc:[]},KOp="wrapper";function JOp(e){let{components:n,...t}=e;return(0,s.yg)(KOp,(0,p.A)({},$Op,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}JOp.isMDXComponent=!0;const ZOp={toc:[]},eUp="wrapper";function nUp(e){let{components:n,...t}=e;return(0,s.yg)(eUp,(0,p.A)({},ZOp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}nUp.isMDXComponent=!0;const tUp={toc:[]},oUp="wrapper";function pUp(e){let{components:n,...t}=e;return(0,s.yg)(oUp,(0,p.A)({},tUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}pUp.isMDXComponent=!0;const rUp={toc:[]},sUp="wrapper";function cUp(e){let{components:n,...t}=e;return(0,s.yg)(sUp,(0,p.A)({},rUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}cUp.isMDXComponent=!0;const aUp={toc:[]},iUp="wrapper";function lUp(e){let{components:n,...t}=e;return(0,s.yg)(iUp,(0,p.A)({},aUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}lUp.isMDXComponent=!0;const uUp={toc:[]},mUp="wrapper";function yUp(e){let{components:n,...t}=e;return(0,s.yg)(mUp,(0,p.A)({},uUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}yUp.isMDXComponent=!0;const dUp={toc:[]},hUp="wrapper";function gUp(e){let{components:n,...t}=e;return(0,s.yg)(hUp,(0,p.A)({},dUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}gUp.isMDXComponent=!0;const fUp={toc:[]},DUp="wrapper";function MUp(e){let{components:n,...t}=e;return(0,s.yg)(DUp,(0,p.A)({},fUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}MUp.isMDXComponent=!0;const XUp={toc:[]},_Up="wrapper";function wUp(e){let{components:n,...t}=e;return(0,s.yg)(_Up,(0,p.A)({},XUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}wUp.isMDXComponent=!0;const TUp={toc:[]},CUp="wrapper";function xUp(e){let{components:n,...t}=e;return(0,s.yg)(CUp,(0,p.A)({},TUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of each grid line that comes after the given percentage will\nbe made invisible."),(0,s.yg)("p",null,"This property is useful for animating the grid appearing on-screen."))}xUp.isMDXComponent=!0;const AUp={toc:[]},vUp="wrapper";function LUp(e){let{components:n,...t}=e;return(0,s.yg)(vUp,(0,p.A)({},AUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage that should be clipped from the end of each grid line."))}LUp.isMDXComponent=!0;const bUp={toc:[]},NUp="wrapper";function kUp(e){let{components:n,...t}=e;return(0,s.yg)(NUp,(0,p.A)({},bUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}kUp.isMDXComponent=!0;const zUp={toc:[]},PUp="wrapper";function IUp(e){let{components:n,...t}=e;return(0,s.yg)(PUp,(0,p.A)({},zUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}IUp.isMDXComponent=!0;const RUp={toc:[]},WUp="wrapper";function SUp(e){let{components:n,...t}=e;return(0,s.yg)(WUp,(0,p.A)({},RUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/GridProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}SUp.isMDXComponent=!0;const BUp={toc:[]},EUp="wrapper";function GUp(e){let{components:n,...t}=e;return(0,s.yg)(EUp,(0,p.A)({},BUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}GUp.isMDXComponent=!0;const OUp={toc:[]},UUp="wrapper";function FUp(e){let{components:n,...t}=e;return(0,s.yg)(UUp,(0,p.A)({},OUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}FUp.isMDXComponent=!0;const VUp={toc:[]},qUp="wrapper";function jUp(e){let{components:n,...t}=e;return(0,s.yg)(qUp,(0,p.A)({},VUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}jUp.isMDXComponent=!0;const HUp={toc:[]},YUp="wrapper";function QUp(e){let{components:n,...t}=e;return(0,s.yg)(YUp,(0,p.A)({},HUp,t,{components:n,mdxType:"MDXLayout"}))}QUp.isMDXComponent=!0;const $Up={toc:[]},KUp="wrapper";function JUp(e){let{components:n,...t}=e;return(0,s.yg)(KUp,(0,p.A)({},$Up,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The spacing between the grid lines."))}JUp.isMDXComponent=!0;const ZUp={toc:[]},eFp="wrapper";function nFp(e){let{components:n,...t}=e;return(0,s.yg)(eFp,(0,p.A)({},ZUp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/GridProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}nFp.isMDXComponent=!0;const tFp={toc:[]},oFp="wrapper";function pFp(e){let{components:n,...t}=e;return(0,s.yg)(oFp,(0,p.A)({},tFp,t,{components:n,mdxType:"MDXLayout"}))}pFp.isMDXComponent=!0;const rFp={toc:[]},sFp="wrapper";function cFp(e){let{components:n,...t}=e;return(0,s.yg)(sFp,(0,p.A)({},rFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of each grid line that comes before the given percentage will\nbe made invisible."),(0,s.yg)("p",null,"This property is useful for animating the grid appearing on-screen."))}cFp.isMDXComponent=!0;const aFp={toc:[]},iFp="wrapper";function lFp(e){let{components:n,...t}=e;return(0,s.yg)(iFp,(0,p.A)({},aFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The percentage that should be clipped from the beginning of each grid line."))}lFp.isMDXComponent=!0;const uFp={toc:[]},mFp="wrapper";function yFp(e){let{components:n,...t}=e;return(0,s.yg)(mFp,(0,p.A)({},uFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}yFp.isMDXComponent=!0;const dFp={toc:[]},hFp="wrapper";function gFp(e){let{components:n,...t}=e;return(0,s.yg)(hFp,(0,p.A)({},dFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}gFp.isMDXComponent=!0;const fFp={toc:[]},DFp="wrapper";function MFp(e){let{components:n,...t}=e;return(0,s.yg)(DFp,(0,p.A)({},fFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}MFp.isMDXComponent=!0;const XFp={toc:[]},_Fp="wrapper";function wFp(e){let{components:n,...t}=e;return(0,s.yg)(_Fp,(0,p.A)({},XFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}wFp.isMDXComponent=!0;const TFp={toc:[]},CFp="wrapper";function xFp(e){let{components:n,...t}=e;return(0,s.yg)(CFp,(0,p.A)({},TFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}xFp.isMDXComponent=!0;const AFp={toc:[]},vFp="wrapper";function LFp(e){let{components:n,...t}=e;return(0,s.yg)(vFp,(0,p.A)({},AFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}LFp.isMDXComponent=!0;const bFp={toc:[]},NFp="wrapper";function kFp(e){let{components:n,...t}=e;return(0,s.yg)(NFp,(0,p.A)({},bFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}kFp.isMDXComponent=!0;const zFp={toc:[]},PFp="wrapper";function IFp(e){let{components:n,...t}=e;return(0,s.yg)(PFp,(0,p.A)({},zFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this image."))}IFp.isMDXComponent=!0;const RFp={toc:[]},WFp="wrapper";function SFp(e){let{components:n,...t}=e;return(0,s.yg)(WFp,(0,p.A)({},RFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}SFp.isMDXComponent=!0;const BFp={toc:[]},EFp="wrapper";function GFp(e){let{components:n,...t}=e;return(0,s.yg)(EFp,(0,p.A)({},BFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}GFp.isMDXComponent=!0;const OFp={toc:[]},UFp="wrapper";function FFp(e){let{components:n,...t}=e;return(0,s.yg)(UFp,(0,p.A)({},OFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}FFp.isMDXComponent=!0;const VFp={toc:[]},qFp="wrapper";function jFp(e){let{components:n,...t}=e;return(0,s.yg)(qFp,(0,p.A)({},VFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}jFp.isMDXComponent=!0;const HFp={toc:[]},YFp="wrapper";function QFp(e){let{components:n,...t}=e;return(0,s.yg)(YFp,(0,p.A)({},HFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}QFp.isMDXComponent=!0;const $Fp={toc:[]},KFp="wrapper";function JFp(e){let{components:n,...t}=e;return(0,s.yg)(KFp,(0,p.A)({},$Fp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}JFp.isMDXComponent=!0;const ZFp={toc:[]},eVp="wrapper";function nVp(e){let{components:n,...t}=e;return(0,s.yg)(eVp,(0,p.A)({},ZFp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}nVp.isMDXComponent=!0;const tVp={toc:[]},oVp="wrapper";function pVp(e){let{components:n,...t}=e;return(0,s.yg)(oVp,(0,p.A)({},tVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}pVp.isMDXComponent=!0;const rVp={toc:[]},sVp="wrapper";function cVp(e){let{components:n,...t}=e;return(0,s.yg)(sVp,(0,p.A)({},rVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}cVp.isMDXComponent=!0;const aVp={toc:[]},iVp="wrapper";function lVp(e){let{components:n,...t}=e;return(0,s.yg)(iVp,(0,p.A)({},aVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}lVp.isMDXComponent=!0;const uVp={toc:[]},mVp="wrapper";function yVp(e){let{components:n,...t}=e;return(0,s.yg)(mVp,(0,p.A)({},uVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}yVp.isMDXComponent=!0;const dVp={toc:[]},hVp="wrapper";function gVp(e){let{components:n,...t}=e;return(0,s.yg)(hVp,(0,p.A)({},dVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}gVp.isMDXComponent=!0;const fVp={toc:[]},DVp="wrapper";function MVp(e){let{components:n,...t}=e;return(0,s.yg)(DVp,(0,p.A)({},fVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}MVp.isMDXComponent=!0;const XVp={toc:[]},_Vp="wrapper";function wVp(e){let{components:n,...t}=e;return(0,s.yg)(_Vp,(0,p.A)({},XVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}wVp.isMDXComponent=!0;const TVp={toc:[]},CVp="wrapper";function xVp(e){let{components:n,...t}=e;return(0,s.yg)(CVp,(0,p.A)({},TVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}xVp.isMDXComponent=!0;const AVp={toc:[]},vVp="wrapper";function LVp(e){let{components:n,...t}=e;return(0,s.yg)(vVp,(0,p.A)({},AVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}LVp.isMDXComponent=!0;const bVp={toc:[]},NVp="wrapper";function kVp(e){let{components:n,...t}=e;return(0,s.yg)(NVp,(0,p.A)({},bVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}kVp.isMDXComponent=!0;const zVp={toc:[]},PVp="wrapper";function IVp(e){let{components:n,...t}=e;return(0,s.yg)(PVp,(0,p.A)({},zVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}IVp.isMDXComponent=!0;const RVp={toc:[]},WVp="wrapper";function SVp(e){let{components:n,...t}=e;return(0,s.yg)(WVp,(0,p.A)({},RVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}SVp.isMDXComponent=!0;const BVp={toc:[]},EVp="wrapper";function GVp(e){let{components:n,...t}=e;return(0,s.yg)(EVp,(0,p.A)({},BVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}GVp.isMDXComponent=!0;const OVp={toc:[]},UVp="wrapper";function FVp(e){let{components:n,...t}=e;return(0,s.yg)(UVp,(0,p.A)({},OVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Provide the color in one of the following formats:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},"named color like ",(0,s.yg)("inlineCode",{parentName:"li"},"red"),", ",(0,s.yg)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.yg)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.yg)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.yg)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.yg)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.yg)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.yg)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.yg)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}FVp.isMDXComponent=!0;const VVp={toc:[]},qVp="wrapper";function jVp(e){let{components:n,...t}=e;return(0,s.yg)(qVp,(0,p.A)({},VVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The color of the icon"))}jVp.isMDXComponent=!0;const HVp={toc:[]},YVp="wrapper";function QVp(e){let{components:n,...t}=e;return(0,s.yg)(YVp,(0,p.A)({},HVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}QVp.isMDXComponent=!0;const $Vp={toc:[]},KVp="wrapper";function JVp(e){let{components:n,...t}=e;return(0,s.yg)(KVp,(0,p.A)({},$Vp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}JVp.isMDXComponent=!0;const ZVp={toc:[]},eqp="wrapper";function nqp(e){let{components:n,...t}=e;return(0,s.yg)(eqp,(0,p.A)({},ZVp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}nqp.isMDXComponent=!0;const tqp={toc:[]},oqp="wrapper";function pqp(e){let{components:n,...t}=e;return(0,s.yg)(oqp,(0,p.A)({},tqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}pqp.isMDXComponent=!0;const rqp={toc:[]},sqp="wrapper";function cqp(e){let{components:n,...t}=e;return(0,s.yg)(sqp,(0,p.A)({},rqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}cqp.isMDXComponent=!0;const aqp={toc:[]},iqp="wrapper";function lqp(e){let{components:n,...t}=e;return(0,s.yg)(iqp,(0,p.A)({},aqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}lqp.isMDXComponent=!0;const uqp={toc:[]},mqp="wrapper";function yqp(e){let{components:n,...t}=e;return(0,s.yg)(mqp,(0,p.A)({},uqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}yqp.isMDXComponent=!0;const dqp={toc:[]},hqp="wrapper";function gqp(e){let{components:n,...t}=e;return(0,s.yg)(hqp,(0,p.A)({},dqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}gqp.isMDXComponent=!0;const fqp={toc:[]},Dqp="wrapper";function Mqp(e){let{components:n,...t}=e;return(0,s.yg)(Dqp,(0,p.A)({},fqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"You can find identifiers on ",(0,s.yg)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}Mqp.isMDXComponent=!0;const Xqp={toc:[]},_qp="wrapper";function wqp(e){let{components:n,...t}=e;return(0,s.yg)(_qp,(0,p.A)({},Xqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The identifier of the icon."))}wqp.isMDXComponent=!0;const Tqp={toc:[]},Cqp="wrapper";function xqp(e){let{components:n,...t}=e;return(0,s.yg)(Cqp,(0,p.A)({},Tqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}xqp.isMDXComponent=!0;const Aqp={toc:[]},vqp="wrapper";function Lqp(e){let{components:n,...t}=e;return(0,s.yg)(vqp,(0,p.A)({},Aqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Lqp.isMDXComponent=!0;const bqp={toc:[]},Nqp="wrapper";function kqp(e){let{components:n,...t}=e;return(0,s.yg)(Nqp,(0,p.A)({},bqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}kqp.isMDXComponent=!0;const zqp={toc:[]},Pqp="wrapper";function Iqp(e){let{components:n,...t}=e;return(0,s.yg)(Pqp,(0,p.A)({},zqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Iqp.isMDXComponent=!0;const Rqp={toc:[]},Wqp="wrapper";function Sqp(e){let{components:n,...t}=e;return(0,s.yg)(Wqp,(0,p.A)({},Rqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Sqp.isMDXComponent=!0;const Bqp={toc:[]},Eqp="wrapper";function Gqp(e){let{components:n,...t}=e;return(0,s.yg)(Eqp,(0,p.A)({},Bqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}Gqp.isMDXComponent=!0;const Oqp={toc:[]},Uqp="wrapper";function Fqp(e){let{components:n,...t}=e;return(0,s.yg)(Uqp,(0,p.A)({},Oqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Fqp.isMDXComponent=!0;const Vqp={toc:[]},qqp="wrapper";function jqp(e){let{components:n,...t}=e;return(0,s.yg)(qqp,(0,p.A)({},Vqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}jqp.isMDXComponent=!0;const Hqp={toc:[]},Yqp="wrapper";function Qqp(e){let{components:n,...t}=e;return(0,s.yg)(Yqp,(0,p.A)({},Hqp,t,{components:n,mdxType:"MDXLayout"}))}Qqp.isMDXComponent=!0;const $qp={toc:[]},Kqp="wrapper";function Jqp(e){let{components:n,...t}=e;return(0,s.yg)(Kqp,(0,p.A)({},$qp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Jqp.isMDXComponent=!0;const Zqp={toc:[]},ejp="wrapper";function njp(e){let{components:n,...t}=e;return(0,s.yg)(ejp,(0,p.A)({},Zqp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}njp.isMDXComponent=!0;const tjp={toc:[]},ojp="wrapper";function pjp(e){let{components:n,...t}=e;return(0,s.yg)(ojp,(0,p.A)({},tjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}pjp.isMDXComponent=!0;const rjp={toc:[]},sjp="wrapper";function cjp(e){let{components:n,...t}=e;return(0,s.yg)(sjp,(0,p.A)({},rjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the image should be smoothed."))}cjp.isMDXComponent=!0;const ajp={toc:[]},ijp="wrapper";function ljp(e){let{components:n,...t}=e;return(0,s.yg)(ijp,(0,p.A)({},ajp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}ljp.isMDXComponent=!0;const ujp={toc:[]},mjp="wrapper";function yjp(e){let{components:n,...t}=e;return(0,s.yg)(mjp,(0,p.A)({},ujp,t,{components:n,mdxType:"MDXLayout"}))}yjp.isMDXComponent=!0;const djp={toc:[]},hjp="wrapper";function gjp(e){let{components:n,...t}=e;return(0,s.yg)(hjp,(0,p.A)({},djp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The source of this image."))}gjp.isMDXComponent=!0;const fjp={toc:[]},Djp="wrapper";function Mjp(e){let{components:n,...t}=e;return(0,s.yg)(Djp,(0,p.A)({},fjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Mjp.isMDXComponent=!0;const Xjp={toc:[]},_jp="wrapper";function wjp(e){let{components:n,...t}=e;return(0,s.yg)(_jp,(0,p.A)({},Xjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}wjp.isMDXComponent=!0;const Tjp={toc:[]},Cjp="wrapper";function xjp(e){let{components:n,...t}=e;return(0,s.yg)(Cjp,(0,p.A)({},Tjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}xjp.isMDXComponent=!0;const Ajp={toc:[]},vjp="wrapper";function Ljp(e){let{components:n,...t}=e;return(0,s.yg)(vjp,(0,p.A)({},Ajp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Ljp.isMDXComponent=!0;const bjp={toc:[]},Njp="wrapper";function kjp(e){let{components:n,...t}=e;return(0,s.yg)(Njp,(0,p.A)({},bjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/IconProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}kjp.isMDXComponent=!0;const zjp={toc:[]},Pjp="wrapper";function Ijp(e){let{components:n,...t}=e;return(0,s.yg)(Pjp,(0,p.A)({},zjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}Ijp.isMDXComponent=!0;const Rjp={toc:[]},Wjp="wrapper";function Sjp(e){let{components:n,...t}=e;return(0,s.yg)(Wjp,(0,p.A)({},Rjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Sjp.isMDXComponent=!0;const Bjp={toc:[]},Ejp="wrapper";function Gjp(e){let{components:n,...t}=e;return(0,s.yg)(Ejp,(0,p.A)({},Bjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Gjp.isMDXComponent=!0;const Ojp={toc:[]},Ujp="wrapper";function Fjp(e){let{components:n,...t}=e;return(0,s.yg)(Ujp,(0,p.A)({},Ojp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Fjp.isMDXComponent=!0;const Vjp={toc:[]},qjp="wrapper";function jjp(e){let{components:n,...t}=e;return(0,s.yg)(qjp,(0,p.A)({},Vjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}jjp.isMDXComponent=!0;const Hjp={toc:[]},Yjp="wrapper";function Qjp(e){let{components:n,...t}=e;return(0,s.yg)(Yjp,(0,p.A)({},Hjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Qjp.isMDXComponent=!0;const $jp={toc:[]},Kjp="wrapper";function Jjp(e){let{components:n,...t}=e;return(0,s.yg)(Kjp,(0,p.A)({},$jp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Jjp.isMDXComponent=!0;const Zjp={toc:[]},eHp="wrapper";function nHp(e){let{components:n,...t}=e;return(0,s.yg)(eHp,(0,p.A)({},Zjp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}nHp.isMDXComponent=!0;const tHp={toc:[]},oHp="wrapper";function pHp(e){let{components:n,...t}=e;return(0,s.yg)(oHp,(0,p.A)({},tHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this image."))}pHp.isMDXComponent=!0;const rHp={toc:[]},sHp="wrapper";function cHp(e){let{components:n,...t}=e;return(0,s.yg)(sHp,(0,p.A)({},rHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}cHp.isMDXComponent=!0;const aHp={toc:[]},iHp="wrapper";function lHp(e){let{components:n,...t}=e;return(0,s.yg)(iHp,(0,p.A)({},aHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}lHp.isMDXComponent=!0;const uHp={toc:[]},mHp="wrapper";function yHp(e){let{components:n,...t}=e;return(0,s.yg)(mHp,(0,p.A)({},uHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}yHp.isMDXComponent=!0;const dHp={toc:[]},hHp="wrapper";function gHp(e){let{components:n,...t}=e;return(0,s.yg)(hHp,(0,p.A)({},dHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}gHp.isMDXComponent=!0;const fHp={toc:[]},DHp="wrapper";function MHp(e){let{components:n,...t}=e;return(0,s.yg)(DHp,(0,p.A)({},fHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}MHp.isMDXComponent=!0;const XHp={toc:[]},_Hp="wrapper";function wHp(e){let{components:n,...t}=e;return(0,s.yg)(_Hp,(0,p.A)({},XHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}wHp.isMDXComponent=!0;const THp={toc:[]},CHp="wrapper";function xHp(e){let{components:n,...t}=e;return(0,s.yg)(CHp,(0,p.A)({},THp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}xHp.isMDXComponent=!0;const AHp={toc:[]},vHp="wrapper";function LHp(e){let{components:n,...t}=e;return(0,s.yg)(vHp,(0,p.A)({},AHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}LHp.isMDXComponent=!0;const bHp={toc:[]},NHp="wrapper";function kHp(e){let{components:n,...t}=e;return(0,s.yg)(NHp,(0,p.A)({},bHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}kHp.isMDXComponent=!0;const zHp={toc:[]},PHp="wrapper";function IHp(e){let{components:n,...t}=e;return(0,s.yg)(PHp,(0,p.A)({},zHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}IHp.isMDXComponent=!0;const RHp={toc:[]},WHp="wrapper";function SHp(e){let{components:n,...t}=e;return(0,s.yg)(WHp,(0,p.A)({},RHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}SHp.isMDXComponent=!0;const BHp={toc:[]},EHp="wrapper";function GHp(e){let{components:n,...t}=e;return(0,s.yg)(EHp,(0,p.A)({},BHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}GHp.isMDXComponent=!0;const OHp={toc:[]},UHp="wrapper";function FHp(e){let{components:n,...t}=e;return(0,s.yg)(UHp,(0,p.A)({},OHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}FHp.isMDXComponent=!0;const VHp={toc:[]},qHp="wrapper";function jHp(e){let{components:n,...t}=e;return(0,s.yg)(qHp,(0,p.A)({},VHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}jHp.isMDXComponent=!0;const HHp={toc:[]},YHp="wrapper";function QHp(e){let{components:n,...t}=e;return(0,s.yg)(YHp,(0,p.A)({},HHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}QHp.isMDXComponent=!0;const $Hp={toc:[]},KHp="wrapper";function JHp(e){let{components:n,...t}=e;return(0,s.yg)(KHp,(0,p.A)({},$Hp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}JHp.isMDXComponent=!0;const ZHp={toc:[]},eYp="wrapper";function nYp(e){let{components:n,...t}=e;return(0,s.yg)(eYp,(0,p.A)({},ZHp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}nYp.isMDXComponent=!0;const tYp={toc:[]},oYp="wrapper";function pYp(e){let{components:n,...t}=e;return(0,s.yg)(oYp,(0,p.A)({},tYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}pYp.isMDXComponent=!0;const rYp={toc:[]},sYp="wrapper";function cYp(e){let{components:n,...t}=e;return(0,s.yg)(sYp,(0,p.A)({},rYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}cYp.isMDXComponent=!0;const aYp={toc:[]},iYp="wrapper";function lYp(e){let{components:n,...t}=e;return(0,s.yg)(iYp,(0,p.A)({},aYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}lYp.isMDXComponent=!0;const uYp={toc:[]},mYp="wrapper";function yYp(e){let{components:n,...t}=e;return(0,s.yg)(mYp,(0,p.A)({},uYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}yYp.isMDXComponent=!0;const dYp={toc:[]},hYp="wrapper";function gYp(e){let{components:n,...t}=e;return(0,s.yg)(hYp,(0,p.A)({},dYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}gYp.isMDXComponent=!0;const fYp={toc:[]},DYp="wrapper";function MYp(e){let{components:n,...t}=e;return(0,s.yg)(DYp,(0,p.A)({},fYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}MYp.isMDXComponent=!0;const XYp={toc:[]},_Yp="wrapper";function wYp(e){let{components:n,...t}=e;return(0,s.yg)(_Yp,(0,p.A)({},XYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}wYp.isMDXComponent=!0;const TYp={toc:[]},CYp="wrapper";function xYp(e){let{components:n,...t}=e;return(0,s.yg)(CYp,(0,p.A)({},TYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}xYp.isMDXComponent=!0;const AYp={toc:[]},vYp="wrapper";function LYp(e){let{components:n,...t}=e;return(0,s.yg)(vYp,(0,p.A)({},AYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}LYp.isMDXComponent=!0;const bYp={toc:[]},NYp="wrapper";function kYp(e){let{components:n,...t}=e;return(0,s.yg)(NYp,(0,p.A)({},bYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}kYp.isMDXComponent=!0;const zYp={toc:[]},PYp="wrapper";function IYp(e){let{components:n,...t}=e;return(0,s.yg)(PYp,(0,p.A)({},zYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}IYp.isMDXComponent=!0;const RYp={toc:[]},WYp="wrapper";function SYp(e){let{components:n,...t}=e;return(0,s.yg)(WYp,(0,p.A)({},RYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}SYp.isMDXComponent=!0;const BYp={toc:[]},EYp="wrapper";function GYp(e){let{components:n,...t}=e;return(0,s.yg)(EYp,(0,p.A)({},BYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}GYp.isMDXComponent=!0;const OYp={toc:[]},UYp="wrapper";function FYp(e){let{components:n,...t}=e;return(0,s.yg)(UYp,(0,p.A)({},OYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}FYp.isMDXComponent=!0;const VYp={toc:[]},qYp="wrapper";function jYp(e){let{components:n,...t}=e;return(0,s.yg)(qYp,(0,p.A)({},VYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}jYp.isMDXComponent=!0;const HYp={toc:[]},YYp="wrapper";function QYp(e){let{components:n,...t}=e;return(0,s.yg)(YYp,(0,p.A)({},HYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}QYp.isMDXComponent=!0;const $Yp={toc:[]},KYp="wrapper";function JYp(e){let{components:n,...t}=e;return(0,s.yg)(KYp,(0,p.A)({},$Yp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}JYp.isMDXComponent=!0;const ZYp={toc:[]},eQp="wrapper";function nQp(e){let{components:n,...t}=e;return(0,s.yg)(eQp,(0,p.A)({},ZYp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}nQp.isMDXComponent=!0;const tQp={toc:[]},oQp="wrapper";function pQp(e){let{components:n,...t}=e;return(0,s.yg)(oQp,(0,p.A)({},tQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}pQp.isMDXComponent=!0;const rQp={toc:[]},sQp="wrapper";function cQp(e){let{components:n,...t}=e;return(0,s.yg)(sQp,(0,p.A)({},rQp,t,{components:n,mdxType:"MDXLayout"}))}cQp.isMDXComponent=!0;const aQp={toc:[]},iQp="wrapper";function lQp(e){let{components:n,...t}=e;return(0,s.yg)(iQp,(0,p.A)({},aQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}lQp.isMDXComponent=!0;const uQp={toc:[]},mQp="wrapper";function yQp(e){let{components:n,...t}=e;return(0,s.yg)(mQp,(0,p.A)({},uQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}yQp.isMDXComponent=!0;const dQp={toc:[]},hQp="wrapper";function gQp(e){let{components:n,...t}=e;return(0,s.yg)(hQp,(0,p.A)({},dQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}gQp.isMDXComponent=!0;const fQp={toc:[]},DQp="wrapper";function MQp(e){let{components:n,...t}=e;return(0,s.yg)(DQp,(0,p.A)({},fQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the image should be smoothed."))}MQp.isMDXComponent=!0;const XQp={toc:[]},_Qp="wrapper";function wQp(e){let{components:n,...t}=e;return(0,s.yg)(_Qp,(0,p.A)({},XQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}wQp.isMDXComponent=!0;const TQp={toc:[]},CQp="wrapper";function xQp(e){let{components:n,...t}=e;return(0,s.yg)(CQp,(0,p.A)({},TQp,t,{components:n,mdxType:"MDXLayout"}))}xQp.isMDXComponent=!0;const AQp={toc:[]},vQp="wrapper";function LQp(e){let{components:n,...t}=e;return(0,s.yg)(vQp,(0,p.A)({},AQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The source of this image."))}LQp.isMDXComponent=!0;const bQp={toc:[]},NQp="wrapper";function kQp(e){let{components:n,...t}=e;return(0,s.yg)(NQp,(0,p.A)({},bQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}kQp.isMDXComponent=!0;const zQp={toc:[]},PQp="wrapper";function IQp(e){let{components:n,...t}=e;return(0,s.yg)(PQp,(0,p.A)({},zQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}IQp.isMDXComponent=!0;const RQp={toc:[]},WQp="wrapper";function SQp(e){let{components:n,...t}=e;return(0,s.yg)(WQp,(0,p.A)({},RQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}SQp.isMDXComponent=!0;const BQp={toc:[]},EQp="wrapper";function GQp(e){let{components:n,...t}=e;return(0,s.yg)(EQp,(0,p.A)({},BQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}GQp.isMDXComponent=!0;const OQp={toc:[]},UQp="wrapper";function FQp(e){let{components:n,...t}=e;return(0,s.yg)(UQp,(0,p.A)({},OQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ImgProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}FQp.isMDXComponent=!0;const VQp={toc:[]},qQp="wrapper";function jQp(e){let{components:n,...t}=e;return(0,s.yg)(qQp,(0,p.A)({},VQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}jQp.isMDXComponent=!0;const HQp={toc:[]},YQp="wrapper";function QQp(e){let{components:n,...t}=e;return(0,s.yg)(YQp,(0,p.A)({},HQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}QQp.isMDXComponent=!0;const $Qp={toc:[]},KQp="wrapper";function JQp(e){let{components:n,...t}=e;return(0,s.yg)(KQp,(0,p.A)({},$Qp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}JQp.isMDXComponent=!0;const ZQp={toc:[]},e$p="wrapper";function n$p(e){let{components:n,...t}=e;return(0,s.yg)(e$p,(0,p.A)({},ZQp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}n$p.isMDXComponent=!0;const t$p={toc:[]},o$p="wrapper";function p$p(e){let{components:n,...t}=e;return(0,s.yg)(o$p,(0,p.A)({},t$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}p$p.isMDXComponent=!0;const r$p={toc:[]},s$p="wrapper";function c$p(e){let{components:n,...t}=e;return(0,s.yg)(s$p,(0,p.A)({},r$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}c$p.isMDXComponent=!0;const a$p={toc:[]},i$p="wrapper";function l$p(e){let{components:n,...t}=e;return(0,s.yg)(i$p,(0,p.A)({},a$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}l$p.isMDXComponent=!0;const u$p={toc:[]},m$p="wrapper";function y$p(e){let{components:n,...t}=e;return(0,s.yg)(m$p,(0,p.A)({},u$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}y$p.isMDXComponent=!0;const d$p={toc:[]},h$p="wrapper";function g$p(e){let{components:n,...t}=e;return(0,s.yg)(h$p,(0,p.A)({},d$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}g$p.isMDXComponent=!0;const f$p={toc:[]},D$p="wrapper";function M$p(e){let{components:n,...t}=e;return(0,s.yg)(D$p,(0,p.A)({},f$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}M$p.isMDXComponent=!0;const X$p={toc:[]},_$p="wrapper";function w$p(e){let{components:n,...t}=e;return(0,s.yg)(_$p,(0,p.A)({},X$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}w$p.isMDXComponent=!0;const T$p={toc:[]},C$p="wrapper";function x$p(e){let{components:n,...t}=e;return(0,s.yg)(C$p,(0,p.A)({},T$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}x$p.isMDXComponent=!0;const A$p={toc:[]},v$p="wrapper";function L$p(e){let{components:n,...t}=e;return(0,s.yg)(v$p,(0,p.A)({},A$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}L$p.isMDXComponent=!0;const b$p={toc:[]},N$p="wrapper";function k$p(e){let{components:n,...t}=e;return(0,s.yg)(N$p,(0,p.A)({},b$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}k$p.isMDXComponent=!0;const z$p={toc:[]},P$p="wrapper";function I$p(e){let{components:n,...t}=e;return(0,s.yg)(P$p,(0,p.A)({},z$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}I$p.isMDXComponent=!0;const R$p={toc:[]},W$p="wrapper";function S$p(e){let{components:n,...t}=e;return(0,s.yg)(W$p,(0,p.A)({},R$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}S$p.isMDXComponent=!0;const B$p={toc:[]},E$p="wrapper";function G$p(e){let{components:n,...t}=e;return(0,s.yg)(E$p,(0,p.A)({},B$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}G$p.isMDXComponent=!0;const O$p={toc:[]},U$p="wrapper";function F$p(e){let{components:n,...t}=e;return(0,s.yg)(U$p,(0,p.A)({},O$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}F$p.isMDXComponent=!0;const V$p={toc:[]},q$p="wrapper";function j$p(e){let{components:n,...t}=e;return(0,s.yg)(q$p,(0,p.A)({},V$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}j$p.isMDXComponent=!0;const H$p={toc:[]},Y$p="wrapper";function Q$p(e){let{components:n,...t}=e;return(0,s.yg)(Y$p,(0,p.A)({},H$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#startHandle"},(0,s.yg)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.yg)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.yg)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.yg)("inlineCode",{parentName:"a"},"auto"))," property."))}Q$p.isMDXComponent=!0;const $$p={toc:[]},K$p="wrapper";function J$p(e){let{components:n,...t}=e;return(0,s.yg)(K$p,(0,p.A)({},$$p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}J$p.isMDXComponent=!0;const Z$p={toc:[]},eKp="wrapper";function nKp(e){let{components:n,...t}=e;return(0,s.yg)(eKp,(0,p.A)({},Z$p,t,{components:n,mdxType:"MDXLayout"}))}nKp.isMDXComponent=!0;const tKp={toc:[]},oKp="wrapper";function pKp(e){let{components:n,...t}=e;return(0,s.yg)(oKp,(0,p.A)({},tKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}pKp.isMDXComponent=!0;const rKp={toc:[]},sKp="wrapper";function cKp(e){let{components:n,...t}=e;return(0,s.yg)(sKp,(0,p.A)({},rKp,t,{components:n,mdxType:"MDXLayout"}))}cKp.isMDXComponent=!0;const aKp={toc:[]},iKp="wrapper";function lKp(e){let{components:n,...t}=e;return(0,s.yg)(iKp,(0,p.A)({},aKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#endHandle"},(0,s.yg)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.yg)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.yg)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.yg)("inlineCode",{parentName:"a"},"auto"))," property."))}lKp.isMDXComponent=!0;const uKp={toc:[]},mKp="wrapper";function yKp(e){let{components:n,...t}=e;return(0,s.yg)(mKp,(0,p.A)({},uKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}yKp.isMDXComponent=!0;const dKp={toc:[]},hKp="wrapper";function gKp(e){let{components:n,...t}=e;return(0,s.yg)(hKp,(0,p.A)({},dKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}gKp.isMDXComponent=!0;const fKp={toc:[]},DKp="wrapper";function MKp(e){let{components:n,...t}=e;return(0,s.yg)(DKp,(0,p.A)({},fKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this image."))}MKp.isMDXComponent=!0;const XKp={toc:[]},_Kp="wrapper";function wKp(e){let{components:n,...t}=e;return(0,s.yg)(_Kp,(0,p.A)({},XKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}wKp.isMDXComponent=!0;const TKp={toc:[]},CKp="wrapper";function xKp(e){let{components:n,...t}=e;return(0,s.yg)(CKp,(0,p.A)({},TKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}xKp.isMDXComponent=!0;const AKp={toc:[]},vKp="wrapper";function LKp(e){let{components:n,...t}=e;return(0,s.yg)(vKp,(0,p.A)({},AKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}LKp.isMDXComponent=!0;const bKp={toc:[]},NKp="wrapper";function kKp(e){let{components:n,...t}=e;return(0,s.yg)(NKp,(0,p.A)({},bKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}kKp.isMDXComponent=!0;const zKp={toc:[]},PKp="wrapper";function IKp(e){let{components:n,...t}=e;return(0,s.yg)(PKp,(0,p.A)({},zKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}IKp.isMDXComponent=!0;const RKp={toc:[]},WKp="wrapper";function SKp(e){let{components:n,...t}=e;return(0,s.yg)(WKp,(0,p.A)({},RKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}SKp.isMDXComponent=!0;const BKp={toc:[]},EKp="wrapper";function GKp(e){let{components:n,...t}=e;return(0,s.yg)(EKp,(0,p.A)({},BKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}GKp.isMDXComponent=!0;const OKp={toc:[]},UKp="wrapper";function FKp(e){let{components:n,...t}=e;return(0,s.yg)(UKp,(0,p.A)({},OKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}FKp.isMDXComponent=!0;const VKp={toc:[]},qKp="wrapper";function jKp(e){let{components:n,...t}=e;return(0,s.yg)(qKp,(0,p.A)({},VKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}jKp.isMDXComponent=!0;const HKp={toc:[]},YKp="wrapper";function QKp(e){let{components:n,...t}=e;return(0,s.yg)(YKp,(0,p.A)({},HKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}QKp.isMDXComponent=!0;const $Kp={toc:[]},KKp="wrapper";function JKp(e){let{components:n,...t}=e;return(0,s.yg)(KKp,(0,p.A)({},$Kp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}JKp.isMDXComponent=!0;const ZKp={toc:[]},eJp="wrapper";function nJp(e){let{components:n,...t}=e;return(0,s.yg)(eJp,(0,p.A)({},ZKp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}nJp.isMDXComponent=!0;const tJp={toc:[]},oJp="wrapper";function pJp(e){let{components:n,...t}=e;return(0,s.yg)(oJp,(0,p.A)({},tJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}pJp.isMDXComponent=!0;const rJp={toc:[]},sJp="wrapper";function cJp(e){let{components:n,...t}=e;return(0,s.yg)(sJp,(0,p.A)({},rJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}cJp.isMDXComponent=!0;const aJp={toc:[]},iJp="wrapper";function lJp(e){let{components:n,...t}=e;return(0,s.yg)(iJp,(0,p.A)({},aJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}lJp.isMDXComponent=!0;const uJp={toc:[]},mJp="wrapper";function yJp(e){let{components:n,...t}=e;return(0,s.yg)(mJp,(0,p.A)({},uJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}yJp.isMDXComponent=!0;const dJp={toc:[]},hJp="wrapper";function gJp(e){let{components:n,...t}=e;return(0,s.yg)(hJp,(0,p.A)({},dJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}gJp.isMDXComponent=!0;const fJp={toc:[]},DJp="wrapper";function MJp(e){let{components:n,...t}=e;return(0,s.yg)(DJp,(0,p.A)({},fJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}MJp.isMDXComponent=!0;const XJp={toc:[]},_Jp="wrapper";function wJp(e){let{components:n,...t}=e;return(0,s.yg)(_Jp,(0,p.A)({},XJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}wJp.isMDXComponent=!0;const TJp={toc:[]},CJp="wrapper";function xJp(e){let{components:n,...t}=e;return(0,s.yg)(CJp,(0,p.A)({},TJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}xJp.isMDXComponent=!0;const AJp={toc:[]},vJp="wrapper";function LJp(e){let{components:n,...t}=e;return(0,s.yg)(vJp,(0,p.A)({},AJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}LJp.isMDXComponent=!0;const bJp={toc:[]},NJp="wrapper";function kJp(e){let{components:n,...t}=e;return(0,s.yg)(NJp,(0,p.A)({},bJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}kJp.isMDXComponent=!0;const zJp={toc:[]},PJp="wrapper";function IJp(e){let{components:n,...t}=e;return(0,s.yg)(PJp,(0,p.A)({},zJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}IJp.isMDXComponent=!0;const RJp={toc:[]},WJp="wrapper";function SJp(e){let{components:n,...t}=e;return(0,s.yg)(WJp,(0,p.A)({},RJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}SJp.isMDXComponent=!0;const BJp={toc:[]},EJp="wrapper";function GJp(e){let{components:n,...t}=e;return(0,s.yg)(EJp,(0,p.A)({},BJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}GJp.isMDXComponent=!0;const OJp={toc:[]},UJp="wrapper";function FJp(e){let{components:n,...t}=e;return(0,s.yg)(UJp,(0,p.A)({},OJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}FJp.isMDXComponent=!0;const VJp={toc:[]},qJp="wrapper";function jJp(e){let{components:n,...t}=e;return(0,s.yg)(qJp,(0,p.A)({},VJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}jJp.isMDXComponent=!0;const HJp={toc:[]},YJp="wrapper";function QJp(e){let{components:n,...t}=e;return(0,s.yg)(YJp,(0,p.A)({},HJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}QJp.isMDXComponent=!0;const $Jp={toc:[]},KJp="wrapper";function JJp(e){let{components:n,...t}=e;return(0,s.yg)(KJp,(0,p.A)({},$Jp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}JJp.isMDXComponent=!0;const ZJp={toc:[]},eZp="wrapper";function nZp(e){let{components:n,...t}=e;return(0,s.yg)(eZp,(0,p.A)({},ZJp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}nZp.isMDXComponent=!0;const tZp={toc:[]},oZp="wrapper";function pZp(e){let{components:n,...t}=e;return(0,s.yg)(oZp,(0,p.A)({},tZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}pZp.isMDXComponent=!0;const rZp={toc:[]},sZp="wrapper";function cZp(e){let{components:n,...t}=e;return(0,s.yg)(sZp,(0,p.A)({},rZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}cZp.isMDXComponent=!0;const aZp={toc:[]},iZp="wrapper";function lZp(e){let{components:n,...t}=e;return(0,s.yg)(iZp,(0,p.A)({},aZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}lZp.isMDXComponent=!0;const uZp={toc:[]},mZp="wrapper";function yZp(e){let{components:n,...t}=e;return(0,s.yg)(mZp,(0,p.A)({},uZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}yZp.isMDXComponent=!0;const dZp={toc:[]},hZp="wrapper";function gZp(e){let{components:n,...t}=e;return(0,s.yg)(hZp,(0,p.A)({},dZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}gZp.isMDXComponent=!0;const fZp={toc:[]},DZp="wrapper";function MZp(e){let{components:n,...t}=e;return(0,s.yg)(DZp,(0,p.A)({},fZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}MZp.isMDXComponent=!0;const XZp={toc:[]},_Zp="wrapper";function wZp(e){let{components:n,...t}=e;return(0,s.yg)(_Zp,(0,p.A)({},XZp,t,{components:n,mdxType:"MDXLayout"}))}wZp.isMDXComponent=!0;const TZp={toc:[]},CZp="wrapper";function xZp(e){let{components:n,...t}=e;return(0,s.yg)(CZp,(0,p.A)({},TZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}xZp.isMDXComponent=!0;const AZp={toc:[]},vZp="wrapper";function LZp(e){let{components:n,...t}=e;return(0,s.yg)(vZp,(0,p.A)({},AZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}LZp.isMDXComponent=!0;const bZp={toc:[]},NZp="wrapper";function kZp(e){let{components:n,...t}=e;return(0,s.yg)(NZp,(0,p.A)({},bZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}kZp.isMDXComponent=!0;const zZp={toc:[]},PZp="wrapper";function IZp(e){let{components:n,...t}=e;return(0,s.yg)(PZp,(0,p.A)({},zZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the image should be smoothed."))}IZp.isMDXComponent=!0;const RZp={toc:[]},WZp="wrapper";function SZp(e){let{components:n,...t}=e;return(0,s.yg)(WZp,(0,p.A)({},RZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}SZp.isMDXComponent=!0;const BZp={toc:[]},EZp="wrapper";function GZp(e){let{components:n,...t}=e;return(0,s.yg)(EZp,(0,p.A)({},BZp,t,{components:n,mdxType:"MDXLayout"}))}GZp.isMDXComponent=!0;const OZp={toc:[]},UZp="wrapper";function FZp(e){let{components:n,...t}=e;return(0,s.yg)(UZp,(0,p.A)({},OZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The source of this image."))}FZp.isMDXComponent=!0;const VZp={toc:[]},qZp="wrapper";function jZp(e){let{components:n,...t}=e;return(0,s.yg)(qZp,(0,p.A)({},VZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}jZp.isMDXComponent=!0;const HZp={toc:[]},YZp="wrapper";function QZp(e){let{components:n,...t}=e;return(0,s.yg)(YZp,(0,p.A)({},HZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}QZp.isMDXComponent=!0;const $Zp={toc:[]},KZp="wrapper";function JZp(e){let{components:n,...t}=e;return(0,s.yg)(KZp,(0,p.A)({},$Zp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}JZp.isMDXComponent=!0;const ZZp={toc:[]},e0p="wrapper";function n0p(e){let{components:n,...t}=e;return(0,s.yg)(e0p,(0,p.A)({},ZZp,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}n0p.isMDXComponent=!0;const t0p={toc:[]},o0p="wrapper";function p0p(e){let{components:n,...t}=e;return(0,s.yg)(o0p,(0,p.A)({},t0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LatexProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}p0p.isMDXComponent=!0;const r0p={toc:[]},s0p="wrapper";function c0p(e){let{components:n,...t}=e;return(0,s.yg)(s0p,(0,p.A)({},r0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}c0p.isMDXComponent=!0;const a0p={toc:[]},i0p="wrapper";function l0p(e){let{components:n,...t}=e;return(0,s.yg)(i0p,(0,p.A)({},a0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}l0p.isMDXComponent=!0;const u0p={toc:[]},m0p="wrapper";function y0p(e){let{components:n,...t}=e;return(0,s.yg)(m0p,(0,p.A)({},u0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}y0p.isMDXComponent=!0;const d0p={toc:[]},h0p="wrapper";function g0p(e){let{components:n,...t}=e;return(0,s.yg)(h0p,(0,p.A)({},d0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}g0p.isMDXComponent=!0;const f0p={toc:[]},D0p="wrapper";function M0p(e){let{components:n,...t}=e;return(0,s.yg)(D0p,(0,p.A)({},f0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}M0p.isMDXComponent=!0;const X0p={toc:[]},_0p="wrapper";function w0p(e){let{components:n,...t}=e;return(0,s.yg)(_0p,(0,p.A)({},X0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}w0p.isMDXComponent=!0;const T0p={toc:[]},C0p="wrapper";function x0p(e){let{components:n,...t}=e;return(0,s.yg)(C0p,(0,p.A)({},T0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}x0p.isMDXComponent=!0;const A0p={toc:[]},v0p="wrapper";function L0p(e){let{components:n,...t}=e;return(0,s.yg)(v0p,(0,p.A)({},A0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}L0p.isMDXComponent=!0;const b0p={toc:[]},N0p="wrapper";function k0p(e){let{components:n,...t}=e;return(0,s.yg)(N0p,(0,p.A)({},b0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}k0p.isMDXComponent=!0;const z0p={toc:[]},P0p="wrapper";function I0p(e){let{components:n,...t}=e;return(0,s.yg)(P0p,(0,p.A)({},z0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}I0p.isMDXComponent=!0;const R0p={toc:[]},W0p="wrapper";function S0p(e){let{components:n,...t}=e;return(0,s.yg)(W0p,(0,p.A)({},R0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}S0p.isMDXComponent=!0;const B0p={toc:[]},E0p="wrapper";function G0p(e){let{components:n,...t}=e;return(0,s.yg)(E0p,(0,p.A)({},B0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}G0p.isMDXComponent=!0;const O0p={toc:[]},U0p="wrapper";function F0p(e){let{components:n,...t}=e;return(0,s.yg)(U0p,(0,p.A)({},O0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}F0p.isMDXComponent=!0;const V0p={toc:[]},q0p="wrapper";function j0p(e){let{components:n,...t}=e;return(0,s.yg)(q0p,(0,p.A)({},V0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}j0p.isMDXComponent=!0;const H0p={toc:[]},Y0p="wrapper";function Q0p(e){let{components:n,...t}=e;return(0,s.yg)(Y0p,(0,p.A)({},H0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Q0p.isMDXComponent=!0;const $0p={toc:[]},K0p="wrapper";function J0p(e){let{components:n,...t}=e;return(0,s.yg)(K0p,(0,p.A)({},$0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}J0p.isMDXComponent=!0;const Z0p={toc:[]},e3p="wrapper";function n3p(e){let{components:n,...t}=e;return(0,s.yg)(e3p,(0,p.A)({},Z0p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}n3p.isMDXComponent=!0;const t3p={toc:[]},o3p="wrapper";function p3p(e){let{components:n,...t}=e;return(0,s.yg)(o3p,(0,p.A)({},t3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}p3p.isMDXComponent=!0;const r3p={toc:[]},s3p="wrapper";function c3p(e){let{components:n,...t}=e;return(0,s.yg)(s3p,(0,p.A)({},r3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}c3p.isMDXComponent=!0;const a3p={toc:[]},i3p="wrapper";function l3p(e){let{components:n,...t}=e;return(0,s.yg)(i3p,(0,p.A)({},a3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}l3p.isMDXComponent=!0;const u3p={toc:[]},m3p="wrapper";function y3p(e){let{components:n,...t}=e;return(0,s.yg)(m3p,(0,p.A)({},u3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}y3p.isMDXComponent=!0;const d3p={toc:[]},h3p="wrapper";function g3p(e){let{components:n,...t}=e;return(0,s.yg)(h3p,(0,p.A)({},d3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}g3p.isMDXComponent=!0;const f3p={toc:[]},D3p="wrapper";function M3p(e){let{components:n,...t}=e;return(0,s.yg)(D3p,(0,p.A)({},f3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}M3p.isMDXComponent=!0;const X3p={toc:[]},_3p="wrapper";function w3p(e){let{components:n,...t}=e;return(0,s.yg)(_3p,(0,p.A)({},X3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}w3p.isMDXComponent=!0;const T3p={toc:[]},C3p="wrapper";function x3p(e){let{components:n,...t}=e;return(0,s.yg)(C3p,(0,p.A)({},T3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}x3p.isMDXComponent=!0;const A3p={toc:[]},v3p="wrapper";function L3p(e){let{components:n,...t}=e;return(0,s.yg)(v3p,(0,p.A)({},A3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}L3p.isMDXComponent=!0;const b3p={toc:[]},N3p="wrapper";function k3p(e){let{components:n,...t}=e;return(0,s.yg)(N3p,(0,p.A)({},b3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}k3p.isMDXComponent=!0;const z3p={toc:[]},P3p="wrapper";function I3p(e){let{components:n,...t}=e;return(0,s.yg)(P3p,(0,p.A)({},z3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}I3p.isMDXComponent=!0;const R3p={toc:[]},W3p="wrapper";function S3p(e){let{components:n,...t}=e;return(0,s.yg)(W3p,(0,p.A)({},R3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}S3p.isMDXComponent=!0;const B3p={toc:[]},E3p="wrapper";function G3p(e){let{components:n,...t}=e;return(0,s.yg)(E3p,(0,p.A)({},B3p,t,{components:n,mdxType:"MDXLayout"}))}G3p.isMDXComponent=!0;const O3p={toc:[]},U3p="wrapper";function F3p(e){let{components:n,...t}=e;return(0,s.yg)(U3p,(0,p.A)({},O3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}F3p.isMDXComponent=!0;const V3p={toc:[]},q3p="wrapper";function j3p(e){let{components:n,...t}=e;return(0,s.yg)(q3p,(0,p.A)({},V3p,t,{components:n,mdxType:"MDXLayout"}))}j3p.isMDXComponent=!0;const H3p={toc:[]},Y3p="wrapper";function Q3p(e){let{components:n,...t}=e;return(0,s.yg)(Y3p,(0,p.A)({},H3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Q3p.isMDXComponent=!0;const $3p={toc:[]},K3p="wrapper";function J3p(e){let{components:n,...t}=e;return(0,s.yg)(K3p,(0,p.A)({},$3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}J3p.isMDXComponent=!0;const Z3p={toc:[]},e1p="wrapper";function n1p(e){let{components:n,...t}=e;return(0,s.yg)(e1p,(0,p.A)({},Z3p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}n1p.isMDXComponent=!0;const t1p={toc:[]},o1p="wrapper";function p1p(e){let{components:n,...t}=e;return(0,s.yg)(o1p,(0,p.A)({},t1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}p1p.isMDXComponent=!0;const r1p={toc:[]},s1p="wrapper";function c1p(e){let{components:n,...t}=e;return(0,s.yg)(s1p,(0,p.A)({},r1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}c1p.isMDXComponent=!0;const a1p={toc:[]},i1p="wrapper";function l1p(e){let{components:n,...t}=e;return(0,s.yg)(i1p,(0,p.A)({},a1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}l1p.isMDXComponent=!0;const u1p={toc:[]},m1p="wrapper";function y1p(e){let{components:n,...t}=e;return(0,s.yg)(m1p,(0,p.A)({},u1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}y1p.isMDXComponent=!0;const d1p={toc:[]},h1p="wrapper";function g1p(e){let{components:n,...t}=e;return(0,s.yg)(h1p,(0,p.A)({},d1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}g1p.isMDXComponent=!0;const f1p={toc:[]},D1p="wrapper";function M1p(e){let{components:n,...t}=e;return(0,s.yg)(D1p,(0,p.A)({},f1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}M1p.isMDXComponent=!0;const X1p={toc:[]},_1p="wrapper";function w1p(e){let{components:n,...t}=e;return(0,s.yg)(_1p,(0,p.A)({},X1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}w1p.isMDXComponent=!0;const T1p={toc:[]},C1p="wrapper";function x1p(e){let{components:n,...t}=e;return(0,s.yg)(C1p,(0,p.A)({},T1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}x1p.isMDXComponent=!0;const A1p={toc:[]},v1p="wrapper";function L1p(e){let{components:n,...t}=e;return(0,s.yg)(v1p,(0,p.A)({},A1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}L1p.isMDXComponent=!0;const b1p={toc:[]},N1p="wrapper";function k1p(e){let{components:n,...t}=e;return(0,s.yg)(N1p,(0,p.A)({},b1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}k1p.isMDXComponent=!0;const z1p={toc:[]},P1p="wrapper";function I1p(e){let{components:n,...t}=e;return(0,s.yg)(P1p,(0,p.A)({},z1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}I1p.isMDXComponent=!0;const R1p={toc:[]},W1p="wrapper";function S1p(e){let{components:n,...t}=e;return(0,s.yg)(W1p,(0,p.A)({},R1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}S1p.isMDXComponent=!0;const B1p={toc:[]},E1p="wrapper";function G1p(e){let{components:n,...t}=e;return(0,s.yg)(E1p,(0,p.A)({},B1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}G1p.isMDXComponent=!0;const O1p={toc:[]},U1p="wrapper";function F1p(e){let{components:n,...t}=e;return(0,s.yg)(U1p,(0,p.A)({},O1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}F1p.isMDXComponent=!0;const V1p={toc:[]},q1p="wrapper";function j1p(e){let{components:n,...t}=e;return(0,s.yg)(q1p,(0,p.A)({},V1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}j1p.isMDXComponent=!0;const H1p={toc:[]},Y1p="wrapper";function Q1p(e){let{components:n,...t}=e;return(0,s.yg)(Y1p,(0,p.A)({},H1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Q1p.isMDXComponent=!0;const $1p={toc:[]},K1p="wrapper";function J1p(e){let{components:n,...t}=e;return(0,s.yg)(K1p,(0,p.A)({},$1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}J1p.isMDXComponent=!0;const Z1p={toc:[]},e9p="wrapper";function n9p(e){let{components:n,...t}=e;return(0,s.yg)(e9p,(0,p.A)({},Z1p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}n9p.isMDXComponent=!0;const t9p={toc:[]},o9p="wrapper";function p9p(e){let{components:n,...t}=e;return(0,s.yg)(o9p,(0,p.A)({},t9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}p9p.isMDXComponent=!0;const r9p={toc:[]},s9p="wrapper";function c9p(e){let{components:n,...t}=e;return(0,s.yg)(s9p,(0,p.A)({},r9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}c9p.isMDXComponent=!0;const a9p={toc:[]},i9p="wrapper";function l9p(e){let{components:n,...t}=e;return(0,s.yg)(i9p,(0,p.A)({},a9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}l9p.isMDXComponent=!0;const u9p={toc:[]},m9p="wrapper";function y9p(e){let{components:n,...t}=e;return(0,s.yg)(m9p,(0,p.A)({},u9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}y9p.isMDXComponent=!0;const d9p={toc:[]},h9p="wrapper";function g9p(e){let{components:n,...t}=e;return(0,s.yg)(h9p,(0,p.A)({},d9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}g9p.isMDXComponent=!0;const f9p={toc:[]},D9p="wrapper";function M9p(e){let{components:n,...t}=e;return(0,s.yg)(D9p,(0,p.A)({},f9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}M9p.isMDXComponent=!0;const X9p={toc:[]},_9p="wrapper";function w9p(e){let{components:n,...t}=e;return(0,s.yg)(_9p,(0,p.A)({},X9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}w9p.isMDXComponent=!0;const T9p={toc:[]},C9p="wrapper";function x9p(e){let{components:n,...t}=e;return(0,s.yg)(C9p,(0,p.A)({},T9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}x9p.isMDXComponent=!0;const A9p={toc:[]},v9p="wrapper";function L9p(e){let{components:n,...t}=e;return(0,s.yg)(v9p,(0,p.A)({},A9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}L9p.isMDXComponent=!0;const b9p={toc:[]},N9p="wrapper";function k9p(e){let{components:n,...t}=e;return(0,s.yg)(N9p,(0,p.A)({},b9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}k9p.isMDXComponent=!0;const z9p={toc:[]},P9p="wrapper";function I9p(e){let{components:n,...t}=e;return(0,s.yg)(P9p,(0,p.A)({},z9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}I9p.isMDXComponent=!0;const R9p={toc:[]},W9p="wrapper";function S9p(e){let{components:n,...t}=e;return(0,s.yg)(W9p,(0,p.A)({},R9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}S9p.isMDXComponent=!0;const B9p={toc:[]},E9p="wrapper";function G9p(e){let{components:n,...t}=e;return(0,s.yg)(E9p,(0,p.A)({},B9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}G9p.isMDXComponent=!0;const O9p={toc:[]},U9p="wrapper";function F9p(e){let{components:n,...t}=e;return(0,s.yg)(U9p,(0,p.A)({},O9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}F9p.isMDXComponent=!0;const V9p={toc:[]},q9p="wrapper";function j9p(e){let{components:n,...t}=e;return(0,s.yg)(q9p,(0,p.A)({},V9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}j9p.isMDXComponent=!0;const H9p={toc:[]},Y9p="wrapper";function Q9p(e){let{components:n,...t}=e;return(0,s.yg)(Y9p,(0,p.A)({},H9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When set to ",(0,s.yg)("inlineCode",{parentName:"p"},"null"),", the Line will use the positions of its children as\npoints."))}Q9p.isMDXComponent=!0;const $9p={toc:[]},K9p="wrapper";function J9p(e){let{components:n,...t}=e;return(0,s.yg)(K9p,(0,p.A)({},$9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The points of the line."))}J9p.isMDXComponent=!0;const Z9p={toc:[]},e2p="wrapper";function n2p(e){let{components:n,...t}=e;return(0,s.yg)(e2p,(0,p.A)({},Z9p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The radius of the line's corners."))}n2p.isMDXComponent=!0;const t2p={toc:[]},o2p="wrapper";function p2p(e){let{components:n,...t}=e;return(0,s.yg)(o2p,(0,p.A)({},t2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}p2p.isMDXComponent=!0;const r2p={toc:[]},s2p="wrapper";function c2p(e){let{components:n,...t}=e;return(0,s.yg)(s2p,(0,p.A)({},r2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}c2p.isMDXComponent=!0;const a2p={toc:[]},i2p="wrapper";function l2p(e){let{components:n,...t}=e;return(0,s.yg)(i2p,(0,p.A)({},a2p,t,{components:n,mdxType:"MDXLayout"}))}l2p.isMDXComponent=!0;const u2p={toc:[]},m2p="wrapper";function y2p(e){let{components:n,...t}=e;return(0,s.yg)(m2p,(0,p.A)({},u2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}y2p.isMDXComponent=!0;const d2p={toc:[]},h2p="wrapper";function g2p(e){let{components:n,...t}=e;return(0,s.yg)(h2p,(0,p.A)({},d2p,t,{components:n,mdxType:"MDXLayout"}))}g2p.isMDXComponent=!0;const f2p={toc:[]},D2p="wrapper";function M2p(e){let{components:n,...t}=e;return(0,s.yg)(D2p,(0,p.A)({},f2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}M2p.isMDXComponent=!0;const X2p={toc:[]},_2p="wrapper";function w2p(e){let{components:n,...t}=e;return(0,s.yg)(_2p,(0,p.A)({},X2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}w2p.isMDXComponent=!0;const T2p={toc:[]},C2p="wrapper";function x2p(e){let{components:n,...t}=e;return(0,s.yg)(C2p,(0,p.A)({},T2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}x2p.isMDXComponent=!0;const A2p={toc:[]},v2p="wrapper";function L2p(e){let{components:n,...t}=e;return(0,s.yg)(v2p,(0,p.A)({},A2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}L2p.isMDXComponent=!0;const b2p={toc:[]},N2p="wrapper";function k2p(e){let{components:n,...t}=e;return(0,s.yg)(N2p,(0,p.A)({},b2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/LineProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}k2p.isMDXComponent=!0;const z2p={toc:[]},P2p="wrapper";function I2p(e){let{components:n,...t}=e;return(0,s.yg)(P2p,(0,p.A)({},z2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}I2p.isMDXComponent=!0;const R2p={toc:[]},W2p="wrapper";function S2p(e){let{components:n,...t}=e;return(0,s.yg)(W2p,(0,p.A)({},R2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}S2p.isMDXComponent=!0;const B2p={toc:[]},E2p="wrapper";function G2p(e){let{components:n,...t}=e;return(0,s.yg)(E2p,(0,p.A)({},B2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}G2p.isMDXComponent=!0;const O2p={toc:[]},U2p="wrapper";function F2p(e){let{components:n,...t}=e;return(0,s.yg)(U2p,(0,p.A)({},O2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}F2p.isMDXComponent=!0;const V2p={toc:[]},q2p="wrapper";function j2p(e){let{components:n,...t}=e;return(0,s.yg)(q2p,(0,p.A)({},V2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}j2p.isMDXComponent=!0;const H2p={toc:[]},Y2p="wrapper";function Q2p(e){let{components:n,...t}=e;return(0,s.yg)(Y2p,(0,p.A)({},H2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Q2p.isMDXComponent=!0;const $2p={toc:[]},K2p="wrapper";function J2p(e){let{components:n,...t}=e;return(0,s.yg)(K2p,(0,p.A)({},$2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}J2p.isMDXComponent=!0;const Z2p={toc:[]},e4p="wrapper";function n4p(e){let{components:n,...t}=e;return(0,s.yg)(e4p,(0,p.A)({},Z2p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}n4p.isMDXComponent=!0;const t4p={toc:[]},o4p="wrapper";function p4p(e){let{components:n,...t}=e;return(0,s.yg)(o4p,(0,p.A)({},t4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}p4p.isMDXComponent=!0;const r4p={toc:[]},s4p="wrapper";function c4p(e){let{components:n,...t}=e;return(0,s.yg)(s4p,(0,p.A)({},r4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}c4p.isMDXComponent=!0;const a4p={toc:[]},i4p="wrapper";function l4p(e){let{components:n,...t}=e;return(0,s.yg)(i4p,(0,p.A)({},a4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}l4p.isMDXComponent=!0;const u4p={toc:[]},m4p="wrapper";function y4p(e){let{components:n,...t}=e;return(0,s.yg)(m4p,(0,p.A)({},u4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}y4p.isMDXComponent=!0;const d4p={toc:[]},h4p="wrapper";function g4p(e){let{components:n,...t}=e;return(0,s.yg)(h4p,(0,p.A)({},d4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}g4p.isMDXComponent=!0;const f4p={toc:[]},D4p="wrapper";function M4p(e){let{components:n,...t}=e;return(0,s.yg)(D4p,(0,p.A)({},f4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}M4p.isMDXComponent=!0;const X4p={toc:[]},_4p="wrapper";function w4p(e){let{components:n,...t}=e;return(0,s.yg)(_4p,(0,p.A)({},X4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}w4p.isMDXComponent=!0;const T4p={toc:[]},C4p="wrapper";function x4p(e){let{components:n,...t}=e;return(0,s.yg)(C4p,(0,p.A)({},T4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}x4p.isMDXComponent=!0;const A4p={toc:[]},v4p="wrapper";function L4p(e){let{components:n,...t}=e;return(0,s.yg)(v4p,(0,p.A)({},A4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}L4p.isMDXComponent=!0;const b4p={toc:[]},N4p="wrapper";function k4p(e){let{components:n,...t}=e;return(0,s.yg)(N4p,(0,p.A)({},b4p,t,{components:n,mdxType:"MDXLayout"}))}k4p.isMDXComponent=!0;const z4p={toc:[]},P4p="wrapper";function I4p(e){let{components:n,...t}=e;return(0,s.yg)(P4p,(0,p.A)({},z4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}I4p.isMDXComponent=!0;const R4p={toc:[]},W4p="wrapper";function S4p(e){let{components:n,...t}=e;return(0,s.yg)(W4p,(0,p.A)({},R4p,t,{components:n,mdxType:"MDXLayout"}))}S4p.isMDXComponent=!0;const B4p={toc:[]},E4p="wrapper";function G4p(e){let{components:n,...t}=e;return(0,s.yg)(E4p,(0,p.A)({},B4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}G4p.isMDXComponent=!0;const O4p={toc:[]},U4p="wrapper";function F4p(e){let{components:n,...t}=e;return(0,s.yg)(U4p,(0,p.A)({},O4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}F4p.isMDXComponent=!0;const V4p={toc:[]},q4p="wrapper";function j4p(e){let{components:n,...t}=e;return(0,s.yg)(q4p,(0,p.A)({},V4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}j4p.isMDXComponent=!0;const H4p={toc:[]},Y4p="wrapper";function Q4p(e){let{components:n,...t}=e;return(0,s.yg)(Y4p,(0,p.A)({},H4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Q4p.isMDXComponent=!0;const $4p={toc:[]},K4p="wrapper";function J4p(e){let{components:n,...t}=e;return(0,s.yg)(K4p,(0,p.A)({},$4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}J4p.isMDXComponent=!0;const Z4p={toc:[]},e6p="wrapper";function n6p(e){let{components:n,...t}=e;return(0,s.yg)(e6p,(0,p.A)({},Z4p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}n6p.isMDXComponent=!0;const t6p={toc:[]},o6p="wrapper";function p6p(e){let{components:n,...t}=e;return(0,s.yg)(o6p,(0,p.A)({},t6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}p6p.isMDXComponent=!0;const r6p={toc:[]},s6p="wrapper";function c6p(e){let{components:n,...t}=e;return(0,s.yg)(s6p,(0,p.A)({},r6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}c6p.isMDXComponent=!0;const a6p={toc:[]},i6p="wrapper";function l6p(e){let{components:n,...t}=e;return(0,s.yg)(i6p,(0,p.A)({},a6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}l6p.isMDXComponent=!0;const u6p={toc:[]},m6p="wrapper";function y6p(e){let{components:n,...t}=e;return(0,s.yg)(m6p,(0,p.A)({},u6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}y6p.isMDXComponent=!0;const d6p={toc:[]},h6p="wrapper";function g6p(e){let{components:n,...t}=e;return(0,s.yg)(h6p,(0,p.A)({},d6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}g6p.isMDXComponent=!0;const f6p={toc:[]},D6p="wrapper";function M6p(e){let{components:n,...t}=e;return(0,s.yg)(D6p,(0,p.A)({},f6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}M6p.isMDXComponent=!0;const X6p={toc:[]},_6p="wrapper";function w6p(e){let{components:n,...t}=e;return(0,s.yg)(_6p,(0,p.A)({},X6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}w6p.isMDXComponent=!0;const T6p={toc:[]},C6p="wrapper";function x6p(e){let{components:n,...t}=e;return(0,s.yg)(C6p,(0,p.A)({},T6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}x6p.isMDXComponent=!0;const A6p={toc:[]},v6p="wrapper";function L6p(e){let{components:n,...t}=e;return(0,s.yg)(v6p,(0,p.A)({},A6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}L6p.isMDXComponent=!0;const b6p={toc:[]},N6p="wrapper";function k6p(e){let{components:n,...t}=e;return(0,s.yg)(N6p,(0,p.A)({},b6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}k6p.isMDXComponent=!0;const z6p={toc:[]},P6p="wrapper";function I6p(e){let{components:n,...t}=e;return(0,s.yg)(P6p,(0,p.A)({},z6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}I6p.isMDXComponent=!0;const R6p={toc:[]},W6p="wrapper";function S6p(e){let{components:n,...t}=e;return(0,s.yg)(W6p,(0,p.A)({},R6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}S6p.isMDXComponent=!0;const B6p={toc:[]},E6p="wrapper";function G6p(e){let{components:n,...t}=e;return(0,s.yg)(E6p,(0,p.A)({},B6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}G6p.isMDXComponent=!0;const O6p={toc:[]},U6p="wrapper";function F6p(e){let{components:n,...t}=e;return(0,s.yg)(U6p,(0,p.A)({},O6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}F6p.isMDXComponent=!0;const V6p={toc:[]},q6p="wrapper";function j6p(e){let{components:n,...t}=e;return(0,s.yg)(q6p,(0,p.A)({},V6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}j6p.isMDXComponent=!0;const H6p={toc:[]},Y6p="wrapper";function Q6p(e){let{components:n,...t}=e;return(0,s.yg)(Y6p,(0,p.A)({},H6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}Q6p.isMDXComponent=!0;const $6p={toc:[]},K6p="wrapper";function J6p(e){let{components:n,...t}=e;return(0,s.yg)(K6p,(0,p.A)({},$6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}J6p.isMDXComponent=!0;const Z6p={toc:[]},e8p="wrapper";function n8p(e){let{components:n,...t}=e;return(0,s.yg)(e8p,(0,p.A)({},Z6p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}n8p.isMDXComponent=!0;const t8p={toc:[]},o8p="wrapper";function p8p(e){let{components:n,...t}=e;return(0,s.yg)(o8p,(0,p.A)({},t8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}p8p.isMDXComponent=!0;const r8p={toc:[]},s8p="wrapper";function c8p(e){let{components:n,...t}=e;return(0,s.yg)(s8p,(0,p.A)({},r8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}c8p.isMDXComponent=!0;const a8p={toc:[]},i8p="wrapper";function l8p(e){let{components:n,...t}=e;return(0,s.yg)(i8p,(0,p.A)({},a8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}l8p.isMDXComponent=!0;const u8p={toc:[]},m8p="wrapper";function y8p(e){let{components:n,...t}=e;return(0,s.yg)(m8p,(0,p.A)({},u8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}y8p.isMDXComponent=!0;const d8p={toc:[]},h8p="wrapper";function g8p(e){let{components:n,...t}=e;return(0,s.yg)(h8p,(0,p.A)({},d8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}g8p.isMDXComponent=!0;const f8p={toc:[]},D8p="wrapper";function M8p(e){let{components:n,...t}=e;return(0,s.yg)(D8p,(0,p.A)({},f8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}M8p.isMDXComponent=!0;const X8p={toc:[]},_8p="wrapper";function w8p(e){let{components:n,...t}=e;return(0,s.yg)(_8p,(0,p.A)({},X8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}w8p.isMDXComponent=!0;const T8p={toc:[]},C8p="wrapper";function x8p(e){let{components:n,...t}=e;return(0,s.yg)(C8p,(0,p.A)({},T8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}x8p.isMDXComponent=!0;const A8p={toc:[]},v8p="wrapper";function L8p(e){let{components:n,...t}=e;return(0,s.yg)(v8p,(0,p.A)({},A8p,t,{components:n,mdxType:"MDXLayout"}))}L8p.isMDXComponent=!0;const b8p={toc:[]},N8p="wrapper";function k8p(e){let{components:n,...t}=e;return(0,s.yg)(N8p,(0,p.A)({},b8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}k8p.isMDXComponent=!0;const z8p={toc:[]},P8p="wrapper";function I8p(e){let{components:n,...t}=e;return(0,s.yg)(P8p,(0,p.A)({},z8p,t,{components:n,mdxType:"MDXLayout"}))}I8p.isMDXComponent=!0;const R8p={toc:[]},W8p="wrapper";function S8p(e){let{components:n,...t}=e;return(0,s.yg)(W8p,(0,p.A)({},R8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}S8p.isMDXComponent=!0;const B8p={toc:[]},E8p="wrapper";function G8p(e){let{components:n,...t}=e;return(0,s.yg)(E8p,(0,p.A)({},B8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}G8p.isMDXComponent=!0;const O8p={toc:[]},U8p="wrapper";function F8p(e){let{components:n,...t}=e;return(0,s.yg)(U8p,(0,p.A)({},O8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}F8p.isMDXComponent=!0;const V8p={toc:[]},q8p="wrapper";function j8p(e){let{components:n,...t}=e;return(0,s.yg)(q8p,(0,p.A)({},V8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}j8p.isMDXComponent=!0;const H8p={toc:[]},Y8p="wrapper";function Q8p(e){let{components:n,...t}=e;return(0,s.yg)(Y8p,(0,p.A)({},H8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PathProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Q8p.isMDXComponent=!0;const $8p={toc:[]},K8p="wrapper";function J8p(e){let{components:n,...t}=e;return(0,s.yg)(K8p,(0,p.A)({},$8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}J8p.isMDXComponent=!0;const Z8p={toc:[]},e5p="wrapper";function n5p(e){let{components:n,...t}=e;return(0,s.yg)(e5p,(0,p.A)({},Z8p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}n5p.isMDXComponent=!0;const t5p={toc:[]},o5p="wrapper";function p5p(e){let{components:n,...t}=e;return(0,s.yg)(o5p,(0,p.A)({},t5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}p5p.isMDXComponent=!0;const r5p={toc:[]},s5p="wrapper";function c5p(e){let{components:n,...t}=e;return(0,s.yg)(s5p,(0,p.A)({},r5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}c5p.isMDXComponent=!0;const a5p={toc:[]},i5p="wrapper";function l5p(e){let{components:n,...t}=e;return(0,s.yg)(i5p,(0,p.A)({},a5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}l5p.isMDXComponent=!0;const u5p={toc:[]},m5p="wrapper";function y5p(e){let{components:n,...t}=e;return(0,s.yg)(m5p,(0,p.A)({},u5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}y5p.isMDXComponent=!0;const d5p={toc:[]},h5p="wrapper";function g5p(e){let{components:n,...t}=e;return(0,s.yg)(h5p,(0,p.A)({},d5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}g5p.isMDXComponent=!0;const f5p={toc:[]},D5p="wrapper";function M5p(e){let{components:n,...t}=e;return(0,s.yg)(D5p,(0,p.A)({},f5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}M5p.isMDXComponent=!0;const X5p={toc:[]},_5p="wrapper";function w5p(e){let{components:n,...t}=e;return(0,s.yg)(_5p,(0,p.A)({},X5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}w5p.isMDXComponent=!0;const T5p={toc:[]},C5p="wrapper";function x5p(e){let{components:n,...t}=e;return(0,s.yg)(C5p,(0,p.A)({},T5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}x5p.isMDXComponent=!0;const A5p={toc:[]},v5p="wrapper";function L5p(e){let{components:n,...t}=e;return(0,s.yg)(v5p,(0,p.A)({},A5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}L5p.isMDXComponent=!0;const b5p={toc:[]},N5p="wrapper";function k5p(e){let{components:n,...t}=e;return(0,s.yg)(N5p,(0,p.A)({},b5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}k5p.isMDXComponent=!0;const z5p={toc:[]},P5p="wrapper";function I5p(e){let{components:n,...t}=e;return(0,s.yg)(P5p,(0,p.A)({},z5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}I5p.isMDXComponent=!0;const R5p={toc:[]},W5p="wrapper";function S5p(e){let{components:n,...t}=e;return(0,s.yg)(W5p,(0,p.A)({},R5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}S5p.isMDXComponent=!0;const B5p={toc:[]},E5p="wrapper";function G5p(e){let{components:n,...t}=e;return(0,s.yg)(E5p,(0,p.A)({},B5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}G5p.isMDXComponent=!0;const O5p={toc:[]},U5p="wrapper";function F5p(e){let{components:n,...t}=e;return(0,s.yg)(U5p,(0,p.A)({},O5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}F5p.isMDXComponent=!0;const V5p={toc:[]},q5p="wrapper";function j5p(e){let{components:n,...t}=e;return(0,s.yg)(q5p,(0,p.A)({},V5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}j5p.isMDXComponent=!0;const H5p={toc:[]},Y5p="wrapper";function Q5p(e){let{components:n,...t}=e;return(0,s.yg)(Y5p,(0,p.A)({},H5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Q5p.isMDXComponent=!0;const $5p={toc:[]},K5p="wrapper";function J5p(e){let{components:n,...t}=e;return(0,s.yg)(K5p,(0,p.A)({},$5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}J5p.isMDXComponent=!0;const Z5p={toc:[]},e7p="wrapper";function n7p(e){let{components:n,...t}=e;return(0,s.yg)(e7p,(0,p.A)({},Z5p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}n7p.isMDXComponent=!0;const t7p={toc:[]},o7p="wrapper";function p7p(e){let{components:n,...t}=e;return(0,s.yg)(o7p,(0,p.A)({},t7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}p7p.isMDXComponent=!0;const r7p={toc:[]},s7p="wrapper";function c7p(e){let{components:n,...t}=e;return(0,s.yg)(s7p,(0,p.A)({},r7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}c7p.isMDXComponent=!0;const a7p={toc:[]},i7p="wrapper";function l7p(e){let{components:n,...t}=e;return(0,s.yg)(i7p,(0,p.A)({},a7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}l7p.isMDXComponent=!0;const u7p={toc:[]},m7p="wrapper";function y7p(e){let{components:n,...t}=e;return(0,s.yg)(m7p,(0,p.A)({},u7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}y7p.isMDXComponent=!0;const d7p={toc:[]},h7p="wrapper";function g7p(e){let{components:n,...t}=e;return(0,s.yg)(h7p,(0,p.A)({},d7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}g7p.isMDXComponent=!0;const f7p={toc:[]},D7p="wrapper";function M7p(e){let{components:n,...t}=e;return(0,s.yg)(D7p,(0,p.A)({},f7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}M7p.isMDXComponent=!0;const X7p={toc:[]},_7p="wrapper";function w7p(e){let{components:n,...t}=e;return(0,s.yg)(_7p,(0,p.A)({},X7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}w7p.isMDXComponent=!0;const T7p={toc:[]},C7p="wrapper";function x7p(e){let{components:n,...t}=e;return(0,s.yg)(C7p,(0,p.A)({},T7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}x7p.isMDXComponent=!0;const A7p={toc:[]},v7p="wrapper";function L7p(e){let{components:n,...t}=e;return(0,s.yg)(v7p,(0,p.A)({},A7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}L7p.isMDXComponent=!0;const b7p={toc:[]},N7p="wrapper";function k7p(e){let{components:n,...t}=e;return(0,s.yg)(N7p,(0,p.A)({},b7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}k7p.isMDXComponent=!0;const z7p={toc:[]},P7p="wrapper";function I7p(e){let{components:n,...t}=e;return(0,s.yg)(P7p,(0,p.A)({},z7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}I7p.isMDXComponent=!0;const R7p={toc:[]},W7p="wrapper";function S7p(e){let{components:n,...t}=e;return(0,s.yg)(W7p,(0,p.A)({},R7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}S7p.isMDXComponent=!0;const B7p={toc:[]},E7p="wrapper";function G7p(e){let{components:n,...t}=e;return(0,s.yg)(E7p,(0,p.A)({},B7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}G7p.isMDXComponent=!0;const O7p={toc:[]},U7p="wrapper";function F7p(e){let{components:n,...t}=e;return(0,s.yg)(U7p,(0,p.A)({},O7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}F7p.isMDXComponent=!0;const V7p={toc:[]},q7p="wrapper";function j7p(e){let{components:n,...t}=e;return(0,s.yg)(q7p,(0,p.A)({},V7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}j7p.isMDXComponent=!0;const H7p={toc:[]},Y7p="wrapper";function Q7p(e){let{components:n,...t}=e;return(0,s.yg)(Y7p,(0,p.A)({},H7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}Q7p.isMDXComponent=!0;const $7p={toc:[]},K7p="wrapper";function J7p(e){let{components:n,...t}=e;return(0,s.yg)(K7p,(0,p.A)({},$7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}J7p.isMDXComponent=!0;const Z7p={toc:[]},eer="wrapper";function ner(e){let{components:n,...t}=e;return(0,s.yg)(eer,(0,p.A)({},Z7p,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The radius of the polygon's corners."))}ner.isMDXComponent=!0;const ter={toc:[]},oer="wrapper";function per(e){let{components:n,...t}=e;return(0,s.yg)(oer,(0,p.A)({},ter,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}per.isMDXComponent=!0;const rer={toc:[]},ser="wrapper";function cer(e){let{components:n,...t}=e;return(0,s.yg)(ser,(0,p.A)({},rer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}cer.isMDXComponent=!0;const aer={toc:[]},ier="wrapper";function ler(e){let{components:n,...t}=e;return(0,s.yg)(ier,(0,p.A)({},aer,t,{components:n,mdxType:"MDXLayout"}))}ler.isMDXComponent=!0;const uer={toc:[]},mer="wrapper";function yer(e){let{components:n,...t}=e;return(0,s.yg)(mer,(0,p.A)({},uer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"For example, a value of 6 creates a hexagon."))}yer.isMDXComponent=!0;const der={toc:[]},her="wrapper";function ger(e){let{components:n,...t}=e;return(0,s.yg)(her,(0,p.A)({},der,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The number of sides of the polygon."))}ger.isMDXComponent=!0;const fer={toc:[]},Der="wrapper";function Mer(e){let{components:n,...t}=e;return(0,s.yg)(Der,(0,p.A)({},fer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Mer.isMDXComponent=!0;const Xer={toc:[]},_er="wrapper";function wer(e){let{components:n,...t}=e;return(0,s.yg)(_er,(0,p.A)({},Xer,t,{components:n,mdxType:"MDXLayout"}))}wer.isMDXComponent=!0;const Ter={toc:[]},Cer="wrapper";function xer(e){let{components:n,...t}=e;return(0,s.yg)(Cer,(0,p.A)({},Ter,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}xer.isMDXComponent=!0;const Aer={toc:[]},ver="wrapper";function Ler(e){let{components:n,...t}=e;return(0,s.yg)(ver,(0,p.A)({},Aer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}Ler.isMDXComponent=!0;const ber={toc:[]},Ner="wrapper";function ker(e){let{components:n,...t}=e;return(0,s.yg)(Ner,(0,p.A)({},ber,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}ker.isMDXComponent=!0;const zer={toc:[]},Per="wrapper";function Ier(e){let{components:n,...t}=e;return(0,s.yg)(Per,(0,p.A)({},zer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Ier.isMDXComponent=!0;const Rer={toc:[]},Wer="wrapper";function Ser(e){let{components:n,...t}=e;return(0,s.yg)(Wer,(0,p.A)({},Rer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Ser.isMDXComponent=!0;const Ber={toc:[]},Eer="wrapper";function Ger(e){let{components:n,...t}=e;return(0,s.yg)(Eer,(0,p.A)({},Ber,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}Ger.isMDXComponent=!0;const Oer={toc:[]},Uer="wrapper";function Fer(e){let{components:n,...t}=e;return(0,s.yg)(Uer,(0,p.A)({},Oer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Fer.isMDXComponent=!0;const Ver={toc:[]},qer="wrapper";function jer(e){let{components:n,...t}=e;return(0,s.yg)(qer,(0,p.A)({},Ver,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}jer.isMDXComponent=!0;const Her={toc:[]},Yer="wrapper";function Qer(e){let{components:n,...t}=e;return(0,s.yg)(Yer,(0,p.A)({},Her,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Qer.isMDXComponent=!0;const $er={toc:[]},Ker="wrapper";function Jer(e){let{components:n,...t}=e;return(0,s.yg)(Ker,(0,p.A)({},$er,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Jer.isMDXComponent=!0;const Zer={toc:[]},enr="wrapper";function nnr(e){let{components:n,...t}=e;return(0,s.yg)(enr,(0,p.A)({},Zer,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}nnr.isMDXComponent=!0;const tnr={toc:[]},onr="wrapper";function pnr(e){let{components:n,...t}=e;return(0,s.yg)(onr,(0,p.A)({},tnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}pnr.isMDXComponent=!0;const rnr={toc:[]},snr="wrapper";function cnr(e){let{components:n,...t}=e;return(0,s.yg)(snr,(0,p.A)({},rnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}cnr.isMDXComponent=!0;const anr={toc:[]},inr="wrapper";function lnr(e){let{components:n,...t}=e;return(0,s.yg)(inr,(0,p.A)({},anr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}lnr.isMDXComponent=!0;const unr={toc:[]},mnr="wrapper";function ynr(e){let{components:n,...t}=e;return(0,s.yg)(mnr,(0,p.A)({},unr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}ynr.isMDXComponent=!0;const dnr={toc:[]},hnr="wrapper";function gnr(e){let{components:n,...t}=e;return(0,s.yg)(hnr,(0,p.A)({},dnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}gnr.isMDXComponent=!0;const fnr={toc:[]},Dnr="wrapper";function Mnr(e){let{components:n,...t}=e;return(0,s.yg)(Dnr,(0,p.A)({},fnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Mnr.isMDXComponent=!0;const Xnr={toc:[]},_nr="wrapper";function wnr(e){let{components:n,...t}=e;return(0,s.yg)(_nr,(0,p.A)({},Xnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}wnr.isMDXComponent=!0;const Tnr={toc:[]},Cnr="wrapper";function xnr(e){let{components:n,...t}=e;return(0,s.yg)(Cnr,(0,p.A)({},Tnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}xnr.isMDXComponent=!0;const Anr={toc:[]},vnr="wrapper";function Lnr(e){let{components:n,...t}=e;return(0,s.yg)(vnr,(0,p.A)({},Anr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Lnr.isMDXComponent=!0;const bnr={toc:[]},Nnr="wrapper";function knr(e){let{components:n,...t}=e;return(0,s.yg)(Nnr,(0,p.A)({},bnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}knr.isMDXComponent=!0;const znr={toc:[]},Pnr="wrapper";function Inr(e){let{components:n,...t}=e;return(0,s.yg)(Pnr,(0,p.A)({},znr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Inr.isMDXComponent=!0;const Rnr={toc:[]},Wnr="wrapper";function Snr(e){let{components:n,...t}=e;return(0,s.yg)(Wnr,(0,p.A)({},Rnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Snr.isMDXComponent=!0;const Bnr={toc:[]},Enr="wrapper";function Gnr(e){let{components:n,...t}=e;return(0,s.yg)(Enr,(0,p.A)({},Bnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Gnr.isMDXComponent=!0;const Onr={toc:[]},Unr="wrapper";function Fnr(e){let{components:n,...t}=e;return(0,s.yg)(Unr,(0,p.A)({},Onr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Fnr.isMDXComponent=!0;const Vnr={toc:[]},qnr="wrapper";function jnr(e){let{components:n,...t}=e;return(0,s.yg)(qnr,(0,p.A)({},Vnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}jnr.isMDXComponent=!0;const Hnr={toc:[]},Ynr="wrapper";function Qnr(e){let{components:n,...t}=e;return(0,s.yg)(Ynr,(0,p.A)({},Hnr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Qnr.isMDXComponent=!0;const $nr={toc:[]},Knr="wrapper";function Jnr(e){let{components:n,...t}=e;return(0,s.yg)(Knr,(0,p.A)({},$nr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Jnr.isMDXComponent=!0;const Znr={toc:[]},etr="wrapper";function ntr(e){let{components:n,...t}=e;return(0,s.yg)(etr,(0,p.A)({},Znr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}ntr.isMDXComponent=!0;const ttr={toc:[]},otr="wrapper";function ptr(e){let{components:n,...t}=e;return(0,s.yg)(otr,(0,p.A)({},ttr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}ptr.isMDXComponent=!0;const rtr={toc:[]},str="wrapper";function ctr(e){let{components:n,...t}=e;return(0,s.yg)(str,(0,p.A)({},rtr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}ctr.isMDXComponent=!0;const atr={toc:[]},itr="wrapper";function ltr(e){let{components:n,...t}=e;return(0,s.yg)(itr,(0,p.A)({},atr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}ltr.isMDXComponent=!0;const utr={toc:[]},mtr="wrapper";function ytr(e){let{components:n,...t}=e;return(0,s.yg)(mtr,(0,p.A)({},utr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}ytr.isMDXComponent=!0;const dtr={toc:[]},htr="wrapper";function gtr(e){let{components:n,...t}=e;return(0,s.yg)(htr,(0,p.A)({},dtr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}gtr.isMDXComponent=!0;const ftr={toc:[]},Dtr="wrapper";function Mtr(e){let{components:n,...t}=e;return(0,s.yg)(Dtr,(0,p.A)({},ftr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Mtr.isMDXComponent=!0;const Xtr={toc:[]},_tr="wrapper";function wtr(e){let{components:n,...t}=e;return(0,s.yg)(_tr,(0,p.A)({},Xtr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}wtr.isMDXComponent=!0;const Ttr={toc:[]},Ctr="wrapper";function xtr(e){let{components:n,...t}=e;return(0,s.yg)(Ctr,(0,p.A)({},Ttr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}xtr.isMDXComponent=!0;const Atr={toc:[]},vtr="wrapper";function Ltr(e){let{components:n,...t}=e;return(0,s.yg)(vtr,(0,p.A)({},Atr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}Ltr.isMDXComponent=!0;const btr={toc:[]},Ntr="wrapper";function ktr(e){let{components:n,...t}=e;return(0,s.yg)(Ntr,(0,p.A)({},btr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}ktr.isMDXComponent=!0;const ztr={toc:[]},Ptr="wrapper";function Itr(e){let{components:n,...t}=e;return(0,s.yg)(Ptr,(0,p.A)({},ztr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Itr.isMDXComponent=!0;const Rtr={toc:[]},Wtr="wrapper";function Str(e){let{components:n,...t}=e;return(0,s.yg)(Wtr,(0,p.A)({},Rtr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}Str.isMDXComponent=!0;const Btr={toc:[]},Etr="wrapper";function Gtr(e){let{components:n,...t}=e;return(0,s.yg)(Etr,(0,p.A)({},Btr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Gtr.isMDXComponent=!0;const Otr={toc:[]},Utr="wrapper";function Ftr(e){let{components:n,...t}=e;return(0,s.yg)(Utr,(0,p.A)({},Otr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Ftr.isMDXComponent=!0;const Vtr={toc:[]},qtr="wrapper";function jtr(e){let{components:n,...t}=e;return(0,s.yg)(qtr,(0,p.A)({},Vtr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}jtr.isMDXComponent=!0;const Htr={toc:[]},Ytr="wrapper";function Qtr(e){let{components:n,...t}=e;return(0,s.yg)(Ytr,(0,p.A)({},Htr,t,{components:n,mdxType:"MDXLayout"}))}Qtr.isMDXComponent=!0;const $tr={toc:[]},Ktr="wrapper";function Jtr(e){let{components:n,...t}=e;return(0,s.yg)(Ktr,(0,p.A)({},$tr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Jtr.isMDXComponent=!0;const Ztr={toc:[]},eor="wrapper";function nor(e){let{components:n,...t}=e;return(0,s.yg)(eor,(0,p.A)({},Ztr,t,{components:n,mdxType:"MDXLayout"}))}nor.isMDXComponent=!0;const tor={toc:[]},oor="wrapper";function por(e){let{components:n,...t}=e;return(0,s.yg)(oor,(0,p.A)({},tor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}por.isMDXComponent=!0;const ror={toc:[]},sor="wrapper";function cor(e){let{components:n,...t}=e;return(0,s.yg)(sor,(0,p.A)({},ror,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}cor.isMDXComponent=!0;const aor={toc:[]},ior="wrapper";function lor(e){let{components:n,...t}=e;return(0,s.yg)(ior,(0,p.A)({},aor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}lor.isMDXComponent=!0;const uor={toc:[]},mor="wrapper";function yor(e){let{components:n,...t}=e;return(0,s.yg)(mor,(0,p.A)({},uor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}yor.isMDXComponent=!0;const dor={toc:[]},hor="wrapper";function gor(e){let{components:n,...t}=e;return(0,s.yg)(hor,(0,p.A)({},dor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}gor.isMDXComponent=!0;const Dor={toc:[]},Mor="wrapper";function Xor(e){let{components:n,...t}=e;return(0,s.yg)(Mor,(0,p.A)({},Dor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}Xor.isMDXComponent=!0;const _or={toc:[]},wor="wrapper";function Tor(e){let{components:n,...t}=e;return(0,s.yg)(wor,(0,p.A)({},_or,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Tor.isMDXComponent=!0;const Cor={toc:[]},xor="wrapper";function Aor(e){let{components:n,...t}=e;return(0,s.yg)(xor,(0,p.A)({},Cor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Aor.isMDXComponent=!0;const vor={toc:[]},Lor="wrapper";function bor(e){let{components:n,...t}=e;return(0,s.yg)(Lor,(0,p.A)({},vor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}bor.isMDXComponent=!0;const Nor={toc:[]},kor="wrapper";function zor(e){let{components:n,...t}=e;return(0,s.yg)(kor,(0,p.A)({},Nor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}zor.isMDXComponent=!0;const Por={toc:[]},Ior="wrapper";function Ror(e){let{components:n,...t}=e;return(0,s.yg)(Ior,(0,p.A)({},Por,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Ror.isMDXComponent=!0;const Wor={toc:[]},Sor="wrapper";function Bor(e){let{components:n,...t}=e;return(0,s.yg)(Sor,(0,p.A)({},Wor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Bor.isMDXComponent=!0;const Eor={toc:[]},Gor="wrapper";function Oor(e){let{components:n,...t}=e;return(0,s.yg)(Gor,(0,p.A)({},Eor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Oor.isMDXComponent=!0;const Uor={toc:[]},For="wrapper";function Vor(e){let{components:n,...t}=e;return(0,s.yg)(For,(0,p.A)({},Uor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}Vor.isMDXComponent=!0;const qor={toc:[]},jor="wrapper";function Hor(e){let{components:n,...t}=e;return(0,s.yg)(jor,(0,p.A)({},qor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Hor.isMDXComponent=!0;const Yor={toc:[]},Qor="wrapper";function $or(e){let{components:n,...t}=e;return(0,s.yg)(Qor,(0,p.A)({},Yor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}$or.isMDXComponent=!0;const Kor={toc:[]},Jor="wrapper";function Zor(e){let{components:n,...t}=e;return(0,s.yg)(Jor,(0,p.A)({},Kor,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Zor.isMDXComponent=!0;const epr={toc:[]},npr="wrapper";function tpr(e){let{components:n,...t}=e;return(0,s.yg)(npr,(0,p.A)({},epr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}tpr.isMDXComponent=!0;const opr={toc:[]},ppr="wrapper";function rpr(e){let{components:n,...t}=e;return(0,s.yg)(ppr,(0,p.A)({},opr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}rpr.isMDXComponent=!0;const spr={toc:[]},cpr="wrapper";function apr(e){let{components:n,...t}=e;return(0,s.yg)(cpr,(0,p.A)({},spr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}apr.isMDXComponent=!0;const ipr={toc:[]},lpr="wrapper";function upr(e){let{components:n,...t}=e;return(0,s.yg)(lpr,(0,p.A)({},ipr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}upr.isMDXComponent=!0;const mpr={toc:[]},ypr="wrapper";function dpr(e){let{components:n,...t}=e;return(0,s.yg)(ypr,(0,p.A)({},mpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}dpr.isMDXComponent=!0;const hpr={toc:[]},gpr="wrapper";function fpr(e){let{components:n,...t}=e;return(0,s.yg)(gpr,(0,p.A)({},hpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}fpr.isMDXComponent=!0;const Dpr={toc:[]},Mpr="wrapper";function Xpr(e){let{components:n,...t}=e;return(0,s.yg)(Mpr,(0,p.A)({},Dpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Xpr.isMDXComponent=!0;const _pr={toc:[]},wpr="wrapper";function Tpr(e){let{components:n,...t}=e;return(0,s.yg)(wpr,(0,p.A)({},_pr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Tpr.isMDXComponent=!0;const Cpr={toc:[]},xpr="wrapper";function Apr(e){let{components:n,...t}=e;return(0,s.yg)(xpr,(0,p.A)({},Cpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Apr.isMDXComponent=!0;const vpr={toc:[]},Lpr="wrapper";function bpr(e){let{components:n,...t}=e;return(0,s.yg)(Lpr,(0,p.A)({},vpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}bpr.isMDXComponent=!0;const Npr={toc:[]},kpr="wrapper";function zpr(e){let{components:n,...t}=e;return(0,s.yg)(kpr,(0,p.A)({},Npr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}zpr.isMDXComponent=!0;const Ppr={toc:[]},Ipr="wrapper";function Rpr(e){let{components:n,...t}=e;return(0,s.yg)(Ipr,(0,p.A)({},Ppr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Rpr.isMDXComponent=!0;const Wpr={toc:[]},Spr="wrapper";function Bpr(e){let{components:n,...t}=e;return(0,s.yg)(Spr,(0,p.A)({},Wpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Bpr.isMDXComponent=!0;const Epr={toc:[]},Gpr="wrapper";function Opr(e){let{components:n,...t}=e;return(0,s.yg)(Gpr,(0,p.A)({},Epr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}Opr.isMDXComponent=!0;const Upr={toc:[]},Fpr="wrapper";function Vpr(e){let{components:n,...t}=e;return(0,s.yg)(Fpr,(0,p.A)({},Upr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}Vpr.isMDXComponent=!0;const qpr={toc:[]},jpr="wrapper";function Hpr(e){let{components:n,...t}=e;return(0,s.yg)(jpr,(0,p.A)({},qpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Hpr.isMDXComponent=!0;const Ypr={toc:[]},Qpr="wrapper";function $pr(e){let{components:n,...t}=e;return(0,s.yg)(Qpr,(0,p.A)({},Ypr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}$pr.isMDXComponent=!0;const Kpr={toc:[]},Jpr="wrapper";function Zpr(e){let{components:n,...t}=e;return(0,s.yg)(Jpr,(0,p.A)({},Kpr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Zpr.isMDXComponent=!0;const err={toc:[]},nrr="wrapper";function trr(e){let{components:n,...t}=e;return(0,s.yg)(nrr,(0,p.A)({},err,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}trr.isMDXComponent=!0;const orr={toc:[]},prr="wrapper";function rrr(e){let{components:n,...t}=e;return(0,s.yg)(prr,(0,p.A)({},orr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}rrr.isMDXComponent=!0;const srr={toc:[]},crr="wrapper";function arr(e){let{components:n,...t}=e;return(0,s.yg)(crr,(0,p.A)({},srr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}arr.isMDXComponent=!0;const irr={toc:[]},lrr="wrapper";function urr(e){let{components:n,...t}=e;return(0,s.yg)(lrr,(0,p.A)({},irr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The starting point of the ray."))}urr.isMDXComponent=!0;const mrr={toc:[]},yrr="wrapper";function drr(e){let{components:n,...t}=e;return(0,s.yg)(yrr,(0,p.A)({},mrr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}drr.isMDXComponent=!0;const hrr={toc:[]},grr="wrapper";function frr(e){let{components:n,...t}=e;return(0,s.yg)(grr,(0,p.A)({},hrr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}frr.isMDXComponent=!0;const Drr={toc:[]},Mrr="wrapper";function Xrr(e){let{components:n,...t}=e;return(0,s.yg)(Mrr,(0,p.A)({},Drr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}Xrr.isMDXComponent=!0;const _rr={toc:[]},wrr="wrapper";function Trr(e){let{components:n,...t}=e;return(0,s.yg)(wrr,(0,p.A)({},_rr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Trr.isMDXComponent=!0;const Crr={toc:[]},xrr="wrapper";function Arr(e){let{components:n,...t}=e;return(0,s.yg)(xrr,(0,p.A)({},Crr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Arr.isMDXComponent=!0;const vrr={toc:[]},Lrr="wrapper";function brr(e){let{components:n,...t}=e;return(0,s.yg)(Lrr,(0,p.A)({},vrr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}brr.isMDXComponent=!0;const Nrr={toc:[]},krr="wrapper";function zrr(e){let{components:n,...t}=e;return(0,s.yg)(krr,(0,p.A)({},Nrr,t,{components:n,mdxType:"MDXLayout"}))}zrr.isMDXComponent=!0;const Prr={toc:[]},Irr="wrapper";function Rrr(e){let{components:n,...t}=e;return(0,s.yg)(Irr,(0,p.A)({},Prr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Rrr.isMDXComponent=!0;const Wrr={toc:[]},Srr="wrapper";function Brr(e){let{components:n,...t}=e;return(0,s.yg)(Srr,(0,p.A)({},Wrr,t,{components:n,mdxType:"MDXLayout"}))}Brr.isMDXComponent=!0;const Err={toc:[]},Grr="wrapper";function Orr(e){let{components:n,...t}=e;return(0,s.yg)(Grr,(0,p.A)({},Err,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Orr.isMDXComponent=!0;const Urr={toc:[]},Frr="wrapper";function Vrr(e){let{components:n,...t}=e;return(0,s.yg)(Frr,(0,p.A)({},Urr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}Vrr.isMDXComponent=!0;const qrr={toc:[]},jrr="wrapper";function Hrr(e){let{components:n,...t}=e;return(0,s.yg)(jrr,(0,p.A)({},qrr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Hrr.isMDXComponent=!0;const Yrr={toc:[]},Qrr="wrapper";function $rr(e){let{components:n,...t}=e;return(0,s.yg)(Qrr,(0,p.A)({},Yrr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}$rr.isMDXComponent=!0;const Krr={toc:[]},Jrr="wrapper";function Zrr(e){let{components:n,...t}=e;return(0,s.yg)(Jrr,(0,p.A)({},Krr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RayProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Zrr.isMDXComponent=!0;const esr={toc:[]},nsr="wrapper";function tsr(e){let{components:n,...t}=e;return(0,s.yg)(nsr,(0,p.A)({},esr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}tsr.isMDXComponent=!0;const osr={toc:[]},psr="wrapper";function rsr(e){let{components:n,...t}=e;return(0,s.yg)(psr,(0,p.A)({},osr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The ending point of the ray."))}rsr.isMDXComponent=!0;const ssr={toc:[]},csr="wrapper";function asr(e){let{components:n,...t}=e;return(0,s.yg)(csr,(0,p.A)({},ssr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}asr.isMDXComponent=!0;const isr={toc:[]},lsr="wrapper";function usr(e){let{components:n,...t}=e;return(0,s.yg)(lsr,(0,p.A)({},isr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}usr.isMDXComponent=!0;const msr={toc:[]},ysr="wrapper";function dsr(e){let{components:n,...t}=e;return(0,s.yg)(ysr,(0,p.A)({},msr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}dsr.isMDXComponent=!0;const hsr={toc:[]},gsr="wrapper";function fsr(e){let{components:n,...t}=e;return(0,s.yg)(gsr,(0,p.A)({},hsr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}fsr.isMDXComponent=!0;const Dsr={toc:[]},Msr="wrapper";function Xsr(e){let{components:n,...t}=e;return(0,s.yg)(Msr,(0,p.A)({},Dsr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Xsr.isMDXComponent=!0;const _sr={toc:[]},wsr="wrapper";function Tsr(e){let{components:n,...t}=e;return(0,s.yg)(wsr,(0,p.A)({},_sr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Tsr.isMDXComponent=!0;const Csr={toc:[]},xsr="wrapper";function Asr(e){let{components:n,...t}=e;return(0,s.yg)(xsr,(0,p.A)({},Csr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Asr.isMDXComponent=!0;const vsr={toc:[]},Lsr="wrapper";function bsr(e){let{components:n,...t}=e;return(0,s.yg)(Lsr,(0,p.A)({},vsr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}bsr.isMDXComponent=!0;const Nsr={toc:[]},ksr="wrapper";function zsr(e){let{components:n,...t}=e;return(0,s.yg)(ksr,(0,p.A)({},Nsr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}zsr.isMDXComponent=!0;const Psr={toc:[]},Isr="wrapper";function Rsr(e){let{components:n,...t}=e;return(0,s.yg)(Isr,(0,p.A)({},Psr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Rsr.isMDXComponent=!0;const Wsr={toc:[]},Ssr="wrapper";function Bsr(e){let{components:n,...t}=e;return(0,s.yg)(Ssr,(0,p.A)({},Wsr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Bsr.isMDXComponent=!0;const Esr={toc:[]},Gsr="wrapper";function Osr(e){let{components:n,...t}=e;return(0,s.yg)(Gsr,(0,p.A)({},Esr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Osr.isMDXComponent=!0;const Usr={toc:[]},Fsr="wrapper";function Vsr(e){let{components:n,...t}=e;return(0,s.yg)(Fsr,(0,p.A)({},Usr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Vsr.isMDXComponent=!0;const qsr={toc:[]},jsr="wrapper";function Hsr(e){let{components:n,...t}=e;return(0,s.yg)(jsr,(0,p.A)({},qsr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Hsr.isMDXComponent=!0;const Ysr={toc:[]},Qsr="wrapper";function $sr(e){let{components:n,...t}=e;return(0,s.yg)(Qsr,(0,p.A)({},Ysr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}$sr.isMDXComponent=!0;const Ksr={toc:[]},Jsr="wrapper";function Zsr(e){let{components:n,...t}=e;return(0,s.yg)(Jsr,(0,p.A)({},Ksr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Zsr.isMDXComponent=!0;const ecr={toc:[]},ncr="wrapper";function tcr(e){let{components:n,...t}=e;return(0,s.yg)(ncr,(0,p.A)({},ecr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}tcr.isMDXComponent=!0;const ocr={toc:[]},pcr="wrapper";function rcr(e){let{components:n,...t}=e;return(0,s.yg)(pcr,(0,p.A)({},ocr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}rcr.isMDXComponent=!0;const scr={toc:[]},ccr="wrapper";function acr(e){let{components:n,...t}=e;return(0,s.yg)(ccr,(0,p.A)({},scr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}acr.isMDXComponent=!0;const icr={toc:[]},lcr="wrapper";function ucr(e){let{components:n,...t}=e;return(0,s.yg)(lcr,(0,p.A)({},icr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}ucr.isMDXComponent=!0;const mcr={toc:[]},ycr="wrapper";function dcr(e){let{components:n,...t}=e;return(0,s.yg)(ycr,(0,p.A)({},mcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}dcr.isMDXComponent=!0;const hcr={toc:[]},gcr="wrapper";function fcr(e){let{components:n,...t}=e;return(0,s.yg)(gcr,(0,p.A)({},hcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}fcr.isMDXComponent=!0;const Dcr={toc:[]},Mcr="wrapper";function Xcr(e){let{components:n,...t}=e;return(0,s.yg)(Mcr,(0,p.A)({},Dcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Xcr.isMDXComponent=!0;const _cr={toc:[]},wcr="wrapper";function Tcr(e){let{components:n,...t}=e;return(0,s.yg)(wcr,(0,p.A)({},_cr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Tcr.isMDXComponent=!0;const Ccr={toc:[]},xcr="wrapper";function Acr(e){let{components:n,...t}=e;return(0,s.yg)(xcr,(0,p.A)({},Ccr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}Acr.isMDXComponent=!0;const vcr={toc:[]},Lcr="wrapper";function bcr(e){let{components:n,...t}=e;return(0,s.yg)(Lcr,(0,p.A)({},vcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}bcr.isMDXComponent=!0;const Ncr={toc:[]},kcr="wrapper";function zcr(e){let{components:n,...t}=e;return(0,s.yg)(kcr,(0,p.A)({},Ncr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}zcr.isMDXComponent=!0;const Pcr={toc:[]},Icr="wrapper";function Rcr(e){let{components:n,...t}=e;return(0,s.yg)(Icr,(0,p.A)({},Pcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Rcr.isMDXComponent=!0;const Wcr={toc:[]},Scr="wrapper";function Bcr(e){let{components:n,...t}=e;return(0,s.yg)(Scr,(0,p.A)({},Wcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Bcr.isMDXComponent=!0;const Ecr={toc:[]},Gcr="wrapper";function Ocr(e){let{components:n,...t}=e;return(0,s.yg)(Gcr,(0,p.A)({},Ecr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}Ocr.isMDXComponent=!0;const Ucr={toc:[]},Fcr="wrapper";function Vcr(e){let{components:n,...t}=e;return(0,s.yg)(Fcr,(0,p.A)({},Ucr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Vcr.isMDXComponent=!0;const qcr={toc:[]},jcr="wrapper";function Hcr(e){let{components:n,...t}=e;return(0,s.yg)(jcr,(0,p.A)({},qcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}Hcr.isMDXComponent=!0;const Ycr={toc:[]},Qcr="wrapper";function $cr(e){let{components:n,...t}=e;return(0,s.yg)(Qcr,(0,p.A)({},Ycr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}$cr.isMDXComponent=!0;const Kcr={toc:[]},Jcr="wrapper";function Zcr(e){let{components:n,...t}=e;return(0,s.yg)(Jcr,(0,p.A)({},Kcr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}Zcr.isMDXComponent=!0;const ear={toc:[]},nar="wrapper";function tar(e){let{components:n,...t}=e;return(0,s.yg)(nar,(0,p.A)({},ear,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}tar.isMDXComponent=!0;const oar={toc:[]},par="wrapper";function rar(e){let{components:n,...t}=e;return(0,s.yg)(par,(0,p.A)({},oar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}rar.isMDXComponent=!0;const sar={toc:[]},car="wrapper";function aar(e){let{components:n,...t}=e;return(0,s.yg)(car,(0,p.A)({},sar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}aar.isMDXComponent=!0;const iar={toc:[]},lar="wrapper";function uar(e){let{components:n,...t}=e;return(0,s.yg)(lar,(0,p.A)({},iar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}uar.isMDXComponent=!0;const mar={toc:[]},yar="wrapper";function dar(e){let{components:n,...t}=e;return(0,s.yg)(yar,(0,p.A)({},mar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}dar.isMDXComponent=!0;const har={toc:[]},gar="wrapper";function far(e){let{components:n,...t}=e;return(0,s.yg)(gar,(0,p.A)({},har,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}far.isMDXComponent=!0;const Dar={toc:[]},Mar="wrapper";function Xar(e){let{components:n,...t}=e;return(0,s.yg)(Mar,(0,p.A)({},Dar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Xar.isMDXComponent=!0;const _ar={toc:[]},war="wrapper";function Tar(e){let{components:n,...t}=e;return(0,s.yg)(war,(0,p.A)({},_ar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Tar.isMDXComponent=!0;const Car={toc:[]},xar="wrapper";function Aar(e){let{components:n,...t}=e;return(0,s.yg)(xar,(0,p.A)({},Car,t,{components:n,mdxType:"MDXLayout"}))}Aar.isMDXComponent=!0;const Lar={toc:[]},bar="wrapper";function Nar(e){let{components:n,...t}=e;return(0,s.yg)(bar,(0,p.A)({},Lar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Nar.isMDXComponent=!0;const kar={toc:[]},zar="wrapper";function Par(e){let{components:n,...t}=e;return(0,s.yg)(zar,(0,p.A)({},kar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}Par.isMDXComponent=!0;const Iar={toc:[]},Rar="wrapper";function War(e){let{components:n,...t}=e;return(0,s.yg)(Rar,(0,p.A)({},Iar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}War.isMDXComponent=!0;const Sar={toc:[]},Bar="wrapper";function Ear(e){let{components:n,...t}=e;return(0,s.yg)(Bar,(0,p.A)({},Sar,t,{components:n,mdxType:"MDXLayout"}))}Ear.isMDXComponent=!0;const Gar={toc:[]},Oar="wrapper";function Uar(e){let{components:n,...t}=e;return(0,s.yg)(Oar,(0,p.A)({},Gar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}Uar.isMDXComponent=!0;const Far={toc:[]},Var="wrapper";function qar(e){let{components:n,...t}=e;return(0,s.yg)(Var,(0,p.A)({},Far,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}qar.isMDXComponent=!0;const jar={toc:[]},Har="wrapper";function Yar(e){let{components:n,...t}=e;return(0,s.yg)(Har,(0,p.A)({},jar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Yar.isMDXComponent=!0;const Qar={toc:[]},$ar="wrapper";function Kar(e){let{components:n,...t}=e;return(0,s.yg)($ar,(0,p.A)({},Qar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Kar.isMDXComponent=!0;const Jar={toc:[]},Zar="wrapper";function eir(e){let{components:n,...t}=e;return(0,s.yg)(Zar,(0,p.A)({},Jar,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/RectProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}eir.isMDXComponent=!0;const nir={toc:[]},tir="wrapper";function oir(e){let{components:n,...t}=e;return(0,s.yg)(tir,(0,p.A)({},nir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}oir.isMDXComponent=!0;const pir={toc:[]},rir="wrapper";function sir(e){let{components:n,...t}=e;return(0,s.yg)(rir,(0,p.A)({},pir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}sir.isMDXComponent=!0;const cir={toc:[]},air="wrapper";function iir(e){let{components:n,...t}=e;return(0,s.yg)(air,(0,p.A)({},cir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}iir.isMDXComponent=!0;const lir={toc:[]},uir="wrapper";function mir(e){let{components:n,...t}=e;return(0,s.yg)(uir,(0,p.A)({},lir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}mir.isMDXComponent=!0;const yir={toc:[]},dir="wrapper";function hir(e){let{components:n,...t}=e;return(0,s.yg)(dir,(0,p.A)({},yir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}hir.isMDXComponent=!0;const gir={toc:[]},fir="wrapper";function Dir(e){let{components:n,...t}=e;return(0,s.yg)(fir,(0,p.A)({},gir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Dir.isMDXComponent=!0;const Mir={toc:[]},Xir="wrapper";function _ir(e){let{components:n,...t}=e;return(0,s.yg)(Xir,(0,p.A)({},Mir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}_ir.isMDXComponent=!0;const wir={toc:[]},Tir="wrapper";function Cir(e){let{components:n,...t}=e;return(0,s.yg)(Tir,(0,p.A)({},wir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represent SVG document that contains SVG shapes.\nThis only used single time because ",(0,s.yg)("inlineCode",{parentName:"p"},"nodes")," have reference to parent SVG renderer."))}Cir.isMDXComponent=!0;const xir={toc:[]},Air="wrapper";function vir(e){let{components:n,...t}=e;return(0,s.yg)(Air,(0,p.A)({},xir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Data of SVGDocument.\nThis can used many times because it do not reference parent SVG.\nThis must build into SVGDocument"))}vir.isMDXComponent=!0;const Lir={toc:[]},bir="wrapper";function Nir(e){let{components:n,...t}=e;return(0,s.yg)(bir,(0,p.A)({},Lir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Nir.isMDXComponent=!0;const kir={toc:[]},zir="wrapper";function Pir(e){let{components:n,...t}=e;return(0,s.yg)(zir,(0,p.A)({},kir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Pir.isMDXComponent=!0;const Iir={toc:[]},Rir="wrapper";function Wir(e){let{components:n,...t}=e;return(0,s.yg)(Rir,(0,p.A)({},Iir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Wir.isMDXComponent=!0;const Sir={toc:[]},Bir="wrapper";function Eir(e){let{components:n,...t}=e;return(0,s.yg)(Bir,(0,p.A)({},Sir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Eir.isMDXComponent=!0;const Gir={toc:[]},Oir="wrapper";function Uir(e){let{components:n,...t}=e;return(0,s.yg)(Oir,(0,p.A)({},Gir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Uir.isMDXComponent=!0;const Fir={toc:[]},Vir="wrapper";function qir(e){let{components:n,...t}=e;return(0,s.yg)(Vir,(0,p.A)({},Fir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}qir.isMDXComponent=!0;const jir={toc:[]},Hir="wrapper";function Yir(e){let{components:n,...t}=e;return(0,s.yg)(Hir,(0,p.A)({},jir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Yir.isMDXComponent=!0;const Qir={toc:[]},$ir="wrapper";function Kir(e){let{components:n,...t}=e;return(0,s.yg)($ir,(0,p.A)({},Qir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Kir.isMDXComponent=!0;const Jir={toc:[]},Zir="wrapper";function elr(e){let{components:n,...t}=e;return(0,s.yg)(Zir,(0,p.A)({},Jir,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}elr.isMDXComponent=!0;const nlr={toc:[]},tlr="wrapper";function olr(e){let{components:n,...t}=e;return(0,s.yg)(tlr,(0,p.A)({},nlr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}olr.isMDXComponent=!0;const plr={toc:[]},rlr="wrapper";function slr(e){let{components:n,...t}=e;return(0,s.yg)(rlr,(0,p.A)({},plr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}slr.isMDXComponent=!0;const clr={toc:[]},alr="wrapper";function ilr(e){let{components:n,...t}=e;return(0,s.yg)(alr,(0,p.A)({},clr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}ilr.isMDXComponent=!0;const llr={toc:[]},ulr="wrapper";function mlr(e){let{components:n,...t}=e;return(0,s.yg)(ulr,(0,p.A)({},llr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}mlr.isMDXComponent=!0;const ylr={toc:[]},dlr="wrapper";function hlr(e){let{components:n,...t}=e;return(0,s.yg)(dlr,(0,p.A)({},ylr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}hlr.isMDXComponent=!0;const glr={toc:[]},flr="wrapper";function Dlr(e){let{components:n,...t}=e;return(0,s.yg)(flr,(0,p.A)({},glr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Dlr.isMDXComponent=!0;const Mlr={toc:[]},Xlr="wrapper";function _lr(e){let{components:n,...t}=e;return(0,s.yg)(Xlr,(0,p.A)({},Mlr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}_lr.isMDXComponent=!0;const wlr={toc:[]},Tlr="wrapper";function Clr(e){let{components:n,...t}=e;return(0,s.yg)(Tlr,(0,p.A)({},wlr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Clr.isMDXComponent=!0;const xlr={toc:[]},Alr="wrapper";function vlr(e){let{components:n,...t}=e;return(0,s.yg)(Alr,(0,p.A)({},xlr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}vlr.isMDXComponent=!0;const Llr={toc:[]},blr="wrapper";function Nlr(e){let{components:n,...t}=e;return(0,s.yg)(blr,(0,p.A)({},Llr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVGProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}Nlr.isMDXComponent=!0;const klr={toc:[]},zlr="wrapper";function Plr(e){let{components:n,...t}=e;return(0,s.yg)(zlr,(0,p.A)({},klr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Plr.isMDXComponent=!0;const Ilr={toc:[]},Rlr="wrapper";function Wlr(e){let{components:n,...t}=e;return(0,s.yg)(Rlr,(0,p.A)({},Ilr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Wlr.isMDXComponent=!0;const Slr={toc:[]},Blr="wrapper";function Elr(e){let{components:n,...t}=e;return(0,s.yg)(Blr,(0,p.A)({},Slr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Elr.isMDXComponent=!0;const Glr={toc:[]},Olr="wrapper";function Ulr(e){let{components:n,...t}=e;return(0,s.yg)(Olr,(0,p.A)({},Glr,t,{components:n,mdxType:"MDXLayout"}))}Ulr.isMDXComponent=!0;const Flr={toc:[]},Vlr="wrapper";function qlr(e){let{components:n,...t}=e;return(0,s.yg)(Vlr,(0,p.A)({},Flr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SVGProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}qlr.isMDXComponent=!0;const jlr={toc:[]},Hlr="wrapper";function Ylr(e){let{components:n,...t}=e;return(0,s.yg)(Hlr,(0,p.A)({},jlr,t,{components:n,mdxType:"MDXLayout"}))}Ylr.isMDXComponent=!0;const Qlr={toc:[]},$lr="wrapper";function Klr(e){let{components:n,...t}=e;return(0,s.yg)($lr,(0,p.A)({},Qlr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Klr.isMDXComponent=!0;const Jlr={toc:[]},Zlr="wrapper";function eur(e){let{components:n,...t}=e;return(0,s.yg)(Zlr,(0,p.A)({},Jlr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}eur.isMDXComponent=!0;const nur={toc:[]},tur="wrapper";function our(e){let{components:n,...t}=e;return(0,s.yg)(tur,(0,p.A)({},nur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}our.isMDXComponent=!0;const pur={toc:[]},rur="wrapper";function sur(e){let{components:n,...t}=e;return(0,s.yg)(rur,(0,p.A)({},pur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}sur.isMDXComponent=!0;const cur={toc:[]},aur="wrapper";function iur(e){let{components:n,...t}=e;return(0,s.yg)(aur,(0,p.A)({},cur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}iur.isMDXComponent=!0;const lur={toc:[]},uur="wrapper";function mur(e){let{components:n,...t}=e;return(0,s.yg)(uur,(0,p.A)({},lur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}mur.isMDXComponent=!0;const yur={toc:[]},dur="wrapper";function hur(e){let{components:n,...t}=e;return(0,s.yg)(dur,(0,p.A)({},yur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represent SVG shape.\nThis only used single time because ",(0,s.yg)("inlineCode",{parentName:"p"},"node")," may have reference to parent SVG renderer."))}hur.isMDXComponent=!0;const gur={toc:[]},fur="wrapper";function Dur(e){let{components:n,...t}=e;return(0,s.yg)(fur,(0,p.A)({},gur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Data of SVGShape.\nThis can used many times  because it do not reference parent SVG.\nThis must build into SVGShape"))}Dur.isMDXComponent=!0;const Mur={toc:[]},Xur="wrapper";function _ur(e){let{components:n,...t}=e;return(0,s.yg)(Xur,(0,p.A)({},Mur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}_ur.isMDXComponent=!0;const wur={toc:[]},Tur="wrapper";function Cur(e){let{components:n,...t}=e;return(0,s.yg)(Tur,(0,p.A)({},wur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Cur.isMDXComponent=!0;const xur={toc:[]},Aur="wrapper";function vur(e){let{components:n,...t}=e;return(0,s.yg)(Aur,(0,p.A)({},xur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}vur.isMDXComponent=!0;const Lur={toc:[]},bur="wrapper";function Nur(e){let{components:n,...t}=e;return(0,s.yg)(bur,(0,p.A)({},Lur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}Nur.isMDXComponent=!0;const kur={toc:[]},zur="wrapper";function Pur(e){let{components:n,...t}=e;return(0,s.yg)(zur,(0,p.A)({},kur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Pur.isMDXComponent=!0;const Iur={toc:[]},Rur="wrapper";function Wur(e){let{components:n,...t}=e;return(0,s.yg)(Rur,(0,p.A)({},Iur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}Wur.isMDXComponent=!0;const Sur={toc:[]},Bur="wrapper";function Eur(e){let{components:n,...t}=e;return(0,s.yg)(Bur,(0,p.A)({},Sur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Eur.isMDXComponent=!0;const Gur={toc:[]},Our="wrapper";function Uur(e){let{components:n,...t}=e;return(0,s.yg)(Our,(0,p.A)({},Gur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Uur.isMDXComponent=!0;const Fur={toc:[]},Vur="wrapper";function qur(e){let{components:n,...t}=e;return(0,s.yg)(Vur,(0,p.A)({},Fur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}qur.isMDXComponent=!0;const jur={toc:[]},Hur="wrapper";function Yur(e){let{components:n,...t}=e;return(0,s.yg)(Hur,(0,p.A)({},jur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Yur.isMDXComponent=!0;const Qur={toc:[]},$ur="wrapper";function Kur(e){let{components:n,...t}=e;return(0,s.yg)($ur,(0,p.A)({},Qur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Kur.isMDXComponent=!0;const Jur={toc:[]},Zur="wrapper";function emr(e){let{components:n,...t}=e;return(0,s.yg)(Zur,(0,p.A)({},Jur,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}emr.isMDXComponent=!0;const nmr={toc:[]},tmr="wrapper";function omr(e){let{components:n,...t}=e;return(0,s.yg)(tmr,(0,p.A)({},nmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}omr.isMDXComponent=!0;const pmr={toc:[]},rmr="wrapper";function smr(e){let{components:n,...t}=e;return(0,s.yg)(rmr,(0,p.A)({},pmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}smr.isMDXComponent=!0;const cmr={toc:[]},amr="wrapper";function imr(e){let{components:n,...t}=e;return(0,s.yg)(amr,(0,p.A)({},cmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}imr.isMDXComponent=!0;const lmr={toc:[]},umr="wrapper";function mmr(e){let{components:n,...t}=e;return(0,s.yg)(umr,(0,p.A)({},lmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}mmr.isMDXComponent=!0;const ymr={toc:[]},dmr="wrapper";function hmr(e){let{components:n,...t}=e;return(0,s.yg)(dmr,(0,p.A)({},ymr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}hmr.isMDXComponent=!0;const gmr={toc:[]},fmr="wrapper";function Dmr(e){let{components:n,...t}=e;return(0,s.yg)(fmr,(0,p.A)({},gmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Dmr.isMDXComponent=!0;const Mmr={toc:[]},Xmr="wrapper";function _mr(e){let{components:n,...t}=e;return(0,s.yg)(Xmr,(0,p.A)({},Mmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}_mr.isMDXComponent=!0;const wmr={toc:[]},Tmr="wrapper";function Cmr(e){let{components:n,...t}=e;return(0,s.yg)(Tmr,(0,p.A)({},wmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Cmr.isMDXComponent=!0;const xmr={toc:[]},Amr="wrapper";function vmr(e){let{components:n,...t}=e;return(0,s.yg)(Amr,(0,p.A)({},xmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}vmr.isMDXComponent=!0;const Lmr={toc:[]},bmr="wrapper";function Nmr(e){let{components:n,...t}=e;return(0,s.yg)(bmr,(0,p.A)({},Lmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Nmr.isMDXComponent=!0;const kmr={toc:[]},zmr="wrapper";function Pmr(e){let{components:n,...t}=e;return(0,s.yg)(zmr,(0,p.A)({},kmr,t,{components:n,mdxType:"MDXLayout"}))}Pmr.isMDXComponent=!0;const Imr={toc:[]},Rmr="wrapper";function Wmr(e){let{components:n,...t}=e;return(0,s.yg)(Rmr,(0,p.A)({},Imr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}Wmr.isMDXComponent=!0;const Smr={toc:[]},Bmr="wrapper";function Emr(e){let{components:n,...t}=e;return(0,s.yg)(Bmr,(0,p.A)({},Smr,t,{components:n,mdxType:"MDXLayout"}))}Emr.isMDXComponent=!0;const Gmr={toc:[]},Omr="wrapper";function Umr(e){let{components:n,...t}=e;return(0,s.yg)(Omr,(0,p.A)({},Gmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Umr.isMDXComponent=!0;const Fmr={toc:[]},Vmr="wrapper";function qmr(e){let{components:n,...t}=e;return(0,s.yg)(Vmr,(0,p.A)({},Fmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}qmr.isMDXComponent=!0;const jmr={toc:[]},Hmr="wrapper";function Ymr(e){let{components:n,...t}=e;return(0,s.yg)(Hmr,(0,p.A)({},jmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Ymr.isMDXComponent=!0;const Qmr={toc:[]},$mr="wrapper";function Kmr(e){let{components:n,...t}=e;return(0,s.yg)($mr,(0,p.A)({},Qmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Kmr.isMDXComponent=!0;const Jmr={toc:[]},Zmr="wrapper";function eyr(e){let{components:n,...t}=e;return(0,s.yg)(Zmr,(0,p.A)({},Jmr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}eyr.isMDXComponent=!0;const nyr={toc:[]},tyr="wrapper";function oyr(e){let{components:n,...t}=e;return(0,s.yg)(tyr,(0,p.A)({},nyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}oyr.isMDXComponent=!0;const pyr={toc:[]},ryr="wrapper";function syr(e){let{components:n,...t}=e;return(0,s.yg)(ryr,(0,p.A)({},pyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}syr.isMDXComponent=!0;const cyr={toc:[]},ayr="wrapper";function iyr(e){let{components:n,...t}=e;return(0,s.yg)(ayr,(0,p.A)({},cyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}iyr.isMDXComponent=!0;const lyr={toc:[]},uyr="wrapper";function myr(e){let{components:n,...t}=e;return(0,s.yg)(uyr,(0,p.A)({},lyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}myr.isMDXComponent=!0;const yyr={toc:[]},dyr="wrapper";function hyr(e){let{components:n,...t}=e;return(0,s.yg)(dyr,(0,p.A)({},yyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}hyr.isMDXComponent=!0;const gyr={toc:[]},fyr="wrapper";function Dyr(e){let{components:n,...t}=e;return(0,s.yg)(fyr,(0,p.A)({},gyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Dyr.isMDXComponent=!0;const Myr={toc:[]},Xyr="wrapper";function _yr(e){let{components:n,...t}=e;return(0,s.yg)(Xyr,(0,p.A)({},Myr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}_yr.isMDXComponent=!0;const wyr={toc:[]},Tyr="wrapper";function Cyr(e){let{components:n,...t}=e;return(0,s.yg)(Tyr,(0,p.A)({},wyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Cyr.isMDXComponent=!0;const xyr={toc:[]},Ayr="wrapper";function vyr(e){let{components:n,...t}=e;return(0,s.yg)(Ayr,(0,p.A)({},xyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}vyr.isMDXComponent=!0;const Lyr={toc:[]},byr="wrapper";function Nyr(e){let{components:n,...t}=e;return(0,s.yg)(byr,(0,p.A)({},Lyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Nyr.isMDXComponent=!0;const kyr={toc:[]},zyr="wrapper";function Pyr(e){let{components:n,...t}=e;return(0,s.yg)(zyr,(0,p.A)({},kyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Pyr.isMDXComponent=!0;const Iyr={toc:[]},Ryr="wrapper";function Wyr(e){let{components:n,...t}=e;return(0,s.yg)(Ryr,(0,p.A)({},Iyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Wyr.isMDXComponent=!0;const Syr={toc:[]},Byr="wrapper";function Eyr(e){let{components:n,...t}=e;return(0,s.yg)(Byr,(0,p.A)({},Syr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Eyr.isMDXComponent=!0;const Gyr={toc:[]},Oyr="wrapper";function Uyr(e){let{components:n,...t}=e;return(0,s.yg)(Oyr,(0,p.A)({},Gyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Uyr.isMDXComponent=!0;const Fyr={toc:[]},Vyr="wrapper";function qyr(e){let{components:n,...t}=e;return(0,s.yg)(Vyr,(0,p.A)({},Fyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}qyr.isMDXComponent=!0;const jyr={toc:[]},Hyr="wrapper";function Yyr(e){let{components:n,...t}=e;return(0,s.yg)(Hyr,(0,p.A)({},jyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Yyr.isMDXComponent=!0;const Qyr={toc:[]},$yr="wrapper";function Kyr(e){let{components:n,...t}=e;return(0,s.yg)($yr,(0,p.A)({},Qyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Kyr.isMDXComponent=!0;const Jyr={toc:[]},Zyr="wrapper";function edr(e){let{components:n,...t}=e;return(0,s.yg)(Zyr,(0,p.A)({},Jyr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}edr.isMDXComponent=!0;const ndr={toc:[]},tdr="wrapper";function odr(e){let{components:n,...t}=e;return(0,s.yg)(tdr,(0,p.A)({},ndr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}odr.isMDXComponent=!0;const pdr={toc:[]},rdr="wrapper";function sdr(e){let{components:n,...t}=e;return(0,s.yg)(rdr,(0,p.A)({},pdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}sdr.isMDXComponent=!0;const cdr={toc:[]},adr="wrapper";function idr(e){let{components:n,...t}=e;return(0,s.yg)(adr,(0,p.A)({},cdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}idr.isMDXComponent=!0;const ldr={toc:[]},udr="wrapper";function mdr(e){let{components:n,...t}=e;return(0,s.yg)(udr,(0,p.A)({},ldr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}mdr.isMDXComponent=!0;const ydr={toc:[]},ddr="wrapper";function hdr(e){let{components:n,...t}=e;return(0,s.yg)(ddr,(0,p.A)({},ydr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}hdr.isMDXComponent=!0;const gdr={toc:[]},fdr="wrapper";function Ddr(e){let{components:n,...t}=e;return(0,s.yg)(fdr,(0,p.A)({},gdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Ddr.isMDXComponent=!0;const Mdr={toc:[]},Xdr="wrapper";function _dr(e){let{components:n,...t}=e;return(0,s.yg)(Xdr,(0,p.A)({},Mdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}_dr.isMDXComponent=!0;const wdr={toc:[]},Tdr="wrapper";function Cdr(e){let{components:n,...t}=e;return(0,s.yg)(Tdr,(0,p.A)({},wdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Cdr.isMDXComponent=!0;const xdr={toc:[]},Adr="wrapper";function vdr(e){let{components:n,...t}=e;return(0,s.yg)(Adr,(0,p.A)({},xdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}vdr.isMDXComponent=!0;const Ldr={toc:[]},bdr="wrapper";function Ndr(e){let{components:n,...t}=e;return(0,s.yg)(bdr,(0,p.A)({},Ldr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Ndr.isMDXComponent=!0;const kdr={toc:[]},zdr="wrapper";function Pdr(e){let{components:n,...t}=e;return(0,s.yg)(zdr,(0,p.A)({},kdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Pdr.isMDXComponent=!0;const Idr={toc:[]},Rdr="wrapper";function Wdr(e){let{components:n,...t}=e;return(0,s.yg)(Rdr,(0,p.A)({},Idr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}Wdr.isMDXComponent=!0;const Sdr={toc:[]},Bdr="wrapper";function Edr(e){let{components:n,...t}=e;return(0,s.yg)(Bdr,(0,p.A)({},Sdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Edr.isMDXComponent=!0;const Gdr={toc:[]},Odr="wrapper";function Udr(e){let{components:n,...t}=e;return(0,s.yg)(Odr,(0,p.A)({},Gdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"You can control the smoothness of the resulting curve\nvia the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#smoothness"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothness"))," property."))}Udr.isMDXComponent=!0;const Fdr={toc:[]},Vdr="wrapper";function qdr(e){let{components:n,...t}=e;return(0,s.yg)(Vdr,(0,p.A)({},Fdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The knots of the spline as an array of knots with auto-calculated handles."))}qdr.isMDXComponent=!0;const jdr={toc:[]},Hdr="wrapper";function Ydr(e){let{components:n,...t}=e;return(0,s.yg)(Hdr,(0,p.A)({},jdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Ydr.isMDXComponent=!0;const Qdr={toc:[]},$dr="wrapper";function Kdr(e){let{components:n,...t}=e;return(0,s.yg)($dr,(0,p.A)({},Qdr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}Kdr.isMDXComponent=!0;const Jdr={toc:[]},Zdr="wrapper";function ehr(e){let{components:n,...t}=e;return(0,s.yg)(Zdr,(0,p.A)({},Jdr,t,{components:n,mdxType:"MDXLayout"}))}ehr.isMDXComponent=!0;const nhr={toc:[]},thr="wrapper";function ohr(e){let{components:n,...t}=e;return(0,s.yg)(thr,(0,p.A)({},nhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property is only applied to knots that don't use explicit handles."))}ohr.isMDXComponent=!0;const phr={toc:[]},rhr="wrapper";function shr(e){let{components:n,...t}=e;return(0,s.yg)(rhr,(0,p.A)({},phr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The smoothness of the spline when using auto-calculated handles."))}shr.isMDXComponent=!0;const chr={toc:[]},ahr="wrapper";function ihr(e){let{components:n,...t}=e;return(0,s.yg)(ahr,(0,p.A)({},chr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}ihr.isMDXComponent=!0;const lhr={toc:[]},uhr="wrapper";function mhr(e){let{components:n,...t}=e;return(0,s.yg)(uhr,(0,p.A)({},lhr,t,{components:n,mdxType:"MDXLayout"}))}mhr.isMDXComponent=!0;const yhr={toc:[]},dhr="wrapper";function hhr(e){let{components:n,...t}=e;return(0,s.yg)(dhr,(0,p.A)({},yhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}hhr.isMDXComponent=!0;const ghr={toc:[]},fhr="wrapper";function Dhr(e){let{components:n,...t}=e;return(0,s.yg)(fhr,(0,p.A)({},ghr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}Dhr.isMDXComponent=!0;const Mhr={toc:[]},Xhr="wrapper";function _hr(e){let{components:n,...t}=e;return(0,s.yg)(Xhr,(0,p.A)({},Mhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}_hr.isMDXComponent=!0;const whr={toc:[]},Thr="wrapper";function Chr(e){let{components:n,...t}=e;return(0,s.yg)(Thr,(0,p.A)({},whr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}Chr.isMDXComponent=!0;const xhr={toc:[]},Ahr="wrapper";function vhr(e){let{components:n,...t}=e;return(0,s.yg)(Ahr,(0,p.A)({},xhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/SplineProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}vhr.isMDXComponent=!0;const Lhr={toc:[]},bhr="wrapper";function Nhr(e){let{components:n,...t}=e;return(0,s.yg)(bhr,(0,p.A)({},Lhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}Nhr.isMDXComponent=!0;const khr={toc:[]},zhr="wrapper";function Phr(e){let{components:n,...t}=e;return(0,s.yg)(zhr,(0,p.A)({},khr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Phr.isMDXComponent=!0;const Ihr={toc:[]},Rhr="wrapper";function Whr(e){let{components:n,...t}=e;return(0,s.yg)(Rhr,(0,p.A)({},Ihr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}Whr.isMDXComponent=!0;const Shr={toc:[]},Bhr="wrapper";function Ehr(e){let{components:n,...t}=e;return(0,s.yg)(Bhr,(0,p.A)({},Shr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Ehr.isMDXComponent=!0;const Ghr={toc:[]},Ohr="wrapper";function Uhr(e){let{components:n,...t}=e;return(0,s.yg)(Ohr,(0,p.A)({},Ghr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}Uhr.isMDXComponent=!0;const Fhr={toc:[]},Vhr="wrapper";function qhr(e){let{components:n,...t}=e;return(0,s.yg)(Vhr,(0,p.A)({},Fhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}qhr.isMDXComponent=!0;const jhr={toc:[]},Hhr="wrapper";function Yhr(e){let{components:n,...t}=e;return(0,s.yg)(Hhr,(0,p.A)({},jhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Yhr.isMDXComponent=!0;const Qhr={toc:[]},$hr="wrapper";function Khr(e){let{components:n,...t}=e;return(0,s.yg)($hr,(0,p.A)({},Qhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Khr.isMDXComponent=!0;const Jhr={toc:[]},Zhr="wrapper";function egr(e){let{components:n,...t}=e;return(0,s.yg)(Zhr,(0,p.A)({},Jhr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}egr.isMDXComponent=!0;const ngr={toc:[]},tgr="wrapper";function ogr(e){let{components:n,...t}=e;return(0,s.yg)(tgr,(0,p.A)({},ngr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}ogr.isMDXComponent=!0;const pgr={toc:[]},rgr="wrapper";function sgr(e){let{components:n,...t}=e;return(0,s.yg)(rgr,(0,p.A)({},pgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}sgr.isMDXComponent=!0;const cgr={toc:[]},agr="wrapper";function igr(e){let{components:n,...t}=e;return(0,s.yg)(agr,(0,p.A)({},cgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}igr.isMDXComponent=!0;const lgr={toc:[]},ugr="wrapper";function mgr(e){let{components:n,...t}=e;return(0,s.yg)(ugr,(0,p.A)({},lgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}mgr.isMDXComponent=!0;const ygr={toc:[]},dgr="wrapper";function hgr(e){let{components:n,...t}=e;return(0,s.yg)(dgr,(0,p.A)({},ygr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}hgr.isMDXComponent=!0;const ggr={toc:[]},fgr="wrapper";function Dgr(e){let{components:n,...t}=e;return(0,s.yg)(fgr,(0,p.A)({},ggr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Dgr.isMDXComponent=!0;const Mgr={toc:[]},Xgr="wrapper";function _gr(e){let{components:n,...t}=e;return(0,s.yg)(Xgr,(0,p.A)({},Mgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}_gr.isMDXComponent=!0;const wgr={toc:[]},Tgr="wrapper";function Cgr(e){let{components:n,...t}=e;return(0,s.yg)(Tgr,(0,p.A)({},wgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Cgr.isMDXComponent=!0;const xgr={toc:[]},Agr="wrapper";function vgr(e){let{components:n,...t}=e;return(0,s.yg)(Agr,(0,p.A)({},xgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}vgr.isMDXComponent=!0;const Lgr={toc:[]},bgr="wrapper";function Ngr(e){let{components:n,...t}=e;return(0,s.yg)(bgr,(0,p.A)({},Lgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Ngr.isMDXComponent=!0;const kgr={toc:[]},zgr="wrapper";function Pgr(e){let{components:n,...t}=e;return(0,s.yg)(zgr,(0,p.A)({},kgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Pgr.isMDXComponent=!0;const Igr={toc:[]},Rgr="wrapper";function Wgr(e){let{components:n,...t}=e;return(0,s.yg)(Rgr,(0,p.A)({},Igr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Wgr.isMDXComponent=!0;const Sgr={toc:[]},Bgr="wrapper";function Egr(e){let{components:n,...t}=e;return(0,s.yg)(Bgr,(0,p.A)({},Sgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}Egr.isMDXComponent=!0;const Ggr={toc:[]},Ogr="wrapper";function Ugr(e){let{components:n,...t}=e;return(0,s.yg)(Ogr,(0,p.A)({},Ggr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}Ugr.isMDXComponent=!0;const Fgr={toc:[]},Vgr="wrapper";function qgr(e){let{components:n,...t}=e;return(0,s.yg)(Vgr,(0,p.A)({},Fgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}qgr.isMDXComponent=!0;const jgr={toc:[]},Hgr="wrapper";function Ygr(e){let{components:n,...t}=e;return(0,s.yg)(Hgr,(0,p.A)({},jgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}Ygr.isMDXComponent=!0;const Qgr={toc:[]},$gr="wrapper";function Kgr(e){let{components:n,...t}=e;return(0,s.yg)($gr,(0,p.A)({},Qgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/TxtProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}Kgr.isMDXComponent=!0;const Jgr={toc:[]},Zgr="wrapper";function efr(e){let{components:n,...t}=e;return(0,s.yg)(Zgr,(0,p.A)({},Jgr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}efr.isMDXComponent=!0;const nfr={toc:[]},tfr="wrapper";function ofr(e){let{components:n,...t}=e;return(0,s.yg)(tfr,(0,p.A)({},nfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}ofr.isMDXComponent=!0;const pfr={toc:[]},rfr="wrapper";function sfr(e){let{components:n,...t}=e;return(0,s.yg)(rfr,(0,p.A)({},pfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}sfr.isMDXComponent=!0;const cfr={toc:[]},afr="wrapper";function ifr(e){let{components:n,...t}=e;return(0,s.yg)(afr,(0,p.A)({},cfr,t,{components:n,mdxType:"MDXLayout"}))}ifr.isMDXComponent=!0;const lfr={toc:[]},ufr="wrapper";function mfr(e){let{components:n,...t}=e;return(0,s.yg)(ufr,(0,p.A)({},lfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/TxtProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}mfr.isMDXComponent=!0;const yfr={toc:[]},dfr="wrapper";function hfr(e){let{components:n,...t}=e;return(0,s.yg)(dfr,(0,p.A)({},yfr,t,{components:n,mdxType:"MDXLayout"}))}hfr.isMDXComponent=!0;const gfr={toc:[]},ffr="wrapper";function Dfr(e){let{components:n,...t}=e;return(0,s.yg)(ffr,(0,p.A)({},gfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Dfr.isMDXComponent=!0;const Mfr={toc:[]},Xfr="wrapper";function _fr(e){let{components:n,...t}=e;return(0,s.yg)(Xfr,(0,p.A)({},Mfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}_fr.isMDXComponent=!0;const wfr={toc:[]},Tfr="wrapper";function Cfr(e){let{components:n,...t}=e;return(0,s.yg)(Tfr,(0,p.A)({},wfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Cfr.isMDXComponent=!0;const xfr={toc:[]},Afr="wrapper";function vfr(e){let{components:n,...t}=e;return(0,s.yg)(Afr,(0,p.A)({},xfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}vfr.isMDXComponent=!0;const Lfr={toc:[]},bfr="wrapper";function Nfr(e){let{components:n,...t}=e;return(0,s.yg)(bfr,(0,p.A)({},Lfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Nfr.isMDXComponent=!0;const kfr={toc:[]},zfr="wrapper";function Pfr(e){let{components:n,...t}=e;return(0,s.yg)(zfr,(0,p.A)({},kfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}Pfr.isMDXComponent=!0;const Ifr={toc:[]},Rfr="wrapper";function Wfr(e){let{components:n,...t}=e;return(0,s.yg)(Rfr,(0,p.A)({},Ifr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}Wfr.isMDXComponent=!0;const Sfr={toc:[]},Bfr="wrapper";function Efr(e){let{components:n,...t}=e;return(0,s.yg)(Bfr,(0,p.A)({},Sfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The alpha value of this video."))}Efr.isMDXComponent=!0;const Gfr={toc:[]},Ofr="wrapper";function Ufr(e){let{components:n,...t}=e;return(0,s.yg)(Ofr,(0,p.A)({},Gfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}Ufr.isMDXComponent=!0;const Ffr={toc:[]},Vfr="wrapper";function qfr(e){let{components:n,...t}=e;return(0,s.yg)(Vfr,(0,p.A)({},Ffr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}qfr.isMDXComponent=!0;const jfr={toc:[]},Hfr="wrapper";function Yfr(e){let{components:n,...t}=e;return(0,s.yg)(Hfr,(0,p.A)({},jfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Yfr.isMDXComponent=!0;const Qfr={toc:[]},$fr="wrapper";function Kfr(e){let{components:n,...t}=e;return(0,s.yg)($fr,(0,p.A)({},Qfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}Kfr.isMDXComponent=!0;const Jfr={toc:[]},Zfr="wrapper";function eDr(e){let{components:n,...t}=e;return(0,s.yg)(Zfr,(0,p.A)({},Jfr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}eDr.isMDXComponent=!0;const nDr={toc:[]},tDr="wrapper";function oDr(e){let{components:n,...t}=e;return(0,s.yg)(tDr,(0,p.A)({},nDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}oDr.isMDXComponent=!0;const pDr={toc:[]},rDr="wrapper";function sDr(e){let{components:n,...t}=e;return(0,s.yg)(rDr,(0,p.A)({},pDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}sDr.isMDXComponent=!0;const cDr={toc:[]},aDr="wrapper";function iDr(e){let{components:n,...t}=e;return(0,s.yg)(aDr,(0,p.A)({},cDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}iDr.isMDXComponent=!0;const lDr={toc:[]},uDr="wrapper";function mDr(e){let{components:n,...t}=e;return(0,s.yg)(uDr,(0,p.A)({},lDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}mDr.isMDXComponent=!0;const yDr={toc:[]},dDr="wrapper";function hDr(e){let{components:n,...t}=e;return(0,s.yg)(dDr,(0,p.A)({},yDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}hDr.isMDXComponent=!0;const gDr={toc:[]},fDr="wrapper";function DDr(e){let{components:n,...t}=e;return(0,s.yg)(fDr,(0,p.A)({},gDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}DDr.isMDXComponent=!0;const MDr={toc:[]},XDr="wrapper";function _Dr(e){let{components:n,...t}=e;return(0,s.yg)(XDr,(0,p.A)({},MDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}_Dr.isMDXComponent=!0;const wDr={toc:[]},TDr="wrapper";function CDr(e){let{components:n,...t}=e;return(0,s.yg)(TDr,(0,p.A)({},wDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}CDr.isMDXComponent=!0;const xDr={toc:[]},ADr="wrapper";function vDr(e){let{components:n,...t}=e;return(0,s.yg)(ADr,(0,p.A)({},xDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}vDr.isMDXComponent=!0;const LDr={toc:[]},bDr="wrapper";function NDr(e){let{components:n,...t}=e;return(0,s.yg)(bDr,(0,p.A)({},LDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}NDr.isMDXComponent=!0;const kDr={toc:[]},zDr="wrapper";function PDr(e){let{components:n,...t}=e;return(0,s.yg)(zDr,(0,p.A)({},kDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}PDr.isMDXComponent=!0;const IDr={toc:[]},RDr="wrapper";function WDr(e){let{components:n,...t}=e;return(0,s.yg)(RDr,(0,p.A)({},IDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}WDr.isMDXComponent=!0;const SDr={toc:[]},BDr="wrapper";function EDr(e){let{components:n,...t}=e;return(0,s.yg)(BDr,(0,p.A)({},SDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}EDr.isMDXComponent=!0;const GDr={toc:[]},ODr="wrapper";function UDr(e){let{components:n,...t}=e;return(0,s.yg)(ODr,(0,p.A)({},GDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}UDr.isMDXComponent=!0;const FDr={toc:[]},VDr="wrapper";function qDr(e){let{components:n,...t}=e;return(0,s.yg)(VDr,(0,p.A)({},FDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}qDr.isMDXComponent=!0;const jDr={toc:[]},HDr="wrapper";function YDr(e){let{components:n,...t}=e;return(0,s.yg)(HDr,(0,p.A)({},jDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}YDr.isMDXComponent=!0;const QDr={toc:[]},$Dr="wrapper";function KDr(e){let{components:n,...t}=e;return(0,s.yg)($Dr,(0,p.A)({},QDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}KDr.isMDXComponent=!0;const JDr={toc:[]},ZDr="wrapper";function eMr(e){let{components:n,...t}=e;return(0,s.yg)(ZDr,(0,p.A)({},JDr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Which decoder to use during rendering. The ",(0,s.yg)("inlineCode",{parentName:"p"},"web")," decoder is the fastest\nbut only supports MP4 files. The ",(0,s.yg)("inlineCode",{parentName:"p"},"ffmpeg")," decoder is slower and more resource\nintensive but supports more formats. The ",(0,s.yg)("inlineCode",{parentName:"p"},"slow")," decoder is the slowest but\nsupports all formats."))}eMr.isMDXComponent=!0;const nMr={toc:[]},tMr="wrapper";function oMr(e){let{components:n,...t}=e;return(0,s.yg)(tMr,(0,p.A)({},nMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}oMr.isMDXComponent=!0;const pMr={toc:[]},rMr="wrapper";function sMr(e){let{components:n,...t}=e;return(0,s.yg)(rMr,(0,p.A)({},pMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}sMr.isMDXComponent=!0;const cMr={toc:[]},aMr="wrapper";function iMr(e){let{components:n,...t}=e;return(0,s.yg)(aMr,(0,p.A)({},cMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}iMr.isMDXComponent=!0;const lMr={toc:[]},uMr="wrapper";function mMr(e){let{components:n,...t}=e;return(0,s.yg)(uMr,(0,p.A)({},lMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}mMr.isMDXComponent=!0;const yMr={toc:[]},dMr="wrapper";function hMr(e){let{components:n,...t}=e;return(0,s.yg)(dMr,(0,p.A)({},yMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}hMr.isMDXComponent=!0;const gMr={toc:[]},fMr="wrapper";function DMr(e){let{components:n,...t}=e;return(0,s.yg)(fMr,(0,p.A)({},gMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}DMr.isMDXComponent=!0;const MMr={toc:[]},XMr="wrapper";function _Mr(e){let{components:n,...t}=e;return(0,s.yg)(XMr,(0,p.A)({},MMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}_Mr.isMDXComponent=!0;const wMr={toc:[]},TMr="wrapper";function CMr(e){let{components:n,...t}=e;return(0,s.yg)(TMr,(0,p.A)({},wMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}CMr.isMDXComponent=!0;const xMr={toc:[]},AMr="wrapper";function vMr(e){let{components:n,...t}=e;return(0,s.yg)(AMr,(0,p.A)({},xMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}vMr.isMDXComponent=!0;const LMr={toc:[]},bMr="wrapper";function NMr(e){let{components:n,...t}=e;return(0,s.yg)(bMr,(0,p.A)({},LMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}NMr.isMDXComponent=!0;const kMr={toc:[]},zMr="wrapper";function PMr(e){let{components:n,...t}=e;return(0,s.yg)(zMr,(0,p.A)({},kMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}PMr.isMDXComponent=!0;const IMr={toc:[]},RMr="wrapper";function WMr(e){let{components:n,...t}=e;return(0,s.yg)(RMr,(0,p.A)({},IMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}WMr.isMDXComponent=!0;const SMr={toc:[]},BMr="wrapper";function EMr(e){let{components:n,...t}=e;return(0,s.yg)(BMr,(0,p.A)({},SMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}EMr.isMDXComponent=!0;const GMr={toc:[]},OMr="wrapper";function UMr(e){let{components:n,...t}=e;return(0,s.yg)(OMr,(0,p.A)({},GMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}UMr.isMDXComponent=!0;const FMr={toc:[]},VMr="wrapper";function qMr(e){let{components:n,...t}=e;return(0,s.yg)(VMr,(0,p.A)({},FMr,t,{components:n,mdxType:"MDXLayout"}))}qMr.isMDXComponent=!0;const jMr={toc:[]},HMr="wrapper";function YMr(e){let{components:n,...t}=e;return(0,s.yg)(HMr,(0,p.A)({},jMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}YMr.isMDXComponent=!0;const QMr={toc:[]},$Mr="wrapper";function KMr(e){let{components:n,...t}=e;return(0,s.yg)($Mr,(0,p.A)({},QMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}KMr.isMDXComponent=!0;const JMr={toc:[]},ZMr="wrapper";function eXr(e){let{components:n,...t}=e;return(0,s.yg)(ZMr,(0,p.A)({},JMr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}eXr.isMDXComponent=!0;const nXr={toc:[]},tXr="wrapper";function oXr(e){let{components:n,...t}=e;return(0,s.yg)(tXr,(0,p.A)({},nXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the video should be smoothed."))}oXr.isMDXComponent=!0;const pXr={toc:[]},rXr="wrapper";function sXr(e){let{components:n,...t}=e;return(0,s.yg)(rXr,(0,p.A)({},pXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}sXr.isMDXComponent=!0;const cXr={toc:[]},aXr="wrapper";function iXr(e){let{components:n,...t}=e;return(0,s.yg)(aXr,(0,p.A)({},cXr,t,{components:n,mdxType:"MDXLayout"}))}iXr.isMDXComponent=!0;const lXr={toc:[]},uXr="wrapper";function mXr(e){let{components:n,...t}=e;return(0,s.yg)(uXr,(0,p.A)({},lXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}mXr.isMDXComponent=!0;const yXr={toc:[]},dXr="wrapper";function hXr(e){let{components:n,...t}=e;return(0,s.yg)(dXr,(0,p.A)({},yXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}hXr.isMDXComponent=!0;const gXr={toc:[]},fXr="wrapper";function DXr(e){let{components:n,...t}=e;return(0,s.yg)(fXr,(0,p.A)({},gXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}DXr.isMDXComponent=!0;const MXr={toc:[]},XXr="wrapper";function _Xr(e){let{components:n,...t}=e;return(0,s.yg)(XXr,(0,p.A)({},MXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}_Xr.isMDXComponent=!0;const wXr={toc:[]},TXr="wrapper";function CXr(e){let{components:n,...t}=e;return(0,s.yg)(TXr,(0,p.A)({},wXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/VideoProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}CXr.isMDXComponent=!0;const xXr={toc:[]},AXr="wrapper";function vXr(e){let{components:n,...t}=e;return(0,s.yg)(AXr,(0,p.A)({},xXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}vXr.isMDXComponent=!0;const LXr={toc:[]},bXr="wrapper";function NXr(e){let{components:n,...t}=e;return(0,s.yg)(bXr,(0,p.A)({},LXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}NXr.isMDXComponent=!0;const kXr={toc:[]},zXr="wrapper";function PXr(e){let{components:n,...t}=e;return(0,s.yg)(zXr,(0,p.A)({},kXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}PXr.isMDXComponent=!0;const IXr={toc:[]},RXr="wrapper";function WXr(e){let{components:n,...t}=e;return(0,s.yg)(RXr,(0,p.A)({},IXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}WXr.isMDXComponent=!0;const SXr={toc:[]},BXr="wrapper";function EXr(e){let{components:n,...t}=e;return(0,s.yg)(BXr,(0,p.A)({},SXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}EXr.isMDXComponent=!0;const GXr={toc:[]},OXr="wrapper";function UXr(e){let{components:n,...t}=e;return(0,s.yg)(OXr,(0,p.A)({},GXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}UXr.isMDXComponent=!0;const FXr={toc:[]},VXr="wrapper";function qXr(e){let{components:n,...t}=e;return(0,s.yg)(VXr,(0,p.A)({},FXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}qXr.isMDXComponent=!0;const jXr={toc:[]},HXr="wrapper";function YXr(e){let{components:n,...t}=e;return(0,s.yg)(HXr,(0,p.A)({},jXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"To make the arrows visible make sure to enable ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endArrow"},(0,s.yg)("inlineCode",{parentName:"a"},"endArrow")),"."))}YXr.isMDXComponent=!0;const QXr={toc:[]},$Xr="wrapper";function KXr(e){let{components:n,...t}=e;return(0,s.yg)($Xr,(0,p.A)({},QXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the size of the end and start arrows."))}KXr.isMDXComponent=!0;const JXr={toc:[]},ZXr="wrapper";function e_r(e){let{components:n,...t}=e;return(0,s.yg)(ZXr,(0,p.A)({},JXr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}e_r.isMDXComponent=!0;const n_r={toc:[]},t_r="wrapper";function o_r(e){let{components:n,...t}=e;return(0,s.yg)(t_r,(0,p.A)({},n_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom edge of this node."))}o_r.isMDXComponent=!0;const p_r={toc:[]},r_r="wrapper";function s_r(e){let{components:n,...t}=e;return(0,s.yg)(r_r,(0,p.A)({},p_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}s_r.isMDXComponent=!0;const c_r={toc:[]},a_r="wrapper";function i_r(e){let{components:n,...t}=e;return(0,s.yg)(a_r,(0,p.A)({},c_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom left corner of this node."))}i_r.isMDXComponent=!0;const l_r={toc:[]},u_r="wrapper";function m_r(e){let{components:n,...t}=e;return(0,s.yg)(u_r,(0,p.A)({},l_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}m_r.isMDXComponent=!0;const y_r={toc:[]},d_r="wrapper";function h_r(e){let{components:n,...t}=e;return(0,s.yg)(d_r,(0,p.A)({},y_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the bottom right corner of this node."))}h_r.isMDXComponent=!0;const g_r={toc:[]},f_r="wrapper";function D_r(e){let{components:n,...t}=e;return(0,s.yg)(f_r,(0,p.A)({},g_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}D_r.isMDXComponent=!0;const M_r={toc:[]},X_r="wrapper";function __r(e){let{components:n,...t}=e;return(0,s.yg)(X_r,(0,p.A)({},M_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}__r.isMDXComponent=!0;const w_r={toc:[]},T_r="wrapper";function C_r(e){let{components:n,...t}=e;return(0,s.yg)(T_r,(0,p.A)({},w_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}C_r.isMDXComponent=!0;const x_r={toc:[]},A_r="wrapper";function v_r(e){let{components:n,...t}=e;return(0,s.yg)(A_r,(0,p.A)({},x_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}v_r.isMDXComponent=!0;const L_r={toc:[]},b_r="wrapper";function N_r(e){let{components:n,...t}=e;return(0,s.yg)(b_r,(0,p.A)({},L_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}N_r.isMDXComponent=!0;const k_r={toc:[]},z_r="wrapper";function P_r(e){let{components:n,...t}=e;return(0,s.yg)(z_r,(0,p.A)({},k_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}P_r.isMDXComponent=!0;const I_r={toc:[]},R_r="wrapper";function W_r(e){let{components:n,...t}=e;return(0,s.yg)(R_r,(0,p.A)({},I_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}W_r.isMDXComponent=!0;const S_r={toc:[]},B_r="wrapper";function E_r(e){let{components:n,...t}=e;return(0,s.yg)(B_r,(0,p.A)({},S_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}E_r.isMDXComponent=!0;const G_r={toc:[]},O_r="wrapper";function U_r(e){let{components:n,...t}=e;return(0,s.yg)(O_r,(0,p.A)({},G_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.yg)("inlineCode",{parentName:"a"},"shaders")),"."))}U_r.isMDXComponent=!0;const F_r={toc:[]},V_r="wrapper";function q_r(e){let{components:n,...t}=e;return(0,s.yg)(V_r,(0,p.A)({},F_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the padding of the cached canvas used by this node."))}q_r.isMDXComponent=!0;const j_r={toc:[]},H_r="wrapper";function Y_r(e){let{components:n,...t}=e;return(0,s.yg)(H_r,(0,p.A)({},j_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Closed curves have their start and end points connected."))}Y_r.isMDXComponent=!0;const Q_r={toc:[]},$_r="wrapper";function K_r(e){let{components:n,...t}=e;return(0,s.yg)($_r,(0,p.A)({},Q_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the curve should be closed."))}K_r.isMDXComponent=!0;const J_r={toc:[]},Z_r="wrapper";function ewr(e){let{components:n,...t}=e;return(0,s.yg)(Z_r,(0,p.A)({},J_r,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"Requires ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}ewr.isMDXComponent=!0;const nwr={toc:[]},twr="wrapper";function owr(e){let{components:n,...t}=e;return(0,s.yg)(twr,(0,p.A)({},nwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Controls the sharpness of ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#smoothCorners"},(0,s.yg)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}owr.isMDXComponent=!0;const pwr={toc:[]},rwr="wrapper";function swr(e){let{components:n,...t}=e;return(0,s.yg)(rwr,(0,p.A)({},pwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}swr.isMDXComponent=!0;const cwr={toc:[]},awr="wrapper";function iwr(e){let{components:n,...t}=e;return(0,s.yg)(awr,(0,p.A)({},cwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start after which the curve should be clipped."))}iwr.isMDXComponent=!0;const lwr={toc:[]},uwr="wrapper";function mwr(e){let{components:n,...t}=e;return(0,s.yg)(uwr,(0,p.A)({},lwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}mwr.isMDXComponent=!0;const ywr={toc:[]},dwr="wrapper";function hwr(e){let{components:n,...t}=e;return(0,s.yg)(dwr,(0,p.A)({},ywr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the end of the visible curve."))}hwr.isMDXComponent=!0;const gwr={toc:[]},fwr="wrapper";function Dwr(e){let{components:n,...t}=e;return(0,s.yg)(fwr,(0,p.A)({},gwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#end"},(0,s.yg)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Dwr.isMDXComponent=!0;const Mwr={toc:[]},Xwr="wrapper";function _wr(e){let{components:n,...t}=e;return(0,s.yg)(Xwr,(0,p.A)({},Mwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the end of the curve."))}_wr.isMDXComponent=!0;const wwr={toc:[]},Twr="wrapper";function Cwr(e){let{components:n,...t}=e;return(0,s.yg)(Twr,(0,p.A)({},wwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Cwr.isMDXComponent=!0;const xwr={toc:[]},Awr="wrapper";function vwr(e){let{components:n,...t}=e;return(0,s.yg)(Awr,(0,p.A)({},xwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the left edge of this node."))}vwr.isMDXComponent=!0;const Lwr={toc:[]},bwr="wrapper";function Nwr(e){let{components:n,...t}=e;return(0,s.yg)(bwr,(0,p.A)({},Lwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#offset"},(0,s.yg)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position")),"."))}Nwr.isMDXComponent=!0;const kwr={toc:[]},zwr="wrapper";function Pwr(e){let{components:n,...t}=e;return(0,s.yg)(zwr,(0,p.A)({},kwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the center of this node."))}Pwr.isMDXComponent=!0;const Iwr={toc:[]},Rwr="wrapper";function Wwr(e){let{components:n,...t}=e;return(0,s.yg)(Rwr,(0,p.A)({},Iwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Wwr.isMDXComponent=!0;const Swr={toc:[]},Bwr="wrapper";function Ewr(e){let{components:n,...t}=e;return(0,s.yg)(Bwr,(0,p.A)({},Swr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Rounds the corners of this rectangle."))}Ewr.isMDXComponent=!0;const Gwr={toc:[]},Owr="wrapper";function Uwr(e){let{components:n,...t}=e;return(0,s.yg)(Owr,(0,p.A)({},Gwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}Uwr.isMDXComponent=!0;const Fwr={toc:[]},Vwr="wrapper";function qwr(e){let{components:n,...t}=e;return(0,s.yg)(Vwr,(0,p.A)({},Fwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the right edge of this node."))}qwr.isMDXComponent=!0;const jwr={toc:[]},Hwr="wrapper";function Ywr(e){let{components:n,...t}=e;return(0,s.yg)(Hwr,(0,p.A)({},jwr,t,{components:n,mdxType:"MDXLayout"}))}Ywr.isMDXComponent=!0;const Qwr={toc:[]},$wr="wrapper";function Kwr(e){let{components:n,...t}=e;return(0,s.yg)($wr,(0,p.A)({},Qwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#radius"},(0,s.yg)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.yg)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#cornerSharpness"},(0,s.yg)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.yg)("p",null,"You can read more about corner smoothing in\n",(0,s.yg)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Kwr.isMDXComponent=!0;const Jwr={toc:[]},Zwr="wrapper";function eTr(e){let{components:n,...t}=e;return(0,s.yg)(Zwr,(0,p.A)({},Jwr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Enables corner smoothing."))}eTr.isMDXComponent=!0;const nTr={toc:[]},tTr="wrapper";function oTr(e){let{components:n,...t}=e;return(0,s.yg)(tTr,(0,p.A)({},nTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#children"},(0,s.yg)("inlineCode",{parentName:"a"},"children"))," instead."))}oTr.isMDXComponent=!0;const pTr={toc:[]},rTr="wrapper";function sTr(e){let{components:n,...t}=e;return(0,s.yg)(rTr,(0,p.A)({},pTr,t,{components:n,mdxType:"MDXLayout"}))}sTr.isMDXComponent=!0;const cTr={toc:[]},aTr="wrapper";function iTr(e){let{components:n,...t}=e;return(0,s.yg)(aTr,(0,p.A)({},cTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.yg)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.yg)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.yg)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endOffset"},(0,s.yg)("inlineCode",{parentName:"a"},"endOffset")),")."))}iTr.isMDXComponent=!0;const lTr={toc:[]},uTr="wrapper";function mTr(e){let{components:n,...t}=e;return(0,s.yg)(uTr,(0,p.A)({},lTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A percentage from the start before which the curve should be clipped."))}mTr.isMDXComponent=!0;const yTr={toc:[]},dTr="wrapper";function hTr(e){let{components:n,...t}=e;return(0,s.yg)(dTr,(0,p.A)({},yTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#arrowSize"},(0,s.yg)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}hTr.isMDXComponent=!0;const gTr={toc:[]},fTr="wrapper";function DTr(e){let{components:n,...t}=e;return(0,s.yg)(fTr,(0,p.A)({},gTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether to display an arrow at the start of the visible curve."))}DTr.isMDXComponent=!0;const MTr={toc:[]},XTr="wrapper";function _Tr(e){let{components:n,...t}=e;return(0,s.yg)(XTr,(0,p.A)({},MTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.yg)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.yg)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/View2DProps#start"},(0,s.yg)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}_Tr.isMDXComponent=!0;const wTr={toc:[]},TTr="wrapper";function CTr(e){let{components:n,...t}=e;return(0,s.yg)(TTr,(0,p.A)({},wTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The offset in pixels from the start of the curve."))}CTr.isMDXComponent=!0;const xTr={toc:[]},ATr="wrapper";function vTr(e){let{components:n,...t}=e;return(0,s.yg)(ATr,(0,p.A)({},xTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}vTr.isMDXComponent=!0;const LTr={toc:[]},bTr="wrapper";function NTr(e){let{components:n,...t}=e;return(0,s.yg)(bTr,(0,p.A)({},LTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top edge of this node."))}NTr.isMDXComponent=!0;const kTr={toc:[]},zTr="wrapper";function PTr(e){let{components:n,...t}=e;return(0,s.yg)(zTr,(0,p.A)({},kTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}PTr.isMDXComponent=!0;const ITr={toc:[]},RTr="wrapper";function WTr(e){let{components:n,...t}=e;return(0,s.yg)(RTr,(0,p.A)({},ITr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top left corner of this node."))}WTr.isMDXComponent=!0;const STr={toc:[]},BTr="wrapper";function ETr(e){let{components:n,...t}=e;return(0,s.yg)(BTr,(0,p.A)({},STr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.yg)("inlineCode",{parentName:"a"},"position"))," property."))}ETr.isMDXComponent=!0;const GTr={toc:[]},OTr="wrapper";function UTr(e){let{components:n,...t}=e;return(0,s.yg)(OTr,(0,p.A)({},GTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The position of the top right corner of this node."))}UTr.isMDXComponent=!0;const FTr={toc:[]},VTr="wrapper";function qTr(e){let{components:n,...t}=e;return(0,s.yg)(VTr,(0,p.A)({},FTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A spline segment representing a cubic B\xe9zier curve."))}qTr.isMDXComponent=!0;const jTr={toc:[]},HTr="wrapper";function YTr(e){let{components:n,...t}=e;return(0,s.yg)(HTr,(0,p.A)({},jTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Evaluate the polynomial at the given t value."))}YTr.isMDXComponent=!0;const QTr={toc:[]},$Tr="wrapper";function KTr(e){let{components:n,...t}=e;return(0,s.yg)($Tr,(0,p.A)({},QTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The t value at which to evaluate the curve."))}KTr.isMDXComponent=!0;const JTr={toc:[]},ZTr="wrapper";function eCr(e){let{components:n,...t}=e;return(0,s.yg)(ZTr,(0,p.A)({},JTr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}eCr.isMDXComponent=!0;const nCr={toc:[]},tCr="wrapper";function oCr(e){let{components:n,...t}=e;return(0,s.yg)(tCr,(0,p.A)({},nCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The t value at which to evaluate the curve."))}oCr.isMDXComponent=!0;const pCr={toc:[]},rCr="wrapper";function sCr(e){let{components:n,...t}=e;return(0,s.yg)(rCr,(0,p.A)({},pCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A polynomial in the form ax^3 + bx^2 + cx + d up to a cubic polynomial."),(0,s.yg)("p",null,"Source code liberally taken from:\n",(0,s.yg)("a",{parentName:"p",href:"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs"},"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs")))}sCr.isMDXComponent=!0;const cCr={toc:[]},aCr="wrapper";function iCr(e){let{components:n,...t}=e;return(0,s.yg)(aCr,(0,p.A)({},cCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}iCr.isMDXComponent=!0;const lCr={toc:[]},uCr="wrapper";function mCr(e){let{components:n,...t}=e;return(0,s.yg)(uCr,(0,p.A)({},lCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}mCr.isMDXComponent=!0;const yCr={toc:[]},dCr="wrapper";function hCr(e){let{components:n,...t}=e;return(0,s.yg)(dCr,(0,p.A)({},yCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The linear coefficient"))}hCr.isMDXComponent=!0;const gCr={toc:[]},fCr="wrapper";function DCr(e){let{components:n,...t}=e;return(0,s.yg)(fCr,(0,p.A)({},gCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}DCr.isMDXComponent=!0;const MCr={toc:[]},XCr="wrapper";function _Cr(e){let{components:n,...t}=e;return(0,s.yg)(XCr,(0,p.A)({},MCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The linear coefficient"))}_Cr.isMDXComponent=!0;const wCr={toc:[]},TCr="wrapper";function CCr(e){let{components:n,...t}=e;return(0,s.yg)(TCr,(0,p.A)({},wCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The quadratic coefficient"))}CCr.isMDXComponent=!0;const xCr={toc:[]},ACr="wrapper";function vCr(e){let{components:n,...t}=e;return(0,s.yg)(ACr,(0,p.A)({},xCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}vCr.isMDXComponent=!0;const LCr={toc:[]},bCr="wrapper";function NCr(e){let{components:n,...t}=e;return(0,s.yg)(bCr,(0,p.A)({},LCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The linear coefficient"))}NCr.isMDXComponent=!0;const kCr={toc:[]},zCr="wrapper";function PCr(e){let{components:n,...t}=e;return(0,s.yg)(zCr,(0,p.A)({},kCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The quadratic coefficient"))}PCr.isMDXComponent=!0;const ICr={toc:[]},RCr="wrapper";function WCr(e){let{components:n,...t}=e;return(0,s.yg)(RCr,(0,p.A)({},ICr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The cubic coefficient"))}WCr.isMDXComponent=!0;const SCr={toc:[]},BCr="wrapper";function ECr(e){let{components:n,...t}=e;return(0,s.yg)(BCr,(0,p.A)({},SCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The degree of the polynomial"))}ECr.isMDXComponent=!0;const GCr={toc:[]},OCr="wrapper";function UCr(e){let{components:n,...t}=e;return(0,s.yg)(OCr,(0,p.A)({},GCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the nth derivative of the polynomial."))}UCr.isMDXComponent=!0;const FCr={toc:[]},VCr="wrapper";function qCr(e){let{components:n,...t}=e;return(0,s.yg)(VCr,(0,p.A)({},FCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The number of times to differentiate the polynomial."))}qCr.isMDXComponent=!0;const jCr={toc:[]},HCr="wrapper";function YCr(e){let{components:n,...t}=e;return(0,s.yg)(HCr,(0,p.A)({},jCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Evaluate the polynomial at the given value t."))}YCr.isMDXComponent=!0;const QCr={toc:[]},$Cr="wrapper";function KCr(e){let{components:n,...t}=e;return(0,s.yg)($Cr,(0,p.A)({},QCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value to sample at"))}KCr.isMDXComponent=!0;const JCr={toc:[]},ZCr="wrapper";function exr(e){let{components:n,...t}=e;return(0,s.yg)(ZCr,(0,p.A)({},JCr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Evaluate the nth derivative of the polynomial at the given value t."))}exr.isMDXComponent=!0;const nxr={toc:[]},txr="wrapper";function oxr(e){let{components:n,...t}=e;return(0,s.yg)(txr,(0,p.A)({},nxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value to sample at"))}oxr.isMDXComponent=!0;const pxr={toc:[]},rxr="wrapper";function sxr(e){let{components:n,...t}=e;return(0,s.yg)(rxr,(0,p.A)({},pxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The derivative of the polynomial to sample from"))}sxr.isMDXComponent=!0;const cxr={toc:[]},axr="wrapper";function ixr(e){let{components:n,...t}=e;return(0,s.yg)(axr,(0,p.A)({},cxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the local extrema of the polynomial."))}ixr.isMDXComponent=!0;const lxr={toc:[]},uxr="wrapper";function mxr(e){let{components:n,...t}=e;return(0,s.yg)(uxr,(0,p.A)({},lxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the local extrema of the polynomial in the unit interval."))}mxr.isMDXComponent=!0;const yxr={toc:[]},dxr="wrapper";function hxr(e){let{components:n,...t}=e;return(0,s.yg)(dxr,(0,p.A)({},yxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the output value range within the unit interval."))}hxr.isMDXComponent=!0;const gxr={toc:[]},fxr="wrapper";function Dxr(e){let{components:n,...t}=e;return(0,s.yg)(fxr,(0,p.A)({},gxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Depending on the degree of the polynomial, returns between 0 and 3 results."))}Dxr.isMDXComponent=!0;const Mxr={toc:[]},Xxr="wrapper";function _xr(e){let{components:n,...t}=e;return(0,s.yg)(Xxr,(0,p.A)({},Mxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the roots (values where this polynomial = 0)."))}_xr.isMDXComponent=!0;const wxr={toc:[]},Txr="wrapper";function Cxr(e){let{components:n,...t}=e;return(0,s.yg)(Txr,(0,p.A)({},wxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Split the polynomial into two polynomials of the same overall shape."))}Cxr.isMDXComponent=!0;const xxr={toc:[]},Axr="wrapper";function vxr(e){let{components:n,...t}=e;return(0,s.yg)(Axr,(0,p.A)({},xxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The point at which to split the polynomial."))}vxr.isMDXComponent=!0;const Lxr={toc:[]},bxr="wrapper";function Nxr(e){let{components:n,...t}=e;return(0,s.yg)(bxr,(0,p.A)({},Lxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Constructs a constant polynomial"))}Nxr.isMDXComponent=!0;const kxr={toc:[]},zxr="wrapper";function Pxr(e){let{components:n,...t}=e;return(0,s.yg)(zxr,(0,p.A)({},kxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}Pxr.isMDXComponent=!0;const Ixr={toc:[]},Rxr="wrapper";function Wxr(e){let{components:n,...t}=e;return(0,s.yg)(Rxr,(0,p.A)({},Ixr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Constructs a cubic polynomial"))}Wxr.isMDXComponent=!0;const Sxr={toc:[]},Bxr="wrapper";function Exr(e){let{components:n,...t}=e;return(0,s.yg)(Bxr,(0,p.A)({},Sxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}Exr.isMDXComponent=!0;const Gxr={toc:[]},Oxr="wrapper";function Uxr(e){let{components:n,...t}=e;return(0,s.yg)(Oxr,(0,p.A)({},Gxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The linear coefficient"))}Uxr.isMDXComponent=!0;const Fxr={toc:[]},Vxr="wrapper";function qxr(e){let{components:n,...t}=e;return(0,s.yg)(Vxr,(0,p.A)({},Fxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The quadratic coefficient"))}qxr.isMDXComponent=!0;const jxr={toc:[]},Hxr="wrapper";function Yxr(e){let{components:n,...t}=e;return(0,s.yg)(Hxr,(0,p.A)({},jxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The cubic coefficient"))}Yxr.isMDXComponent=!0;const Qxr={toc:[]},$xr="wrapper";function Kxr(e){let{components:n,...t}=e;return(0,s.yg)($xr,(0,p.A)({},Qxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Constructs a linear polynomial"))}Kxr.isMDXComponent=!0;const Jxr={toc:[]},Zxr="wrapper";function eAr(e){let{components:n,...t}=e;return(0,s.yg)(Zxr,(0,p.A)({},Jxr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}eAr.isMDXComponent=!0;const nAr={toc:[]},tAr="wrapper";function oAr(e){let{components:n,...t}=e;return(0,s.yg)(tAr,(0,p.A)({},nAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The linear coefficient"))}oAr.isMDXComponent=!0;const pAr={toc:[]},rAr="wrapper";function sAr(e){let{components:n,...t}=e;return(0,s.yg)(rAr,(0,p.A)({},pAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Constructs a quadratic polynomial"))}sAr.isMDXComponent=!0;const cAr={toc:[]},aAr="wrapper";function iAr(e){let{components:n,...t}=e;return(0,s.yg)(aAr,(0,p.A)({},cAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The constant coefficient"))}iAr.isMDXComponent=!0;const lAr={toc:[]},uAr="wrapper";function mAr(e){let{components:n,...t}=e;return(0,s.yg)(uAr,(0,p.A)({},lAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The linear coefficient"))}mAr.isMDXComponent=!0;const yAr={toc:[]},dAr="wrapper";function hAr(e){let{components:n,...t}=e;return(0,s.yg)(dAr,(0,p.A)({},yAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The quadratic coefficient"))}hAr.isMDXComponent=!0;const gAr={toc:[]},fAr="wrapper";function DAr(e){let{components:n,...t}=e;return(0,s.yg)(fAr,(0,p.A)({},gAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the tight axis-aligned bounds of the curve in the unit interval."))}DAr.isMDXComponent=!0;const MAr={toc:[]},XAr="wrapper";function _Ar(e){let{components:n,...t}=e;return(0,s.yg)(XAr,(0,p.A)({},MAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A spline segment representing a quadratic B\xe9zier curve."))}_Ar.isMDXComponent=!0;const wAr={toc:[]},TAr="wrapper";function CAr(e){let{components:n,...t}=e;return(0,s.yg)(TAr,(0,p.A)({},wAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Evaluate the polynomial at the given t value."))}CAr.isMDXComponent=!0;const xAr={toc:[]},AAr="wrapper";function vAr(e){let{components:n,...t}=e;return(0,s.yg)(AAr,(0,p.A)({},xAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The t value at which to evaluate the curve."))}vAr.isMDXComponent=!0;const LAr={toc:[]},bAr="wrapper";function NAr(e){let{components:n,...t}=e;return(0,s.yg)(bAr,(0,p.A)({},LAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}NAr.isMDXComponent=!0;const kAr={toc:[]},zAr="wrapper";function PAr(e){let{components:n,...t}=e;return(0,s.yg)(zAr,(0,p.A)({},kAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The t value at which to evaluate the curve."))}PAr.isMDXComponent=!0;const IAr={toc:[]},RAr="wrapper";function WAr(e){let{components:n,...t}=e;return(0,s.yg)(RAr,(0,p.A)({},IAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The tangent is currently inconsistent for different types of curves and may\nsometimes return the normal of the point, instead. This will be fixed in\nthe next major version but is kept as is for now for backwards\ncompatibility reasons. To always get the real tangent of the point, you can\nuse ",(0,s.yg)("inlineCode",{parentName:"p"},"normal.flipped.perpendicular"),", instead."))}WAr.isMDXComponent=!0;const SAr={toc:[]},BAr="wrapper";function EAr(e){let{components:n,...t}=e;return(0,s.yg)(BAr,(0,p.A)({},SAr,t,{components:n,mdxType:"MDXLayout"}))}EAr.isMDXComponent=!0;const GAr={toc:[]},OAr="wrapper";function UAr(e){let{components:n,...t}=e;return(0,s.yg)(OAr,(0,p.A)({},GAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Calculate the curve profile of a spline based on a set of knots."))}UAr.isMDXComponent=!0;const FAr={toc:[]},VAr="wrapper";function qAr(e){let{components:n,...t}=e;return(0,s.yg)(VAr,(0,p.A)({},FAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The knots defining the spline"))}qAr.isMDXComponent=!0;const jAr={toc:[]},HAr="wrapper";function YAr(e){let{components:n,...t}=e;return(0,s.yg)(HAr,(0,p.A)({},jAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the spline should be closed or not"))}YAr.isMDXComponent=!0;const QAr={toc:[]},$Ar="wrapper";function KAr(e){let{components:n,...t}=e;return(0,s.yg)($Ar,(0,p.A)({},QAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The desired smoothness of the spline when using auto\ncalculated handles."))}KAr.isMDXComponent=!0;const JAr={toc:[]},ZAr="wrapper";function evr(e){let{components:n,...t}=e;return(0,s.yg)(ZAr,(0,p.A)({},JAr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the initial value of this signal."))}evr.isMDXComponent=!0;const nvr={toc:[]},tvr="wrapper";function ovr(e){let{components:n,...t}=e;return(0,s.yg)(tvr,(0,p.A)({},nvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}ovr.isMDXComponent=!0;const pvr={toc:[]},rvr="wrapper";function svr(e){let{components:n,...t}=e;return(0,s.yg)(rvr,(0,p.A)({},pvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Check if the signal is currently using its initial value."))}svr.isMDXComponent=!0;const cvr={toc:[]},avr="wrapper";function ivr(e){let{components:n,...t}=e;return(0,s.yg)(avr,(0,p.A)({},cvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Is the signal undergoing a tween?"))}ivr.isMDXComponent=!0;const lvr={toc:[]},uvr="wrapper";function mvr(e){let{components:n,...t}=e;return(0,s.yg)(uvr,(0,p.A)({},lvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.yg)("p",null,"This method can be used to create copies of signals."))}mvr.isMDXComponent=!0;const yvr={toc:[]},dvr="wrapper";function hvr(e){let{components:n,...t}=e;return(0,s.yg)(dvr,(0,p.A)({},yvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}hvr.isMDXComponent=!0;const gvr={toc:[]},fvr="wrapper";function Dvr(e){let{components:n,...t}=e;return(0,s.yg)(fvr,(0,p.A)({},gvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Get the raw value of this signal."))}Dvr.isMDXComponent=!0;const Mvr={toc:[]},Xvr="wrapper";function _vr(e){let{components:n,...t}=e;return(0,s.yg)(Xvr,(0,p.A)({},Mvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}_vr.isMDXComponent=!0;const wvr={toc:[]},Tvr="wrapper";function Cvr(e){let{components:n,...t}=e;return(0,s.yg)(Tvr,(0,p.A)({},wvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Reset the signal to its initial value (if one has been set)."))}Cvr.isMDXComponent=!0;const xvr={toc:[]},Avr="wrapper";function vvr(e){let{components:n,...t}=e;return(0,s.yg)(Avr,(0,p.A)({},xvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}vvr.isMDXComponent=!0;const Lvr={toc:[]},bvr="wrapper";function Nvr(e){let{components:n,...t}=e;return(0,s.yg)(bvr,(0,p.A)({},Lvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}Nvr.isMDXComponent=!0;const kvr={toc:[]},zvr="wrapper";function Pvr(e){let{components:n,...t}=e;return(0,s.yg)(zvr,(0,p.A)({},kvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Compute the current value of the signal and immediately set it."))}Pvr.isMDXComponent=!0;const Ivr={toc:[]},Rvr="wrapper";function Wvr(e){let{components:n,...t}=e;return(0,s.yg)(Rvr,(0,p.A)({},Ivr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,s.yg)("p",null,"By default, any property is cloneable."),(0,s.yg)("p",null,"Must be specified before the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.yg)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Wvr.isMDXComponent=!0;const Svr={toc:[]},Bvr="wrapper";function Evr(e){let{components:n,...t}=e;return(0,s.yg)(Bvr,(0,p.A)({},Svr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}Evr.isMDXComponent=!0;const Gvr={toc:[]},Ovr="wrapper";function Uvr(e){let{components:n,...t}=e;return(0,s.yg)(Ovr,(0,p.A)({},Gvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a cloneable property decorator."))}Uvr.isMDXComponent=!0;const Fvr={toc:[]},Vvr="wrapper";function qvr(e){let{components:n,...t}=e;return(0,s.yg)(Vvr,(0,p.A)({},Fvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the property should be cloneable."))}qvr.isMDXComponent=!0;const jvr={toc:[]},Hvr="wrapper";function Yvr(e){let{components:n,...t}=e;return(0,s.yg)(Hvr,(0,p.A)({},jvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}Yvr.isMDXComponent=!0;const Qvr={toc:[]},$vr="wrapper";function Kvr(e){let{components:n,...t}=e;return(0,s.yg)($vr,(0,p.A)({},Qvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}Kvr.isMDXComponent=!0;const Jvr={toc:[]},Zvr="wrapper";function eLr(e){let{components:n,...t}=e;return(0,s.yg)(Zvr,(0,p.A)({},Jvr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a compound property decorator."))}eLr.isMDXComponent=!0;const nLr={toc:[]},tLr="wrapper";function oLr(e){let{components:n,...t}=e;return(0,s.yg)(tLr,(0,p.A)({},nLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}oLr.isMDXComponent=!0;const pLr={toc:[]},rLr="wrapper";function sLr(e){let{components:n,...t}=e;return(0,s.yg)(rLr,(0,p.A)({},pLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,s.yg)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,s.yg)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}sLr.isMDXComponent=!0;const cLr={toc:[]},aLr="wrapper";function iLr(e){let{components:n,...t}=e;return(0,s.yg)(aLr,(0,p.A)({},cLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a computed method decorator."))}iLr.isMDXComponent=!0;const lLr={toc:[]},uLr="wrapper";function mLr(e){let{components:n,...t}=e;return(0,s.yg)(uLr,(0,p.A)({},lLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator specifies the initial value of a property."),(0,s.yg)("p",null,"Must be specified before the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.yg)("inlineCode",{parentName:"a"},"signal"))," decorator."))}mLr.isMDXComponent=!0;const yLr={toc:[]},dLr="wrapper";function hLr(e){let{components:n,...t}=e;return(0,s.yg)(dLr,(0,p.A)({},yLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}hLr.isMDXComponent=!0;const gLr={toc:[]},fLr="wrapper";function DLr(e){let{components:n,...t}=e;return(0,s.yg)(fLr,(0,p.A)({},gLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an initial signal value decorator."))}DLr.isMDXComponent=!0;const MLr={toc:[]},XLr="wrapper";function _Lr(e){let{components:n,...t}=e;return(0,s.yg)(XLr,(0,p.A)({},MLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The initial value of the property."))}_Lr.isMDXComponent=!0;const wLr={toc:[]},TLr="wrapper";function CLr(e){let{components:n,...t}=e;return(0,s.yg)(TLr,(0,p.A)({},wLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,s.yg)("p",null,"By default, any property is inspectable."),(0,s.yg)("p",null,"Must be specified before the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.yg)("inlineCode",{parentName:"a"},"signal"))," decorator."))}CLr.isMDXComponent=!0;const xLr={toc:[]},ALr="wrapper";function vLr(e){let{components:n,...t}=e;return(0,s.yg)(ALr,(0,p.A)({},xLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}vLr.isMDXComponent=!0;const LLr={toc:[]},bLr="wrapper";function NLr(e){let{components:n,...t}=e;return(0,s.yg)(bLr,(0,p.A)({},LLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an inspectable property decorator."))}NLr.isMDXComponent=!0;const kLr={toc:[]},zLr="wrapper";function PLr(e){let{components:n,...t}=e;return(0,s.yg)(zLr,(0,p.A)({},kLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Whether the property should be inspectable."))}PLr.isMDXComponent=!0;const ILr={toc:[]},RLr="wrapper";function WLr(e){let{components:n,...t}=e;return(0,s.yg)(RLr,(0,p.A)({},ILr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,s.yg)("p",null,"Must be specified before the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.yg)("inlineCode",{parentName:"a"},"signal"))," decorator."))}WLr.isMDXComponent=!0;const SLr={toc:[]},BLr="wrapper";function ELr(e){let{components:n,...t}=e;return(0,s.yg)(BLr,(0,p.A)({},SLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}ELr.isMDXComponent=!0;const GLr={toc:[]},OLr="wrapper";function ULr(e){let{components:n,...t}=e;return(0,s.yg)(OLr,(0,p.A)({},GLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a signal interpolation function decorator."))}ULr.isMDXComponent=!0;const FLr={toc:[]},VLr="wrapper";function qLr(e){let{components:n,...t}=e;return(0,s.yg)(VLr,(0,p.A)({},FLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The interpolation function for the property."))}qLr.isMDXComponent=!0;const jLr={toc:[]},HLr="wrapper";function YLr(e){let{components:n,...t}=e;return(0,s.yg)(HLr,(0,p.A)({},jLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,s.yg)("p",null,"If the wrapper class has a method called ",(0,s.yg)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,s.yg)("p",null,"Must be specified before the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.yg)("inlineCode",{parentName:"a"},"signal"))," decorator."))}YLr.isMDXComponent=!0;const QLr={toc:[]},$Lr="wrapper";function KLr(e){let{components:n,...t}=e;return(0,s.yg)($Lr,(0,p.A)({},QLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}KLr.isMDXComponent=!0;const JLr={toc:[]},ZLr="wrapper";function ebr(e){let{components:n,...t}=e;return(0,s.yg)(ZLr,(0,p.A)({},JLr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a signal parser decorator."))}ebr.isMDXComponent=!0;const nbr={toc:[]},tbr="wrapper";function obr(e){let{components:n,...t}=e;return(0,s.yg)(tbr,(0,p.A)({},nbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The wrapper class for the property."))}obr.isMDXComponent=!0;const pbr={toc:[]},rbr="wrapper";function sbr(e){let{components:n,...t}=e;return(0,s.yg)(rbr,(0,p.A)({},pbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This decorator turns the given property into a signal."),(0,s.yg)("p",null,"The class using this decorator can implement the following methods:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}sbr.isMDXComponent=!0;const cbr={toc:[]},abr="wrapper";function ibr(e){let{components:n,...t}=e;return(0,s.yg)(abr,(0,p.A)({},cbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}ibr.isMDXComponent=!0;const lbr={toc:[]},ubr="wrapper";function mbr(e){let{components:n,...t}=e;return(0,s.yg)(ubr,(0,p.A)({},lbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a signal decorator."))}mbr.isMDXComponent=!0;const ybr={toc:[]},dbr="wrapper";function hbr(e){let{components:n,...t}=e;return(0,s.yg)(dbr,(0,p.A)({},ybr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This is a shortcut decorator for setting both the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,s.yg)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,s.yg)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,s.yg)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,s.yg)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,s.yg)("p",null,"Must be specified before the ",(0,s.yg)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.yg)("inlineCode",{parentName:"a"},"signal"))," decorator."))}hbr.isMDXComponent=!0;const gbr={toc:[]},fbr="wrapper";function Dbr(e){let{components:n,...t}=e;return(0,s.yg)(fbr,(0,p.A)({},gbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}Dbr.isMDXComponent=!0;const Mbr={toc:[]},Xbr="wrapper";function _br(e){let{components:n,...t}=e;return(0,s.yg)(Xbr,(0,p.A)({},Mbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a signal wrapper decorator."))}_br.isMDXComponent=!0;const wbr={toc:[]},Tbr="wrapper";function Cbr(e){let{components:n,...t}=e;return(0,s.yg)(Tbr,(0,p.A)({},wbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The wrapper class for the property."))}Cbr.isMDXComponent=!0;const xbr={toc:[]},Abr="wrapper";function vbr(e){let{components:n,...t}=e;return(0,s.yg)(Abr,(0,p.A)({},xbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"A unified abstraction for all CSS filters."))}vbr.isMDXComponent=!0;const Lbr={toc:[]},bbr="wrapper";function Nbr(e){let{components:n,...t}=e;return(0,s.yg)(bbr,(0,p.A)({},Lbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"When the desired length is set to ",(0,s.yg)("inlineCode",{parentName:"p"},"null")," it represents a default value for\nwhatever property it describes."))}Nbr.isMDXComponent=!0;const kbr={toc:[]},zbr="wrapper";function Pbr(e){let{components:n,...t}=e;return(0,s.yg)(zbr,(0,p.A)({},kbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a desired length used internally by layout Nodes."))}Pbr.isMDXComponent=!0;const Ibr={toc:[]},Rbr="wrapper";function Wbr(e){let{components:n,...t}=e;return(0,s.yg)(Rbr,(0,p.A)({},Ibr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value can be either:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.yg)("inlineCode",{parentName:"li"},"'50%'"))))}Wbr.isMDXComponent=!0;const Sbr={toc:[]},Bbr="wrapper";function Ebr(e){let{components:n,...t}=e;return(0,s.yg)(Bbr,(0,p.A)({},Sbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a length used by most layout properties."))}Ebr.isMDXComponent=!0;const Gbr={toc:[]},Obr="wrapper";function Ubr(e){let{components:n,...t}=e;return(0,s.yg)(Obr,(0,p.A)({},Gbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Represents a length limit used by layout properties such as ",(0,s.yg)("inlineCode",{parentName:"p"},"max-width"),"."))}Ubr.isMDXComponent=!0;const Fbr={toc:[]},Vbr="wrapper";function qbr(e){let{components:n,...t}=e;return(0,s.yg)(Vbr,(0,p.A)({},Fbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,s.yg)("inlineCode",{parentName:"a"},"blur"))," filter."))}qbr.isMDXComponent=!0;const jbr={toc:[]},Hbr="wrapper";function Ybr(e){let{components:n,...t}=e;return(0,s.yg)(Hbr,(0,p.A)({},jbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter in pixels."))}Ybr.isMDXComponent=!0;const Qbr={toc:[]},$br="wrapper";function Kbr(e){let{components:n,...t}=e;return(0,s.yg)($br,(0,p.A)({},Qbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,s.yg)("inlineCode",{parentName:"a"},"brightness"))," filter."))}Kbr.isMDXComponent=!0;const Jbr={toc:[]},Zbr="wrapper";function eNr(e){let{components:n,...t}=e;return(0,s.yg)(Zbr,(0,p.A)({},Jbr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter."))}eNr.isMDXComponent=!0;const nNr={toc:[]},tNr="wrapper";function oNr(e){let{components:n,...t}=e;return(0,s.yg)(tNr,(0,p.A)({},nNr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,s.yg)("inlineCode",{parentName:"a"},"contrast"))," filter."))}oNr.isMDXComponent=!0;const pNr={toc:[]},rNr="wrapper";function sNr(e){let{components:n,...t}=e;return(0,s.yg)(rNr,(0,p.A)({},pNr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter."))}sNr.isMDXComponent=!0;const cNr={toc:[]},aNr="wrapper";function iNr(e){let{components:n,...t}=e;return(0,s.yg)(aNr,(0,p.A)({},cNr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,s.yg)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}iNr.isMDXComponent=!0;const lNr={toc:[]},uNr="wrapper";function mNr(e){let{components:n,...t}=e;return(0,s.yg)(uNr,(0,p.A)({},lNr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter."))}mNr.isMDXComponent=!0;const yNr={toc:[]},dNr="wrapper";function hNr(e){let{components:n,...t}=e;return(0,s.yg)(dNr,(0,p.A)({},yNr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,s.yg)("inlineCode",{parentName:"a"},"hue"))," filter."))}hNr.isMDXComponent=!0;const gNr={toc:[]},fNr="wrapper";function DNr(e){let{components:n,...t}=e;return(0,s.yg)(fNr,(0,p.A)({},gNr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter in degrees."))}DNr.isMDXComponent=!0;const MNr={toc:[]},XNr="wrapper";function _Nr(e){let{components:n,...t}=e;return(0,s.yg)(XNr,(0,p.A)({},MNr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create an ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,s.yg)("inlineCode",{parentName:"a"},"invert"))," filter."))}_Nr.isMDXComponent=!0;const wNr={toc:[]},TNr="wrapper";function CNr(e){let{components:n,...t}=e;return(0,s.yg)(TNr,(0,p.A)({},wNr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter."))}CNr.isMDXComponent=!0;const xNr={toc:[]},ANr="wrapper";function vNr(e){let{components:n,...t}=e;return(0,s.yg)(ANr,(0,p.A)({},xNr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,s.yg)("inlineCode",{parentName:"a"},"saturate"))," filter."))}vNr.isMDXComponent=!0;const LNr={toc:[]},bNr="wrapper";function NNr(e){let{components:n,...t}=e;return(0,s.yg)(bNr,(0,p.A)({},LNr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter."))}NNr.isMDXComponent=!0;const kNr={toc:[]},zNr="wrapper";function PNr(e){let{components:n,...t}=e;return(0,s.yg)(zNr,(0,p.A)({},kNr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a ",(0,s.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,s.yg)("inlineCode",{parentName:"a"},"sepia"))," filter."))}PNr.isMDXComponent=!0;const INr={toc:[]},RNr="wrapper";function WNr(e){let{components:n,...t}=e;return(0,s.yg)(RNr,(0,p.A)({},INr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The value of the filter."))}WNr.isMDXComponent=!0;const SNr={toc:[]},BNr="wrapper";function ENr(e){let{components:n,...t}=e;return(0,s.yg)(BNr,(0,p.A)({},SNr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}ENr.isMDXComponent=!0;const GNr={toc:[]},ONr="wrapper";function UNr(e){let{components:n,...t}=e;return(0,s.yg)(ONr,(0,p.A)({},GNr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Invoke the given callback in the context of this scene."))}UNr.isMDXComponent=!0;const FNr={toc:[]},VNr="wrapper";function qNr(e){let{components:n,...t}=e;return(0,s.yg)(VNr,(0,p.A)({},FNr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The callback to invoke."))}qNr.isMDXComponent=!0;const jNr={toc:[]},HNr="wrapper";function YNr(e){let{components:n,...t}=e;return(0,s.yg)(HNr,(0,p.A)({},jNr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Update the view."),(0,s.yg)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.yg)("p",null,"Can modify the state of the view."))}YNr.isMDXComponent=!0;const QNr={toc:[]},$Nr="wrapper";function KNr(e){let{components:n,...t}=e;return(0,s.yg)($Nr,(0,p.A)({},QNr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"Create a predicate that checks if the given object is an instance of the\ngiven class."))}KNr.isMDXComponent=!0;const JNr={toc:[]},ZNr="wrapper";function ekr(e){let{components:n,...t}=e;return(0,s.yg)(ZNr,(0,p.A)({},JNr,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The class to check against."))}function nkr(e){let{id:n}=e;const t=o[n]??r.Fragment;return r.createElement(t,null)}ekr.isMDXComponent=!0},5063:(e,n,t)=>{t.d(n,{A:()=>i});var o=t(6476),p=t(3310),r=t(7576),s=t(53),c=t(4041);const a={toggle:"toggle_S_IX",collapsed:"collapsed_wdUB",collapse:"collapse_TjTN",inverse:"inverse_g6vW",clearFix:"clearFix_HQ1T"};function i(e){let{comment:n,full:t=!0}=e;const o=(0,c.useMemo)((()=>n?.blockTags?.find((e=>{let{tag:n}=e;return"@remarks"===n}))),[n]);return c.createElement(c.Fragment,null,t&&c.createElement(l,{comment:n}),c.createElement(p.A,{id:n?.summaryId}),c.createElement(p.A,{id:o?.contentId}),t&&c.createElement(u,{comment:n}))}function l(e){let{comment:n}=e;return(0,c.useMemo)((()=>n?.modifierTags?.includes("@experimental")),[n])?c.createElement(r.A,null):null}function u(e){let{comment:n}=e;const[t,r]=(0,c.useState)(!0),i=(0,c.useMemo)((()=>n?.blockTags?.find((e=>{let{tag:n}=e;return"@preview"===n}))),[n]),l=(0,c.useMemo)((()=>n?.blockTags?.filter((e=>{let{tag:n}=e;return"@example"===n}))??[]),[n]),u=(0,c.useMemo)((()=>n?.blockTags?.find((e=>{let{tag:n}=e;return"@defaultValue"===n}))),[n]),m=(0,c.useMemo)((()=>n?.blockTags?.find((e=>{let{tag:n}=e;return"@deprecated"===n}))),[n]),y=(0,c.useMemo)((()=>n?.blockTags?.find((e=>{let{tag:n}=e;return"@see"===n}))),[n]);return c.createElement(c.Fragment,null,c.createElement(p.A,{id:i?.contentId}),l.length>0&&c.createElement(c.Fragment,null,c.createElement("h4",null,c.createElement("a",{className:(0,s.A)(a.toggle,t&&a.collapsed),onClick:e=>{e.preventDefault(),r(!t)},href:"#"},"Examples")),c.createElement(o.N,{lazy:!0,as:"div",collapsed:t},c.createElement("div",{className:a.collapse},l.map((e=>c.createElement(p.A,{key:e.contentId,id:e.contentId})))),c.createElement("div",{className:a.clearFix})),c.createElement("div",{className:(0,s.A)(a.clearFix,a.inverse)})),u&&c.createElement(c.Fragment,null,"Default Value:"," ",c.createElement("code",null,u.content.map((e=>e.text)).join(""))),m&&c.createElement(c.Fragment,null,c.createElement("h4",null,"Deprecated"),c.createElement(p.A,{id:m.contentId})),y&&c.createElement(c.Fragment,null,c.createElement("h4",null,"See also"),c.createElement(p.A,{id:y.contentId})))}},1125:(e,n,t)=>{t.d(n,{A:()=>Be});var o=t(1282),p=t(4905),r=t(9575),s=t(4041);function c(e){let{width:n=24,height:t=24,...o}=e;return s.createElement("svg",(0,r.A)({width:n,height:t,"aria-hidden":"true",viewBox:"0 0 24 24"},o),s.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}const a={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var i=t(4593),l=t(53);function u(e){let{children:n,highlight:t,onClick:r,link:u}=e;const m=(0,p.f)(),y=(0,i.o0)();return s.createElement("div",{className:(0,l.A)(o.A.codeBlockContent,a.codeBlock,t&&a.highlight,r&&a.pointer)},s.createElement("pre",{onClick:r,onKeyDown:e=>{"Enter"===e.key&&r?.()},tabIndex:0,ref:m.codeBlockRef,className:(0,l.A)(o.A.codeBlock,"thin-scrollbar")},s.createElement("code",{className:o.A.codeBlockLines,style:y},n)),u&&s.createElement("div",{className:o.A.buttonGroup},s.createElement("button",{title:"Go to source",className:"clean-btn",onClick:e=>{e.preventDefault(),window.open(u,"_blank")}},s.createElement(c,{width:18,height:18}))))}var m=t(6333);function y(e){let{children:n}=e;return s.createElement(m.A,{as:"div",className:(0,l.A)(a.codeBlockContainer,"language-typescript")},n)}function d(e){let{children:n}=e;const t=(0,s.useRef)();return(0,s.useLayoutEffect)((()=>{if(!t.current)return;const e=t.current.closest("pre");if(e.scrollWidth>e.clientWidth){const n=Array.from(t.current.querySelectorAll(`.${a.elements}`)).sort(((e,n)=>function(e,n){return e>n?1:e<n?-1:0}(n.innerText.length,e.innerText.length)));for(;e.scrollWidth>e.clientWidth&&n.length>0;)n.shift().classList.add(a.wrap)}})),s.createElement(s.Fragment,null,n&&s.createElement("span",{ref:t,className:(0,l.A)(a.line,"token-line")},n),s.createElement("br",null))}var h=t(5063),g=t(9659);function f(e){let{width:n=24,height:t=24,...o}=e;return s.createElement("svg",(0,r.A)({viewBox:"0 0 24 24",width:n,height:t,"aria-hidden":!0},o),s.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}var D=t(6382);const M={header:"header_nSmr",filters:"filters_z1iC",icon:"icon_ROIU"};function X(){const e=(0,s.useRef)(null),[n,t]=(0,s.useState)(!1),[o,p]=(0,D.R7)();return(0,s.useEffect)((()=>{const n=n=>{e.current&&!e.current.contains(n.target)&&t(!1)};return document.addEventListener("mousedown",n),document.addEventListener("touchstart",n),()=>{document.removeEventListener("mousedown",n),document.removeEventListener("touchstart",n)}}),[e]),s.createElement(s.Fragment,null,s.createElement("div",{ref:e,className:(0,l.A)("dropdown dropdown--right margin-bottom--md",n&&"dropdown--show")},s.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:e=>{e.preventDefault(),t(!n)},onKeyDown:e=>{"Enter"===e.key&&(e.preventDefault(),t(!n))}},"Filters",s.createElement(f,{className:M.icon})),s.createElement("ul",{className:"dropdown__menu"},s.createElement("li",null,s.createElement("label",{htmlFor:"private",className:(0,l.A)("dropdown__link",o.private&&"dropdown__link--active")},s.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:o.private,onChange:e=>{p({...o,private:e.target.checked})}}),"Protected members")),s.createElement("li",{onKeyDown:e=>{"Tab"===e.key&&t(!1)}},s.createElement("label",{htmlFor:"inherited",className:(0,l.A)("dropdown__link",o.inherited&&"dropdown__link--active")},s.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:o.inherited,onChange:e=>{p({...o,inherited:e.target.checked})}}),"Inherited members")))))}function _(e){let{children:n,kind:t}=e;return t===g.k.Class||t===g.k.Interface?s.createElement("div",{className:(0,l.A)("row",M.header)},s.createElement("div",{className:(0,l.A)("col",M.filters)},s.createElement(X,null)),s.createElement("div",{className:"col"},n)):s.createElement(s.Fragment,null,n)}var w=t(6090),T=t(9631);function C(e){let{children:n,type:t,to:o,id:p,tooltip:c}=e;const a=(0,i.J2)(t);return o?s.createElement(T.A,(0,r.A)({id:p,to:o,"data-tooltip":c},a),n):s.createElement("span",(0,r.A)({id:p},a),n)}let x=function(e){return e[e.None=0]="None",e[e.Angle=1]="Angle",e[e.Curly=2]="Curly",e[e.Square=3]="Square",e[e.Parentheses=4]="Parentheses",e}({}),A=function(e){return e.Comma=", ",e.Pipe=" | ",e.Ampersand=" & ",e}({});const v={[x.None]:a.none,[x.Angle]:a.angle,[x.Curly]:a.curly,[x.Square]:a.square,[x.Parentheses]:a.parentheses};function L(e){let{children:n,type:t,separator:o=A.Comma}=e;return s.createElement("span",{className:(0,l.A)(a.list,v[t??x.None])},s.createElement("span",{className:(0,l.A)(a.elements,o!==A.Comma&&a.left)},(Array.isArray(n)?n:[n]).flatMap(((e,n)=>s.createElement("span",{"data-separator":o,key:n,className:a.element},e)))))}function b(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(oe,{type:n.elementType}),"[]")}function N(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(oe,{type:n.checkType}),s.createElement(C,{type:"keyword"}," extends "),s.createElement(oe,{type:n.extendsType})," ? ",s.createElement(oe,{type:n.trueType})," : ",s.createElement(oe,{type:n.falseType}))}function k(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(oe,{type:n.objectType}),"[",s.createElement(oe,{type:n.indexType}),"]")}function z(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"infer "),s.createElement(C,{type:"constant"},n.name))}function P(e){let{type:n}=e;return s.createElement(L,{type:x.Parentheses,separator:A.Ampersand},n.types.map(((e,n)=>s.createElement(oe,{key:n,type:e}))))}function I(e){let{type:n}=e;return s.createElement(C,{type:"keyword"},n.name)}function R(e){let{type:n}=e;const[t,o]=(0,s.useMemo)((()=>{if(null===n.value)return["null","keyword"];switch(typeof n.value){case"object":return[(n.value.negative?"-":"")+n.value.value,"number"];case"boolean":return[n.value,"keyword"];case"number":return[n.value,"number"];case"string":return[`'${n.value}'`,"string"];default:return[n.value,"constant"]}}),[n.value]);return s.createElement(C,{type:o},t)}function W(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(L,{type:x.Curly},s.createElement(s.Fragment,null,"[",s.createElement(C,{type:"class"},n.parameter),s.createElement(C,{type:"keyword"}," in "),s.createElement(oe,{type:n.parameterType}),"]: ",s.createElement(oe,{type:n.templateType}))))}function S(e){let{type:n}=e;return s.createElement(s.Fragment,null,n.name,": ",s.createElement(oe,{type:n.element}))}function B(e){let{type:n}=e;return n.asserts?s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"asserts "),s.createElement(C,null,n.name," ")):s.createElement(s.Fragment,null,s.createElement(C,null,n.name," "),s.createElement(C,{type:"keyword"},"is "),s.createElement(oe,{type:n.targetType}))}function E(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"typeof "),s.createElement(oe,{type:n.queryType}))}function G(e){let{flags:n,explicitAccessModifier:t}=e;const o=[];return n?.isAbstract&&o.push("abstract"),n?.isStatic&&o.push("static"),n?.isConst&&o.push("const"),n?.isReadonly&&o.push("readonly"),n?.isPrivate&&o.push("private"),n?.isProtected&&o.push("protected"),(n?.isPublic||t&&!n?.isProtected&&!n?.isPrivate)&&o.push("public"),s.createElement(s.Fragment,null,o.map((e=>s.createElement(C,{key:e,type:"keyword"},e," "))))}function O(e){let{reflection:n}=e;return s.createElement(s.Fragment,null,s.createElement(G,{flags:n.flags}),n.varianceModifier&&s.createElement(C,{type:"keyword"},n.varianceModifier," "),s.createElement(C,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"class-name"},n.name),n.type&&s.createElement(s.Fragment,null," extends ",s.createElement(oe,{type:n.type})),n.default&&s.createElement(s.Fragment,null," = ",s.createElement(oe,{type:n.default})))}var U=t(8675);const F={[g.k.Namespace]:"namespace",[g.k.Enum]:"enum",[g.k.Class]:"class",[g.k.Interface]:"interface"};function V(e){let{reflection:n}=e;const t=(0,U.as)();return s.createElement(s.Fragment,null,s.createElement(G,{flags:n.flags}),s.createElement(C,{type:"keyword"},F[n.kind]," "),s.createElement(C,{type:"class-name"},n.name),!!n.typeParameters?.length&&s.createElement(L,{type:x.Angle},n.typeParameters.map((e=>s.createElement(O,{key:e.id,reflection:t(e)}))))," ",!!n.extendedTypes?.length&&s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"extends "),s.createElement(L,null,n.extendedTypes.map(((e,n)=>s.createElement(oe,{key:n,type:e}))))),!!n.implementedTypes?.length&&s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"implements "),s.createElement(L,null,n.implementedTypes.map(((e,n)=>s.createElement(oe,{key:n,type:e}))))))}function q(e){let{reflection:n}=e;const t="__namedParameters"===n.name?"{...}":n.name;return s.createElement(s.Fragment,null,s.createElement(G,{flags:n.flags}),n.flags.isRest&&"...",s.createElement(C,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"plain"},t),n.flags.isOptional&&"?",": ",n.type&&s.createElement(oe,{type:n.type}),n.defaultValue&&s.createElement(s.Fragment,null," = ",s.createElement(C,{type:"plain"},n.defaultValue)))}function j(e){let{reflection:n,flags:t}=e;const o=(0,U.as)(),p="__type"===n.name;return s.createElement(s.Fragment,null,s.createElement(G,{flags:t??n.flags,explicitAccessModifier:!p}),n.kind===g.k.GetSignature&&s.createElement(C,{type:"keyword"},"get "),n.kind===g.k.SetSignature&&s.createElement(C,{type:"keyword"},"set "),n.overwrites&&s.createElement(s.Fragment,null,s.createElement(C,{to:n.overwrites.externalUrl??(0,U.ID)(o(n.overwrites.id)),type:"keyword"},"override")," "),n.kind===g.k.ConstructorSignature?s.createElement(s.Fragment,null,s.createElement(C,{to:"#",type:"keyword"},"new")," ",s.createElement(C,{type:"plain"},n.type.name)):p?"":s.createElement(C,{type:"function"},n.name),!!n.typeParameter?.length&&s.createElement(L,{type:x.Angle},n.typeParameter.map((e=>s.createElement(O,{key:e.id,reflection:o(e)})))),n.parameters?.length?s.createElement(L,{type:x.Parentheses},n.parameters.map((e=>s.createElement(q,{key:e,reflection:o(e)})))):"()",n.type&&s.createElement(s.Fragment,null,p?" => ":": ",s.createElement(oe,{type:n.type})))}function H(e){let{reflection:n}=e;const t=n.signatures?.[0]??n.getSignature??n.setSignature??n.indexSignature;return s.createElement(j,{reflection:t})}function Y(e){let{reflection:n}=e;return s.createElement(q,{reflection:n})}function Q(e){let{reflection:n}=e;const t=(0,U.as)();return s.createElement(s.Fragment,null,s.createElement(G,{flags:n.flags}),s.createElement(C,{type:"keyword"},"type "),s.createElement(C,{type:"class-name"},n.name),n.typeParameters&&s.createElement(L,{type:x.Angle},n.typeParameters.map((e=>s.createElement(O,{key:e.id,reflection:t(e)}))))," = ",s.createElement(oe,{type:n.type}))}function $(e){let{reflection:n}=e;const t=(0,U.as)();if(n.signatures){let e=n.signatures[0];if(e?.kind||(e=t(e)),e)return s.createElement(j,{reflection:e})}return n.children?s.createElement(L,{type:x.Curly},n.children.map((e=>s.createElement(K,{key:e.id,reflection:t(e)})))):s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"unknown"))}function K(e){let{reflection:n}=e;const t=(0,s.useMemo)((()=>{switch(n.kind){case g.k.Project:case g.k.Module:case g.k.EnumMember:case g.k.Variable:case g.k.Function:break;case g.k.Namespace:case g.k.Enum:case g.k.Class:case g.k.Interface:return V;case g.k.Constructor:return j;case g.k.Property:return Y;case g.k.Method:return H;case g.k.CallSignature:case g.k.IndexSignature:case g.k.ConstructorSignature:case g.k.Parameter:break;case g.k.TypeLiteral:return $;case g.k.TypeParameter:return O;case g.k.Accessor:case g.k.GetSignature:case g.k.SetSignature:case g.k.ObjectLiteral:break;case g.k.TypeAlias:return Q;case g.k.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.id]);return s.createElement(t,{reflection:n})}function J(e){let{type:n}=e;const t=(0,U.as)();return s.createElement(K,{reflection:t(n.declaration)})}function Z(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(C,{type:"string"},"`",n.head),n.tail.map(((e,n)=>{let[t,o]=e;return s.createElement(s.Fragment,null,"${",s.createElement(oe,{key:n,type:t}),"}",s.createElement(C,{type:"string"},o))})),s.createElement(C,{type:"string"},"`"))}function ee(e){let{type:n}=e;return n.elements?s.createElement(L,{type:x.Square},n.elements.map(((e,n)=>s.createElement(oe,{key:n,type:e})))):s.createElement(s.Fragment,null,"[]")}function ne(e){let{type:n}=e;return s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},n.operator," "),s.createElement(oe,{type:n.target}))}function te(e){let{type:n}=e;return s.createElement(L,{type:x.Parentheses,separator:A.Pipe},n.types.map(((e,n)=>s.createElement(oe,{key:n,type:e}))))}function oe(e){const n=(0,s.useMemo)((()=>{switch(e.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return ne;case"conditional":return N;case"reflection":return J;case"query":return E;case"named-tuple-member":return S;case"union":return te;case"intrinsic":return I;case"literal":return R;case"reference":return pe;case"predicate":return B;case"tuple":return ee;case"array":return b;case"intersection":return P;case"inferred":return z;case"mapped":return W;case"template-literal":return Z;case"indexedAccess":return k}throw new Error(`Missing component for type: ${e.type.type}`)}),[e.type]);return s.createElement(n,e)}function pe(e){let{type:n}=e;const t=(0,U.gG)(n.project),o=t?.[n.id],p=n.externalUrl??(0,U.ID)(o);return s.createElement(s.Fragment,null,s.createElement(C,{to:p,type:p?"class-name":"constant",tooltip:!0},n.name),!!n.typeArguments?.length&&s.createElement(L,{type:x.Angle},n.typeArguments.map(((e,n)=>s.createElement(oe,{key:n,type:e})))))}function re(e){let{group:n}=e;return"Constructors"===n.title&&0===n.external.length&&1===n.nested.length?s.createElement(Be,{reflection:n.nested[0]}):s.createElement(s.Fragment,null,n.external.length>0&&s.createElement("ul",null,n.external.map((e=>s.createElement("li",{key:e.id},s.createElement("code",null,s.createElement(pe,{type:e})))))),n.nested.length>0&&n.nested.map(((e,n)=>s.createElement(s.Fragment,{key:e.id},n>0&&s.createElement("hr",null),s.createElement(Be,{reflection:e})))))}var se=t(4441),ce=t(2663);const ae={tabItem:"tabItem_OMyP"};function ie(e){let{children:n,hidden:t,className:o}=e;return s.createElement("div",{role:"tabpanel",className:(0,ce.A)(ae.tabItem,o),hidden:t},n)}var le=t(1034),ue=t(6703),me=t(6004),ye=t(2096);function de(e){return function(e){return s.Children.map(e,(e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:n,label:t,attributes:o,default:p}}=e;return{value:n,label:t,attributes:o,default:p}}))}function he(e){const{values:n,children:t}=e;return(0,s.useMemo)((()=>{const e=n??de(t);return function(e){const n=(0,me.X)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function ge(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function fe(e){let{queryString:n=!1,groupId:t}=e;const o=(0,w.W6)(),p=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,ue.aZ)(p),(0,s.useCallback)((e=>{if(!p)return;const n=new URLSearchParams(o.location.search);n.set(p,e),o.replace({...o.location,search:n.toString()})}),[p,o])]}function De(e){const{defaultValue:n,queryString:t=!1,groupId:o}=e,p=he(e),[r,c]=(0,s.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!ge({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const o=t.find((e=>e.default))??t[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:n,tabValues:p}))),[a,i]=fe({queryString:t,groupId:o}),[l,u]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[o,p]=(0,ye.Dv)(t);return[o,(0,s.useCallback)((e=>{t&&p.set(e)}),[t,p])]}({groupId:o}),m=(()=>{const e=a??l;return ge({value:e,tabValues:p})?e:null})();(0,s.useLayoutEffect)((()=>{m&&c(m)}),[m]);return{selectedValue:r,selectValue:(0,s.useCallback)((e=>{if(!ge({value:e,tabValues:p}))throw new Error(`Can't select invalid tab value=${e}`);c(e),i(e),u(e)}),[i,u,p]),tabValues:p}}var Me=t(213);const Xe={tabList:"tabList_M0Dn",tabItem:"tabItem_ysIP"};function _e(e){let{className:n,block:t,selectedValue:o,selectValue:p,tabValues:c}=e;const a=[],{blockElementScrollPositionUntilNextRender:i}=(0,le.a_)(),l=e=>{const n=e.currentTarget,t=a.indexOf(n),r=c[t].value;r!==o&&(i(n),p(r))},u=e=>{let n=null;switch(e.key){case"Enter":l(e);break;case"ArrowRight":{const t=a.indexOf(e.currentTarget)+1;n=a[t]??a[0];break}case"ArrowLeft":{const t=a.indexOf(e.currentTarget)-1;n=a[t]??a[a.length-1];break}}n?.focus()};return s.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,ce.A)("tabs",{"tabs--block":t},n)},c.map((e=>{let{value:n,label:t,attributes:p}=e;return s.createElement("li",(0,r.A)({role:"tab",tabIndex:o===n?0:-1,"aria-selected":o===n,key:n,ref:e=>a.push(e),onKeyDown:u,onClick:l},p,{className:(0,ce.A)("tabs__item",Xe.tabItem,p?.className,{"tabs__item--active":o===n})}),t??n)})))}function we(e){let{lazy:n,children:t,selectedValue:o}=e;const p=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=p.find((e=>e.props.value===o));return e?(0,s.cloneElement)(e,{className:"margin-top--md"}):null}return s.createElement("div",{className:"margin-top--md"},p.map(((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==o}))))}function Te(e){const n=De(e);return s.createElement("div",{className:(0,ce.A)("tabs-container",Xe.tabList)},s.createElement(_e,(0,r.A)({},e,n)),s.createElement(we,(0,r.A)({},e,n)))}function Ce(e){const n=(0,Me.A)();return s.createElement(Te,(0,r.A)({key:String(n)},e))}function xe(e){let{group:n,project:t}=e;const o=(0,w.zy)(),p=(0,U.gG)(t),r=o.hash.split("-")[0].slice(1),[c]=(0,D.R7)(),a=(0,s.useMemo)((()=>(n.categories??[n]).map((e=>function(e,n,t){const o=[],p=[],r=[];for(const s of e.children){const e=n[s];e&&(0,D.XN)(t,e)&&(r.push(e.anchor),e.hasOwnPage?o.push(e):p.push(e))}if(o.length>0||p.length>0)return{title:e.title,external:o,nested:p,anchors:r}}(e,p,c))).filter((e=>!!e))),[n,p,c]);return(0,s.useEffect)((()=>{if(1===a.length)return;const e=o.hash.split("-")[0].slice(1);for(const n of a)if(n.anchors.includes(e))return}),[o.hash,a]),0===a.length?s.createElement(s.Fragment,null):s.createElement(s.Fragment,null,s.createElement(se.A,{as:"h2",id:n.title},n.title),a.length>1?s.createElement(Ce,{groupId:n.title},a.map((e=>s.createElement(ie,{default:e.anchors.includes(r),value:e.title,label:e.title,className:"margin-top--lg"},s.createElement(re,{group:e}))))):s.createElement(re,{group:a[0]}))}var Ae=t(3310);function ve(e){let{parameters:n}=e;const t=(0,U.as)(),o=(0,s.useMemo)((()=>n?.map(t)),[n]);return o?.length?s.createElement(s.Fragment,null,s.createElement("h4",null,"Parameters"),s.createElement("ul",null,o.map((e=>s.createElement("li",{key:e.id},s.createElement("code",null,s.createElement(q,{reflection:e})),s.createElement(Ae.A,{id:e.comment?.summaryId})))))):s.createElement(s.Fragment,null)}function Le(e){let{parameters:n}=e;const t=(0,U.as)(),o=(0,s.useMemo)((()=>n?.map(t)),[n]);return o?.length?s.createElement(s.Fragment,null,s.createElement("h4",null,"Type Parameters"),s.createElement("ul",null,o.map((e=>s.createElement("li",{key:e.id},s.createElement("code",null,s.createElement(O,{reflection:e})),s.createElement(Ae.A,{id:e.comment?.summaryId})))))):s.createElement(s.Fragment,null)}function be(e){let{signatures:n,flags:t,source:o}=e;const p=(0,U.as)(),r=(0,s.useMemo)((()=>n.map(p)),[n]),[c,a]=(0,s.useState)(r[0]);return s.createElement(s.Fragment,null,s.createElement(y,null,r.map((e=>s.createElement(u,{link:o?.url,key:e.id,highlight:n.length>1&&e.id===c.id,onClick:n.length>1?()=>a(e):void 0},s.createElement(d,null,s.createElement(j,{reflection:e,flags:t})))))),s.createElement(h.A,{comment:c.comment}),s.createElement(Le,{parameters:c.typeParameter}),s.createElement(ve,{parameters:c.parameters}))}function Ne(e){let{reflection:n}=e;return s.createElement(s.Fragment,null,s.createElement(y,null,s.createElement(u,{link:n.sources?.[0]?.url},s.createElement(d,null,s.createElement(K,{reflection:n})))),s.createElement(_,{kind:n.kind},s.createElement(h.A,{comment:n.comment})),s.createElement(Le,{parameters:n.typeParameters}),n.implementedBy?.length&&s.createElement(s.Fragment,null,s.createElement("h4",null,"Implemented by"),s.createElement("ul",null,n.implementedBy.map((e=>s.createElement("li",{key:e.id},s.createElement("code",null,s.createElement(pe,{type:e}))))))),n.extendedBy?.length&&s.createElement(s.Fragment,null,s.createElement("h4",null,"Extended by"),s.createElement("ul",null,n.extendedBy.map((e=>s.createElement("li",{key:e.id},s.createElement("code",null,s.createElement(pe,{type:e}))))))),n.signatures&&s.createElement(s.Fragment,null,s.createElement("h2",null,"Callable"),s.createElement(be,{signatures:n.signatures})),n.groups?.map((e=>s.createElement(xe,{group:e,key:e.title,project:n.project}))))}function ke(e){let{reflection:n,headless:t}=e;const o=[...n.signatures??[],n.setSignature,n.getSignature,n.indexSignature].filter((e=>!!e));return s.createElement(s.Fragment,null,!t&&(n.hasOwnPage?s.createElement("h1",null,n.name):s.createElement(se.A,{as:"h3",id:n.anchor},s.createElement("code",null,n.name))),s.createElement(be,{signatures:o,flags:n.flags,source:n.sources?.[0]}),n.inheritedFrom&&s.createElement("small",null,"Inherited from"," ",s.createElement("code",null,s.createElement(pe,{type:n.inheritedFrom}))),n.overwrites&&s.createElement("small",null,"Overwrites"," ",s.createElement("code",null,s.createElement(pe,{type:n.overwrites}))))}var ze=t(154);function Pe(e){let{reflection:n}=e;return s.createElement(s.Fragment,null,s.createElement(ze.A,{language:"ts"},"import ","{...}",' from "',n.importPath,'";'),s.createElement(_,{kind:n.kind},s.createElement(h.A,{comment:n.comment})),n.groups?.map((e=>s.createElement(xe,{group:e,key:e.title,project:n.project}))))}const Ie={cardContainer:"cardContainer_ybwo",cardTitle:"cardTitle_Ehd1",cardDescription:"cardDescription_b6wr"};function Re(e){let{reflection:n}=e;const t=(0,U.gG)(n.project),o=n.groups[0].children.map((e=>t[e])).filter((e=>!!e));return s.createElement("article",{className:"margin-top--lg"},s.createElement("section",{className:(0,l.A)("row")},o.map((e=>s.createElement("article",{key:e.id,className:"col col--6 margin-bottom--lg"},s.createElement(T.A,{href:e.href,className:(0,l.A)("card padding--lg",Ie.cardContainer)},s.createElement("h2",{className:(0,l.A)("text--truncate",Ie.cardTitle)},s.createElement("code",null,e.name)),s.createElement("div",{className:(0,l.A)("text--truncate",Ie.cardDescription)},e.comment?.summaryText??"\xa0")))))))}function We(e){let{reflection:n,headless:t}=e;return s.createElement(s.Fragment,null,!t&&(n.hasOwnPage?s.createElement("h1",null,n.name):s.createElement(se.A,{as:"h3",id:n.anchor},s.createElement("code",null,n.name))),s.createElement(y,null,s.createElement(u,{link:n.sources?.[0]?.url},s.createElement(d,null,s.createElement(Y,{reflection:n})))),s.createElement(h.A,{comment:n.comment}),n.inheritedFrom&&s.createElement("small",null,"Inherited from"," ",s.createElement("code",null,s.createElement(pe,{type:n.inheritedFrom}))))}function Se(e){let{reflection:n}=e;const t=(0,U.gG)(n.project);return s.createElement(s.Fragment,null,s.createElement(se.A,{as:"h3",id:n.anchor},s.createElement("code",null,n.name)),s.createElement(y,null,s.createElement(u,{link:n.sources?.[0]?.url},s.createElement(d,null,s.createElement(K,{reflection:n})))),s.createElement(h.A,{comment:n.comment}),s.createElement(Le,{parameters:n.typeParameters}),n.signatures&&s.createElement(s.Fragment,null,s.createElement("h2",null,"Callable"),s.createElement(be,{signatures:n.signatures})),n.groups?.map((e=>s.createElement(s.Fragment,{key:e.title},s.createElement("h2",null,e.title),e.children.map((e=>t[e])).filter((e=>e&&(e.flags.isPublic||!e.flags.isProtected&&!e.flags.isPrivate))).map((e=>s.createElement(Be,{key:e.id,reflection:e})))))))}function Be(e){let{reflection:n,headless:t=!1}=e;const o=(0,s.useMemo)((()=>{switch(n.kind){case g.k.Project:return Re;case g.k.Module:return Pe;case g.k.Namespace:case g.k.Enum:case g.k.Class:case g.k.Interface:return Ne;case g.k.Function:case g.k.Accessor:case g.k.Constructor:case g.k.Method:return ke;case g.k.Variable:case g.k.Property:case g.k.EnumMember:return We;case g.k.CallSignature:case g.k.IndexSignature:case g.k.ConstructorSignature:case g.k.Parameter:case g.k.TypeLiteral:case g.k.TypeParameter:case g.k.GetSignature:case g.k.SetSignature:case g.k.ObjectLiteral:break;case g.k.TypeAlias:return Se;case g.k.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.kind]);return s.createElement(o,{reflection:n,headless:t})}},9659:(e,n,t)=>{t.d(n,{k:()=>o});let o=function(e){return e[e.Project=1]="Project",e[e.Module=2]="Module",e[e.Namespace=4]="Namespace",e[e.Enum=8]="Enum",e[e.EnumMember=16]="EnumMember",e[e.Variable=32]="Variable",e[e.Function=64]="Function",e[e.Class=128]="Class",e[e.Interface=256]="Interface",e[e.Constructor=512]="Constructor",e[e.Property=1024]="Property",e[e.Method=2048]="Method",e[e.CallSignature=4096]="CallSignature",e[e.IndexSignature=8192]="IndexSignature",e[e.ConstructorSignature=16384]="ConstructorSignature",e[e.Parameter=32768]="Parameter",e[e.TypeLiteral=65536]="TypeLiteral",e[e.TypeParameter=131072]="TypeParameter",e[e.Accessor=262144]="Accessor",e[e.GetSignature=524288]="GetSignature",e[e.SetSignature=1048576]="SetSignature",e[e.ObjectLiteral=2097152]="ObjectLiteral",e[e.TypeAlias=4194304]="TypeAlias",e[e.Reference=8388608]="Reference",e}({})},7576:(e,n,t)=>{t.d(n,{A:()=>s});var o=t(9631),p=t(9996),r=t(4041);function s(){return r.createElement(p.A,{type:"experimental"},"This is an ",r.createElement(o.A,{to:"/experimental"},"experimental feature"),". The behavior and API may change drastically between minor releases.")}},8675:(e,n,t)=>{t.d(n,{Fx:()=>a,ID:()=>i,Kv:()=>r,as:()=>c,gG:()=>s});var o=t(4041);const p=o.createContext({lookup:{},urlLookup:{}});function r(e){let{children:n,lookup:t,urlLookup:r}=e;return o.createElement(p.Provider,{value:{lookup:t,urlLookup:r}},n)}function s(e){const{lookup:n}=(0,o.useContext)(p);return n[e]}function c(){const{lookup:e}=(0,o.useContext)(p);return n=>{if("number"==typeof n?.project)return e[n.project][n.id]}}function a(){const{urlLookup:e,lookup:n}=(0,o.useContext)(p);return t=>{const o=e[t];return o?n[o.projectId]?.[o.id]??null:null}}function i(e){if(e)return e.href}},4593:(e,n,t)=>{t.d(n,{J2:()=>c,d5:()=>s,o0:()=>a});var o=t(8408),p=t(4041);const r=p.createContext(null);function s(e){let{children:n}=e;const t=(0,o.A)(),s=(0,p.useMemo)((()=>function(e,n){const{plain:t}=e,o=Object.create(null),p=e.styles.reduce(((e,t)=>{const{languages:o,style:p}=t;return o&&!o.includes(n)||t.types.forEach((n=>{e[n]={...e[n],...p}})),e}),o);return p.root=t,p.plain={...t,backgroundColor:null},p}(t,"typescript")),[t]);return p.createElement(r.Provider,{value:s},n)}function c(e){void 0===e&&(e="plain");const n=(0,p.useContext)(r);return{className:`token ${e}`,style:n[e]??n.plain}}function a(e){void 0===e&&(e="plain");const n=(0,p.useContext)(r);return n[e]??n.plain}},6382:(e,n,t)=>{t.d(n,{B4:()=>l,R7:()=>u,XN:()=>m});var o=t(9531),p=t(213),r=t(4041);const s="api-filters",c=o.A.canUseDOM?localStorage.getItem(s):null,a=c?JSON.parse(c):{inherited:!0,private:!1},i=r.createContext([a,()=>{}]);function l(e){let{children:n}=e;const[t,o]=(0,r.useState)(a),c=(0,p.A)();return r.createElement(i.Provider,{value:[t,e=>{c&&localStorage.setItem(s,JSON.stringify(e)),o(e)}]},n)}function u(){return(0,r.useContext)(i)}function m(e,n){const t=n.flags?.isPrivate||n.flags?.isProtected;if(!e.private&&t)return!1;const o=!!n.inheritedFrom;return!(!e.inherited&&o)}},9996:(e,n,t)=>{t.d(n,{A:()=>m});var o=t(9575),p=t(4041);function r(e){let{width:n=24,height:t=24,...r}=e;return p.createElement("svg",(0,o.A)({viewBox:"0 0 24 24",width:n,height:t,"aria-hidden":!0,fill:"currentColor"},r),p.createElement("path",{d:"M19.8,18.4L14,10.67V6.5l1.35-1.69C15.61,4.48,15.38,4,14.96,4H9.04C8.62,4,8.39,4.48,8.65,4.81L10,6.5v4.17L4.2,18.4 C3.71,19.06,4.18,20,5,20h14C19.82,20,20.29,19.06,19.8,18.4z"}))}function s(e){return p.createElement("svg",(0,o.A)({viewBox:"0 0 24 24",fill:"currentColor"},e),p.createElement("path",{d:"M15.73 3H8.27L3 8.27v7.46L8.27 21h7.46L21 15.73V8.27L15.73 3zM12 17.3c-.72 0-1.3-.58-1.3-1.3 0-.72.58-1.3 1.3-1.3.72 0 1.3.58 1.3 1.3 0 .72-.58 1.3-1.3 1.3zm1-4.3h-2V7h2v6z"}))}function c(e){return p.createElement("svg",(0,o.A)({viewBox:"0 0 24 24",fill:"currentColor"},e),p.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"}))}function a(e){return p.createElement("svg",(0,o.A)({viewBox:"0 0 24 24",fill:"currentColor"},e),p.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"}))}function i(e){return p.createElement("svg",(0,o.A)({viewBox:"0 0 24 24",fill:"currentColor"},e),p.createElement("path",{d:"M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"}))}var l=t(8621);const u={icon:"icon_Fw4I"};function m(e){let{title:n,type:t,...m}=e;const y=(0,p.useMemo)((()=>{switch(t){case"tip":return a;case"caution":return i;case"danger":return s;case"experimental":return r;default:return c}}),[t]);return"experimental"===t&&(n??="Experimental",t="caution"),p.createElement(p.Fragment,null,p.createElement(l.A,(0,o.A)({icon:p.createElement(y,{className:u.icon}),title:n,type:t},m)))}},6048:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>c,metadata:()=>i,toc:()=>u});var o=t(9575),p=(t(4041),t(2247)),r=t(5906),s=t(9987);const c={sidebar_position:4,slug:"/positioning"},a="Positioning",i={unversionedId:"motion-canvas/positioning",id:"motion-canvas/positioning",title:"Positioning",description:"_Note: These docs were adopted from the original",source:"@site/docs/motion-canvas/positioning.mdx",sourceDirName:"motion-canvas",slug:"/positioning",permalink:"/positioning",draft:!1,editUrl:"https://github.com/havenhq/revideo/blob/main/packages/docs/docs/motion-canvas/positioning.mdx",tags:[],version:"current",lastUpdatedBy:"Justus Mattern",sidebarPosition:4,frontMatter:{sidebar_position:4,slug:"/positioning"},sidebar:"docs",previous:{title:"Scene hierarchy",permalink:"/hierarchy"},next:{title:"Layouts",permalink:"/layouts"}},l={},u=[{value:"Transform",id:"transform",level:2},{value:"<code>Node.position</code>",id:"nodeposition",level:3},{value:"<code>Node.scale</code>",id:"nodescale",level:3},{value:"<code>Node.rotation</code>",id:"noderotation",level:3},{value:"Absolute transform",id:"absolute-transform",level:2},{value:"<code>Node.absolutePosition</code>",id:"nodeabsoluteposition",level:3},{value:"<code>Node.absoluteScale</code>",id:"nodeabsolutescale",level:3},{value:"<code>Node.absoluteRotation</code>",id:"nodeabsoluterotation",level:3},{value:"Matrices",id:"matrices",level:2},{value:"<code>Node.localToWorld</code>",id:"nodelocaltoworld",level:3},{value:"<code>Node.worldToLocal</code>",id:"nodeworldtolocal",level:3},{value:"<code>Node.localToParent</code>",id:"nodelocaltoparent",level:3},{value:"<code>Node.worldToParent</code>",id:"nodeworldtoparent",level:3}],m={toc:u},y="wrapper";function d(e){let{components:n,...t}=e;return(0,p.yg)(y,(0,o.A)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,p.yg)("h1",{id:"positioning"},"Positioning"),(0,p.yg)("p",null,(0,p.yg)("em",{parentName:"p"},"Note: These docs were adopted from the original\n",(0,p.yg)("a",{parentName:"em",href:"https://motioncanvas.io/docs/"},"Motion Canvas")," docs")),(0,p.yg)(r.A,{name:"positioning",banner:!0,mdxType:"AnimationPlayer"}),(0,p.yg)("p",null,"Motion Canvas uses a Cartesian coordinate system. Its origin is located in the\ncenter of the scene, with the x-axis going to the right and the y-axis going\ndown."),(0,p.yg)("h2",{id:"transform"},"Transform"),(0,p.yg)("p",null,"All nodes are positioned relative to their parents. This means that any\ntransformations applied to the parent are also applied to its children. The\ntransform of each node consists of the following properties:"),(0,p.yg)("h3",{id:"nodeposition"},(0,p.yg)("inlineCode",{parentName:"h3"},"Node.position")),(0,p.yg)(s.A,{url:"/api/2d/components/Node#position",mdxType:"ApiSnippet"}),(0,p.yg)("hr",null),(0,p.yg)("h3",{id:"nodescale"},(0,p.yg)("inlineCode",{parentName:"h3"},"Node.scale")),(0,p.yg)(s.A,{url:"/api/2d/components/Node#scale",mdxType:"ApiSnippet"}),(0,p.yg)("hr",null),(0,p.yg)("h3",{id:"noderotation"},(0,p.yg)("inlineCode",{parentName:"h3"},"Node.rotation")),(0,p.yg)(s.A,{url:"/api/2d/components/Node#rotation",mdxType:"ApiSnippet"}),(0,p.yg)("hr",null),(0,p.yg)("h2",{id:"absolute-transform"},"Absolute transform"),(0,p.yg)("p",null,"Each of the basic transform properties has a dedicated helper method that\noperates in world space."),(0,p.yg)("p",null,"This can be helpful, for instance, when we need to match the transforms of two\nnodes located within different parents. Consider the following example:"),(0,p.yg)("pre",null,(0,p.yg)("code",{parentName:"pre",className:"language-tsx"},"const circleA = createRef<Node>();\nconst circleB = createRef<Node>();\n\nview.add(\n  <>\n    <Node position={[200, 100]}>\n      <Circle\n        position={[0, 100]}\n        ref={circleA}\n        width={20}\n        height={20}\n        fill={'white'}\n      />\n    </Node>\n    <Circle ref={circleB} width={10} height={10} fill={'red'} />\n  </>,\n);\n\ncircleB().absolutePosition(circleA().absolutePosition());\n")),(0,p.yg)("p",null,"We access the absolute position (position in world space) of ",(0,p.yg)("inlineCode",{parentName:"p"},"circleA")," and\nassign it as the absolute position of ",(0,p.yg)("inlineCode",{parentName:"p"},"circleB"),". This will move the ",(0,p.yg)("inlineCode",{parentName:"p"},"circleB"),"\nright on top of ",(0,p.yg)("inlineCode",{parentName:"p"},"circleA"),"."),(0,p.yg)("admonition",{type:"info"},(0,p.yg)("p",{parentName:"admonition"},"Note that we still need to set the ",(0,p.yg)("inlineCode",{parentName:"p"},"absolutePosition")," of ",(0,p.yg)("inlineCode",{parentName:"p"},"circleB")," and not just\nthe ",(0,p.yg)("inlineCode",{parentName:"p"},"position"),". It may seem redundant since ",(0,p.yg)("inlineCode",{parentName:"p"},"circleB")," is a direct child of the\nscene view. But the local space of the scene view is ",(0,p.yg)("strong",{parentName:"p"},"not")," the same as the\nworld space.")),(0,p.yg)("p",null,"All available world-space properties are listed below:"),(0,p.yg)("h3",{id:"nodeabsoluteposition"},(0,p.yg)("inlineCode",{parentName:"h3"},"Node.absolutePosition")),(0,p.yg)(s.A,{url:"/api/2d/components/Node#absolutePosition",mdxType:"ApiSnippet"}),(0,p.yg)("hr",null),(0,p.yg)("h3",{id:"nodeabsolutescale"},(0,p.yg)("inlineCode",{parentName:"h3"},"Node.absoluteScale")),(0,p.yg)(s.A,{url:"/api/2d/components/Node#absoluteScale",mdxType:"ApiSnippet"}),(0,p.yg)("hr",null),(0,p.yg)("h3",{id:"nodeabsoluterotation"},(0,p.yg)("inlineCode",{parentName:"h3"},"Node.absoluteRotation")),(0,p.yg)(s.A,{url:"/api/2d/components/Node#absoluteRotation",mdxType:"ApiSnippet"}),(0,p.yg)("hr",null),(0,p.yg)("h2",{id:"matrices"},"Matrices"),(0,p.yg)("p",null,"For more advanced uses, nodes expose all the matrices necessary to map vectors\nfrom one space to another. For example, the helper properties described above\ncould be reimplemented using the ",(0,p.yg)("inlineCode",{parentName:"p"},"worldToParent")," and ",(0,p.yg)("inlineCode",{parentName:"p"},"localToWorld")," matrices:"),(0,p.yg)("pre",null,(0,p.yg)("code",{parentName:"pre",className:"language-ts"},"// getting the absolute position:\nnode.absolutePosition();\n// same as:\nVector2.zero.transformAsPoint(node.localToWorld());\n\n// setting the absolute position:\nnode.absolutePosition(vector);\n// same as:\nnode.position(vector.transformAsPoint(node.worldToParent()));\n")),(0,p.yg)("p",null,"The available matrices include:"),(0,p.yg)("h3",{id:"nodelocaltoworld"},(0,p.yg)("inlineCode",{parentName:"h3"},"Node.localToWorld")),(0,p.yg)(s.A,{url:"/api/2d/components/Node#localToWorld",mdxType:"ApiSnippet"}),(0,p.yg)("hr",null),(0,p.yg)("h3",{id:"nodeworldtolocal"},(0,p.yg)("inlineCode",{parentName:"h3"},"Node.worldToLocal")),(0,p.yg)(s.A,{url:"/api/2d/components/Node#worldToLocal",mdxType:"ApiSnippet"}),(0,p.yg)("hr",null),(0,p.yg)("h3",{id:"nodelocaltoparent"},(0,p.yg)("inlineCode",{parentName:"h3"},"Node.localToParent")),(0,p.yg)(s.A,{url:"/api/2d/components/Node#localToParent",mdxType:"ApiSnippet"}),(0,p.yg)("hr",null),(0,p.yg)("h3",{id:"nodeworldtoparent"},(0,p.yg)("inlineCode",{parentName:"h3"},"Node.worldToParent")),(0,p.yg)(s.A,{url:"/api/2d/components/Node#worldToParent",mdxType:"ApiSnippet"}),(0,p.yg)("hr",null))}d.isMDXComponent=!0}}]);